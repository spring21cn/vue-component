(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(definition);
  } else {
    context.SystemInfo = definition();
  }
})(this, function() {
  'use strict';
  var win = window || {};
  var nav = navigator || {};
  var ua = nav.userAgent;
  var self = {};
  var match = {
    'Trident': ua.indexOf('Trident') !== -1 || ua.indexOf('NET CLR') !== -1,
    'Presto': ua.indexOf('Presto') !== -1,
    'WebKit': ua.indexOf('AppleWebKit') !== -1,
    'Gecko': ua.indexOf('Gecko/') !== -1,
    'Safari': ua.indexOf('Safari') !== -1 || ua.indexOf('iPhone') !== -1,
    'Chrome': ua.indexOf('Chrome') !== -1 || ua.indexOf('CriOS') !== -1,
    'IE': ua.indexOf('MSIE') !== -1 || ua.indexOf('Trident') !== -1,
    'Edge': ua.indexOf('Edge') !== -1,
    'Firefox': ua.indexOf('Firefox') !== -1 || ua.indexOf('FxiOS') !== -1,
    'Firefox Focus': ua.indexOf('Focus') !== -1,
    'Chromium': ua.indexOf('Chromium') !== -1,
    'Opera': ua.indexOf('Opera') !== -1 || ua.indexOf('OPR') !== -1,
    'Vivaldi': ua.indexOf('Vivaldi') !== -1,
    'Yandex': ua.indexOf('YaBrowser') !== -1,
    'Kindle': ua.indexOf('Kindle') !== -1 || ua.indexOf('Silk/') !== -1,
    '360': ua.indexOf('360EE') !== -1 || ua.indexOf('360SE') !== -1,
    'UC': ua.indexOf('UC') !== -1 || ua.indexOf(' UBrowser') !== -1,
    'QQBrowser': ua.indexOf('QQBrowser') !== -1,
    'QQ': ua.indexOf('QQ/') !== -1,
    'Baidu': ua.indexOf('Baidu') !== -1 || ua.indexOf('BIDUBrowser') !== -1,
    'Maxthon': ua.indexOf('Maxthon') !== -1,
    'Sogou': ua.indexOf('MetaSr') !== -1 || ua.indexOf('Sogou') !== -1,
    'LBBROWSER': ua.indexOf('LBBROWSER') !== -1,
    '2345Explorer': ua.indexOf('2345Explorer') !== -1,
    'TheWorld': ua.indexOf('TheWorld') !== -1,
    'XiaoMi': ua.indexOf('MiuiBrowser') !== -1,
    'Quark': ua.indexOf('Quark') !== -1,
    'Qiyu': ua.indexOf('Qiyu') !== -1,
    'Wechat': ua.indexOf('MicroMessenger') !== -1,
    'Taobao': ua.indexOf('AliApp(TB') !== -1,
    'Alipay': ua.indexOf('AliApp(AP') !== -1,
    'Weibo': ua.indexOf('Weibo') !== -1,
    'Douban': ua.indexOf('com.douban.frodo') !== -1,
    'Suning': ua.indexOf('SNEBUY-APP') !== -1,
    'iQiYi': ua.indexOf('IqiyiApp') !== -1,
    'Windows': ua.indexOf('Windows') !== -1,
    'Linux': ua.indexOf('Linux') !== -1 || ua.indexOf('X11') !== -1,
    'Mac OS': ua.indexOf('Macintosh') !== -1,
    'Android': ua.indexOf('Android') !== -1 || ua.indexOf('Adr') !== -1,
    'Ubuntu': ua.indexOf('Ubuntu') !== -1,
    'FreeBSD': ua.indexOf('FreeBSD') !== -1,
    'Debian': ua.indexOf('Debian') !== -1,
    'Windows Phone': ua.indexOf('IEMobile') !== -1 || ua.indexOf('Windows Phone') !== -1,
    'BlackBerry': ua.indexOf('BlackBerry') !== -1 || ua.indexOf('RIM') !== -1,
    'MeeGo': ua.indexOf('MeeGo') !== -1,
    'Symbian': ua.indexOf('Symbian') !== -1,
    'iOS': ua.indexOf('like Mac OS X') !== -1,
    'Chrome OS': ua.indexOf('CrOS') !== -1,
    'WebOS': ua.indexOf('hpwOS') !== -1,
    'Mobile': ua.indexOf('Android') !== -1 || ua.indexOf('Adr') !== -1 ||  ua.indexOf('Mobile') !== -1 || ua.indexOf('Ios') !== -1 || ua.indexOf('like Mac OS X') !== -1 || ua.indexOf('iPhone') !== -1 || ua.indexOf('iPad') !== -1 || ua.indexOf('iPod') !== -1  || ua.indexOf('Tablet') !== -1 
  };
  if (match['Mobile']) {
    // match['Mobile'] = !(ua.indexOf('iPad') !== -1);
  } else if (win.showModalDialog && win.chrome) {
    match['360'] = true;
  }
  var hash = {
    engine: ['WebKit', 'Trident', 'Gecko', 'Presto'],
    browser: ['Safari', 'Chrome', 'Edge', 'IE', 'Firefox', 'Firefox Focus', 'Chromium', 'Opera', 'Vivaldi', 'Yandex', 'Kindle', '360', 'UC', 'QQBrowser', 'QQ', 'Baidu', 'Maxthon', 'Sogou', 'LBBROWSER', '2345Explorer', 'TheWorld', 'XiaoMi', 'Quark', 'Qiyu', 'Wechat', 'Taobao', 'Alipay', 'Weibo', 'Douban', 'Suning', 'iQiYi'],
    os: ['Windows', 'Linux', 'Mac OS', 'Android', 'Ubuntu', 'FreeBSD', 'Debian', 'iOS', 'Windows Phone', 'BlackBerry', 'MeeGo', 'Symbian', 'Chrome OS', 'WebOS'],
    device: ['Mobile']
  };
  self.device = 'PC';
  if(window.isForceMobile){
    self.device = 'Mobile';
  }
  self.language = (function() {
    var g = (nav.browserLanguage || nav.language);
    var arr = g.split('-');
    if (arr[1]) {
      arr[1] = arr[1].toUpperCase();
    }
    return arr.join('_');
  })();
  for (var s in hash) {
    for (var i = 0; i < hash[s].length; i++) {
      var value = hash[s][i];
      if (match[value]) {
        self[s] = value;
      }
    }
  }
  var osVersion = {
    'Windows': function() {
      var v = ua.replace(/^.*Windows NT ([\d.]+);.*$/, '$1');
      var hash = {
        '6.4': '10',
        '6.3': '8.1',
        '6.2': '8',
        '6.1': '7',
        '6.0': 'Vista',
        '5.2': 'XP',
        '5.1': 'XP',
        '5.0': '2000'
      };
      return hash[v] || v;
    },
    'Android': function() {
      return ua.replace(/^.*Android ([\d.]+);.*$/, '$1');
    },
    'iOS': function() {
      return ua.replace(/^.*OS ([\d_]+) like.*$/, '$1').replace(/_/g, '.');
    },
    'Debian': function() {
      return ua.replace(/^.*Debian\/([\d.]+).*$/, '$1');
    },
    'Windows Phone': function() {
      return ua.replace(/^.*Windows Phone( OS)? ([\d.]+);.*$/, '$2');
    },
    'Mac OS': function() {
      return ua.replace(/^.*Mac OS X ([\d_]+).*$/, '$1').replace(/_/g, '.');
    },
    'WebOS': function() {
      return ua.replace(/^.*hpwOS\/([\d.]+);.*$/, '$1');
    }
  };
  self.osVersion = '';
  if (osVersion[self.os]) {
    self.osVersion = osVersion[self.os]();
    if (self.osVersion == ua) {
      self.osVersion = '';
    }
  }
  var version = {
    'Safari': function() {
      return ua.replace(/^.*Version\/([\d.]+).*$/, '$1');
    },
    'Chrome': function() {
      return ua.replace(/^.*Chrome\/([\d.]+).*$/, '$1').replace(/^.*CriOS\/([\d.]+).*$/, '$1');
    },
    'IE': function() {
      return ua.replace(/^.*MSIE ([\d.]+).*$/, '$1').replace(/^.*rv:([\d.]+).*$/, '$1');
    },
    'Edge': function() {
      return ua.replace(/^.*Edge\/([\d.]+).*$/, '$1');
    },
    'Firefox': function() {
      return ua.replace(/^.*Firefox\/([\d.]+).*$/, '$1').replace(/^.*FxiOS\/([\d.]+).*$/, '$1');
    },
    'Firefox Focus': function() {
      return ua.replace(/^.*Focus\/([\d.]+).*$/, '$1');
    },
    'Chromium': function() {
      return ua.replace(/^.*Chromium\/([\d.]+).*$/, '$1');
    },
    'Opera': function() {
      return ua.replace(/^.*Opera\/([\d.]+).*$/, '$1').replace(/^.*OPR\/([\d.]+).*$/, '$1');
    },
    'Vivaldi': function() {
      return ua.replace(/^.*Vivaldi\/([\d.]+).*$/, '$1');
    },
    'Yandex': function() {
      return ua.replace(/^.*YaBrowser\/([\d.]+).*$/, '$1');
    },
    'Kindle': function() {
      return ua.replace(/^.*Version\/([\d.]+).*$/, '$1');
    },
    'Maxthon': function() {
      return ua.replace(/^.*Maxthon\/([\d.]+).*$/, '$1');
    },
    'QQBrowser': function() {
      return ua.replace(/^.*QQBrowser\/([\d.]+).*$/, '$1');
    },
    'QQ': function() {
      return ua.replace(/^.*QQ\/([\d.]+).*$/, '$1');
    },
    'Baidu': function() {
      return ua.replace(/^.*BIDUBrowser[\s\/]([\d.]+).*$/, '$1');
    },
    'UC': function() {
      return ua.replace(/^.*UC?Browser\/([\d.]+).*$/, '$1');
    },
    'Sogou': function() {
      return ua.replace(/^.*SE ([\d.X]+).*$/, '$1').replace(/^.*SogouMobileBrowser\/([\d.]+).*$/, '$1');
    },
    '2345Explorer': function() {
      return ua.replace(/^.*2345Explorer\/([\d.]+).*$/, '$1');
    },
    'TheWorld': function() {
      return ua.replace(/^.*TheWorld ([\d.]+).*$/, '$1');
    },
    'XiaoMi': function() {
      return ua.replace(/^.*MiuiBrowser\/([\d.]+).*$/, '$1');
    },
    'Quark': function() {
      return ua.replace(/^.*Quark\/([\d.]+).*$/, '$1');
    },
    'Qiyu': function() {
      return ua.replace(/^.*Qiyu\/([\d.]+).*$/, '$1');
    },
    'Wechat': function() {
      return ua.replace(/^.*MicroMessenger\/([\d.]+).*$/, '$1');
    },
    'Taobao': function() {
      return ua.replace(/^.*AliApp\(TB\/([\d.]+).*$/, '$1');
    },
    'Alipay': function() {
      return ua.replace(/^.*AliApp\(AP\/([\d.]+).*$/, '$1');
    },
    'Weibo': function() {
      return ua.replace(/^.*weibo__([\d.]+).*$/, '$1');
    },
    'Douban': function() {
      return ua.replace(/^.*com.douban.frodo\/([\d.]+).*$/, '$1');
    },
    'Suning': function() {
      return ua.replace(/^.*SNEBUY-APP([\d.]+).*$/, '$1');
    },
    'iQiYi': function() {
      return ua.replace(/^.*IqiyiVersion\/([\d.]+).*$/, '$1');
    }
  };
  self.version = '';
  if (version[self.browser]) {
    self.version = version[self.browser]();
    if (self.version == ua) {
      self.version = '';
    }
  }
  return {
    device: self.device,
    os: self.os,
    osVersion: self.osVersion,
    browser: self.browser,
    version: self.version,
    language: self.language,
  };
});





(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(definition);
  } else {
    context.DateUtil = definition();
  }
})(this, function() {
  'use strict';
  var fecha = {};
  var token = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = /\d\d?/;
  var threeDigits = /\d{3}/;
  var fourDigits = /\d{4}/;
  var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var noop = function() {};
  var shorten = function(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  };
  var monthUpdate = function(arrName) {
    return function(d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
      if (~index) {
        d.month = index;
      }
    };
  };
  var pad = function(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = '0' + val;
    }
    return val;
  };
  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  var formatFlags = {
    D: function(dateObj) {
      return dateObj.getDay();
    },
    DD: function(dateObj) {
      return pad(dateObj.getDay());
    },
    Do: function(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function(dateObj) {
      return dateObj.getDate();
    },
    dd: function(dateObj) {
      return pad(dateObj.getDate());
    },
    ddd: function(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function(dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    yy: function(dateObj) {
      return String(dateObj.getFullYear()).substr(2);
    },
    yyyy: function(dateObj) {
      return dateObj.getFullYear();
    },
    h: function(dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function(dateObj) {
      return dateObj.getHours();
    },
    HH: function(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function(dateObj) {
      return dateObj.getMinutes();
    },
    mm: function(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function(dateObj) {
      return dateObj.getSeconds();
    },
    ss: function(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function(dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function(dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };
  var parseFlags = {
    d: [twoDigits, function(d, v) {
      d.day = v;
    }],
    M: [twoDigits, function(d, v) {
      d.month = v - 1;
    }],
    yy: [twoDigits, function(d, v) {
      var da = new Date()
        , cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function(d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function(d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function(d, v) {
      d.second = v;
    }],
    yyyy: [fourDigits, function(d, v) {
      d.year = v;
    }],
    S: [/\d/, function(d, v) {
      d.millisecond = v * 100;
    }],
    SS: [/\d{2}/, function(d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function(d, v) {
      d.millisecond = v;
    }],
    D: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function(d, v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: [/[\+\-]\d\d:?\d\d/, function(d, v) {
      var parts = (v + '').match(/([\+\-]|\d\d)/gi), minutes;
      if (parts) {
        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.DD = parseFlags.D;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.Do = parseFlags.dd = parseFlags.d;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a;
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };
  fecha.masks = {
    'default': 'ddd MMM dd yyyy HH:mm:ss',
    shortDate: 'M/D/yy',
    mediumDate: 'MMM d, yyyy',
    longDate: 'MMMM d, yyyy',
    fullDate: 'dddd, MMMM d, yyyy',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };
  fecha.format = function(dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;
    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }
    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw 'Invalid Date in fecha.format';
    }
    mask = fecha.masks[mask] || mask || fecha.masks['default'];
    return mask.replace(token, function($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    });
  };
  fecha.parse = function(dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;
    if (typeof format !== 'string') {
      throw 'Invalid format in fecha.parse';
    }
    format = fecha.masks[format] || format;
    if (dateStr.length > 1000) {
      return null;
    }
    var isValid = true;
    var dateInfo = {};
    format.replace(token, function($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        var index = dateStr.search(info[0]);
        if (!~index) {
          isValid = false;
        } else {
          dateStr.replace(info[0], function(result) {
            info[1](dateInfo, result, i18n);
            dateStr = dateStr.substr(index + result.length);
            return result;
          });
        }
      }
      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
    });
    if (!isValid) {
      return null;
    }
    var today = new Date();
    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }
    var date;
    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }
    return date;
  };
  return fecha;
});

/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash category="math" include="pad,padEnd,padStart,parseInt,trim,trimEnd,trimStart,clone,cloneDeep,debounce,throttle,countBy,filter,eachRight,find,findLast,includes,groupBy,map,reduce,orderBy,sortBy,some,every,compact,concat,difference,differenceBy,differenceWith,dropWhile,findIndex,findLastIndex,indexOf,intersection,intersectionBy,intersectionWith,join,last,head,pull,pullAll,pullAt,reverse,slice,tail,initial,take,takeRight,takeWhile,union,unionBy,unionWith,uniq,uniqBy,uniqWith,without,xor,xorBy,xorWith,set,isEqual,isEqualWith,mapValues,assign,forEach,isEmpty,uniqueId,pick,pickBy"`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.5';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsAstral = '[' + rsAstralRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /*--------------------------------------------------------------------------*/

  /** Used for built-in method references. */
  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to generate unique IDs. */
  var idCounter = 0;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined,
      Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice,
      spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
      symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  var defineProperty = (function() {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeCeil = Math.ceil,
      nativeFloor = Math.floor,
      nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeJoin = arrayProto.join,
      nativeKeys = overArg(Object.keys, Object),
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeNow = Date.now,
      nativeParseInt = root.parseInt,
      nativeReverse = arrayProto.reverse;

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');

  /** Used to lookup unminified function names. */
  var realNames = {};

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps `value` to enable implicit method
   * chain sequences. Methods that operate on and return arrays, collections,
   * and functions can be chained together. Methods that retrieve a single value
   * or may return a primitive value will automatically end the chain sequence
   * and return the unwrapped value. Otherwise, the value must be unwrapped
   * with `_#value`.
   *
   * Explicit chain sequences, which must be unwrapped with `_#value`, may be
   * enabled using `_.chain`.
   *
   * The execution of chained methods is lazy, that is, it's deferred until
   * `_#value` is implicitly or explicitly called.
   *
   * Lazy evaluation allows several methods to support shortcut fusion.
   * Shortcut fusion is an optimization to merge iteratee calls; this avoids
   * the creation of intermediate arrays and can greatly reduce the number of
   * iteratee executions. Sections of a chain sequence qualify for shortcut
   * fusion if the section is applied to an array and iteratees accept only
   * one argument. The heuristic for whether a section qualifies for shortcut
   * fusion is subject to change.
   *
   * Chaining is supported in custom builds as long as the `_#value` method is
   * directly or indirectly included in the build.
   *
   * In addition to lodash methods, wrappers have `Array` and `String` methods.
   *
   * The wrapper `Array` methods are:
   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
   *
   * The wrapper `String` methods are:
   * `replace` and `split`
   *
   * The wrapper methods that support shortcut fusion are:
   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
   *
   * The chainable wrapper methods are:
   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
   * `zipObject`, `zipObjectDeep`, and `zipWith`
   *
   * The wrapper methods that are **not** chainable by default are:
   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
   * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
   * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
   * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
   * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
   * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
   * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
   * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
   * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
   * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
   * `upperFirst`, `value`, and `words`
   *
   * @name _
   * @constructor
   * @category Seq
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // Returns an unwrapped value.
   * wrapped.reduce(_.add);
   * // => 6
   *
   * // Returns a wrapped value.
   * var squares = wrapped.map(square);
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash() {
    // No operation performed.
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  /*------------------------------------------------------------------------*/

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
  }

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map || ListCache),
      'string': new Hash
    };
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /*------------------------------------------------------------------------*/

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /**
   * Aggregates elements of `collection` on `accumulator` with keys transformed
   * by `iteratee` and values set by `setter`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function baseAggregator(collection, setter, iteratee, accumulator) {
    baseEach(collection, function(value, key, collection) {
      setter(accumulator, value, iteratee(value), collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  /**
   * The base implementation of `_.assignIn` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * The base implementation of `_.at` without support for individual paths.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {string[]} paths The property paths to pick.
   * @returns {Array} Returns the picked elements.
   */
  function baseAt(object, paths) {
    var index = -1,
        length = paths.length,
        result = Array(length),
        skip = object == null;

    while (++index < length) {
      result[index] = skip ? undefined : get(object, paths[index]);
    }
    return result;
  }

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
        result = (isFlat || isFunc) ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat
            ? copySymbolsIn(value, baseAssignIn(result, value))
            : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });

      return result;
    }

    if (isMap(value)) {
      value.forEach(function(subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });

      return result;
    }

    var keysFunc = isFull
      ? (isFlat ? getAllKeysIn : getAllKeys)
      : (isFlat ? keysIn : keys);

    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function(subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  /**
   * The base implementation of methods like `_.difference` without support
   * for excluding multiple arrays or iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Array} values The values to exclude.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   */
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1,
        includes = arrayIncludes,
        isCommon = true,
        length = array.length,
        result = [],
        valuesLength = values.length;

    if (!length) {
      return result;
    }
    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    }
    else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }
    outer:
    while (++index < length) {
      var value = array[index],
          computed = iteratee == null ? value : iteratee(value);

      value = (comparator || value !== 0) ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values[valuesIndex] === computed) {
            continue outer;
          }
        }
        result.push(value);
      }
      else if (!includes(values, computed, comparator)) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = createBaseEach(baseForOwn);

  /**
   * The base implementation of `_.forEachRight` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEachRight = createBaseEach(baseForOwnRight, true);

  /**
   * The base implementation of `_.every` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`
   */
  function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function(value, index, collection) {
      result = !!predicate(value, index, collection);
      return result;
    });
    return result;
  }

  /**
   * The base implementation of methods like `_.max` and `_.min` which accepts a
   * `comparator` to determine the extremum value.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The iteratee invoked per iteration.
   * @param {Function} comparator The comparator used to compare values.
   * @returns {*} Returns the extremum value.
   */
  function baseExtremum(array, iteratee, comparator) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      var value = array[index],
          current = iteratee(value);

      if (current != null && (computed === undefined
            ? (current === current && !isSymbol(current))
            : comparator(current, computed)
          )) {
        var computed = current,
            result = value;
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.filter` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value, index, collection) {
      if (predicate(value, index, collection)) {
        result.push(value);
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;

    predicate || (predicate = isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();

  /**
   * This function is like `baseFor` except that it iterates over properties
   * in the opposite order.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseForRight = createBaseFor(true);

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }

  /**
   * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwnRight(object, iteratee) {
    return object && baseForRight(object, iteratee, keys);
  }

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * The base implementation of `_.gt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   */
  function baseGt(value, other) {
    return value > other;
  }

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  /**
   * The base implementation of methods like `_.intersection`, without support
   * for iteratee shorthands, that accepts an array of arrays to inspect.
   *
   * @private
   * @param {Array} arrays The arrays to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of shared values.
   */
  function baseIntersection(arrays, iteratee, comparator) {
    var includes = comparator ? arrayIncludesWith : arrayIncludes,
        length = arrays[0].length,
        othLength = arrays.length,
        othIndex = othLength,
        caches = Array(othLength),
        maxLength = Infinity,
        result = [];

    while (othIndex--) {
      var array = arrays[othIndex];
      if (othIndex && iteratee) {
        array = arrayMap(array, baseUnary(iteratee));
      }
      maxLength = nativeMin(array.length, maxLength);
      caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
        ? new SetCache(othIndex && array)
        : undefined;
    }
    array = arrays[0];

    var index = -1,
        seen = caches[0];

    outer:
    while (++index < length && result.length < maxLength) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;

      value = (comparator || value !== 0) ? value : 0;
      if (!(seen
            ? cacheHas(seen, computed)
            : includes(result, computed, comparator)
          )) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache
                ? cacheHas(cache, computed)
                : includes(arrays[othIndex], computed, comparator))
              ) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : getTag(object),
        othTag = othIsArr ? arrayTag : getTag(other);

    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;

    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack);
      return (objIsArr || isTypedArray(object))
        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)
          ) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined
              ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
              : result
            )) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == 'object') {
      return isArray(value)
        ? baseMatchesProperty(value[0], value[1])
        : baseMatches(value);
    }
    return property(value);
  }

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.lt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   */
  function baseLt(value, other) {
    return value < other;
  }

  /**
   * The base implementation of `_.map` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike(collection) ? Array(collection.length) : [];

    baseEach(collection, function(value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return (objValue === undefined && objValue === srcValue)
        ? hasIn(object, path)
        : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }

  /**
   * The base implementation of `_.orderBy` without param guards.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
   * @param {string[]} orders The sort orders of `iteratees`.
   * @returns {Array} Returns the new sorted array.
   */
  function baseOrderBy(collection, iteratees, orders) {
    var index = -1;
    iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

    var result = baseMap(collection, function(value, key, collection) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { 'criteria': criteria, 'index': ++index, 'value': value };
    });

    return baseSortBy(result, function(object, other) {
      return compareMultiple(object, other, orders);
    });
  }

  /**
   * The base implementation of `_.pick` without support for individual
   * property identifiers.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @returns {Object} Returns the new object.
   */
  function basePick(object, paths) {
    return basePickBy(object, paths, function(value, path) {
      return hasIn(object, path);
    });
  }

  /**
   * The base implementation of  `_.pickBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @param {Function} predicate The function invoked per property.
   * @returns {Object} Returns the new object.
   */
  function basePickBy(object, paths, predicate) {
    var index = -1,
        length = paths.length,
        result = {};

    while (++index < length) {
      var path = paths[index],
          value = baseGet(object, path);

      if (predicate(value, path)) {
        baseSet(result, castPath(path, object), value);
      }
    }
    return result;
  }

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }

  /**
   * The base implementation of `_.pullAllBy` without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to remove.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns `array`.
   */
  function basePullAll(array, values, iteratee, comparator) {
    var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
        index = -1,
        length = values.length,
        seen = array;

    if (array === values) {
      values = copyArray(values);
    }
    if (iteratee) {
      seen = arrayMap(array, baseUnary(iteratee));
    }
    while (++index < length) {
      var fromIndex = 0,
          value = values[index],
          computed = iteratee ? iteratee(value) : value;

      while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
        if (seen !== array) {
          splice.call(seen, fromIndex, 1);
        }
        splice.call(array, fromIndex, 1);
      }
    }
    return array;
  }

  /**
   * The base implementation of `_.pullAt` without support for individual
   * indexes or capturing the removed elements.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {number[]} indexes The indexes of elements to remove.
   * @returns {Array} Returns `array`.
   */
  function basePullAt(array, indexes) {
    var length = array ? indexes.length : 0,
        lastIndex = length - 1;

    while (length--) {
      var index = indexes[length];
      if (length == lastIndex || index !== previous) {
        var previous = index;
        if (isIndex(index)) {
          splice.call(array, index, 1);
        } else {
          baseUnset(array, index);
        }
      }
    }
    return array;
  }

  /**
   * The base implementation of `_.repeat` which doesn't coerce arguments.
   *
   * @private
   * @param {string} string The string to repeat.
   * @param {number} n The number of times to repeat the string.
   * @returns {string} Returns the repeated string.
   */
  function baseRepeat(string, n) {
    var result = '';
    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
      return result;
    }
    // Leverage the exponentiation by squaring algorithm for a faster repeat.
    // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
    do {
      if (n % 2) {
        result += string;
      }
      n = nativeFloor(n / 2);
      if (n) {
        string += string;
      }
    } while (n);

    return result;
  }

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + '');
  }

  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */
  function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
      return object;
    }
    path = castPath(path, object);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = toKey(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = isObject(objValue)
            ? objValue
            : (isIndex(path[index + 1]) ? [] : {});
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * The base implementation of `_.some` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function baseSome(collection, predicate) {
    var result;

    baseEach(collection, function(value, index, collection) {
      result = predicate(value, index, collection);
      return !result;
    });
    return !!result;
  }

  /**
   * The base implementation of `_.toNumber` which doesn't ensure correct
   * conversions of binary, hexadecimal, or octal string values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   */
  function baseToNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    return +value;
  }

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  /**
   * The base implementation of `_.uniqBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   */
  function baseUniq(array, iteratee, comparator) {
    var index = -1,
        includes = arrayIncludes,
        length = array.length,
        isCommon = true,
        result = [],
        seen = result;

    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    }
    else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache;
    }
    else {
      seen = iteratee ? [] : result;
    }
    outer:
    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;

      value = (comparator || value !== 0) ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      }
      else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.unset`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The property path to unset.
   * @returns {boolean} Returns `true` if the property is deleted, else `false`.
   */
  function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent(object, path);
    return object == null || delete object[toKey(last(path))];
  }

  /**
   * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
   * without support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to query.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseWhile(array, predicate, isDrop, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length) &&
      predicate(array[index], index, array)) {}

    return isDrop
      ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
      : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
  }

  /**
   * The base implementation of methods like `_.xor`, without support for
   * iteratee shorthands, that accepts an array of arrays to inspect.
   *
   * @private
   * @param {Array} arrays The arrays to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of values.
   */
  function baseXor(arrays, iteratee, comparator) {
    var length = arrays.length;
    if (length < 2) {
      return length ? baseUniq(arrays[0]) : [];
    }
    var index = -1,
        result = Array(length);

    while (++index < length) {
      var array = arrays[index],
          othIndex = -1;

      while (++othIndex < length) {
        if (othIndex != index) {
          result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
        }
      }
    }
    return baseUniq(baseFlatten(result, 1), iteratee, comparator);
  }

  /**
   * Casts `value` to an empty array if it's not an array like object.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Array|Object} Returns the cast array-like object.
   */
  function castArrayLikeObject(value) {
    return isArrayLikeObject(value) ? value : [];
  }

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return (!start && end >= length) ? array : baseSlice(array, start, end);
  }

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Compares values to sort them in ascending order.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined,
          valIsNull = value === null,
          valIsReflexive = value === value,
          valIsSymbol = isSymbol(value);

      var othIsDefined = other !== undefined,
          othIsNull = other === null,
          othIsReflexive = other === other,
          othIsSymbol = isSymbol(other);

      if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
          (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
          (valIsNull && othIsDefined && othIsReflexive) ||
          (!valIsDefined && othIsReflexive) ||
          !valIsReflexive) {
        return 1;
      }
      if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
          (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
          (othIsNull && valIsDefined && valIsReflexive) ||
          (!othIsDefined && valIsReflexive) ||
          !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * Used by `_.orderBy` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
   * specify an order of "desc" for descending or "asc" for ascending sort order
   * of corresponding values.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]|string[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = compareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * (order == 'desc' ? -1 : 1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * Copies own symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  /**
   * Copies own and inherited symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }

  /**
   * Creates a function like `_.groupBy`.
   *
   * @private
   * @param {Function} setter The function to set accumulator values.
   * @param {Function} [initializer] The accumulator object initializer.
   * @returns {Function} Returns the new aggregator function.
   */
  function createAggregator(setter, initializer) {
    return function(collection, iteratee) {
      var func = isArray(collection) ? arrayAggregator : baseAggregator,
          accumulator = initializer ? initializer() : {};

      return func(collection, setter, getIteratee(iteratee, 2), accumulator);
    };
  }

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * Creates a `_.find` or `_.findLast` function.
   *
   * @private
   * @param {Function} findIndexFunc The function to find the collection index.
   * @returns {Function} Returns the new find function.
   */
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = getIteratee(predicate, 3);
        collection = keys(collection);
        predicate = function(key) { return iteratee(iterable[key], key, iterable); };
      }
      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
    };
  }

  /**
   * Creates a function that performs a mathematical operation on two values.
   *
   * @private
   * @param {Function} operator The function to perform the operation.
   * @param {number} [defaultValue] The value used for `undefined` arguments.
   * @returns {Function} Returns the new mathematical operation function.
   */
  function createMathOperation(operator, defaultValue) {
    return function(value, other) {
      var result;
      if (value === undefined && other === undefined) {
        return defaultValue;
      }
      if (value !== undefined) {
        result = value;
      }
      if (other !== undefined) {
        if (result === undefined) {
          return other;
        }
        if (typeof value == 'string' || typeof other == 'string') {
          value = baseToString(value);
          other = baseToString(other);
        } else {
          value = baseToNumber(value);
          other = baseToNumber(other);
        }
        result = operator(value, other);
      }
      return result;
    };
  }

  /**
   * Creates the padding for `string` based on `length`. The `chars` string
   * is truncated if the number of characters exceeds `length`.
   *
   * @private
   * @param {number} length The padding length.
   * @param {string} [chars=' '] The string used as padding.
   * @returns {string} Returns the padding for `string`.
   */
  function createPadding(length, chars) {
    chars = chars === undefined ? ' ' : baseToString(chars);

    var charsLength = chars.length;
    if (charsLength < 2) {
      return charsLength ? baseRepeat(chars, length) : chars;
    }
    var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
    return hasUnicode(chars)
      ? castSlice(stringToArray(result), 0, length).join('')
      : result.slice(0, length);
  }

  /**
   * Creates a function like `_.round`.
   *
   * @private
   * @param {string} methodName The name of the `Math` method to use when rounding.
   * @returns {Function} Returns the new round function.
   */
  function createRound(methodName) {
    var func = Math[methodName];
    return function(number, precision) {
      number = toNumber(number);
      precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
      if (precision) {
        // Shift with exponential notation to avoid floating-point issues.
        // See [MDN](https://mdn.io/round#Examples) for more details.
        var pair = (toString(number) + 'e').split('e'),
            value = func(pair[0] + 'e' + (+pair[1] + precision));

        pair = (toString(value) + 'e').split('e');
        return +(pair[0] + 'e' + (+pair[1] - precision));
      }
      return func(number);
    };
  }

  /**
   * Creates a set object of `values`.
   *
   * @private
   * @param {Array} values The values to add to the set.
   * @returns {Object} Returns the new set.
   */
  var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
    return new Set(values);
  };

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!arraySome(other, function(othValue, othIndex) {
              if (!cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  /**
   * A specialized version of `baseRest` which flattens the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @returns {Function} Returns the new function.
   */
  function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + '');
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }

  /**
   * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
   * this function returns the custom method, otherwise it returns `baseIteratee`.
   * If arguments are provided, the chosen function is invoked with them and
   * its result is returned.
   *
   * @private
   * @param {*} [value] The value to convert to an iteratee.
   * @param {number} [arity] The arity of the created iteratee.
   * @returns {Function} Returns the chosen function or its result.
   */
  function getIteratee() {
    var result = lodash.iteratee || iteratee;
    result = result === iteratee ? baseIteratee : result;
    return arguments.length ? result(arguments[0], arguments[1]) : result;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];

      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
      (Map && getTag(new Map) != mapTag) ||
      (Promise && getTag(Promise.resolve()) != promiseTag) ||
      (Set && getTag(new Set) != setTag) ||
      (WeakMap && getTag(new WeakMap) != weakMapTag)) {
    getTag = function(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag;
          case mapCtorString: return mapTag;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag;
          case weakMapCtorString: return weakMapTag;
        }
      }
      return result;
    };
  }

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) &&
      (isArray(object) || isArguments(object));
  }

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate(getPrototype(object))
      : {};
  }

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag: case float64Tag:
      case int8Tag: case int16Tag: case int32Tag:
      case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return new Ctor;

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return new Ctor;

      case symbolTag:
        return cloneSymbol(object);
    }
  }

  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) ||
      !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq(object[index], value);
    }
    return false;
  }

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

    return value === proto;
  }

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue &&
        (srcValue !== undefined || (key in Object(object)));
    };
  }

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }

  /**
   * Gets the parent value at `path` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} path The path to get the parent value of.
   * @returns {*} Returns the parent value.
   */
  function parent(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  }

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = shortOut(baseSetToString);

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates an array with all falsey values removed. The values `false`, `null`,
   * `0`, `""`, `undefined`, and `NaN` are falsey.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to compact.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.compact([0, 1, false, 2, '', 3]);
   * // => [1, 2, 3]
   */
  function compact(array) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * Creates a new array concatenating `array` with any additional arrays
   * and/or values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to concatenate.
   * @param {...*} [values] The values to concatenate.
   * @returns {Array} Returns the new concatenated array.
   * @example
   *
   * var array = [1];
   * var other = _.concat(array, 2, [3], [[4]]);
   *
   * console.log(other);
   * // => [1, 2, 3, [4]]
   *
   * console.log(array);
   * // => [1]
   */
  function concat() {
    var length = arguments.length;
    if (!length) {
      return [];
    }
    var args = Array(length - 1),
        array = arguments[0],
        index = length;

    while (index--) {
      args[index - 1] = arguments[index];
    }
    return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
  }

  /**
   * Creates an array of `array` values not included in the other given arrays
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. The order and references of result values are
   * determined by the first array.
   *
   * **Note:** Unlike `_.pullAll`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...Array} [values] The values to exclude.
   * @returns {Array} Returns the new array of filtered values.
   * @see _.without, _.xor
   * @example
   *
   * _.difference([2, 1], [2, 3]);
   * // => [1]
   */
  var difference = baseRest(function(array, values) {
    return isArrayLikeObject(array)
      ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
      : [];
  });

  /**
   * This method is like `_.difference` except that it accepts `iteratee` which
   * is invoked for each element of `array` and `values` to generate the criterion
   * by which they're compared. The order and references of result values are
   * determined by the first array. The iteratee is invoked with one argument:
   * (value).
   *
   * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...Array} [values] The values to exclude.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
   * // => [1.2]
   *
   * // The `_.property` iteratee shorthand.
   * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
   * // => [{ 'x': 2 }]
   */
  var differenceBy = baseRest(function(array, values) {
    var iteratee = last(values);
    if (isArrayLikeObject(iteratee)) {
      iteratee = undefined;
    }
    return isArrayLikeObject(array)
      ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
      : [];
  });

  /**
   * This method is like `_.difference` except that it accepts `comparator`
   * which is invoked to compare elements of `array` to `values`. The order and
   * references of result values are determined by the first array. The comparator
   * is invoked with two arguments: (arrVal, othVal).
   *
   * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...Array} [values] The values to exclude.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
   *
   * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
   * // => [{ 'x': 2, 'y': 1 }]
   */
  var differenceWith = baseRest(function(array, values) {
    var comparator = last(values);
    if (isArrayLikeObject(comparator)) {
      comparator = undefined;
    }
    return isArrayLikeObject(array)
      ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
      : [];
  });

  /**
   * Creates a slice of `array` excluding elements dropped from the beginning.
   * Elements are dropped until `predicate` returns falsey. The predicate is
   * invoked with three arguments: (value, index, array).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to query.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.dropWhile(users, function(o) { return !o.active; });
   * // => objects for ['pebbles']
   *
   * // The `_.matches` iteratee shorthand.
   * _.dropWhile(users, { 'user': 'barney', 'active': false });
   * // => objects for ['fred', 'pebbles']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.dropWhile(users, ['active', false]);
   * // => objects for ['pebbles']
   *
   * // The `_.property` iteratee shorthand.
   * _.dropWhile(users, 'active');
   * // => objects for ['barney', 'fred', 'pebbles']
   */
  function dropWhile(array, predicate) {
    return (array && array.length)
      ? baseWhile(array, getIteratee(predicate, 3), true)
      : [];
  }

  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseFindIndex(array, getIteratee(predicate, 3), index);
  }

  /**
   * This method is like `_.findIndex` except that it iterates over elements
   * of `collection` from right to left.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=array.length-1] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': true },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': false }
   * ];
   *
   * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
   * // => 2
   *
   * // The `_.matches` iteratee shorthand.
   * _.findLastIndex(users, { 'user': 'barney', 'active': true });
   * // => 0
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findLastIndex(users, ['active', false]);
   * // => 2
   *
   * // The `_.property` iteratee shorthand.
   * _.findLastIndex(users, 'active');
   * // => 0
   */
  function findLastIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = length - 1;
    if (fromIndex !== undefined) {
      index = toInteger(fromIndex);
      index = fromIndex < 0
        ? nativeMax(length + index, 0)
        : nativeMin(index, length - 1);
    }
    return baseFindIndex(array, getIteratee(predicate, 3), index, true);
  }

  /**
   * Flattens `array` a single level deep.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flatten([1, [2, [3, [4]], 5]]);
   * // => [1, 2, [3, [4]], 5]
   */
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }

  /**
   * Gets the first element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias first
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the first element of `array`.
   * @example
   *
   * _.head([1, 2, 3]);
   * // => 1
   *
   * _.head([]);
   * // => undefined
   */
  function head(array) {
    return (array && array.length) ? array[0] : undefined;
  }

  /**
   * Gets the index at which the first occurrence of `value` is found in `array`
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. If `fromIndex` is negative, it's used as the
   * offset from the end of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   * @example
   *
   * _.indexOf([1, 2, 1, 2], 2);
   * // => 1
   *
   * // Search from the `fromIndex`.
   * _.indexOf([1, 2, 1, 2], 2, 2);
   * // => 3
   */
  function indexOf(array, value, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseIndexOf(array, value, index);
  }

  /**
   * Gets all but the last element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * _.initial([1, 2, 3]);
   * // => [1, 2]
   */
  function initial(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseSlice(array, 0, -1) : [];
  }

  /**
   * Creates an array of unique values that are included in all given arrays
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. The order and references of result values are
   * determined by the first array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of intersecting values.
   * @example
   *
   * _.intersection([2, 1], [2, 3]);
   * // => [2]
   */
  var intersection = baseRest(function(arrays) {
    var mapped = arrayMap(arrays, castArrayLikeObject);
    return (mapped.length && mapped[0] === arrays[0])
      ? baseIntersection(mapped)
      : [];
  });

  /**
   * This method is like `_.intersection` except that it accepts `iteratee`
   * which is invoked for each element of each `arrays` to generate the criterion
   * by which they're compared. The order and references of result values are
   * determined by the first array. The iteratee is invoked with one argument:
   * (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {Array} Returns the new array of intersecting values.
   * @example
   *
   * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
   * // => [2.1]
   *
   * // The `_.property` iteratee shorthand.
   * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 1 }]
   */
  var intersectionBy = baseRest(function(arrays) {
    var iteratee = last(arrays),
        mapped = arrayMap(arrays, castArrayLikeObject);

    if (iteratee === last(mapped)) {
      iteratee = undefined;
    } else {
      mapped.pop();
    }
    return (mapped.length && mapped[0] === arrays[0])
      ? baseIntersection(mapped, getIteratee(iteratee, 2))
      : [];
  });

  /**
   * This method is like `_.intersection` except that it accepts `comparator`
   * which is invoked to compare elements of `arrays`. The order and references
   * of result values are determined by the first array. The comparator is
   * invoked with two arguments: (arrVal, othVal).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of intersecting values.
   * @example
   *
   * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
   * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
   *
   * _.intersectionWith(objects, others, _.isEqual);
   * // => [{ 'x': 1, 'y': 2 }]
   */
  var intersectionWith = baseRest(function(arrays) {
    var comparator = last(arrays),
        mapped = arrayMap(arrays, castArrayLikeObject);

    comparator = typeof comparator == 'function' ? comparator : undefined;
    if (comparator) {
      mapped.pop();
    }
    return (mapped.length && mapped[0] === arrays[0])
      ? baseIntersection(mapped, undefined, comparator)
      : [];
  });

  /**
   * Converts all elements in `array` into a string separated by `separator`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to convert.
   * @param {string} [separator=','] The element separator.
   * @returns {string} Returns the joined string.
   * @example
   *
   * _.join(['a', 'b', 'c'], '~');
   * // => 'a~b~c'
   */
  function join(array, separator) {
    return array == null ? '' : nativeJoin.call(array, separator);
  }

  /**
   * Gets the last element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the last element of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   */
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
  }

  /**
   * Removes all given values from `array` using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
   * to remove elements from an array by predicate.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @param {...*} [values] The values to remove.
   * @returns {Array} Returns `array`.
   * @example
   *
   * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
   *
   * _.pull(array, 'a', 'c');
   * console.log(array);
   * // => ['b', 'b']
   */
  var pull = baseRest(pullAll);

  /**
   * This method is like `_.pull` except that it accepts an array of values to remove.
   *
   * **Note:** Unlike `_.difference`, this method mutates `array`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @param {Array} values The values to remove.
   * @returns {Array} Returns `array`.
   * @example
   *
   * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
   *
   * _.pullAll(array, ['a', 'c']);
   * console.log(array);
   * // => ['b', 'b']
   */
  function pullAll(array, values) {
    return (array && array.length && values && values.length)
      ? basePullAll(array, values)
      : array;
  }

  /**
   * Removes elements from `array` corresponding to `indexes` and returns an
   * array of removed elements.
   *
   * **Note:** Unlike `_.at`, this method mutates `array`.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @param {...(number|number[])} [indexes] The indexes of elements to remove.
   * @returns {Array} Returns the new array of removed elements.
   * @example
   *
   * var array = ['a', 'b', 'c', 'd'];
   * var pulled = _.pullAt(array, [1, 3]);
   *
   * console.log(array);
   * // => ['a', 'c']
   *
   * console.log(pulled);
   * // => ['b', 'd']
   */
  var pullAt = flatRest(function(array, indexes) {
    var length = array == null ? 0 : array.length,
        result = baseAt(array, indexes);

    basePullAt(array, arrayMap(indexes, function(index) {
      return isIndex(index, length) ? +index : index;
    }).sort(compareAscending));

    return result;
  });

  /**
   * Reverses `array` so that the first element becomes the last, the second
   * element becomes the second to last, and so on.
   *
   * **Note:** This method mutates `array` and is based on
   * [`Array#reverse`](https://mdn.io/Array/reverse).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @returns {Array} Returns `array`.
   * @example
   *
   * var array = [1, 2, 3];
   *
   * _.reverse(array);
   * // => [3, 2, 1]
   *
   * console.log(array);
   * // => [3, 2, 1]
   */
  function reverse(array) {
    return array == null ? array : nativeReverse.call(array);
  }

  /**
   * Creates a slice of `array` from `start` up to, but not including, `end`.
   *
   * **Note:** This method is used instead of
   * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
   * returned.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function slice(array, start, end) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
      start = 0;
      end = length;
    }
    else {
      start = start == null ? 0 : toInteger(start);
      end = end === undefined ? length : toInteger(end);
    }
    return baseSlice(array, start, end);
  }

  /**
   * Gets all but the first element of `array`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * _.tail([1, 2, 3]);
   * // => [2, 3]
   */
  function tail(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseSlice(array, 1, length) : [];
  }

  /**
   * Creates a slice of `array` with `n` elements taken from the beginning.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @param {number} [n=1] The number of elements to take.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * _.take([1, 2, 3]);
   * // => [1]
   *
   * _.take([1, 2, 3], 2);
   * // => [1, 2]
   *
   * _.take([1, 2, 3], 5);
   * // => [1, 2, 3]
   *
   * _.take([1, 2, 3], 0);
   * // => []
   */
  function take(array, n, guard) {
    if (!(array && array.length)) {
      return [];
    }
    n = (guard || n === undefined) ? 1 : toInteger(n);
    return baseSlice(array, 0, n < 0 ? 0 : n);
  }

  /**
   * Creates a slice of `array` with `n` elements taken from the end.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to query.
   * @param {number} [n=1] The number of elements to take.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * _.takeRight([1, 2, 3]);
   * // => [3]
   *
   * _.takeRight([1, 2, 3], 2);
   * // => [2, 3]
   *
   * _.takeRight([1, 2, 3], 5);
   * // => [1, 2, 3]
   *
   * _.takeRight([1, 2, 3], 0);
   * // => []
   */
  function takeRight(array, n, guard) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    n = (guard || n === undefined) ? 1 : toInteger(n);
    n = length - n;
    return baseSlice(array, n < 0 ? 0 : n, length);
  }

  /**
   * Creates a slice of `array` with elements taken from the beginning. Elements
   * are taken until `predicate` returns falsey. The predicate is invoked with
   * three arguments: (value, index, array).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to query.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.takeWhile(users, function(o) { return !o.active; });
   * // => objects for ['barney', 'fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.takeWhile(users, { 'user': 'barney', 'active': false });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.takeWhile(users, ['active', false]);
   * // => objects for ['barney', 'fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.takeWhile(users, 'active');
   * // => []
   */
  function takeWhile(array, predicate) {
    return (array && array.length)
      ? baseWhile(array, getIteratee(predicate, 3))
      : [];
  }

  /**
   * Creates an array of unique values, in order, from all given arrays using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of combined values.
   * @example
   *
   * _.union([2], [1, 2]);
   * // => [2, 1]
   */
  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });

  /**
   * This method is like `_.union` except that it accepts `iteratee` which is
   * invoked for each element of each `arrays` to generate the criterion by
   * which uniqueness is computed. Result values are chosen from the first
   * array in which the value occurs. The iteratee is invoked with one argument:
   * (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {Array} Returns the new array of combined values.
   * @example
   *
   * _.unionBy([2.1], [1.2, 2.3], Math.floor);
   * // => [2.1, 1.2]
   *
   * // The `_.property` iteratee shorthand.
   * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 1 }, { 'x': 2 }]
   */
  var unionBy = baseRest(function(arrays) {
    var iteratee = last(arrays);
    if (isArrayLikeObject(iteratee)) {
      iteratee = undefined;
    }
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
  });

  /**
   * This method is like `_.union` except that it accepts `comparator` which
   * is invoked to compare elements of `arrays`. Result values are chosen from
   * the first array in which the value occurs. The comparator is invoked
   * with two arguments: (arrVal, othVal).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of combined values.
   * @example
   *
   * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
   * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
   *
   * _.unionWith(objects, others, _.isEqual);
   * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
   */
  var unionWith = baseRest(function(arrays) {
    var comparator = last(arrays);
    comparator = typeof comparator == 'function' ? comparator : undefined;
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
  });

  /**
   * Creates a duplicate-free version of an array, using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons, in which only the first occurrence of each element
   * is kept. The order of result values is determined by the order they occur
   * in the array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @returns {Array} Returns the new duplicate free array.
   * @example
   *
   * _.uniq([2, 1, 2]);
   * // => [2, 1]
   */
  function uniq(array) {
    return (array && array.length) ? baseUniq(array) : [];
  }

  /**
   * This method is like `_.uniq` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the criterion by which
   * uniqueness is computed. The order of result values is determined by the
   * order they occur in the array. The iteratee is invoked with one argument:
   * (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   * @example
   *
   * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
   * // => [2.1, 1.2]
   *
   * // The `_.property` iteratee shorthand.
   * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 1 }, { 'x': 2 }]
   */
  function uniqBy(array, iteratee) {
    return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
  }

  /**
   * This method is like `_.uniq` except that it accepts `comparator` which
   * is invoked to compare elements of `array`. The order of result values is
   * determined by the order they occur in the array.The comparator is invoked
   * with two arguments: (arrVal, othVal).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   * @example
   *
   * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
   *
   * _.uniqWith(objects, _.isEqual);
   * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
   */
  function uniqWith(array, comparator) {
    comparator = typeof comparator == 'function' ? comparator : undefined;
    return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
  }

  /**
   * Creates an array excluding all given values using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * **Note:** Unlike `_.pull`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...*} [values] The values to exclude.
   * @returns {Array} Returns the new array of filtered values.
   * @see _.difference, _.xor
   * @example
   *
   * _.without([2, 1, 2, 3], 1, 2);
   * // => [3]
   */
  var without = baseRest(function(array, values) {
    return isArrayLikeObject(array)
      ? baseDifference(array, values)
      : [];
  });

  /**
   * Creates an array of unique values that is the
   * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
   * of the given arrays. The order of result values is determined by the order
   * they occur in the arrays.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of filtered values.
   * @see _.difference, _.without
   * @example
   *
   * _.xor([2, 1], [2, 3]);
   * // => [1, 3]
   */
  var xor = baseRest(function(arrays) {
    return baseXor(arrayFilter(arrays, isArrayLikeObject));
  });

  /**
   * This method is like `_.xor` except that it accepts `iteratee` which is
   * invoked for each element of each `arrays` to generate the criterion by
   * which by which they're compared. The order of result values is determined
   * by the order they occur in the arrays. The iteratee is invoked with one
   * argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
   * // => [1.2, 3.4]
   *
   * // The `_.property` iteratee shorthand.
   * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 2 }]
   */
  var xorBy = baseRest(function(arrays) {
    var iteratee = last(arrays);
    if (isArrayLikeObject(iteratee)) {
      iteratee = undefined;
    }
    return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
  });

  /**
   * This method is like `_.xor` except that it accepts `comparator` which is
   * invoked to compare elements of `arrays`. The order of result values is
   * determined by the order they occur in the arrays. The comparator is invoked
   * with two arguments: (arrVal, othVal).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
   * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
   *
   * _.xorWith(objects, others, _.isEqual);
   * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
   */
  var xorWith = baseRest(function(arrays) {
    var comparator = last(arrays);
    comparator = typeof comparator == 'function' ? comparator : undefined;
    return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
  });

  /*------------------------------------------------------------------------*/

  /**
   * Creates an object composed of keys generated from the results of running
   * each element of `collection` thru `iteratee`. The corresponding value of
   * each key is the number of times the key was returned by `iteratee`. The
   * iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.countBy([6.1, 4.2, 6.3], Math.floor);
   * // => { '4': 1, '6': 2 }
   *
   * // The `_.property` iteratee shorthand.
   * _.countBy(['one', 'two', 'three'], 'length');
   * // => { '3': 2, '5': 1 }
   */
  var countBy = createAggregator(function(result, value, key) {
    if (hasOwnProperty.call(result, key)) {
      ++result[key];
    } else {
      baseAssignValue(result, key, 1);
    }
  });

  /**
   * Checks if `predicate` returns truthy for **all** elements of `collection`.
   * Iteration is stopped once `predicate` returns falsey. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * **Note:** This method returns `true` for
   * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
   * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
   * elements of empty collections.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes'], Boolean);
   * // => false
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': false },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.every(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.every(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.every(users, 'active');
   * // => false
   */
  function every(collection, predicate, guard) {
    var func = isArray(collection) ? arrayEvery : baseEvery;
    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = undefined;
    }
    return func(collection, getIteratee(predicate, 3));
  }

  /**
   * Iterates over elements of `collection`, returning an array of all elements
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * **Note:** Unlike `_.remove`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   * @see _.reject
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * _.filter(users, function(o) { return !o.active; });
   * // => objects for ['fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, { 'age': 36, 'active': true });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, ['active', false]);
   * // => objects for ['fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.filter(users, 'active');
   * // => objects for ['barney']
   */
  function filter(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, getIteratee(predicate, 3));
  }

  /**
   * Iterates over elements of `collection`, returning the first element
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36, 'active': true },
   *   { 'user': 'fred',    'age': 40, 'active': false },
   *   { 'user': 'pebbles', 'age': 1,  'active': true }
   * ];
   *
   * _.find(users, function(o) { return o.age < 40; });
   * // => object for 'barney'
   *
   * // The `_.matches` iteratee shorthand.
   * _.find(users, { 'age': 1, 'active': true });
   * // => object for 'pebbles'
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.find(users, ['active', false]);
   * // => object for 'fred'
   *
   * // The `_.property` iteratee shorthand.
   * _.find(users, 'active');
   * // => object for 'barney'
   */
  var find = createFind(findIndex);

  /**
   * This method is like `_.find` except that it iterates over elements of
   * `collection` from right to left.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=collection.length-1] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * _.findLast([1, 2, 3, 4], function(n) {
   *   return n % 2 == 1;
   * });
   * // => 3
   */
  var findLast = createFind(findLastIndex);

  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */
  function forEach(collection, iteratee) {
    var func = isArray(collection) ? arrayEach : baseEach;
    return func(collection, getIteratee(iteratee, 3));
  }

  /**
   * This method is like `_.forEach` except that it iterates over elements of
   * `collection` from right to left.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @alias eachRight
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEach
   * @example
   *
   * _.forEachRight([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `2` then `1`.
   */
  function forEachRight(collection, iteratee) {
    var func = isArray(collection) ? arrayEachRight : baseEachRight;
    return func(collection, getIteratee(iteratee, 3));
  }

  /**
   * Creates an object composed of keys generated from the results of running
   * each element of `collection` thru `iteratee`. The order of grouped values
   * is determined by the order they occur in `collection`. The corresponding
   * value of each key is an array of elements responsible for generating the
   * key. The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.groupBy([6.1, 4.2, 6.3], Math.floor);
   * // => { '4': [4.2], '6': [6.1, 6.3] }
   *
   * // The `_.property` iteratee shorthand.
   * _.groupBy(['one', 'two', 'three'], 'length');
   * // => { '3': ['one', 'two'], '5': ['three'] }
   */
  var groupBy = createAggregator(function(result, value, key) {
    if (hasOwnProperty.call(result, key)) {
      result[key].push(value);
    } else {
      baseAssignValue(result, key, [value]);
    }
  });

  /**
   * Checks if `value` is in `collection`. If `collection` is a string, it's
   * checked for a substring of `value`, otherwise
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * is used for equality comparisons. If `fromIndex` is negative, it's used as
   * the offset from the end of `collection`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {boolean} Returns `true` if `value` is found, else `false`.
   * @example
   *
   * _.includes([1, 2, 3], 1);
   * // => true
   *
   * _.includes([1, 2, 3], 1, 2);
   * // => false
   *
   * _.includes({ 'a': 1, 'b': 2 }, 1);
   * // => true
   *
   * _.includes('abcd', 'bc');
   * // => true
   */
  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection)
      ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
      : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
  }

  /**
   * Creates an array of values by running each element in `collection` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
   *
   * The guarded methods are:
   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * _.map([4, 8], square);
   * // => [16, 64]
   *
   * _.map({ 'a': 4, 'b': 8 }, square);
   * // => [16, 64] (iteration order is not guaranteed)
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, 'user');
   * // => ['barney', 'fred']
   */
  function map(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, getIteratee(iteratee, 3));
  }

  /**
   * This method is like `_.sortBy` except that it allows specifying the sort
   * orders of the iteratees to sort by. If `orders` is unspecified, all values
   * are sorted in ascending order. Otherwise, specify an order of "desc" for
   * descending or "asc" for ascending sort order of corresponding values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @param {string[]} [orders] The sort orders of `iteratees`.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 34 },
   *   { 'user': 'fred',   'age': 40 },
   *   { 'user': 'barney', 'age': 36 }
   * ];
   *
   * // Sort by `user` in ascending order and by `age` in descending order.
   * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
   */
  function orderBy(collection, iteratees, orders, guard) {
    if (collection == null) {
      return [];
    }
    if (!isArray(iteratees)) {
      iteratees = iteratees == null ? [] : [iteratees];
    }
    orders = guard ? undefined : orders;
    if (!isArray(orders)) {
      orders = orders == null ? [] : [orders];
    }
    return baseOrderBy(collection, iteratees, orders);
  }

  /**
   * Reduces `collection` to a value which is the accumulated result of running
   * each element in `collection` thru `iteratee`, where each successive
   * invocation is supplied the return value of the previous. If `accumulator`
   * is not given, the first element of `collection` is used as the initial
   * value. The iteratee is invoked with four arguments:
   * (accumulator, value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.reduce`, `_.reduceRight`, and `_.transform`.
   *
   * The guarded methods are:
   * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
   * and `sortBy`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @returns {*} Returns the accumulated value.
   * @see _.reduceRight
   * @example
   *
   * _.reduce([1, 2], function(sum, n) {
   *   return sum + n;
   * }, 0);
   * // => 3
   *
   * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
   *   (result[value] || (result[value] = [])).push(key);
   *   return result;
   * }, {});
   * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
   */
  function reduce(collection, iteratee, accumulator) {
    var func = isArray(collection) ? arrayReduce : baseReduce,
        initAccum = arguments.length < 3;

    return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
  }

  /**
   * Checks if `predicate` returns truthy for **any** element of `collection`.
   * Iteration is stopped once `predicate` returns truthy. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, 'yes', false], Boolean);
   * // => true
   *
   * var users = [
   *   { 'user': 'barney', 'active': true },
   *   { 'user': 'fred',   'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.some(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.some(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.some(users, 'active');
   * // => true
   */
  function some(collection, predicate, guard) {
    var func = isArray(collection) ? arraySome : baseSome;
    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = undefined;
    }
    return func(collection, getIteratee(predicate, 3));
  }

  /**
   * Creates an array of elements, sorted in ascending order by the results of
   * running each element in a collection thru each iteratee. This method
   * performs a stable sort, that is, it preserves the original sort order of
   * equal elements. The iteratees are invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {...(Function|Function[])} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 40 },
   *   { 'user': 'barney', 'age': 34 }
   * ];
   *
   * _.sortBy(users, [function(o) { return o.user; }]);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
   *
   * _.sortBy(users, ['user', 'age']);
   * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
   */
  var sortBy = baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length = iteratees.length;
    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });

  /*------------------------------------------------------------------------*/

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root.Date.now();
  };

  /*------------------------------------------------------------------------*/

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;

  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a shallow clone of `value`.
   *
   * **Note:** This method is loosely based on the
   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
   * and supports cloning arrays, array buffers, booleans, date objects, maps,
   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
   * arrays. The own enumerable properties of `arguments` objects are cloned
   * as plain objects. An empty object is returned for uncloneable values such
   * as error objects, functions, DOM nodes, and WeakMaps.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to clone.
   * @returns {*} Returns the cloned value.
   * @see _.cloneDeep
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var shallow = _.clone(objects);
   * console.log(shallow[0] === objects[0]);
   * // => true
   */
  function clone(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG);
  }

  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /**
   * Checks if `value` is an empty object, collection, map, or set.
   *
   * Objects are considered empty if they have no own enumerable string keyed
   * properties.
   *
   * Array-like values such as `arguments` objects, arrays, buffers, strings, or
   * jQuery-like collections are considered empty if they have a `length` of `0`.
   * Similarly, maps and sets are considered empty if they have a `size` of `0`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty(null);
   * // => true
   *
   * _.isEmpty(true);
   * // => true
   *
   * _.isEmpty(1);
   * // => true
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({ 'a': 1 });
   * // => false
   */
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike(value) &&
        (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
          isBuffer(value) || isTypedArray(value) || isArguments(value))) {
      return !value.length;
    }
    var tag = getTag(value);
    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }
    if (isPrototype(value)) {
      return !baseKeys(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent.
   *
   * **Note:** This method supports comparing arrays, array buffers, booleans,
   * date objects, error objects, maps, numbers, `Object` objects, regexes,
   * sets, strings, symbols, and typed arrays. `Object` objects are compared
   * by their own, not inherited, enumerable properties. Functions and DOM
   * nodes are compared by strict equality, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.isEqual(object, other);
   * // => true
   *
   * object === other;
   * // => false
   */
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }

  /**
   * This method is like `_.isEqual` except that it accepts `customizer` which
   * is invoked to compare values. If `customizer` returns `undefined`, comparisons
   * are handled by the method instead. The `customizer` is invoked with up to
   * six arguments: (objValue, othValue [, index|key, object, other, stack]).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * function isGreeting(value) {
   *   return /^h(?:i|ello)$/.test(value);
   * }
   *
   * function customizer(objValue, othValue) {
   *   if (isGreeting(objValue) && isGreeting(othValue)) {
   *     return true;
   *   }
   * }
   *
   * var array = ['hello', 'goodbye'];
   * var other = ['hi', 'goodbye'];
   *
   * _.isEqualWith(array, other, customizer);
   * // => true
   */
  function isEqualWith(value, other, customizer) {
    customizer = typeof customizer == 'function' ? customizer : undefined;
    var result = customizer ? customizer(value, other) : undefined;
    return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
  }

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */
  function isString(value) {
    return typeof value == 'string' ||
      (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
  }

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag);
  }

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = (value < 0 ? -1 : 1);
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  function toInteger(value) {
    var result = toFinite(value),
        remainder = result % 1;

    return result === result ? (remainder ? result - remainder : result) : 0;
  }

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable string keyed properties of source objects to the
   * destination object. Source objects are applied from left to right.
   * Subsequent sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object` and is loosely based on
   * [`Object.assign`](https://mdn.io/Object/assign).
   *
   * @static
   * @memberOf _
   * @since 0.10.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assignIn
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assign({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'c': 3 }
   */
  var assign = createAssigner(function(object, source) {
    if (isPrototype(source) || isArrayLike(source)) {
      copyObject(source, keys(source), object);
      return;
    }
    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        assignValue(object, key, source[key]);
      }
    }
  });

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /**
   * Creates an object with the same keys as `object` and values generated
   * by running each own enumerable string keyed property of `object` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, key, object).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Object
   * @param {Object} object The object to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Object} Returns the new mapped object.
   * @see _.mapKeys
   * @example
   *
   * var users = {
   *   'fred':    { 'user': 'fred',    'age': 40 },
   *   'pebbles': { 'user': 'pebbles', 'age': 1 }
   * };
   *
   * _.mapValues(users, function(o) { return o.age; });
   * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
   *
   * // The `_.property` iteratee shorthand.
   * _.mapValues(users, 'age');
   * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
   */
  function mapValues(object, iteratee) {
    var result = {};
    iteratee = getIteratee(iteratee, 3);

    baseForOwn(object, function(value, key, object) {
      baseAssignValue(result, key, iteratee(value, key, object));
    });
    return result;
  }

  /**
   * Creates an object composed of the picked `object` properties.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The source object.
   * @param {...(string|string[])} [paths] The property paths to pick.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.pick(object, ['a', 'c']);
   * // => { 'a': 1, 'c': 3 }
   */
  var pick = flatRest(function(object, paths) {
    return object == null ? {} : basePick(object, paths);
  });

  /**
   * Creates an object composed of the `object` properties `predicate` returns
   * truthy for. The predicate is invoked with two arguments: (value, key).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The source object.
   * @param {Function} [predicate=_.identity] The function invoked per property.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.pickBy(object, _.isNumber);
   * // => { 'a': 1, 'c': 3 }
   */
  function pickBy(object, predicate) {
    if (object == null) {
      return {};
    }
    var props = arrayMap(getAllKeysIn(object), function(prop) {
      return [prop];
    });
    predicate = getIteratee(predicate);
    return basePickBy(object, props, function(value, path) {
      return predicate(value, path[0]);
    });
  }

  /**
   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
   * it's created. Arrays are created for missing index properties while objects
   * are created for all other missing properties. Use `_.setWith` to customize
   * `path` creation.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.set(object, 'a[0].b.c', 4);
   * console.log(object.a[0].b.c);
   * // => 4
   *
   * _.set(object, ['x', '0', 'y', 'z'], 5);
   * console.log(object.x[0].y.z);
   * // => 5
   */
  function set(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
  }

  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */
  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }

  /*------------------------------------------------------------------------*/

  /**
   * Pads `string` on the left and right sides if it's shorter than `length`.
   * Padding characters are truncated if they can't be evenly divided by `length`.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to pad.
   * @param {number} [length=0] The padding length.
   * @param {string} [chars=' '] The string used as padding.
   * @returns {string} Returns the padded string.
   * @example
   *
   * _.pad('abc', 8);
   * // => '  abc   '
   *
   * _.pad('abc', 8, '_-');
   * // => '_-abc_-_'
   *
   * _.pad('abc', 3);
   * // => 'abc'
   */
  function pad(string, length, chars) {
    string = toString(string);
    length = toInteger(length);

    var strLength = length ? stringSize(string) : 0;
    if (!length || strLength >= length) {
      return string;
    }
    var mid = (length - strLength) / 2;
    return (
      createPadding(nativeFloor(mid), chars) +
      string +
      createPadding(nativeCeil(mid), chars)
    );
  }

  /**
   * Pads `string` on the right side if it's shorter than `length`. Padding
   * characters are truncated if they exceed `length`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to pad.
   * @param {number} [length=0] The padding length.
   * @param {string} [chars=' '] The string used as padding.
   * @returns {string} Returns the padded string.
   * @example
   *
   * _.padEnd('abc', 6);
   * // => 'abc   '
   *
   * _.padEnd('abc', 6, '_-');
   * // => 'abc_-_'
   *
   * _.padEnd('abc', 3);
   * // => 'abc'
   */
  function padEnd(string, length, chars) {
    string = toString(string);
    length = toInteger(length);

    var strLength = length ? stringSize(string) : 0;
    return (length && strLength < length)
      ? (string + createPadding(length - strLength, chars))
      : string;
  }

  /**
   * Pads `string` on the left side if it's shorter than `length`. Padding
   * characters are truncated if they exceed `length`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to pad.
   * @param {number} [length=0] The padding length.
   * @param {string} [chars=' '] The string used as padding.
   * @returns {string} Returns the padded string.
   * @example
   *
   * _.padStart('abc', 6);
   * // => '   abc'
   *
   * _.padStart('abc', 6, '_-');
   * // => '_-_abc'
   *
   * _.padStart('abc', 3);
   * // => 'abc'
   */
  function padStart(string, length, chars) {
    string = toString(string);
    length = toInteger(length);

    var strLength = length ? stringSize(string) : 0;
    return (length && strLength < length)
      ? (createPadding(length - strLength, chars) + string)
      : string;
  }

  /**
   * Converts `string` to an integer of the specified radix. If `radix` is
   * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
   * hexadecimal, in which case a `radix` of `16` is used.
   *
   * **Note:** This method aligns with the
   * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category String
   * @param {string} string The string to convert.
   * @param {number} [radix=10] The radix to interpret `value` by.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.parseInt('08');
   * // => 8
   *
   * _.map(['6', '08', '10'], _.parseInt);
   * // => [6, 8, 10]
   */
  function parseInt(string, radix, guard) {
    if (guard || radix == null) {
      radix = 0;
    } else if (radix) {
      radix = +radix;
    }
    return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
  }

  /**
   * Removes leading and trailing whitespace or specified characters from `string`.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to trim.
   * @param {string} [chars=whitespace] The characters to trim.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {string} Returns the trimmed string.
   * @example
   *
   * _.trim('  abc  ');
   * // => 'abc'
   *
   * _.trim('-_-abc-_-', '_-');
   * // => 'abc'
   *
   * _.map(['  foo  ', '  bar  '], _.trim);
   * // => ['foo', 'bar']
   */
  function trim(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === undefined)) {
      return string.replace(reTrim, '');
    }
    if (!string || !(chars = baseToString(chars))) {
      return string;
    }
    var strSymbols = stringToArray(string),
        chrSymbols = stringToArray(chars),
        start = charsStartIndex(strSymbols, chrSymbols),
        end = charsEndIndex(strSymbols, chrSymbols) + 1;

    return castSlice(strSymbols, start, end).join('');
  }

  /**
   * Removes trailing whitespace or specified characters from `string`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to trim.
   * @param {string} [chars=whitespace] The characters to trim.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {string} Returns the trimmed string.
   * @example
   *
   * _.trimEnd('  abc  ');
   * // => '  abc'
   *
   * _.trimEnd('-_-abc-_-', '_-');
   * // => '-_-abc'
   */
  function trimEnd(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === undefined)) {
      return string.replace(reTrimEnd, '');
    }
    if (!string || !(chars = baseToString(chars))) {
      return string;
    }
    var strSymbols = stringToArray(string),
        end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

    return castSlice(strSymbols, 0, end).join('');
  }

  /**
   * Removes leading whitespace or specified characters from `string`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to trim.
   * @param {string} [chars=whitespace] The characters to trim.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {string} Returns the trimmed string.
   * @example
   *
   * _.trimStart('  abc  ');
   * // => 'abc  '
   *
   * _.trimStart('-_-abc-_-', '_-');
   * // => 'abc-_-'
   */
  function trimStart(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === undefined)) {
      return string.replace(reTrimStart, '');
    }
    if (!string || !(chars = baseToString(chars))) {
      return string;
    }
    var strSymbols = stringToArray(string),
        start = charsStartIndex(strSymbols, stringToArray(chars));

    return castSlice(strSymbols, start).join('');
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * Creates a function that invokes `func` with the arguments of the created
   * function. If `func` is a property name, the created function returns the
   * property value for a given element. If `func` is an array or object, the
   * created function returns `true` for elements that contain the equivalent
   * source properties, otherwise it returns `false`.
   *
   * @static
   * @since 4.0.0
   * @memberOf _
   * @category Util
   * @param {*} [func=_.identity] The value to convert to a callback.
   * @returns {Function} Returns the callback.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
   * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, _.iteratee(['user', 'fred']));
   * // => [{ 'user': 'fred', 'age': 40 }]
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, _.iteratee('user'));
   * // => ['barney', 'fred']
   *
   * // Create custom iteratee shorthands.
   * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
   *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
   *     return func.test(string);
   *   };
   * });
   *
   * _.filter(['abc', 'def'], /ef/);
   * // => ['def']
   */
  function iteratee(func) {
    return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
  }

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /**
   * Generates a unique ID. If `prefix` is given, the ID is appended to it.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {string} [prefix=''] The value to prefix the ID with.
   * @returns {string} Returns the unique ID.
   * @example
   *
   * _.uniqueId('contact_');
   * // => 'contact_104'
   *
   * _.uniqueId();
   * // => '105'
   */
  function uniqueId(prefix) {
    var id = ++idCounter;
    return toString(prefix) + id;
  }

  /*------------------------------------------------------------------------*/

  /**
   * Adds two numbers.
   *
   * @static
   * @memberOf _
   * @since 3.4.0
   * @category Math
   * @param {number} augend The first number in an addition.
   * @param {number} addend The second number in an addition.
   * @returns {number} Returns the total.
   * @example
   *
   * _.add(6, 4);
   * // => 10
   */
  var add = createMathOperation(function(augend, addend) {
    return augend + addend;
  }, 0);

  /**
   * Computes `number` rounded up to `precision`.
   *
   * @static
   * @memberOf _
   * @since 3.10.0
   * @category Math
   * @param {number} number The number to round up.
   * @param {number} [precision=0] The precision to round up to.
   * @returns {number} Returns the rounded up number.
   * @example
   *
   * _.ceil(4.006);
   * // => 5
   *
   * _.ceil(6.004, 2);
   * // => 6.01
   *
   * _.ceil(6040, -2);
   * // => 6100
   */
  var ceil = createRound('ceil');

  /**
   * Divide two numbers.
   *
   * @static
   * @memberOf _
   * @since 4.7.0
   * @category Math
   * @param {number} dividend The first number in a division.
   * @param {number} divisor The second number in a division.
   * @returns {number} Returns the quotient.
   * @example
   *
   * _.divide(6, 4);
   * // => 1.5
   */
  var divide = createMathOperation(function(dividend, divisor) {
    return dividend / divisor;
  }, 1);

  /**
   * Computes `number` rounded down to `precision`.
   *
   * @static
   * @memberOf _
   * @since 3.10.0
   * @category Math
   * @param {number} number The number to round down.
   * @param {number} [precision=0] The precision to round down to.
   * @returns {number} Returns the rounded down number.
   * @example
   *
   * _.floor(4.006);
   * // => 4
   *
   * _.floor(0.046, 2);
   * // => 0.04
   *
   * _.floor(4060, -2);
   * // => 4000
   */
  var floor = createRound('floor');

  /**
   * Computes the maximum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the maximum value.
   * @example
   *
   * _.max([4, 2, 8, 6]);
   * // => 8
   *
   * _.max([]);
   * // => undefined
   */
  function max(array) {
    return (array && array.length)
      ? baseExtremum(array, identity, baseGt)
      : undefined;
  }

  /**
   * This method is like `_.max` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the criterion by which
   * the value is ranked. The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {*} Returns the maximum value.
   * @example
   *
   * var objects = [{ 'n': 1 }, { 'n': 2 }];
   *
   * _.maxBy(objects, function(o) { return o.n; });
   * // => { 'n': 2 }
   *
   * // The `_.property` iteratee shorthand.
   * _.maxBy(objects, 'n');
   * // => { 'n': 2 }
   */
  function maxBy(array, iteratee) {
    return (array && array.length)
      ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
      : undefined;
  }

  /**
   * Computes the mean of the values in `array`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {number} Returns the mean.
   * @example
   *
   * _.mean([4, 2, 8, 6]);
   * // => 5
   */
  function mean(array) {
    return baseMean(array, identity);
  }

  /**
   * This method is like `_.mean` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the value to be averaged.
   * The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.7.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {number} Returns the mean.
   * @example
   *
   * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
   *
   * _.meanBy(objects, function(o) { return o.n; });
   * // => 5
   *
   * // The `_.property` iteratee shorthand.
   * _.meanBy(objects, 'n');
   * // => 5
   */
  function meanBy(array, iteratee) {
    return baseMean(array, getIteratee(iteratee, 2));
  }

  /**
   * Computes the minimum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * _.min([4, 2, 8, 6]);
   * // => 2
   *
   * _.min([]);
   * // => undefined
   */
  function min(array) {
    return (array && array.length)
      ? baseExtremum(array, identity, baseLt)
      : undefined;
  }

  /**
   * This method is like `_.min` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the criterion by which
   * the value is ranked. The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * var objects = [{ 'n': 1 }, { 'n': 2 }];
   *
   * _.minBy(objects, function(o) { return o.n; });
   * // => { 'n': 1 }
   *
   * // The `_.property` iteratee shorthand.
   * _.minBy(objects, 'n');
   * // => { 'n': 1 }
   */
  function minBy(array, iteratee) {
    return (array && array.length)
      ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
      : undefined;
  }

  /**
   * Multiply two numbers.
   *
   * @static
   * @memberOf _
   * @since 4.7.0
   * @category Math
   * @param {number} multiplier The first number in a multiplication.
   * @param {number} multiplicand The second number in a multiplication.
   * @returns {number} Returns the product.
   * @example
   *
   * _.multiply(6, 4);
   * // => 24
   */
  var multiply = createMathOperation(function(multiplier, multiplicand) {
    return multiplier * multiplicand;
  }, 1);

  /**
   * Computes `number` rounded to `precision`.
   *
   * @static
   * @memberOf _
   * @since 3.10.0
   * @category Math
   * @param {number} number The number to round.
   * @param {number} [precision=0] The precision to round to.
   * @returns {number} Returns the rounded number.
   * @example
   *
   * _.round(4.006);
   * // => 4
   *
   * _.round(4.006, 2);
   * // => 4.01
   *
   * _.round(4060, -2);
   * // => 4100
   */
  var round = createRound('round');

  /**
   * Subtract two numbers.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {number} minuend The first number in a subtraction.
   * @param {number} subtrahend The second number in a subtraction.
   * @returns {number} Returns the difference.
   * @example
   *
   * _.subtract(6, 4);
   * // => 2
   */
  var subtract = createMathOperation(function(minuend, subtrahend) {
    return minuend - subtrahend;
  }, 0);

  /**
   * Computes the sum of the values in `array`.
   *
   * @static
   * @memberOf _
   * @since 3.4.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {number} Returns the sum.
   * @example
   *
   * _.sum([4, 2, 8, 6]);
   * // => 20
   */
  function sum(array) {
    return (array && array.length)
      ? baseSum(array, identity)
      : 0;
  }

  /**
   * This method is like `_.sum` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the value to be summed.
   * The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {number} Returns the sum.
   * @example
   *
   * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
   *
   * _.sumBy(objects, function(o) { return o.n; });
   * // => 20
   *
   * // The `_.property` iteratee shorthand.
   * _.sumBy(objects, 'n');
   * // => 20
   */
  function sumBy(array, iteratee) {
    return (array && array.length)
      ? baseSum(array, getIteratee(iteratee, 2))
      : 0;
  }

  /*------------------------------------------------------------------------*/

  // Add methods that return wrapped values in chain sequences.
  lodash.assign = assign;
  lodash.compact = compact;
  lodash.concat = concat;
  lodash.constant = constant;
  lodash.countBy = countBy;
  lodash.debounce = debounce;
  lodash.difference = difference;
  lodash.differenceBy = differenceBy;
  lodash.differenceWith = differenceWith;
  lodash.dropWhile = dropWhile;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.groupBy = groupBy;
  lodash.initial = initial;
  lodash.intersection = intersection;
  lodash.intersectionBy = intersectionBy;
  lodash.intersectionWith = intersectionWith;
  lodash.iteratee = iteratee;
  lodash.keys = keys;
  lodash.keysIn = keysIn;
  lodash.map = map;
  lodash.mapValues = mapValues;
  lodash.memoize = memoize;
  lodash.orderBy = orderBy;
  lodash.pick = pick;
  lodash.pickBy = pickBy;
  lodash.property = property;
  lodash.pull = pull;
  lodash.pullAll = pullAll;
  lodash.pullAt = pullAt;
  lodash.reverse = reverse;
  lodash.set = set;
  lodash.slice = slice;
  lodash.sortBy = sortBy;
  lodash.tail = tail;
  lodash.take = take;
  lodash.takeRight = takeRight;
  lodash.takeWhile = takeWhile;
  lodash.throttle = throttle;
  lodash.union = union;
  lodash.unionBy = unionBy;
  lodash.unionWith = unionWith;
  lodash.uniq = uniq;
  lodash.uniqBy = uniqBy;
  lodash.uniqWith = uniqWith;
  lodash.values = values;
  lodash.without = without;
  lodash.xor = xor;
  lodash.xorBy = xorBy;
  lodash.xorWith = xorWith;

  /*------------------------------------------------------------------------*/

  // Add methods that return unwrapped values in chain sequences.
  lodash.add = add;
  lodash.ceil = ceil;
  lodash.clone = clone;
  lodash.cloneDeep = cloneDeep;
  lodash.divide = divide;
  lodash.eq = eq;
  lodash.every = every;
  lodash.find = find;
  lodash.findIndex = findIndex;
  lodash.findLast = findLast;
  lodash.findLastIndex = findLastIndex;
  lodash.floor = floor;
  lodash.forEach = forEach;
  lodash.forEachRight = forEachRight;
  lodash.get = get;
  lodash.hasIn = hasIn;
  lodash.head = head;
  lodash.identity = identity;
  lodash.includes = includes;
  lodash.indexOf = indexOf;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isArrayLike = isArrayLike;
  lodash.isArrayLikeObject = isArrayLikeObject;
  lodash.isBuffer = isBuffer;
  lodash.isEmpty = isEmpty;
  lodash.isEqual = isEqual;
  lodash.isEqualWith = isEqualWith;
  lodash.isFunction = isFunction;
  lodash.isLength = isLength;
  lodash.isMap = isMap;
  lodash.isObject = isObject;
  lodash.isObjectLike = isObjectLike;
  lodash.isSet = isSet;
  lodash.isString = isString;
  lodash.isSymbol = isSymbol;
  lodash.isTypedArray = isTypedArray;
  lodash.join = join;
  lodash.last = last;
  lodash.max = max;
  lodash.maxBy = maxBy;
  lodash.mean = mean;
  lodash.meanBy = meanBy;
  lodash.min = min;
  lodash.minBy = minBy;
  lodash.stubArray = stubArray;
  lodash.stubFalse = stubFalse;
  lodash.multiply = multiply;
  lodash.noop = noop;
  lodash.now = now;
  lodash.pad = pad;
  lodash.padEnd = padEnd;
  lodash.padStart = padStart;
  lodash.parseInt = parseInt;
  lodash.reduce = reduce;
  lodash.round = round;
  lodash.some = some;
  lodash.subtract = subtract;
  lodash.sum = sum;
  lodash.sumBy = sumBy;
  lodash.toFinite = toFinite;
  lodash.toInteger = toInteger;
  lodash.toNumber = toNumber;
  lodash.toString = toString;
  lodash.trim = trim;
  lodash.trimEnd = trimEnd;
  lodash.trimStart = trimStart;
  lodash.uniqueId = uniqueId;

  // Add aliases.
  lodash.each = forEach;
  lodash.eachRight = forEachRight;
  lodash.first = head;

  /*------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type {string}
   */
  lodash.VERSION = VERSION;

  /*--------------------------------------------------------------------------*/

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root.lodash = lodash;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return lodash;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = lodash).lodash = lodash;
    // Export for CommonJS support.
    freeExports.lodash = lodash;
  }
  else {
    // Export to the global object.
    root.lodash = lodash;
  }
}.call(this));

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'SystemInfo', 'DateUtil', 'VueI18n', 'VueResource'], definition);
  } else {
    context.VueUtil = definition(context.Vue, context.SystemInfo, context.DateUtil);
    delete context.SystemInfo;
    delete context.DateUtil;
    delete context.VueResource;
    delete context.VueI18n;
  }
})(this, function(Vue, SystemInfo, DateUtil) {
  'use strict';
  var version = '1.6.8';
  var _toString = Object.prototype.toString;
  var _map = Array.prototype.map;
  var _filter = Array.prototype.filter;
  var isNull = function(v) {
    return v === null;
  };
  var isUndefined = function(v) {
    return typeof v === 'undefined';
  };
  var isRegExp = function(v) {
    return '[object RegExp]' === Object.prototype.toString.call(v);
  };
  var isDef = function(v) {
    return v !== undefined && v !== null;
  };
  var objType = function(obj) {
    return _toString.call(obj).slice(8, -1);
  };
  var isString = function(obj) {
    return objType(obj) === 'String';
  };
  var isNumber = function(obj) {
    return objType(obj) === 'Number' && obj === obj;
  };
  var isNumberStr = function(num) {
    if (typeof num === 'number') {
      return num - num === 0;
    }
    if (typeof num === 'string' && num.trim() !== '') {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };
  var newArray = function (start, end) {
    var result = [];
  
    for (var i = start; i <= end; i++) {
      result.push(i);
    }
  
    return result;
  };
  var isBoolean = function(obj) {
    return objType(obj) === 'Boolean';
  };
  var isFile = function(obj) {
    return objType(obj) === 'File';
  };
  var isObject = function(obj) {
    return objType(obj) === 'Object';
  };
  var isArray = function(obj) {
    return objType(obj) === 'Array';
  };
  var isFunction = function(obj) {
    return objType(obj) === 'Function';
  };
  var isDate = function(obj) {
    return objType(obj) === 'Date';
  };
  var isDateObject = function(val) {
    return val instanceof Date;
  };
  var isNodeList = function(obj) {
    return objType(obj) === 'NodeList';
  };
  var isElement = function(obj) {
    return objType(obj).indexOf('Element') !== -1;
  };
  var isVNode = function(node) {
    return isObject(node) && node.hasOwnProperty('componentOptions');
  };
  var isVueComponent = function(node) {
    return isObject(node) && node.hasOwnProperty('$root');
  };
  var toString = function(val) {
    return !isDef(val) ? '' : typeof val === 'object' ? JSON.stringify(val) : String(val);
  };
  var toDate = function(date) {
    return (!isDef(date) || isNaN(new Date(date).getTime())) ? null : new Date(date);
  };
  var formatNumber = function(number, dec, dsep, tsep) {
    isDef(number) && (number = number*1);
    if (!isNumber(number)) return null;
    isDef(dec) && (dec = dec*1);
    if (!isNumber(dec)) dec = 2;
    number = number.toFixed(dec);
    if (!isString(dsep)) dsep = '.';
    if (!isString(tsep)) tsep = ',';
    var parts = number.split('.');
    var fnums = parts[0];
    var decimals = parts[1] ? dsep + parts[1] : '';
    return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + tsep) + decimals;
  };
  var formatDate = function(date, format) {
    date = toDate(date);
    if (!isDef(date)) return null;

    if(format == 'timestamp'){
      return date.getTime();
    }
    return DateUtil.format(date, format || 'yyyy-MM-dd');
  };
  var range = function a(n) {
    // see https://stackoverflow.com/questions/3746725/create-a-javascript-array-containing-1-n
    return Array.apply(null, {
      length: n
    }).map(function (_, n) {
      return n;
    });
  };

  var modifyDate = function (date, y, m, d) {
    return new Date(y, m, d, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
  };
  
  var modifyTime = function (date, h, m, s) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), h, m, s, date.getMilliseconds());
  };
  
  var modifyWithTimeString = function (date, time) {
    if (date == null || !time) {
      return date;
    }
  
    time = parseDate(time, 'HH:mm:ss');
    return modifyTime(date, time.getHours(), time.getMinutes(), time.getSeconds());
  };
  
  var clearTime = function (date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate());
  };
  
  var clearMilliseconds = function (date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0);
  };
  
  var limitTimeRange = function (date, ranges) {
    var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'HH:mm:ss';
    if (ranges.length === 0) return date;
  
    var normalizeDate = function (date) {
      return DateUtil.parse(DateUtil.format(date, format), format);
    };
  
    var ndate = normalizeDate(date);
    var nranges = ranges.map(function (range) {
      return range.map(normalizeDate);
    });
    if (nranges.some(function (nrange) {
      return ndate >= nrange[0] && ndate <= nrange[1];
    })) return date;
    var minDate = nranges[0][0];
    var maxDate = nranges[0][0];
    nranges.forEach(function (nrange) {
      minDate = new Date(Math.min(nrange[0], minDate));
      maxDate = new Date(Math.max(nrange[1], minDate));
    });
    var ret = ndate < minDate ? minDate : maxDate; // preserve Year/Month/Date
  
    return modifyDate(ret, date.getFullYear(), date.getMonth(), date.getDate());
  };
  var parseDate = function(string, format) {
    // 对应timepicker选中值不会改变问题  string=1730 format=HHmm 结果20190101 08:05
    // var str = formatDate(string, format);
    // if (!isDef(str)) str = string;
    var str;

    if (typeof string === 'number' && format === 'timestamp') {
      return new Date(string);
    }

    if(typeof string != 'string') {
      str = formatDate(string, format);
    } else if(!format && string.indexOf('GMT') > -1) {
      return new Date(string);
    }

    if (!isDef(str)) str = string;
    return DateUtil.parse(str, format || 'yyyy-MM-dd');
  };
  var getDayCountOfMonth = function(year, month) {
    isDef(year) && (year = year*1);
    isDef(month) && (month = month*1);
    if (!isNumber(year) || !isNumber(month)) return null;
    if (month === 3 || month === 5 || month === 8 || month === 10) {
      return 30;
    }
    if (month === 1) {
      if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
        return 29;
      } else {
        return 28;
      }
    }
    return 31;
  };
  var getDayCountOfYear = function(year) {
    var isLeapYear = year % 400 === 0 || (year % 100 !== 0 && year % 4 === 0);
    return isLeapYear ? 366 : 365;
  };
  var getFirstDayOfMonth = function(date) {
    var temp = toDate(date);
    if (!isDate(temp)) return null;
    temp.setDate(1);
    return temp.getDay();
  };
  var getStartDateOfMonth = function (year, month) {
    var result = new Date(year, month, 1);
    var day = result.getDay();
  
    if (day === 0) {
      return prevDate(result, 7);
    } else {
      return prevDate(result, day);
    }
  };
  
  var prevDate = function (date) {
    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return new Date(date.getFullYear(), date.getMonth(), date.getDate() - amount);
  };
  
  var nextDate = function (date) {
    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return new Date(date.getFullYear(), date.getMonth(), date.getDate() + amount);
  };
  
  var timeWithinRange = function (date, selectableRange, format) {
    var limitedDate = limitTimeRange(date, selectableRange, format);
    return limitedDate.getTime() === date.getTime();
  };
  
  var changeYearMonthAndClampDate = function (date, year, month) {
    var monthDate = Math.min(date.getDate(), getDayCountOfMonth(year, month));
    return modifyDate(date, year, month, monthDate);
  };
  
  var prevMonth = function (date) {
    var year = date.getFullYear();
    var month = date.getMonth();
    return month === 0 ? changeYearMonthAndClampDate(date, year - 1, 11) : changeYearMonthAndClampDate(date, year, month - 1);
  };
  
  var nextMonth = function (date) {
    var year = date.getFullYear();
    var month = date.getMonth();
    return month === 11 ? changeYearMonthAndClampDate(date, year + 1, 0) : changeYearMonthAndClampDate(date, year, month + 1);
  };
  
  var prevYear = function (date) {
    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var year = date.getFullYear();
    var month = date.getMonth();
    return changeYearMonthAndClampDate(date, year - amount, month);
  };
  
  var nextYear = function (date) {
    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var year = date.getFullYear();
    var month = date.getMonth();
    return changeYearMonthAndClampDate(date, year + amount, month);
  };
  var getWeekNumber = function(date) {
    date = toDate(date);
    if (!isDate(date)) return null;
    date.setHours(0, 0, 0, 0);
    date.setTime((date.getTime() + (6 - date.getDay()) * 86400000));
    var firstDate = new Date(date.getFullYear(), 0, 1);
    return Math.ceil(((date.getTime() - firstDate.getTime()) / 86400000) / 7);
  };

  var getRangeHours = function (ranges) {
    var hours = [];
    var disabledHours = [];
    (ranges || []).forEach(function (range) {
      var value = range.map(function (date) {
        return date.getHours();
      });
      disabledHours = disabledHours.concat(newArray(value[0], value[1]));
    });
  
    if (disabledHours.length) {
      for (var i = 0; i < 24; i++) {
        hours[i] = disabledHours.indexOf(i) === -1;
      }
    } else {
      for (var _i = 0; _i < 24; _i++) {
        hours[_i] = false;
      }
    }
  
    return hours;
  };
  
  var setRangeData = function (arr, start, end, value) {
    for (var i = start; i < end; i++) {
      arr[i] = value;
    }
  };
  
  var getRangeMinutes = function (ranges, hour) {
    var minutes = new Array(60);
  
    if (ranges.length > 0) {
      ranges.forEach(function (range) {
        var start = range[0];
        var end = range[1];
        var startHour = start.getHours();
        var startMinute = start.getMinutes();
        var endHour = end.getHours();
        var endMinute = end.getMinutes();
  
        if (startHour === hour && endHour !== hour) {
          setRangeData(minutes, startMinute, 60, true);
        } else if (startHour === hour && endHour === hour) {
          setRangeData(minutes, startMinute, endMinute + 1, true);
        } else if (startHour !== hour && endHour === hour) {
          setRangeData(minutes, 0, endMinute + 1, true);
        } else if (startHour < hour && endHour > hour) {
          setRangeData(minutes, 0, 60, true);
        }
      });
    } else {
      setRangeData(minutes, 0, 60, true);
    }
  
    return minutes;
  };
  var addDate = function(src, num, type) {
    src = toDate(src);
    isDef(num) && (num = num*1);
    if (!isDate(src) || !isNumber(num)) return null;
    if (type !== 'week' && type !== 'day' && type !== 'month' && type !== 'year') type = 'day';
    var result = new Date();
    switch (type.toLowerCase()) {
      case 'week':
        var week = 7;
        result.setTime(src.getTime() + 86400000 * num * (week || 1));
        break;
      case 'day':
        result.setTime(src.getTime() + 86400000 * num * (week || 1));
        break;
      case 'month':
        var year = src.getFullYear();
        var month = src.getMonth();
        var date = src.getDate();
        var addMonth = 1;
        if (num < 0) {
          addMonth = -1;
          num = -num;
        }
        while (num--) {
          if (addMonth > 0) {
            year = month === 11 ? year + addMonth : year;
            month = month === 11 ? 0 : month + addMonth;
          } else {
            year = month === 0 ? year + addMonth : year;
            month = month === 0 ? 11 : month + addMonth;
          }
        }
        var newMonthDayCount = getDayCountOfMonth(year, month);
        if (newMonthDayCount < date) {
          src.setDate(newMonthDayCount);
        }
        src.setMonth(month);
        src.setFullYear(year);
        result.setTime(src.getTime());
        break;
      case 'year':
        src.setFullYear(src.getFullYear() + num);
        result.setTime(src.getTime());
        break;
    }
    return result;
  };

  var extractDateFormat = function (format) {
    return format.replace(/\W?m{1,2}|\W?ZZ/g, '').replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, '').trim();
  };

  var extractTimeFormat = function (format) {
    return format.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?y{2,4}/g, '').trim();
  };

  var loop = function(arr, fn) {
    if (isDef(arr) && isNumber(arr.length) && isFunction(fn)) {
      for (var i=0, j=arr.length; i<j; i++) {
        if (fn(arr[i], i) === false) break;
      }
    }
  };
  var ownPropertyLoop = function (obj, fn) {
    isDef(obj) && loop(Object.keys(obj), fn);
  };
  var map = function(arr, fn) {
    if (isArray(arr) && isFunction(fn)) {
      return _map.call(arr, fn);
    }
    return [];
  };
  var filter = function(arr, fn) {
    if (isArray(arr) && isFunction(fn)) {
      return _filter.call(arr, fn);
    }
    return [];
  };
  var trim = function(str) {
    if (!isString(str)) str = '';
    return str.replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
  };
  var deepCopy = function(obj, parent) {
    if (!isDef(parent)) parent = null;
    var result = {};
    if (isArray(obj)) result = [];
    var _parent = parent;
    while (_parent) {
      if (_parent.originalParent === obj) {
        return _parent.currentParent;
      }
      _parent = _parent.parent;
    }
    ownPropertyLoop(obj, function(key) {
      var temp = obj[key];
      if (temp && typeof temp === 'object') {
        result[key] = deepCopy(temp, {
          originalParent: obj,
          currentParent: result,
          parent: parent
        });
      } else {
        result[key] = temp;
      }
    });
    return result;
  };
  var destructuring = function (destination, sources) {
    if (destination && sources) {
      var rest = VueUtil.assign.apply(this, [{}].concat(VueUtil.slice(arguments, 1)));
      var restKeys = Object.keys(rest);
      VueUtil.loop(Object.keys(destination), function (key) {
        if (restKeys.indexOf(key) > -1) {
          destination[key] = rest[key];
        }
      });
    }
    return destination;
  };
  var merge = function(target) {
    loop(arguments, function(source, index) {
      if (index === 0) return;
      ownPropertyLoop(source, function(prop) {
        if (isObject(target[prop]) && isObject(source[prop])) {
          target[prop] = merge({}, target[prop], source[prop]);
        } else {
          isDef(source[prop]) && (target[prop] = source[prop]);
        }
      });
    });
    return target;
  };
  var mergeArray = function(target) {
    if (!isArray(target)) target = [];
    loop(arguments, function(array, index) {
      if (index === 0 || !isDef(array)) return;
      if (!isArray(array)) {
        target.push(array);
      } else {
        loop(array, function(item) {
          if (isArray(item)) item = mergeArray([], item);
          target.push(item);
        });
      }
    });
    return target;
  };

  function arrayIndexOfVal (obj, val) {
    if (obj.indexOf) {
      return obj.indexOf(val);
    }
    for (var index = 0, len = obj.length; index < len; index++) {
      if (val === obj[index]) {
        return index;
      }
    }
  }

  var arrayFindIndex = function (arr, pred) {
    for (var i = 0; i !== arr.length; ++i) {
      if (pred(arr[i])) {
        return i;
      }
    }
  
    return -1;
  };
  
  var arrayFind = function (arr, pred) {
    var idx = arrayFindIndex(arr, pred);
    return idx !== -1 ? arr[idx] : undefined;
  }; // coerce truthy value to array
  
  function findTreeItem (parent, obj, iterate, context, path, node, parseChildren, opts) {
    if (obj) {
      var item, index, len, paths, nodes, match;
      for (index = 0, len = obj.length; index < len; index++) {
        item = obj[index];
        paths = path.concat(['' + index]);
        nodes = node.concat([item]);
        if (iterate.call(context, item, index, obj, paths, parent, nodes)) {
          return { index: index, item: item, path: paths, items: obj, parent: parent, nodes: nodes };
        }
        if (parseChildren && item) {
          match = findTreeItem(item, item[parseChildren], iterate, context, paths.concat([parseChildren]), nodes, parseChildren, opts);
          if (match) {
            return match;
          }
        }
      }
    }
  }

  function eachTreeItem (parent, obj, iterate, context, path, node, parseChildren, opts) {
    var paths, nodes;
    VueUtil.forEach(obj, function (item, index) {
      paths = path.concat(['' + index]);
      nodes = node.concat([item]);
      iterate.call(context, item, index, obj, paths, parent, nodes);
      if (item && parseChildren) {
        paths.push(parseChildren);
        eachTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
      }
    });
  }

  function helperCreateTreeFunc (handle) {
    return function (obj, iterate, options, context) {
      var opts = options || {};
      var optChildren = opts.children || 'children';
      return handle(null, obj, iterate, context, [], [], optChildren, opts);
    };
  }

  function mapTreeItem (parent, obj, iterate, context, path, node, parseChildren, opts) {
    var paths, nodes, rest;
    var mapChildren = opts.mapChildren || parseChildren;
    return VueUtil.map(obj, function (item, index) {
      paths = path.concat(['' + index]);
      nodes = node.concat([item]);
      rest = iterate.call(context, item, index, obj, paths, parent, nodes);
      if (rest && item && parseChildren && item[parseChildren]) {
        rest[mapChildren] = mapTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
      }
      return rest;
    });
  }

  function searchTreeItem (parentAllow, parent, obj, iterate, context, path, node, parseChildren, opts) {
    var paths, nodes, rest, isAllow, hasChild;
    var rests = [];
    var hasOriginal = opts.original;
    var mapChildren = opts.mapChildren || parseChildren;
    VueUtil.forEach(obj, function (item, index) {
      paths = path.concat(['' + index]);
      nodes = node.concat([item]);
      isAllow = parentAllow || iterate.call(context, item, index, obj, paths, parent, nodes);
      hasChild = parseChildren && item[parseChildren];
      if (isAllow || hasChild) {
        rest = hasOriginal ? item : VueUtil.assign({}, item);
      }
      if (isAllow || hasChild) {
        rest[mapChildren] = searchTreeItem(isAllow, item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
        if (isAllow || rest[mapChildren].length) {
          rests.push(rest);
        }
      } else if (isAllow) {
        rests.push(rest);
      }
    });
    return rests;
  }

  function unTreeList (result, array, opts) {
    var children;
    var optChildren = opts.children;
    var optData = opts.data;
    VueUtil.forEach(array, function (item) {
      children = item[optChildren];
      if (optData) {
        item = item[optData];
      }
      result.push(item);
      if (children) {
        unTreeList(result, children, opts);
      }
    });
    return result;
  }

  function toTreeArray (array, options) {
    return unTreeList([], array, VueUtil.assign({},  {
      parentKey: 'parentId',
      key: 'id',
      children: 'children'
    }, options));
  }

  
function strictTree (array, optChildren) {
  VueUtil.each(array, function (item) {
    if (item.children && !item.children.length) {
      VueUtil.remove(item, optChildren);
    }
  });
}

/**
  * 将一个带层级的数据列表转成树结构
  *
  * @param {Array} array 数组
  * @param {Object} options {strict: false, parentKey: 'parentId', key: 'id', children: 'children', data: 'data'}
  * @return {Array}
  */
function toArrayTree (array, options) {
  var opts = VueUtil.assign({}, {
    parentKey: 'parentId',
    key: 'id',
    children: 'children'
  }, options);

  var optStrict = opts.strict;
  var optKey = opts.key;
  var optParentKey = opts.parentKey;
  var optChildren = opts.children;
  var optSortKey = opts.sortKey;
  var optReverse = opts.reverse;
  var optData = opts.data;
  var result = [];
  var treeMap = {};
  var idList, id, treeData, parentId;

  if (optSortKey) {
    array = VueUtil.sortBy(VueUtil.clone(array), optSortKey);
    if (optReverse) {
      array = array.reverse();
    }
  }

  idList = VueUtil.map(array, function (item) {
    return item[optKey];
  });

  VueUtil.each(array, function (item) {
    id = item[optKey];

    if (optData) {
      treeData = {};
      treeData[optData] = item;
    } else {
      treeData = item;
    }

    parentId = item[optParentKey];
    treeMap[id] = treeMap[id] || [];
    treeMap[parentId] = treeMap[parentId] || [];
    treeMap[parentId].push(treeData);
    treeData[optKey] = id;
    treeData[optParentKey] = parentId;
    treeData[optChildren] = treeMap[id];

    if (!optStrict || (optStrict && !parentId)) {
      if (!VueUtil.includes(idList, parentId)) {
        result.push(treeData);
      }
    }
  });

  if (optStrict) {
    strictTree(array, optChildren);
  }

  return result;
}

  var findTree = helperCreateTreeFunc(findTreeItem);
  var eachTree = helperCreateTreeFunc(eachTreeItem);
  var mapTree = helperCreateTreeFunc(mapTreeItem);
  var searchTree = helperCreateTreeFunc(function (parent, obj, iterate, context, path, nodes, parseChildren, opts) {
    return searchTreeItem(0, parent, obj, iterate, context, path, nodes, parseChildren, opts);
  });
  
  function filterTree (obj, iterate, options, context) {
    var result = [];
    if (obj && iterate) {
      eachTree(obj, function (item, index, items, path, parent, nodes) {
        if (iterate.call(context, item, index, items, path, parent, nodes)) {
          result.push(item);
        }
      }, options);
    }
    return result;
  }
  
  var coerceTruthyValueToArray = function (val) {
    if (Array.isArray(val)) {
      return val;
    } else if (val) {
      return [val];
    } else {
      return [];
    }
  };
  var createUuid = function() {
    var s4 = function() {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    };
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
  };
  var on = function(el, event, handler, options) {
    if (el && event && handler) {
      if (!isDef(options)) options = {passive: false};
      el.addEventListener(event, handler, options);
    }
  };
  var off = function(el, event, handler, options) {
    if (el && event) {
      if (!isDef(options)) options = {passive: false};
      el.removeEventListener(event, handler, options);
    }
  };
  var once = function(el, event, handler, options) {
    var listener = function() {
      isFunction(handler) && handler.apply(this, arguments);
      off(el, event, listener, options);
    };
    on(el, event, listener, options);
  };
  var removeNode = function(node) {
    node && node.parentElement && node.parentElement.removeChild(node);
  };
  var insertNodeAt = function(fatherNode, node, position) {
    isDef(position) && (position = position*1);
    if (!isNumber(position)) position = 0;
    var refNode = (position === 0) ? fatherNode.firstElementChild : fatherNode.children[position - 1].nextElementSibling;
    fatherNode.insertBefore(node, refNode);
  };
  var scrollBarWidth = function() {
    if (!isNumber(document.__scrollBarWidth__)) {
      var inner = document.createElement('div');
      inner.style.width = '100%';
      var outer = document.createElement('div');
      outer.style.visibility = 'hidden';
      outer.style.width = '100px';
      outer.style.overflow = 'scroll';
      outer.appendChild(inner);
      document.body.appendChild(outer);
      document.__scrollBarWidth__ = outer.offsetWidth - inner.offsetWidth;
      removeNode(inner);
      removeNode(outer);
    }
    return document.__scrollBarWidth__;
  };
  var hasClass = function(el, clazz) {
    if (!isElement(el) || !isString(clazz)) return false;
    return el.classList.contains(clazz);
  };
  var addClass = function(el, clazz) {
    if (isElement(el) && isString(clazz)) el.classList.add(clazz);
  };
  var removeClass = function(el, clazz) {
    if (isElement(el) && isString(clazz)) el.classList.remove(clazz);
  };
  var getStyle = function(el, styleName) {
    if (!isElement(el) || !isString(styleName)) return null;
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    return el.style[styleName] || getComputedStyle(el, null)[styleName];
  };
  var setStyle = function(el, styleName, value) {
    if (!isElement(el) || !isString(styleName)) return;
    el.style[styleName] = value;
  };
  var getCookie = function(name) {
    var arr = document.cookie.replace(/\s/g, '').split(';');
    for (var i = 0, j = arr.length; i < j; i++) {
      var tempArr = arr[i].split('=');
      if (tempArr[0] === name) return decodeURIComponent(tempArr[1]);
    }
    return null;
  };
  var setCookie = function(name, value, days) {
    isDef(days) && (days = days*1);
    if (!isNumber(days)) days = 1;
    var date = addDate((new Date), days);
    document.cookie = name + '=' + encodeURIComponent(value) + ';expires=' + date;
  };
  var removeCookie = function(name) {
    var val = getCookie(name);
    setCookie(name, val, -1);
  };
  var performance = function(delay, callback, throttleflg) {
    if (!isFunction(callback)) {
      callback = delay;
      delay = null;
    }
    if (!isFunction(callback)) return function() {};
    var defaultTimer = Object.create(null);
    var setTimer = requestAnimationFrame;
    var clearTimer = cancelAnimationFrame;
    if (isNumber(delay)) {
      setTimer = setTimeout;
      clearTimer = clearTimeout;
    }
    return function() {
      var self = this;
      var timer = null;
      if (!isDef(self)) {
        timer = defaultTimer;
      } else {
        if (!isDef(self[callback])) self[callback] = Object.create(null);
        timer = self[callback];
      }
      var args = arguments;
      if (throttleflg) {
        if (isDef(timer.__timer__)) return false;
      } else {
        clearTimer(timer.__timer__);
      }
      timer.__timer__ = setTimer(function() {
        callback.apply(self, args);
        clearTimer(timer.__timer__);
        timer.__timer__ = null;
      }, delay);
    };
  };
  var throttle = function(delay, callback) {
    return performance(delay, callback, true);
  };
  var debounce = function(delay, callback) {
    return performance(delay, callback);
  };
  var resizeListener = function(el, fn, removeFlg) {
    if (!isFunction(fn)) {
      fn = el;
      el = document.body;
    }
    if (!isArray(el.__resizeListeners__)) {
      var resetTrigger = function(el) {
        var trigger = el.__resizeTrigger__;
        var expand = trigger.firstElementChild;
        var contract = trigger.lastElementChild;
        var expandChild = expand.firstElementChild;
        contract.scrollLeft = contract.scrollWidth;
        contract.scrollTop = contract.scrollHeight;
        expandChild.style.width = expand.offsetWidth + 1 + 'px';
        expandChild.style.height = expand.offsetHeight + 1 + 'px';
        expand.scrollLeft = expand.scrollWidth;
        expand.scrollTop = expand.scrollHeight;
      };
      var resizeListeners = function(el, event) {
        if (el.offsetWidth !== el.__resizeLast__.width || el.offsetHeight !== el.__resizeLast__.height) {
          el.__resizeLast__.width = el.offsetWidth;
          el.__resizeLast__.height = el.offsetHeight;
          loop(el.__resizeListeners__, function(resizeListener) {
            resizeListener.call(el, event);
          });
        }
      };
      var scrollListener = debounce(function(event) {
        resetTrigger(el);
        resizeListeners(el, event);
      });
      var resizeStart = function(event) {
        if (event.animationName === 'resizeanim') {
          resetTrigger(el);
        }
      };
      if (getStyle(el, 'position') === 'static') {
        // 对应win10 ie11 遮罩层无法正常遮罩的问题
        el != document.body && setStyle(el, 'position', 'relative');
        // setStyle(el, 'position', 'relative');
      }
      var resizeTrigger = el.__resizeTrigger__ = document.createElement('div');
      resizeTrigger.className = 'resize-triggers';
      resizeTrigger.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>';
      on(resizeTrigger, 'animationstart', resizeStart);
      el.__resizeLast__ = {};
      el.__resizeListeners__ = [];
      el.appendChild(resizeTrigger);
      on(el, 'scroll', scrollListener, true);
    }
    if (removeFlg) {
      var index = el.__resizeListeners__.indexOf(fn);
      index !== -1 && el.__resizeListeners__.splice(index, 1);
    } else {
      isFunction(fn) && el.__resizeListeners__.push(fn);
    }
  };
  var addResizeListener = function(el, fn) {
    resizeListener(el, fn);
  };
  var removeResizeListener = function(el, fn) {
    resizeListener(el, fn, true);
  };
  var addHoverListener = function(el, inFn, outFn) {
    if (!isFunction(inFn)) return;
    on(el, 'mouseenter', inFn);
    if (!isFunction(outFn)) outFn = inFn;
    on(el, 'mouseleave', outFn);
  };
  var removeHoverListener = function(el, inFn, outFn) {
    if (!isFunction(inFn)) return;
    off(el, 'mouseenter', inFn);
    if (!isFunction(outFn)) outFn = inFn;
    off(el, 'mouseleave', outFn);
  };
  var addTouchStart = function(el, fn) {
    on(el, 'mousedown', fn);
    on(el, 'touchstart', fn);
  };
  var removeTouchStart = function(el, fn) {
    off(el, 'mousedown', fn);
    off(el, 'touchstart', fn);
  };
  var addTouchMove = function(el, fn) {
    on(el, 'mousemove', fn);
    on(el, 'touchmove', fn);
  };
  var removeTouchMove = function(el, fn) {
    off(el, 'mousemove', fn);
    off(el, 'touchmove', fn);
  };
  var addTouchEnd = function(el, fn) {
    on(el, 'mouseup', fn);
    on(el, 'touchend', fn);
  };
  var removeTouchEnd = function(el, fn) {
    off(el, 'mouseup', fn);
    off(el, 'touchend', fn);
  };
  var screenfull = function() {
    var fn = (function() {
      var fnMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror']
            , ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror']
            , ['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror']
            , ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror']
            , ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];
      var ret = {};
      for (var i = 0, l = fnMap.length; i < l; i++) {
        var val = fnMap[i];
        if (val[1] in document) {
          for (i = 0; i < val.length; i++) {
            ret[fnMap[0][i]] = val[i];
          }
          return ret;
        }
      }
      return null;
    })();
    if (!isDef(fn)) {
      Vue.notify.warning({message: Vue.t('vue.screenfull.canot')});
      return false;
    }
    var screenfull = {
      request: function(elem) {
        var request = fn.requestFullscreen;
        elem = elem || document.documentElement;
        if (/5\.1[.\d]* Safari/.test(navigator.userAgent)) {
          elem[request]();
        } else {
          elem[request]((typeof Element !== 'undefined' && 'ALLOW_KEYBOARD_INPUT' in Element) ? Element.ALLOW_KEYBOARD_INPUT : {});
        }
      },
      exit: function() {
        document[fn.exitFullscreen]();
      },
      toggle: function(elem) {
        if (this.isFullscreen) {
          this.exit();
        } else {
          this.request(elem);
        }
      },
      onchange: function(callback) {
        on(document, fn.fullscreenchange, callback);
      },
      onerror: function(callback) {
        on(document, fn.fullscreenerror, callback);
      },
      raw: fn
    };
    Object.defineProperties(screenfull, {
      isFullscreen: {
        get: function() {
          return Boolean(document[fn.fullscreenElement]);
        }
      },
      element: {
        enumerable: true,
        get: function() {
          return document[fn.fullscreenElement];
        }
      },
      enabled: {
        enumerable: true,
        get: function() {
          return Boolean(document[fn.fullscreenEnabled]);
        }
      }
    });
    if (!isDef(screenfull.enabled)) {
      Vue.notify.warning({message: Vue.t('vue.screenfull.canot')});
      return false;
    }
    screenfull.toggle();
  };
  var getSystemInfo = function() {
    return SystemInfo;
  };
  var setLang = function(lang) {
    if (Vue.i18n) {
      if (isString(lang)) Vue.i18n.locale = lang;
    } else {
      if (isString(lang)) Vue.config.lang = lang;
    }
  };
  var setLocale = function(lang, langObjs) {
    if(Vue.i18n) {
      Vue.i18n.setLocaleMessage(lang, merge({}, Vue.i18n.getLocaleMessage(lang), langObjs));
    } else {
      Vue.locale && Vue.locale(lang, merge({}, Vue.locale(lang), langObjs));
    }
  };
  var popupManager = {
    instances: {},
    zIndex: 2000,
    getInstance: function(id) {
      return popupManager.instances[id];
    },
    register: function(id, instance) {
      if (id && instance) {
        popupManager.instances[id] = instance;
      }
    },
    deregister: function(id) {
      if (id) {
        popupManager.instances[id] = null;
        delete popupManager.instances[id];
      }
    },
    setZindex: function(value) {
        return popupManager.zIndex = value;
    },
    nextZIndex: function() {
      return popupManager.zIndex++;
    },
    modalStack: [],
    openModal: function(id, zIndex) {
      if (!isDef(id) || !isDef(zIndex)) return;
      var modalStack = this.modalStack;
      for (var i = 0, j = modalStack.length; i < j; i++) {
        var item = modalStack[i];
        if (item.id === id) return;
      }
      this.modalStack.push({
        id: id,
        zIndex: zIndex
      });
    },
    closeModal: function(id) {
      var modalStack = this.modalStack;
      if (modalStack.length > 0) {
        var topItem = modalStack[modalStack.length - 1];
        if (topItem.id === id) {
          modalStack.pop();
        } else {
          for (var i = modalStack.length - 1; i >= 0; i--) {
            if (modalStack[i].id === id) {
              modalStack.splice(i, 1);
              break;
            }
          }
        }
      }
    }
  };
  var emitter = {
    methods: {
      dispatch: function(componentName, eventName, params) {
        var parent = this.$parent || this.$root;
        var name = parent.$options.name;
        while (parent && (!isDef(name) || name !== componentName)) {
          parent = parent.$parent;
          if (parent) {
            name = parent.$options.name;
          }
        }
        if (parent) {
          parent.$emit.apply(parent, mergeArray([eventName], params));
        }
      },
      broadcast: function(componentName, eventName, params) {
        var broadcast = function(componentName, eventName, params) {
          loop(this.$children, function(child) {
            var name = child.$options.name;
            if (name === componentName) {
              child.$emit.apply(child, mergeArray([eventName], params));
            } else {
              broadcast.apply(child, mergeArray([componentName, eventName], [params]));
            }
          });
        };
        broadcast.call(this, componentName, eventName, params);
      }
    }
  };
  var menumixin = {
    computed: {
      indexPath: function() {
        var path = [this.index];
        var parent = this.$parent;
        while (parent.$options.name !== 'VueMenu') {
          if (parent.index) {
            path.unshift(parent.index);
          }
          parent = parent.$parent;
        }
        return path;
      },
      rootMenu: function() {
        var parent = this.$parent;
        while (parent && parent.$options.name !== 'VueMenu') {
          parent = parent.$parent;
        }
        return parent;
      },
      parentMenu: function() {
        var parent = this.$parent;
        while (parent && ['VueMenu', 'VueSubmenu'].indexOf(parent.$options.name) === -1) {
          parent = parent.$parent;
        }
        return parent;
      },
      paddingStyle: function() {
        if (this.rootMenu.mode !== 'vertical') return {};
        var padding = 20;
        var parent = this.$parent;

        if (this.rootMenu.collapse) {
          return {
            paddingLeft: '20px',
            paddingRight: '20px'
          };
        } else {
          while (parent && parent.$options.name !== 'VueMenu') {
            if (parent.$options.name === 'VueSubmenu') {
              padding += 20;
            }
            parent = parent.$parent;
          }

          return {
            paddingLeft: padding + 'px'
          };
        }

        
      }
    }
  };
  var collapseTransition = {
    functional: true,
    render: function(createElement, obj) {
      var vueComponent = obj.parent;
      var children = obj.children;
      var data = {
        on: {
          'beforeEnter': function(el) {
            addClass(el, 'collapse-transition');
            if (!isDef(el.dataset)) el.dataset = {};
            el.dataset.oldPaddingTop = el.style.paddingTop;
            el.dataset.oldPaddingBottom = el.style.paddingBottom;
            el.style.height = '0';
            el.style.paddingTop = 0;
            el.style.paddingBottom = 0;
            if (isFunction(vueComponent.collapseBeforeEnter)) {
              vueComponent.collapseBeforeEnter();
            }
          },
          'enter': function(el) {
            el.dataset.oldOverflow = el.style.overflow;
            if (el.scrollHeight !== 0) {
              el.style.height = el.scrollHeight + 'px';
              el.style.paddingTop = el.dataset.oldPaddingTop;
              el.style.paddingBottom = el.dataset.oldPaddingBottom;
            } else {
              el.style.height = '';
              el.style.paddingTop = el.dataset.oldPaddingTop;
              el.style.paddingBottom = el.dataset.oldPaddingBottom;
            }
            el.style.overflow = 'hidden';
            if (isFunction(vueComponent.collapseEnter)) {
              vueComponent.collapseEnter();
            }
          },
          'afterEnter': function(el) {
            removeClass(el, 'collapse-transition');
            el.style.height = '';
            el.style.overflow = el.dataset.oldOverflow;
            if (isFunction(vueComponent.collapseAfterEnter)) {
              vueComponent.collapseAfterEnter();
            }
          },
          'beforeLeave': function(el) {
            if (!isDef(el.dataset)) el.dataset = {};
            el.dataset.oldPaddingTop = el.style.paddingTop;
            el.dataset.oldPaddingBottom = el.style.paddingBottom;
            el.dataset.oldOverflow = el.style.overflow;
            el.style.height = el.scrollHeight + 'px';
            el.style.overflow = 'hidden';
            if (isFunction(vueComponent.collapseBeforeLeave)) {
              vueComponent.collapseBeforeLeave();
            }
          },
          'leave': function(el) {
            if (el.scrollHeight !== 0) {
              addClass(el, 'collapse-transition');
              el.style.height = 0;
              el.style.paddingTop = 0;
              el.style.paddingBottom = 0;
            }
            if (isFunction(vueComponent.collapseLeave)) {
              vueComponent.collapseLeave();
            }
          },
          'afterLeave': function(el) {
            removeClass(el, 'collapse-transition');
            el.style.height = '';
            el.style.overflow = el.dataset.oldOverflow;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
            if (isFunction(vueComponent.collapseAfterLeave)) {
              vueComponent.collapseAfterLeave();
            }
          }
        }
      };
      return createElement('transition', data, children);
    }
  };
  var clickoutside = function(fn) {
    var startClick;
    var nodes = document.__clickoutsideNodes__;
    var CTX = '__clickoutsideContext__';
    if (!isArray(nodes)) {
      nodes = document.__clickoutsideNodes__ = [];
      var clickOutSideFn = function(mouseup, mousedown) {
        mouseup = mouseup || {};
        mousedown = mousedown || {};
        loop(nodes, function(node) {
          var vnode = node[CTX].vnode;
          var binding = node[CTX].binding;
          if (!vnode ||
            !vnode.context ||
            !mouseup.target ||
            !mousedown.target ||
            node.contains(mouseup.target) ||
            node.contains(mousedown.target) ||
            node === mouseup.target ||
            (vnode.context.popperElm &&
            (vnode.context.popperElm.contains(mouseup.target) ||
            vnode.context.popperElm.contains(mousedown.target)))) {
              var validFn = node[CTX].fn;
              if(typeof validFn =='function'){
                if(!validFn(vnode,mouseup,mousedown)) return ;
              }else{
                return;
              }
              
            }
            
          if (isDef(binding.expression) && isFunction(vnode.context[binding.expression])) {
            vnode.context[binding.expression]();
          } else {
            isFunction(binding.value) && binding.value();
          }
        });
      };
      on(document, 'mousedown', function(e) {
        startClick = e;
      });
      on(document, 'mouseup', function(e) {
        clickOutSideFn(e, startClick);
      });
    }
    return {
      bind: function(el, binding, vnode) {
        el[CTX] = {
          id: createUuid(),
          vnode: vnode,
          fn:fn,
          binding: binding
        };
        nodes.push(el);
      },
      update: function(el, binding, vnode) {
        el[CTX].binding = binding;
        el[CTX].vnode = vnode;
      },
      unbind: function(el) {
        var id = el[CTX].id;
        loop(nodes, function(node, i) {
          if (node[CTX].id === id) {
            nodes.splice(i, 1);
            delete el[CTX];
            return false;
          }
        });
      }
    };
  };

  var scrollingMethods = [];
  document.addEventListener('scroll', lodash.debounce(function(e) {

    if (VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs) return;
    var className = e.target.className || '';
    if(className.indexOf('contract-trigger') > -1 || className.indexOf('expand-trigger') > -1) return;

    scrollingMethods.forEach(function(obj) {

      if (e.target !== obj.el && e.target.contains(obj.el)) {
        if(typeof obj.method == 'function') {
          var method = obj.method;
          method();
        }
      }
        
    });
  },200, {
    'leading': true,
    'trailing': true
  }),true);

  var scrolling = {
    bind: function(el, binding) {
      var bindingObj = {
        el: el,
      };
      el.__scrollingNodes__ = bindingObj;
      bindingObj.method = binding.value;
      if(scrollingMethods.indexOf(bindingObj) == -1) {
        scrollingMethods.push(bindingObj);
      }
    },
    unbind: function(el) {
      var bindingObj = el.__scrollingNodes__;
      var index = scrollingMethods.indexOf(bindingObj);
      if(index > -1) {
        scrollingMethods.splice(index, 1);
      }
    }
  };

  var repeatClick = {
    bind: function bind(el, binding, vnode) {
      var interval = null;
      var startTime;
  
      var handler = function () {
        return vnode.context[binding.expression].apply();
      };
  
      var clear = function () {
        if (Date.now() - startTime < 100) {
          handler();
        }
  
        clearInterval(interval);
        interval = null;
      };
  
      on(el, 'mousedown', function (e) {
        if (e.button !== 0) return;
        startTime = Date.now();
        once(document, 'mouseup', clear);
        clearInterval(interval);
        interval = setInterval(handler, 100);
      });
    }
  };
  var getScrollParent = function(el) {
    var parent = el.parentNode;
    if (!isDef(parent)) {
      return el;
    }
    if (parent === document) {
      if (document.body.scrollTop) {
        return document.body;
      } else {
        return document.documentElement;
      }
    }
    if ((['scroll', 'auto'].indexOf(getStyle(parent, 'overflowX')) !== -1 && parent.scrollWidth > parent.clientWidth)
     || (['scroll', 'auto'].indexOf(getStyle(parent, 'overflowY')) !== -1 && parent.scrollHeight > parent.clientHeight)
     || hasClass(parent, 'vue-scrollbar__wrap')) {
      return parent;
    }
    return getScrollParent(el.parentNode);
  };
  var config = new Vue({
    data: function() {
      return {
        notifyStack: false,
        produceModel: false
      };
    },
    watch: {
      produceModel: function(val) {
        Vue.config.productionTip = !val;
        Vue.config.devtools = !val;
        Vue.config.silent = val;
      }
    }
  });

  var keyCode = function keyCode(searchInput) {
    // Keyboard Events
    if (searchInput && typeof searchInput === 'object') {
      var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
  
      if (hasKeyCode) {
        searchInput = hasKeyCode;
      }
    }
  
  
    var search = String(searchInput); // check codes
  
    var foundNamedKeyCodes = codes[search.toLowerCase()];
  
    if (foundNamedKeyCodes) {
      return foundNamedKeyCodes;
    } // check aliases
  
  
    var foundNamedKeyAliases = aliases[search.toLowerCase()];
  
    if (foundNamedKeyAliases) {
      return foundNamedKeyAliases;
    } // weird character?
  
  
    if (search.length === 1) {
      return search.charCodeAt(0);
    }
  
    return undefined;
  };
  
  var codes = {
    'backspace': 8,
    'tab': 9,
    'enter': 13,
    'shift': 16,
    'ctrl': 17,
    'alt': 18,
    'pause/break': 19,
    'caps lock': 20,
    'esc': 27,
    'space': 32,
    'page up': 33,
    'page down': 34,
    'end': 35,
    'home': 36,
    'left': 37,
    'up': 38,
    'right': 39,
    'down': 40,
    // 'add': 43,
    'insert': 45,
    'delete': 46,
    'command': 91,
    'left command': 91,
    'right command': 93,
    'numpad *': 106,
    // 'numpad +': 107,
    'numpad +': 43,
    'numpad add': 43,
    // as a trick
    'numpad -': 109,
    'numpad .': 110,
    'numpad /': 111,
    'num lock': 144,
    'scroll lock': 145,
    'my computer': 182,
    'my calculator': 183,
    ';': 186,
    '=': 187,
    ',': 188,
    '-': 189,
    '.': 190,
    '/': 191,
    '`': 192,
    '[': 219,
    '\\': 220,
    ']': 221,
    '\'': 222 // Helper aliases
  
  };
  var aliases = {
    'windows': 91,
    '⇧': 16,
    '⌥': 18,
    '⌃': 17,
    '⌘': 91,
    'ctl': 17,
    'control': 17,
    'option': 18,
    'pause': 19,
    'break': 19,
    'caps': 20,
    'return': 13,
    'escape': 27,
    'spc': 32,
    'pgup': 33,
    'pgdn': 34,
    'ins': 45,
    'del': 46,
    'cmd': 91
    /*!
     * Programatically add the following
     */
    // lower case chars
  
  };
  
  for (var i = 97; i < 123; i++) {
    codes[String.fromCharCode(i)] = i - 32;
  } // numbers
  
  
  for (var _i = 48; _i < 58; _i++) {
    codes[_i - 48] = _i;
  } // function keys
  
  
  for (var _i2 = 1; _i2 < 13; _i2++) {
    codes['f' + _i2] = _i2 + 111;
  } // numpad keys
  
  
  for (var _i3 = 0; _i3 < 10; _i3++) {
    codes['numpad ' + _i3] = _i3 + 96;
  }
  
  var noop = function noop() {};
  
  var getKeyMap = function getKeyMap(key, bind) {
      var result = {};
      var keyup = bind.keyup;
      var keydown = bind.keydown;
      key.replace('numpad +', 'numpad add').split('+').forEach(function (keyName) {
        switch (keyName.toLowerCase()) {
          case 'ctrl':
          case 'alt':
          case 'shift':
          case 'meta':
            result[keyName] = true;
            break;
  
          default:
            result.keyCode = keyCode(keyName);
        }
      });
      result.callback = {
        keydown: keydown || (keyup ? noop : bind),
        keyup: keyup || noop
      };
      return result;
  };

  function isElementTopLayer(el) {
    var elPos = el.getBoundingClientRect();
    var x = Math.ceil(elPos.left);
    var y = Math.ceil(elPos.top);

    var offset = 3;//为了防止点击不到，加上3像素
    var topElementXY = document.elementFromPoint(x + offset, y + offset);
    if(topElementXY == el || el.contains(topElementXY)) {
      return true;
    }
    return false;
  }

  var hotkeyHandlers = {
    click: function (e, el) {
      if(isElementTopLayer(el)) {
        setTimeout(function() {
          el.click();
        }, 0);
      }
    },

    focus: function (e, el) {
      if(isElementTopLayer(el)) {
        setTimeout(function() {
          var vueObj = el.__vue__;
          if(vueObj) {
            if(vueObj.focus) {
              vueObj.focus();
              return;
            } else if(vueObj.$refs.input) {
              vueObj.$refs.input.focus && vueObj.$refs.input.focus();
              return;
            }
          }
          el.focus();
        }, 0);
      }
    },
  };
  function bindEvent(el, binding, vnode) {
    var key = binding.arg;
    var handler = binding.value || 'click';
    
    if (typeof handler === 'string') {
      handler = hotkeyHandlers[handler];
    }
    if(!handler) return;

    el._keymap = getKeyMap(key, handler);
    var allow = binding.modifiers.allow || false;

    el._keyHandler = function (e) {
        var hotkey = el._keymap;
        var callback = hotkey.keyCode === e.keyCode &&
          !!hotkey.ctrl === e.ctrlKey &&
          !!hotkey.alt === e.altKey &&
          !!hotkey.shift === e.shiftKey &&
          !!hotkey.meta === e.metaKey &&
          hotkey.callback[e.type];

        if(callback && !allow) {
          e.preventDefault();

          //ie11 f1 problem
          if ( 'onhelp' in window && e.keyCode == 112) {
            window.onhelp = function () {
              return false;
            };
          }
        }

        if(!callback || callback === noop) return;
        
        // 获取最顶层aside,dialog
        var topContainer = Array.prototype.filter.call(document.querySelectorAll('.vue-dialog, .vue-aside'), function(container) {
          return isElementTopLayer(container);
        });

        // 判断当前元素是不是在顶层容器里
        if (topContainer.length > 0 && !(topContainer[topContainer.length - 1].contains(el) )) {
          var parentAside = getParentAside(el.__vue__);
          if((!parentAside) || (!parentAside.$el.contains(topContainer[topContainer.length - 1]))){
            return;
          }
        }
        
        var currentElm = el;
        while(!currentElm.__vue__ && currentElm.parentElement) {
          currentElm = currentElm.parentElement;
        }

        if(!currentElm.__vue__ || currentElm.__vue__._inactive) {
          return;
        }
        
        if (callback.prototype) {
          callback.call(vnode.context, e, el);
        } else {
          callback(e, el);
        }
    };
  
    document.addEventListener('keydown', el._keyHandler);
    document.addEventListener('keyup', el._keyHandler);
  }
  
  function unbindEvent(el) {
    document.removeEventListener('keydown', el._keyHandler);
    document.removeEventListener('keyup', el._keyHandler);
  }

  function getParentAside(vm){
    if((!vm.$parent) || (!vm.$parent.$options.name)){
     return null;
    }else if(vm.$parent.$options.name === 'VueAside' || vm.$parent.$options.name === 'VueDialog'){
        return vm.$parent;
    }else {
        return getParentAside(vm.$parent);
    }
  }
  
  Vue.directive('hotkey', {
    bind: function (el, binding, vnode) {
      bindEvent.call(this, el, binding, vnode);
    },
    componentUpdated: function (el, binding) {
      if (binding.value !== binding.oldValue) {
        unbindEvent.call(this, arguments);
        bindEvent.apply(this, el, binding);
      }
    },
    unbind: unbindEvent
  });

  var clipboard = (function() {
    var doc = window.document;
    var $elem = doc.createElement('textarea');
  
    function handleText(content) {
      var styles = $elem.style;
      $elem.id = '$VueCopy';
      styles.width = '48px';
      styles.height = '24px';
      styles.position = 'fixed';
      styles.zIndex = '0';
      styles.left = '-500px';
      styles.top = '-500px';
      $elem.value = content === null || content === undefined ? '' : '' + content;
  
      if (!$elem.parentNode) {
        doc.body.appendChild($elem);
      }
    }
  
    function copyText() {
      $elem.focus();
      $elem.select();
      $elem.setSelectionRange(0, $elem.value.length);
      return doc.execCommand('copy');
    }
    /**
     * 复制内容到剪贴板
     *
     * @param {String} content Text 内容
     */
  
  
    function clipboard(content) {
      var result = false;
  
      try {
        handleText(content);
        result = copyText();
      } catch (e) {}
  
      return result;
    }

    clipboard.copy = clipboard;
    return clipboard;
  })();

  function pluckProperty (name) {
    return function (obj, key) {
      return key === name;
    };
  }

  var remove = function (obj, iterate, context) {
    if (obj) {
      if (!isNull(iterate)) {
        var removeKeys = [];
        var rest = [];
        if (!isFunction(iterate)) {
          iterate = pluckProperty(iterate);
        }
        VueUtil.each(obj, function (item, index, rest) {
          if (iterate.call(context, item, index, rest)) {
            removeKeys.push(index);
          }
        });
        if (isArray(obj)) {
          VueUtil.eachRight(removeKeys, function (item, key) {
            rest.push(obj[item]);
            obj.splice(item, 1);
          });
        } else {
          rest = {};
          VueUtil.each(removeKeys, function (key) {
            rest[key] = obj[key];
            delete obj[key];
          });
        }
        return rest;
      }
      return {};
    }
    return obj;
  };

  var ElementPrototype = window.Element.prototype;
  if (typeof ElementPrototype.matches !== 'function') {
    ElementPrototype.matches = ElementPrototype.msMatchesSelector || ElementPrototype.mozMatchesSelector || ElementPrototype.webkitMatchesSelector;
  }

  var closest = function (element, selector) {

    while (element && element.nodeType === 1) {
      if (element.matches(selector)) {
        return element;
      }
      element = element.parentNode;
    }

    return null;
  };
  
  
  var VueUtil = {
    isNull: isNull,
    isUndefined: isUndefined,
    isRegExp: isRegExp,
    isDef: isDef,
    isString: isString,
    isNumber: isNumber,
    isNumberStr: isNumberStr,
    isBoolean: isBoolean,
    isFile: isFile,
    isObject: isObject,
    isArray: isArray,
    isFunction: isFunction,
    isDate: isDate,
    isDateObject: isDateObject,
    isNodeList: isNodeList,
    isElement: isElement,
    isVNode: isVNode,
    isVueComponent: isVueComponent,
    toString: toString,
    toDate: toDate,
    formatNumber: formatNumber,
    formatDate: formatDate,
    range: range,
    modifyDate: modifyDate,
    modifyTime: modifyTime,
    modifyWithTimeString: modifyWithTimeString,
    clearTime: clearTime,
    clearMilliseconds: clearMilliseconds,
    limitTimeRange: limitTimeRange,
    parseDate: parseDate,
    prevDate: prevDate,
    nextDate: nextDate,
    timeWithinRange: timeWithinRange,
    changeYearMonthAndClampDate:changeYearMonthAndClampDate,
    prevMonth: prevMonth,
    nextMonth: nextMonth,
    prevYear: prevYear,
    nextYear: nextYear,
    getDayCountOfMonth: getDayCountOfMonth,
    getDayCountOfYear: getDayCountOfYear,
    getFirstDayOfMonth: getFirstDayOfMonth,
    getStartDateOfMonth: getStartDateOfMonth,
    getWeekNumber: getWeekNumber,
    getRangeHours: getRangeHours,
    setRangeData: setRangeData,
    getRangeMinutes: getRangeMinutes,
    addDate: addDate,
    extractDateFormat: extractDateFormat,
    extractTimeFormat: extractTimeFormat,
    loop: loop,
    ownPropertyLoop: ownPropertyLoop,
    map: map,
    filter: filter,
    trim: trim,
    deepCopy: deepCopy,
    destructuring: destructuring,
    merge: merge,
    mergeArray: mergeArray,
    arrayIndexOfVal:arrayIndexOfVal,
    arrayFindIndex: arrayFindIndex,
    arrayFind: arrayFind,
    findTree: findTree,
    eachTree: eachTree,
    filterTree: filterTree,
    searchTree: searchTree,
    mapTree: mapTree,
    toTreeArray: toTreeArray,
    toArrayTree: toArrayTree,
    coerceTruthyValueToArray: coerceTruthyValueToArray,
    createUuid: createUuid,
    on: on,
    off: off,
    once: once,
    removeNode: removeNode,
    insertNodeAt: insertNodeAt,
    scrollBarWidth: scrollBarWidth,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    getStyle: getStyle,
    setStyle: setStyle,
    getCookie: getCookie,
    setCookie: setCookie,
    removeCookie: removeCookie,
    throttle: throttle,
    debounce: debounce,
    addResizeListener: addResizeListener,
    removeResizeListener: removeResizeListener,
    addHoverListener: addHoverListener,
    removeHoverListener: removeHoverListener,
    addTouchStart: addTouchStart,
    addTouchMove: addTouchMove,
    addTouchEnd: addTouchEnd,
    removeTouchStart: removeTouchStart,
    removeTouchMove: removeTouchMove,
    removeTouchEnd: removeTouchEnd,
    screenfull: screenfull,
    getSystemInfo: getSystemInfo,
    setLang: setLang,
    setLocale: setLocale,
    config: config,
    nextZIndex: popupManager.nextZIndex,
    setZIndex: popupManager.setZindex,
    version: version,
    isIE: SystemInfo.browser.toLowerCase() === 'ie',
    isFirefox: SystemInfo.browser.toLowerCase() === 'firefox',
    isChrome: SystemInfo.browser.toLowerCase() === 'chrome',
    isEdge: SystemInfo.browser.toLowerCase() === 'edge',
    isSafari: SystemInfo.browser.toLowerCase() === 'safari',
    remove: remove,
    closest: closest,
    component: {
      menumixin: menumixin,
      emitter: emitter,
      collapseTransition: collapseTransition,
      clickoutside: clickoutside,
      scrolling: scrolling,
      repeatClick: repeatClick,
      popupManager: popupManager,
      getScrollParent: getScrollParent
    },
    hotkeyHandlers: hotkeyHandlers,
    clipboard: clipboard,
  };

  Object.keys(lodash).forEach(function(funcName) {
    if(typeof lodash[funcName] == 'function' && VueUtil[funcName] === undefined) {
      VueUtil[funcName] = lodash[funcName];
    }
  });
  VueUtil._throttle = lodash.throttle;
  VueUtil._debounce = lodash.debounce;
  VueUtil._filter = lodash.filter;

   Vue.prototype.$vu = VueUtil;
  return VueUtil;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(definition);
  } else {
    context.Sortable = definition();
  }
})(this, function() {
  function _typeof(obj) {
    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === '[object Arguments]') return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError('Invalid attempt to spread non-iterable instance');
  }

  var version = '1.10.1';

  function userAgent(pattern) {
    if (typeof window !== 'undefined' && window.navigator) {
      return !!
      /*@__PURE__*/
      navigator.userAgent.match(pattern);
    }
  }

  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

  var captureMode = {
    capture: false,
    passive: false
  };

  function on(el, event, fn) {
    el.addEventListener(event, fn, !IE11OrLess && captureMode);
  }

  function off(el, event, fn) {
    el.removeEventListener(event, fn, !IE11OrLess && captureMode);
  }

  function matches(
  /**HTMLElement*/
  el,
  /**String*/
  selector) {
    if (!selector) return;
    selector[0] === '>' && (selector = selector.substring(1));

    if (el) {
      try {
        if (el.matches) {
          return el.matches(selector);
        } else if (el.msMatchesSelector) {
          return el.msMatchesSelector(selector);
        } else if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector(selector);
        }
      } catch (_) {
        return false;
      }
    }

    return false;
  }

  function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
  }

  function closest(
  /**HTMLElement*/
  el,
  /**String*/
  selector,
  /**HTMLElement*/
  ctx, includeCTX) {
    if (el) {
      ctx = ctx || document;

      do {
        if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
          return el;
        }

        if (el === ctx) break;
        /* jshint boss:true */
      } while (el = getParentOrHost(el));
    }

    return null;
  }

  var R_SPACE = /\s+/g;

  function toggleClass(el, name, state) {
    if (el && name) {
      if (el.classList) {
        el.classList[state ? 'add' : 'remove'](name);
      } else {
        var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
        el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
      }
    }
  }

  function css(el, prop, val) {
    var style = el && el.style;

    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, '');
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }

        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style) && prop.indexOf('webkit') === -1) {
          prop = '-webkit-' + prop;
        }

        style[prop] = val + (typeof val === 'string' ? '' : 'px');
      }
    }
  }

  function matrix(el, selfOnly) {
    var appliedTransforms = '';

    if (typeof el === 'string') {
      appliedTransforms = el;
    } else {
      do {
        var transform = css(el, 'transform');

        if (transform && transform !== 'none') {
          appliedTransforms = transform + ' ' + appliedTransforms;
        }
        /* jshint boss:true */

      } while (!selfOnly && (el = el.parentNode));
    }

    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix;
    /*jshint -W056 */

    return matrixFn && new matrixFn(appliedTransforms);
  }

  function find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName),
          i = 0,
          n = list.length;

      if (iterator) {
        for (; i < n; i++) {
          iterator(list[i], i);
        }
      }

      return list;
    }

    return [];
  }

  function getWindowScrollingElement() {
    if (IE11OrLess) {
      return document.documentElement;
    } else {
      return document.scrollingElement;
    }
  }
  /**
   * Returns the "bounding client rect" of given element
   * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
   * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
   * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
   * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
   * @param  {[HTMLElement]} container              The parent the element will be placed in
   * @return {Object}                               The boundingClientRect of el, with specified adjustments
   */


  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el.getBoundingClientRect && el !== window) return;
    var elRect, top, left, bottom, right, height, width;

    if (el !== window && el !== getWindowScrollingElement()) {
      elRect = el.getBoundingClientRect();
      top = elRect.top;
      left = elRect.left;
      bottom = elRect.bottom;
      right = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top = 0;
      left = 0;
      bottom = window.innerHeight;
      right = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }

    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
      // Adjust for translate()
      container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
      // Not needed on <= IE11

      if (!IE11OrLess) {
        do {
          if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
            var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

            top -= containerRect.top + parseInt(css(container, 'border-top-width'));
            left -= containerRect.left + parseInt(css(container, 'border-left-width'));
            bottom = top + elRect.height;
            right = left + elRect.width;
            break;
          }
          /* jshint boss:true */

        } while (container = container.parentNode);
      }
    }

    if (undoScale && el !== window) {
      // Adjust for scale()
      var elMatrix = matrix(container || el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d;

      if (elMatrix) {
        top /= scaleY;
        left /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom = top + height;
        right = left + width;
      }
    }

    return {
      top: top,
      left: left,
      bottom: bottom,
      right: right,
      width: width,
      height: height
    };
  }
  /**
   * Checks if a side of an element is scrolled past a side of its parents
   * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
   * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
   * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
   * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
   */


  function isScrolledPast(el, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el, true),
        elSideVal = getRect(el)[elSide];
    /* jshint boss:true */

    while (parent) {
      var parentSideVal = getRect(parent)[parentSide],
          visible = void 0;

      if (parentSide === 'top' || parentSide === 'left') {
        visible = elSideVal >= parentSideVal;
      } else {
        visible = elSideVal <= parentSideVal;
      }

      if (!visible) return parent;
      if (parent === getWindowScrollingElement()) break;
      parent = getParentAutoScrollElement(parent, false);
    }

    return false;
  }
  /**
   * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
   * and non-draggable elements
   * @param  {HTMLElement} el       The parent element
   * @param  {Number} childNum      The index of the child
   * @param  {Object} options       Parent Sortable's options
   * @return {HTMLElement}          The child at index childNum, or null if not found
   */


  function getChild(el, childNum, options) {
    var currentChild = 0,
        i = 0,
        children = el.children;

    while (i < children.length) {
      if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {
        if (currentChild === childNum) {
          return children[i];
        }

        currentChild++;
      }

      i++;
    }

    return null;
  }
  /**
   * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
   * @param  {HTMLElement} el       Parent element
   * @param  {selector} selector    Any other elements that should be ignored
   * @return {HTMLElement}          The last child, ignoring ghostEl
   */


  function lastChild(el, selector) {
    var last = el.lastElementChild;

    while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
      last = last.previousElementSibling;
    }

    return last || null;
  }
  /**
   * Returns the index of an element within its parent for a selected set of
   * elements
   * @param  {HTMLElement} el
   * @param  {selector} selector
   * @return {number}
   */


  function index(el, selector) {
    var index = 0;

    if (!el || !el.parentNode) {
      return -1;
    }
    /* jshint boss:true */


    while (el = el.previousElementSibling) {
      if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
        index++;
      }
    }

    return index;
  }
  /**
   * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
   * The value is returned in real pixels.
   * @param  {HTMLElement} el
   * @return {Array}             Offsets in the format of [left, top]
   */


  function getRelativeScrollOffset(el) {
    var offsetLeft = 0,
        offsetTop = 0,
        winScroller = getWindowScrollingElement();

    if (el) {
      do {
        var elMatrix = matrix(el),
            scaleX = elMatrix.a,
            scaleY = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX;
        offsetTop += el.scrollTop * scaleY;
      } while (el !== winScroller && (el = el.parentNode));
    }

    return [offsetLeft, offsetTop];
  }
  /**
   * Returns the index of the object within the given array
   * @param  {Array} arr   Array that may or may not hold the object
   * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
   * @return {Number}      The index of the object in the array, or -1
   */


  function indexOfObject(arr, obj) {
    for (var i in arr) {
      if (!arr.hasOwnProperty(i)) continue;

      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
      }
    }

    return -1;
  }

  function getParentAutoScrollElement(el, includeSelf) {
    // skip to window
    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;

    do {
      // we don't need to get elem css if it isn't even overflowing in the first place (performance)
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);

        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
          if (gotSelf || includeSelf) return elem;
          gotSelf = true;
        }
      }
      /* jshint boss:true */

    } while (elem = elem.parentNode);

    return getWindowScrollingElement();
  }

  function extend(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }

    return dst;
  }

  function isRectEqual(rect1, rect2) {
    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
  }

  var _throttleTimeout;

  function throttle(callback, ms) {
    return function () {
      if (!_throttleTimeout) {
        var args = arguments,
            _this = this;

        if (args.length === 1) {
          callback.call(_this, args[0]);
        } else {
          callback.apply(_this, args);
        }

        _throttleTimeout = setTimeout(function () {
          _throttleTimeout = void 0;
        }, ms);
      }
    };
  }

  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }

  function scrollBy(el, x, y) {
    el.scrollLeft += x;
    el.scrollTop += y;
  }

  function clone(el) {
    var Polymer = window.Polymer;
    var $ = window.jQuery || window.Zepto;

    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else if ($) {
      return $(el).clone(true)[0];
    } else {
      return el.cloneNode(true);
    }
  }

  function setRect(el, rect) {
    css(el, 'position', 'absolute');
    css(el, 'top', rect.top);
    css(el, 'left', rect.left);
    css(el, 'width', rect.width);
    css(el, 'height', rect.height);
  }

  function unsetRect(el) {
    css(el, 'position', '');
    css(el, 'top', '');
    css(el, 'left', '');
    css(el, 'width', '');
    css(el, 'height', '');
  }

  var expando = 'Sortable' + new Date().getTime();

  function AnimationStateManager() {
    var animationStates = [],
        animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation) return;
        var children = [].slice.call(this.el.children);
        children.forEach(function (child) {
          if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });

          var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);

            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }

          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target: target
        }), 1);
      },
      animateAll: function animateAll(callback) {
        var _this = this;

        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback === 'function') callback();
          return;
        }

        var animating = false,
            animationTime = 0;
        animationStates.forEach(function (state) {
          var time = 0,
              target = state.target,
              fromRect = target.fromRect,
              toRect = getRect(target),
              prevFromRect = target.prevFromRect,
              prevToRect = target.prevToRect,
              animatingRect = state.rect,
              targetMatrix = matrix(target, true);

          if (targetMatrix) {
            // Compensate for current animation
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }

          target.toRect = toRect;

          if (target.thisAnimationDuration) {
            // Could also check if animatingRect is between fromRect and toRect
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              // If returning to same place as started from animation and on same axis
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          } // if fromRect != toRect: animate


          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;

            if (!time) {
              time = _this.options.animation;
            }

            _this.animate(target, animatingRect, toRect, time);
          }

          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function () {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);

        if (!animating) {
          if (typeof callback === 'function') callback();
        } else {
          animationCallbackId = setTimeout(function () {
            if (typeof callback === 'function') callback();
          }, animationTime);
        }

        animationStates = [];
      },
      animate: function animate(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, 'transition', '');
          css(target, 'transform', '');
          var elMatrix = matrix(this.el),
              scaleX = elMatrix && elMatrix.a,
              scaleY = elMatrix && elMatrix.d,
              translateX = (currentRect.left - toRect.left) / (scaleX || 1),
              translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
          repaint(target); // repaint

          css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
          css(target, 'transform', 'translate3d(0,0,0)');
          typeof target.animated === 'number' && clearTimeout(target.animated);
          target.animated = setTimeout(function () {
            css(target, 'transition', '');
            css(target, 'transform', '');
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      }
    };
  }

  function repaint(target) {
    return target.offsetWidth;
  }

  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
  }

  var plugins = [];
  var defaults = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: function mount(plugin) {
      // Set default static properties
      for (var option in defaults) {
        if (defaults.hasOwnProperty(option) && !(option in plugin)) {
          plugin[option] = defaults[option];
        }
      }

      plugins.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;

      this.eventCanceled = false;

      evt.cancel = function () {
        _this.eventCanceled = true;
      };

      var eventNameGlobal = eventName + 'Global';
      plugins.forEach(function (plugin) {
        if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread({
            sortable: sortable
          }, evt));
        } // Only fire plugin event if plugin is enabled in this sortable,
        // and plugin has event defined


        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread({
            sortable: sortable
          }, evt));
        }
      });
    },
    initializePlugins: function initializePlugins(sortable, el, defaults, options) {
      plugins.forEach(function (plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
        var initialized = new plugin(sortable, el, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized; // Add default options from plugin

        _extends(defaults, initialized.defaults);
      });

      for (var option in sortable.options) {
        if (!sortable.options.hasOwnProperty(option)) continue;
        var modified = this.modifyOption(sortable, option, sortable.options[option]);

        if (typeof modified !== 'undefined') {
          sortable.options[option] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name, sortable) {
      var eventProperties = {};
      plugins.forEach(function (plugin) {
        if (typeof plugin.eventProperties !== 'function') return;

        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name, value) {
      var modifiedValue;
      plugins.forEach(function (plugin) {
        // Plugin must exist on the Sortable
        if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

        if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
        }
      });
      return modifiedValue;
    }
  };

  function dispatchEvent(_ref) {
    var sortable = _ref.sortable,
        rootEl = _ref.rootEl,
        name = _ref.name,
        targetEl = _ref.targetEl,
        cloneEl = _ref.cloneEl,
        toEl = _ref.toEl,
        fromEl = _ref.fromEl,
        oldIndex = _ref.oldIndex,
        newIndex = _ref.newIndex,
        oldDraggableIndex = _ref.oldDraggableIndex,
        newDraggableIndex = _ref.newDraggableIndex,
        originalEvent = _ref.originalEvent,
        putSortable = _ref.putSortable,
        extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl && rootEl[expando];
    if (!sortable) return;
    var evt,
        options = sortable.options,
        onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent('Event');
      evt.initEvent(name, true, true);
    }

    evt.to = toEl || rootEl;
    evt.from = fromEl || rootEl;
    evt.item = targetEl || rootEl;
    evt.clone = cloneEl;
    evt.oldIndex = oldIndex;
    evt.newIndex = newIndex;
    evt.oldDraggableIndex = oldDraggableIndex;
    evt.newDraggableIndex = newDraggableIndex;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

    var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));

    for (var option in allEventProperties) {
      evt[option] = allEventProperties[option];
    }

    if (rootEl) {
      rootEl.dispatchEvent(evt);
    }

    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }

  var pluginEvent = function pluginEvent(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        originalEvent = _ref.evt,
        data = _objectWithoutProperties(_ref, ['evt']);

    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({
      dragEl: dragEl,
      parentEl: parentEl,
      ghostEl: ghostEl,
      rootEl: rootEl,
      nextEl: nextEl,
      lastDownEl: lastDownEl,
      cloneEl: cloneEl,
      cloneHidden: cloneHidden,
      dragStarted: moved,
      putSortable: putSortable,
      activeSortable: Sortable.active,
      originalEvent: originalEvent,
      oldIndex: oldIndex,
      oldDraggableIndex: oldDraggableIndex,
      newIndex: newIndex,
      newDraggableIndex: newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: function cloneNowHidden() {
        cloneHidden = true;
      },
      cloneNowShown: function cloneNowShown() {
        cloneHidden = false;
      },
      dispatchSortableEvent: function dispatchSortableEvent(name) {
        _dispatchEvent({
          sortable: sortable,
          name: name,
          originalEvent: originalEvent
        });
      }
    }, data));
  };

  function _dispatchEvent(info) {
    dispatchEvent(_objectSpread({
      putSortable: putSortable,
      cloneEl: cloneEl,
      targetEl: dragEl,
      rootEl: rootEl,
      oldIndex: oldIndex,
      oldDraggableIndex: oldDraggableIndex,
      newIndex: newIndex,
      newDraggableIndex: newDraggableIndex
    }, info));
  }

  var dragEl,
      parentEl,
      ghostEl,
      rootEl,
      nextEl,
      lastDownEl,
      cloneEl,
      cloneHidden,
      oldIndex,
      newIndex,
      oldDraggableIndex,
      newDraggableIndex,
      activeGroup,
      putSortable,
      awaitingDragStarted = false,
      ignoreNextClick = false,
      sortables = [],
      tapEvt,
      touchEvt,
      lastDx,
      lastDy,
      tapDistanceLeft,
      tapDistanceTop,
      moved,
      lastTarget,
      lastDirection,
      pastFirstInvertThresh = false,
      isCircumstantialInvert = false,
      targetMoveDistance,
      // For positioning ghost absolutely
  ghostRelativeParent,
      ghostRelativeParentInitialScroll = [],
      // (left, top)
  _silent = false,
      savedInputChecked = [];
  /** @const */

  var documentExists = typeof document !== 'undefined',
      PositionGhostAbsolutely = IOS,
      CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
      // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
      supportCssPointerEvents = function () {
    if (!documentExists) return; // false when <= IE11

    if (IE11OrLess) {
      return false;
    }

    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
      _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
        elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
        child1 = getChild(el, 0, options),
        child2 = getChild(el, 1, options),
        firstChildCSS = child1 && css(child1),
        secondChildCSS = child2 && css(child2),
        firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
        secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }

    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }

    if (child1 && firstChildCSS['float'] && firstChildCSS['float'] !== 'none') {
      var touchingSideChild2 = firstChildCSS['float'] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }

    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
      _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
        dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
        dragElOppLength = vertical ? dragRect.width : dragRect.height,
        targetS1Opp = vertical ? targetRect.left : targetRect.top,
        targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
        targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },

  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      if (lastChild(sortable)) return;
      var rect = getRect(sortable),
          threshold = sortable[expando].options.emptyInsertThreshold,
          insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
          insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

      if (threshold && insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
      _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }

    var group = {};
    var originalGroup = options.group;

    if (!originalGroup || _typeof(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }

    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
      _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
      _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


  if (documentExists) {
    document.addEventListener('click', function (evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }

  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;

      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

      if (nearest) {
        // Create imitation event
        var event = {};

        for (var i in evt) {
          if (evt.hasOwnProperty(i)) {
            event[i] = evt[i];
          }
        }

        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;

        nearest[expando]._onDragOver(event);
      }
    }
  };

  var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };
  /**
   * @class  Sortable
   * @param  {HTMLElement}  el
   * @param  {Object}       [options]
   */


  function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw 'Sortable: `el` must be an HTMLElement, not '.concat({}.toString.call(el));
    }

    this.el = el; // root element

    this.options = options = _extends({}, options); // Export instance

    el[expando] = this;
    var defaults = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function direction() {
        return _detectDirection(el, this.options);
      },
      ghostClass: 'sortable-ghost',
      chosenClass: 'sortable-chosen',
      dragClass: 'sortable-drag',
      ignore: 'a, img',
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData(dataTransfer, dragEl) {
        dataTransfer.setData('Text', dragEl.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: 'data-id',
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: 'sortable-fallback',
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el, defaults); // Set default options

    for (var name in defaults) {
      !(name in options) && (options[name] = defaults[name]);
    }

    _prepareGroup(options); // Bind all private methods


    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    } // Setup drag mode


    this.nativeDraggable = options.forceFallback ? false : supportDraggable;

    if (this.nativeDraggable) {
      // Touch start threshold cannot be greater than the native dragstart threshold
      this.options.touchStartThreshold = 1;
    } // Bind events


    if (options.supportPointer) {
      on(el, 'pointerdown', this._onTapStart);
    } else {
      on(el, 'mousedown', this._onTapStart);
      on(el, 'touchstart', this._onTapStart);
    }

    if (this.nativeDraggable) {
      on(el, 'dragover', this);
      on(el, 'dragenter', this);
    }

    sortables.push(this.el); // Restore sorting

    options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

    _extends(this, AnimationStateManager());
  }

  Sortable.prototype =
  /** @lends Sortable.prototype */
  {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart(
    /** Event|TouchEvent */
    evt) {
      if (!evt.cancelable) return;

      var _this = this,
          el = this.el,
          options = this.options,
          preventOnFilter = options.preventOnFilter,
          type = evt.type,
          touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
          target = (touch || evt).target,
          originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
          filter = options.filter;

      _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


      if (dragEl) {
        return;
      }

      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return; // only left button and enabled
      } // cancel dnd if original target is content editable


      if (originalTarget.isContentEditable) {
        return;
      }

      target = closest(target, options.draggable, el, false);

      if (target && target.animated) {
        return;
      }

      if (lastDownEl === target) {
        // Ignoring duplicate `down`
        return;
      } // Get the index of the dragged element within its parent


      oldIndex = index(target);
      oldDraggableIndex = index(target, options.draggable); // Check filter

      if (typeof filter === 'function') {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: 'filter',
            targetEl: target,
            toEl: el,
            fromEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return; // cancel dnd
        }
      } else if (filter) {
        filter = filter.split(',').some(function (criteria) {
          criteria = closest(originalTarget, criteria.trim(), el, false);

          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: 'filter',
              targetEl: target,
              fromEl: el,
              toEl: el
            });

            pluginEvent('filter', _this, {
              evt: evt
            });
            return true;
          }
        });

        if (filter) {
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return; // cancel dnd
        }
      }

      if (options.handle && !closest(originalTarget, options.handle, el, false)) {
        return;
      } // Prepare `dragstart`


      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(
    /** Event */
    evt,
    /** Touch */
    touch,
    /** HTMLElement */
    target) {
      var _this = this,
          el = _this.el,
          options = _this.options,
          ownerDocument = el.ownerDocument,
          dragStartFn;

      if (target && !dragEl && target.parentNode === el) {
        var dragRect = getRect(target);
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style['will-change'] = 'all';

        dragStartFn = function dragStartFn() {
          pluginEvent('delayEnded', _this, {
            evt: evt
          });

          if (Sortable.eventCanceled) {
            _this._onDrop();

            return;
          } // Delayed drag has been triggered
          // we can re-enable the events: touchmove/mousemove


          _this._disableDelayedDragEvents();

          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          } // Bind the events: dragstart/dragend


          _this._triggerDragStart(evt, touch); // Drag start event


          _dispatchEvent({
            sortable: _this,
            name: 'choose',
            originalEvent: evt
          }); // Chosen item


          toggleClass(dragEl, options.chosenClass, true);
        }; // Disable "draggable"


        options.ignore.split(',').forEach(function (criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'mouseup', _this._onDrop);
        on(ownerDocument, 'touchend', _this._onDrop);
        on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }

        pluginEvent('delayStart', this, {
          evt: evt
        }); // Delay is impossible for native DnD in Edge or IE

        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();

            return;
          } // If the user moves the pointer or let go the click or touch
          // before the delay has been reached:
          // disable the delayed drag


          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
          on(ownerDocument, 'touchend', _this._disableDelayedDrag);
          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
          on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
          on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
          options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
    /** TouchEvent|PointerEvent **/
    e) {
      var touch = e.touches ? e.touches[0] : e;

      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);

      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, 'mouseup', this._disableDelayedDrag);
      off(ownerDocument, 'touchend', this._disableDelayedDrag);
      off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
      off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
      off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
      off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(
    /** Event */
    evt,
    /** Touch */
    touch) {
      touch = touch || evt.pointerType == 'touch' && evt;

      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._onTouchMove);
        } else if (touch) {
          on(document, 'touchmove', this._onTouchMove);
        } else {
          on(document, 'mousemove', this._onTouchMove);
        }
      } else {
        on(dragEl, 'dragend', this);
        on(rootEl, 'dragstart', this._onDragStart);
      }

      try {
        if (document.selection) {
          // Timeout neccessary for IE9
          _nextTick(function () {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {}
    },
    _dragStarted: function _dragStarted(fallback, evt) {

      awaitingDragStarted = false;

      if (rootEl && dragEl) {
        pluginEvent('dragStarted', this, {
          evt: evt
        });

        if (this.nativeDraggable) {
          on(document, 'dragover', _checkOutsideTargetEl);
        }

        var options = this.options; // Apply effect

        !fallback && toggleClass(dragEl, options.dragClass, false);
        toggleClass(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost(); // Drag start event

        _dispatchEvent({
          sortable: this,
          name: 'start',
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;

        _hideGhostForTarget();

        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;

        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent) break;
          parent = target;
        }

        dragEl.parentNode[expando]._isOutsideThisEl(target);

        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target: target,
                rootEl: parent
              });

              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }

            target = parent; // store last element
          }
          /* jshint boss:true */
          while (parent = parent.parentNode);
        }

        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove(
    /**TouchEvent*/
    evt) {
      if (tapEvt) {
        var options = this.options,
            fallbackTolerance = options.fallbackTolerance,
            fallbackOffset = options.fallbackOffset,
            touch = evt.touches ? evt.touches[0] : evt,
            ghostMatrix = ghostEl && matrix(ghostEl),
            scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
            scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
            relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
            dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
            dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }

          this._onDragStart(evt, true);
        }

        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }

          var cssMatrix = 'matrix('.concat(ghostMatrix.a, ',').concat(ghostMatrix.b, ',').concat(ghostMatrix.c, ',').concat(ghostMatrix.d, ',').concat(ghostMatrix.e, ',').concat(ghostMatrix.f, ')');
          css(ghostEl, 'webkitTransform', cssMatrix);
          css(ghostEl, 'mozTransform', cssMatrix);
          css(ghostEl, 'msTransform', cssMatrix);
          css(ghostEl, 'transform', cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }

        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      // Bug if using scale(): https://stackoverflow.com/questions/2637058
      // Not being adjusted for
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl,
            rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
            options = this.options; // Position absolutely

        if (PositionGhostAbsolutely) {
          // Get relatively positioned parent
          ghostRelativeParent = container;

          while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }

          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
            rect.top += ghostRelativeParent.scrollTop;
            rect.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }

          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }

        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options.ghostClass, false);
        toggleClass(ghostEl, options.fallbackClass, true);
        toggleClass(ghostEl, options.dragClass, true);
        css(ghostEl, 'transition', '');
        css(ghostEl, 'transform', '');
        css(ghostEl, 'box-sizing', 'border-box');
        css(ghostEl, 'margin', 0);
        css(ghostEl, 'top', rect.top);
        css(ghostEl, 'left', rect.left);
        css(ghostEl, 'width', rect.width);
        css(ghostEl, 'height', rect.height);
        css(ghostEl, 'opacity', '0.8');
        css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
        css(ghostEl, 'zIndex', '100000');
        css(ghostEl, 'pointerEvents', 'none');
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl); // Set transform-origin

        css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
      }
    },
    _onDragStart: function _onDragStart(
    /**Event*/
    evt,
    /**boolean*/
    fallback) {
      var _this = this;

      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent('dragStart', this, {
        evt: evt
      });

      if (Sortable.eventCanceled) {
        this._onDrop();

        return;
      }

      pluginEvent('setupClone', this);

      if (!Sortable.eventCanceled) {
        cloneEl = clone(dragEl);
        cloneEl.draggable = false;
        cloneEl.style['will-change'] = '';

        this._hideClone();

        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      } // #1143: IFrame support workaround


      _this.cloneId = _nextTick(function () {
        pluginEvent('clone', _this);
        if (Sortable.eventCanceled) return;

        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }

        _this._hideClone();

        _dispatchEvent({
          sortable: _this,
          name: 'clone'
        });
      });
      !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        // Undo what was set in _prepareDragStart before drag started
        off(document, 'mouseup', _this._onDrop);
        off(document, 'touchend', _this._onDrop);
        off(document, 'touchcancel', _this._onDrop);

        if (dataTransfer) {
          dataTransfer.effectAllowed = 'move';
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }

        on(document, 'drop', _this); // #1276 fix:

        css(dragEl, 'transform', 'translateZ(0)');
      }

      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, 'selectstart', _this);
      moved = true;

      if (Safari) {
        css(document.body, 'user-select', 'none');
      }
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver(
    /**Event*/
    evt) {
      var el = this.el,
          target = evt.target,
          dragRect,
          targetRect,
          revert,
          options = this.options,
          group = options.group,
          activeSortable = Sortable.active,
          isOwner = activeGroup === group,
          canSort = options.sort,
          fromSortable = putSortable || activeSortable,
          vertical,
          _this = this,
          completedFired = false;

      if (_silent) return;

      function dragOverEvent(name, extra) {
        pluginEvent(name, _this, _objectSpread({
          evt: evt,
          isOwner: isOwner,
          axis: vertical ? 'vertical' : 'horizontal',
          revert: revert,
          dragRect: dragRect,
          targetRect: targetRect,
          canSort: canSort,
          fromSortable: fromSortable,
          target: target,
          completed: completed,
          onMove: function onMove(target, after) {
            return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
          },
          changed: changed
        }, extra));
      } // Capture animation state


      function capture() {
        dragOverEvent('dragOverAnimationCapture');

        _this.captureAnimationState();

        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      } // Return invocation when dragEl is inserted (or completed)


      function completed(insertion) {
        dragOverEvent('dragOverCompleted', {
          insertion: insertion
        });

        if (insertion) {
          // Clones must be hidden before folding animation to capture dragRectAbsolute properly
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }

          if (_this !== fromSortable) {
            // Set ghost class to new sortable's ghost class
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass(dragEl, options.ghostClass, true);
          }

          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          } // Animation


          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }

          _this.animateAll(function () {
            dragOverEvent('dragOverAnimationComplete');
            _this._ignoreWhileAnimating = null;
          });

          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        } // Null lastTarget if it is not inside a previously swapped element


        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
          lastTarget = null;
        } // no bubbling and not fallback


        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


          !insertion && nearestEmptyInsertDetectEvent(evt);
        }

        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      } // Call when dragEl has been inserted


      function changed() {
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);

        _dispatchEvent({
          sortable: _this,
          name: 'change',
          toEl: el,
          newIndex: newIndex,
          newDraggableIndex: newDraggableIndex,
          originalEvent: evt
        });
      }

      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }

      target = closest(target, options.draggable, el, true);
      dragOverEvent('dragOver');
      if (Sortable.eventCanceled) return completedFired;

      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }

      ignoreNextClick = false;

      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
      : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
        vertical = this._getDirection(evt, target) === 'vertical';
        dragRect = getRect(dragEl);
        dragOverEvent('dragOverValid');
        if (Sortable.eventCanceled) return completedFired;

        if (revert) {
          parentEl = rootEl; // actualization

          capture();

          this._hideClone();

          dragOverEvent('revert');

          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }

          return completed(true);
        }

        var elLastChild = lastChild(el, options.draggable);

        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
          // If already at end of list: Do not insert
          if (elLastChild === dragEl) {
            return completed(false);
          } // assign target only if condition is true


          if (elLastChild && el === evt.target) {
            target = elLastChild;
          }

          if (target) {
            targetRect = getRect(target);
          }

          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();
            el.appendChild(dragEl);
            parentEl = el; // actualization

            changed();
            return completed(true);
          }
        } else if (target.parentNode === el) {
          targetRect = getRect(target);
          var direction = 0,
              targetBeforeFirstSwap,
              differentLevel = dragEl.parentNode !== el,
              differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
              side1 = vertical ? 'top' : 'left',
              scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
              scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
          }

          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;

          if (direction !== 0) {
            // Check if target is beside dragEl in respective direction (ignoring hidden elements)
            var dragIndex = index(dragEl);

            do {
              dragIndex -= direction;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
          } // If dragEl is already beside target: Do not insert


          if (direction === 0 || sibling === target) {
            return completed(false);
          }

          lastTarget = target;
          lastDirection = direction;
          var nextSibling = target.nextElementSibling,
              after = false;
          after = direction === 1;

          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }

            _silent = true;
            setTimeout(_unsilent, 30);
            capture();

            if (after && !nextSibling) {
              el.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
            } // Undo chrome's scroll adjustment (has no effect on other browsers)


            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }

            parentEl = dragEl.parentNode; // actualization
            // must be done before animation

            if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }

            changed();
            return completed(true);
          }
        }

        if (el.contains(dragEl)) {
          return completed(false);
        }
      }

      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, 'mousemove', this._onTouchMove);
      off(document, 'touchmove', this._onTouchMove);
      off(document, 'pointermove', this._onTouchMove);
      off(document, 'dragover', nearestEmptyInsertDetectEvent);
      off(document, 'mousemove', nearestEmptyInsertDetectEvent);
      off(document, 'touchmove', nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, 'mouseup', this._onDrop);
      off(ownerDocument, 'touchend', this._onDrop);
      off(ownerDocument, 'pointerup', this._onDrop);
      off(ownerDocument, 'touchcancel', this._onDrop);
      off(document, 'selectstart', this);
    },
    _onDrop: function _onDrop(
    /**Event*/
    evt) {
      var el = this.el,
          options = this.options; // Get the index of the dragged element within its parent

      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      pluginEvent('drop', this, {
        evt: evt
      });
      parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      if (Sortable.eventCanceled) {
        this._nulling();

        return;
      }

      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);

      _cancelNextTick(this.cloneId);

      _cancelNextTick(this._dragStartId); // Unbind events


      if (this.nativeDraggable) {
        off(document, 'drop', this);
        off(el, 'dragstart', this._onDragStart);
      }

      this._offMoveEvents();

      this._offUpEvents();

      if (Safari) {
        css(document.body, 'user-select', '');
      }

      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }

        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
          // Remove clone(s)
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }

        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, 'dragend', this);
          }

          _disableDraggable(dragEl);

          dragEl.style['will-change'] = ''; // Remove classes
          // ghostClass is added in dragStarted

          if (moved && !awaitingDragStarted) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }

          toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

          _dispatchEvent({
            sortable: this,
            name: 'unchoose',
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });

          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              // Add event
              _dispatchEvent({
                rootEl: parentEl,
                name: 'add',
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              }); // Remove event


              _dispatchEvent({
                sortable: this,
                name: 'remove',
                toEl: parentEl,
                originalEvent: evt
              }); // drag from one list and drop into another


              _dispatchEvent({
                rootEl: parentEl,
                name: 'sort',
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }

            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                // drag & drop within the same list
                _dispatchEvent({
                  sortable: this,
                  name: 'update',
                  toEl: parentEl,
                  originalEvent: evt
                });

                _dispatchEvent({
                  sortable: this,
                  name: 'sort',
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }

          if (Sortable.active) {
            /* jshint eqnull:true */
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }

            _dispatchEvent({
              sortable: this,
              name: 'end',
              toEl: parentEl,
              originalEvent: evt
            }); // Save sorting


            this.save();
          }
        }
      }

      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent('nulling', this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function (el) {
        el.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(
    /**Event*/
    evt) {
      switch (evt.type) {
        case 'drop':
        case 'dragend':
          this._onDrop(evt);

          break;

        case 'dragenter':
        case 'dragover':
          if (dragEl) {
            this._onDragOver(evt);

            _globalDragOver(evt);
          }

          break;

        case 'selectstart':
          evt.preventDefault();
          break;
      }
    },

    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function toArray() {
      var order = [],
          el,
          children = this.el.children,
          i = 0,
          n = children.length,
          options = this.options;

      for (; i < n; i++) {
        el = children[i];

        if (closest(el, options.draggable, this.el, false)) {
          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }

      return order;
    },

    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function sort(order) {
      var items = {},
          rootEl = this.el;
      this.toArray().forEach(function (id, i) {
        var el = rootEl.children[i];

        if (closest(el, this.options.draggable, rootEl, false)) {
          items[id] = el;
        }
      }, this);
      order.forEach(function (id) {
        if (items[id]) {
          rootEl.removeChild(items[id]);
          rootEl.appendChild(items[id]);
        }
      });
    },

    /**
     * Save the current sorting
     */
    save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },

    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function closest$1(el, selector) {
      return closest(el, selector || this.options.draggable, this.el, false);
    },

    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function option(name, value) {
      var options = this.options;

      if (value === void 0) {
        return options[name];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name, value);

        if (typeof modifiedValue !== 'undefined') {
          options[name] = modifiedValue;
        } else {
          options[name] = value;
        }

        if (name === 'group') {
          _prepareGroup(options);
        }
      }
    },

    /**
     * Destroy
     */
    destroy: function destroy() {
      pluginEvent('destroy', this);
      var el = this.el;
      el[expando] = null;
      off(el, 'mousedown', this._onTapStart);
      off(el, 'touchstart', this._onTapStart);
      off(el, 'pointerdown', this._onTapStart);

      if (this.nativeDraggable) {
        off(el, 'dragover', this);
        off(el, 'dragenter', this);
      } // Remove draggable attributes


      Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
        el.removeAttribute('draggable');
      });

      this._onDrop();

      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent('hideClone', this);
        if (Sortable.eventCanceled) return;
        css(cloneEl, 'display', 'none');

        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }

        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable) {
      if (putSortable.lastPutMode !== 'clone') {
        this._hideClone();

        return;
      }

      if (cloneHidden) {
        pluginEvent('showClone', this);
        if (Sortable.eventCanceled) return; // show clone at dragEl or original position

        if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }

        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }

        css(cloneEl, 'display', '');
        cloneHidden = false;
      }
    }
  };

  function _globalDragOver(
  /**Event*/
  evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = 'move';
    }

    evt.cancelable && evt.preventDefault();
  }

  function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt,
        sortable = fromEl[expando],
        onMoveFn = sortable.options.onMove,
        retVal; // Support for new CustomEvent feature

    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent('move', {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent('Event');
      evt.initEvent('move', true, true);
    }

    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);

    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }

    return retVal;
  }

  function _disableDraggable(el) {
    el.draggable = false;
  }

  function _unsilent() {
    _silent = false;
  }

  function _ghostIsLast(evt, vertical, sortable) {
    var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var spacer = 10;
    return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
  }

  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
        targetLength = vertical ? targetRect.height : targetRect.width,
        targetS1 = vertical ? targetRect.top : targetRect.left,
        targetS2 = vertical ? targetRect.bottom : targetRect.right,
        invert = false;

    if (!invertSwap) {
      // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
        // check if past first invert threshold on side opposite of lastDirection
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          // past first invert threshold, do not restrict inverted threshold to dragEl shadow
          pastFirstInvertThresh = true;
        }

        if (!pastFirstInvertThresh) {
          // dragEl shadow (target move distance shadow)
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
          : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert = true;
        }
      } else {
        // Regular
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }

    invert = invert || invertSwap;

    if (invert) {
      // Invert of regular
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }

    return 0;
  }
  /**
   * Gets the direction dragEl must be swapped relative to target in order to make it
   * seem that dragEl has been "inserted" into that element's position
   * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
   * @return {Number}                   Direction dragEl must be swapped
   */


  function _getInsertDirection(target) {
    if (index(dragEl) < index(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  /**
   * Generate id
   * @param   {HTMLElement} el
   * @returns {String}
   * @private
   */


  function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent,
        i = str.length,
        sum = 0;

    while (i--) {
      sum += str.charCodeAt(i);
    }

    return sum.toString(36);
  }

  function _saveInputCheckedState(root) {
    savedInputChecked.length = 0;
    var inputs = root.getElementsByTagName('input');
    var idx = inputs.length;

    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }

  function _nextTick(fn) {
    return setTimeout(fn, 0);
  }

  function _cancelNextTick(id) {
    return clearTimeout(id);
  } // Fixed #973:


  if (documentExists) {
    on(document, 'touchmove', function (evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  } // Export utils


  Sortable.utils = {
    on: on,
    off: off,
    css: css,
    find: find,
    is: function is(el, selector) {
      return !!closest(el, selector, el, false);
    },
    extend: extend,
    throttle: throttle,
    closest: closest,
    toggleClass: toggleClass,
    clone: clone,
    index: index,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild: getChild
  };
  /**
   * Get the Sortable instance of an element
   * @param  {HTMLElement} element The element
   * @return {Sortable|undefined}         The instance of Sortable
   */

  Sortable.get = function (element) {
    return element[expando];
  };
  /**
   * Mount a plugin to Sortable
   * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
   */


  Sortable.mount = function () {
    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    if (plugins[0].constructor === Array) plugins = plugins[0];
    plugins.forEach(function (plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw 'Sortable: Mounted plugin must be a constructor function, not '.concat({}.toString.call(plugin));
      }

      if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  /**
   * Create sortable instance
   * @param {HTMLElement}  el
   * @param {Object}      [options]
   */


  Sortable.create = function (el, options) {
    return new Sortable(el, options);
  }; // Export


  Sortable.version = version;

  var autoScrolls = [],
      scrollEl,
      scrollRootEl,
      scrolling = false,
      lastAutoScrollX,
      lastAutoScrollY,
      touchEvt$1,
      pointerElemChangedInterval;

  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      }; // Bind all private methods

      for (var fn in this) {
        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
          this[fn] = this[fn].bind(this);
        }
      }
    }

    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;

        if (this.sortable.nativeDraggable) {
          on(document, 'dragover', this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, 'pointermove', this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, 'touchmove', this._handleFallbackAutoScroll);
          } else {
            on(document, 'mousemove', this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent;

        // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop() {
        if (this.sortable.nativeDraggable) {
          off(document, 'dragover', this._handleAutoScroll);
        } else {
          off(document, 'pointermove', this._handleFallbackAutoScroll);
          off(document, 'touchmove', this._handleFallbackAutoScroll);
          off(document, 'mousemove', this._handleFallbackAutoScroll);
        }

        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;

        var x = (evt.touches ? evt.touches[0] : evt).clientX,
            y = (evt.touches ? evt.touches[0] : evt).clientY,
            elem = document.elementFromPoint(x, y);
        touchEvt$1 = evt; // IE does not seem to have native autoscroll,
        // Edge's autoscroll seems too conditional,
        // MACOS Safari does not have autoscroll,
        // Firefox and Chrome are good

        if (fallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

          var ogElemScroller = getParentAutoScrollElement(elem, true);

          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
            pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

            pointerElemChangedInterval = setInterval(function () {
              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }

              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x;
            lastAutoScrollY = y;
          }
        } else {
          // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
            clearAutoScrolls();
            return;
          }

          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
        }
      }
    };
    return _extends(AutoScroll, {
      pluginName: 'scroll',
      initializeByDefault: true
    });
  }

  function clearAutoScrolls() {
    autoScrolls.forEach(function (autoScroll) {
      clearInterval(autoScroll.pid);
    });
    autoScrolls = [];
  }

  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }

  var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
    // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
    if (!options.scroll) return;
    var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        sens = options.scrollSensitivity,
        speed = options.scrollSpeed,
        winScroller = getWindowScrollingElement();
    var scrollThisInstance = false,
        scrollCustomFn; // New scroll root, set scrollEl

    if (scrollRootEl !== rootEl) {
      scrollRootEl = rootEl;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;

      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl, true);
      }
    }

    var layersOut = 0;
    var currentParent = scrollEl;

    do {
      var el = currentParent,
          rect = getRect(el),
          top = rect.top,
          bottom = rect.bottom,
          left = rect.left,
          right = rect.right,
          width = rect.width,
          height = rect.height,
          canScrollX = void 0,
          canScrollY = void 0,
          scrollWidth = el.scrollWidth,
          scrollHeight = el.scrollHeight,
          elCSS = css(el),
          scrollPosX = el.scrollLeft,
          scrollPosY = el.scrollTop;

      if (el === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
      }

      var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

      if (!autoScrolls[layersOut]) {
        for (var i = 0; i <= layersOut; i++) {
          if (!autoScrolls[i]) {
            autoScrolls[i] = {};
          }
        }
      }

      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
        autoScrolls[layersOut].el = el;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);

        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          /* jshint loopfunc:true */

          autoScrolls[layersOut].pid = setInterval(function () {
            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

            }

            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

            if (typeof scrollCustomFn === 'function') {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
                return;
              }
            }

            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }

      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

    scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
  }, 30);

  var drop = function drop(_ref) {
    var originalEvent = _ref.originalEvent,
        putSortable = _ref.putSortable,
        dragEl = _ref.dragEl,
        activeSortable = _ref.activeSortable,
        dispatchSortableEvent = _ref.dispatchSortableEvent,
        hideGhostForTarget = _ref.hideGhostForTarget,
        unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent) return;
    var toSortable = putSortable || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();

    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent('spill');
      this.onSpill({
        dragEl: dragEl,
        putSortable: putSortable
      });
    }
  };

  function Revert() {}

  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl = _ref3.dragEl,
          putSortable = _ref3.putSortable;
      this.sortable.captureAnimationState();

      if (putSortable) {
        putSortable.captureAnimationState();
      }

      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl);
      }

      this.sortable.animateAll();

      if (putSortable) {
        putSortable.animateAll();
      }
    },
    drop: drop
  };

  _extends(Revert, {
    pluginName: 'revertOnSpill'
  });

  function Remove() {}

  Remove.prototype = {
    onSpill: function onSpill(_ref4) {
      var dragEl = _ref4.dragEl,
          putSortable = _ref4.putSortable;
      var parentSortable = putSortable || this.sortable;
      parentSortable.captureAnimationState();
      dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
      parentSortable.animateAll();
    },
    drop: drop
  };

  _extends(Remove, {
    pluginName: 'removeOnSpill'
  });

  var lastSwapEl;

  function SwapPlugin() {
    function Swap() {
      this.defaults = {
        swapClass: 'sortable-swap-highlight'
      };
    }

    Swap.prototype = {
      dragStart: function dragStart(_ref) {
        var dragEl = _ref.dragEl;
        lastSwapEl = dragEl;
      },
      dragOverValid: function dragOverValid(_ref2) {
        var completed = _ref2.completed,
            target = _ref2.target,
            onMove = _ref2.onMove,
            activeSortable = _ref2.activeSortable,
            changed = _ref2.changed,
            cancel = _ref2.cancel;
        if (!activeSortable.options.swap) return;
        var el = this.sortable.el,
            options = this.options;

        if (target && target !== el) {
          var prevSwapEl = lastSwapEl;

          if (onMove(target) !== false) {
            toggleClass(target, options.swapClass, true);
            lastSwapEl = target;
          } else {
            lastSwapEl = null;
          }

          if (prevSwapEl && prevSwapEl !== lastSwapEl) {
            toggleClass(prevSwapEl, options.swapClass, false);
          }
        }

        changed();
        completed(true);
        cancel();
      },
      drop: function drop(_ref3) {
        var activeSortable = _ref3.activeSortable,
            putSortable = _ref3.putSortable,
            dragEl = _ref3.dragEl;
        var toSortable = putSortable || this.sortable;
        var options = this.options;
        lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);

        if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
          if (dragEl !== lastSwapEl) {
            toSortable.captureAnimationState();
            if (toSortable !== activeSortable) activeSortable.captureAnimationState();
            swapNodes(dragEl, lastSwapEl);
            toSortable.animateAll();
            if (toSortable !== activeSortable) activeSortable.animateAll();
          }
        }
      },
      nulling: function nulling() {
        lastSwapEl = null;
      }
    };
    return _extends(Swap, {
      pluginName: 'swap',
      eventProperties: function eventProperties() {
        return {
          swapItem: lastSwapEl
        };
      }
    });
  }

  function swapNodes(n1, n2) {
    var p1 = n1.parentNode,
        p2 = n2.parentNode,
        i1,
        i2;
    if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
    i1 = index(n1);
    i2 = index(n2);

    if (p1.isEqualNode(p2) && i1 < i2) {
      i2++;
    }

    p1.insertBefore(n2, p1.children[i1]);
    p2.insertBefore(n1, p2.children[i2]);
  }

  var multiDragElements = [],
      multiDragClones = [],
      lastMultiDragSelect,
      // for selection with modifier key down (SHIFT)
  multiDragSortable,
      initialFolding = false,
      // Initial multi-drag fold when drag started
  folding = false,
      // Folding any other time
  dragStarted = false,
      dragEl$1,
      clonesFromRect,
      clonesHidden;

  function MultiDragPlugin() {
    function MultiDrag(sortable) {
      // Bind all private methods
      for (var fn in this) {
        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
          this[fn] = this[fn].bind(this);
        }
      }

      if (sortable.options.supportPointer) {
        on(document, 'pointerup', this._deselectMultiDrag);
      } else {
        on(document, 'mouseup', this._deselectMultiDrag);
        on(document, 'touchend', this._deselectMultiDrag);
      }

      on(document, 'keydown', this._checkKeyDown);
      on(document, 'keyup', this._checkKeyUp);
      this.defaults = {
        selectedClass: 'sortable-selected',
        multiDragKey: null,
        setData: function setData(dataTransfer, dragEl) {
          var data = '';

          if (multiDragElements.length && multiDragSortable === sortable) {
            multiDragElements.forEach(function (multiDragElement, i) {
              data += (!i ? '' : ', ') + multiDragElement.textContent;
            });
          } else {
            data = dragEl.textContent;
          }

          dataTransfer.setData('Text', data);
        }
      };
    }

    MultiDrag.prototype = {
      multiDragKeyDown: false,
      isMultiDrag: false,
      delayStartGlobal: function delayStartGlobal(_ref) {
        var dragged = _ref.dragEl;
        dragEl$1 = dragged;
      },
      delayEnded: function delayEnded() {
        this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
      },
      setupClone: function setupClone(_ref2) {
        var sortable = _ref2.sortable,
            cancel = _ref2.cancel;
        if (!this.isMultiDrag) return;

        for (var i = 0; i < multiDragElements.length; i++) {
          multiDragClones.push(clone(multiDragElements[i]));
          multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
          multiDragClones[i].draggable = false;
          multiDragClones[i].style['will-change'] = '';
          toggleClass(multiDragClones[i], this.options.selectedClass, false);
          multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
        }

        sortable._hideClone();

        cancel();
      },
      clone: function clone(_ref3) {
        var sortable = _ref3.sortable,
            rootEl = _ref3.rootEl,
            dispatchSortableEvent = _ref3.dispatchSortableEvent,
            cancel = _ref3.cancel;
        if (!this.isMultiDrag) return;

        if (!this.options.removeCloneOnHide) {
          if (multiDragElements.length && multiDragSortable === sortable) {
            insertMultiDragClones(true, rootEl);
            dispatchSortableEvent('clone');
            cancel();
          }
        }
      },
      showClone: function showClone(_ref4) {
        var cloneNowShown = _ref4.cloneNowShown,
            rootEl = _ref4.rootEl,
            cancel = _ref4.cancel;
        if (!this.isMultiDrag) return;
        insertMultiDragClones(false, rootEl);
        multiDragClones.forEach(function (clone) {
          css(clone, 'display', '');
        });
        cloneNowShown();
        clonesHidden = false;
        cancel();
      },
      hideClone: function hideClone(_ref5) {
        var _this = this;

        var sortable = _ref5.sortable,
            cloneNowHidden = _ref5.cloneNowHidden,
            cancel = _ref5.cancel;
        if (!this.isMultiDrag) return;
        multiDragClones.forEach(function (clone) {
          css(clone, 'display', 'none');

          if (_this.options.removeCloneOnHide && clone.parentNode) {
            clone.parentNode.removeChild(clone);
          }
        });
        cloneNowHidden();
        clonesHidden = true;
        cancel();
      },
      dragStartGlobal: function dragStartGlobal(_ref6) {
        var sortable = _ref6.sortable;

        if (!this.isMultiDrag && multiDragSortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();
        }

        multiDragElements.forEach(function (multiDragElement) {
          multiDragElement.sortableIndex = index(multiDragElement);
        }); // Sort multi-drag elements

        multiDragElements = multiDragElements.sort(function (a, b) {
          return a.sortableIndex - b.sortableIndex;
        });
        dragStarted = true;
      },
      dragStarted: function dragStarted(_ref7) {
        var _this2 = this;

        var sortable = _ref7.sortable;
        if (!this.isMultiDrag) return;

        if (this.options.sort) {
          // Capture rects,
          // hide multi drag elements (by positioning them absolute),
          // set multi drag elements rects to dragRect,
          // show multi drag elements,
          // animate to rects,
          // unset rects & remove from DOM
          sortable.captureAnimationState();

          if (this.options.animation) {
            multiDragElements.forEach(function (multiDragElement) {
              if (multiDragElement === dragEl$1) return;
              css(multiDragElement, 'position', 'absolute');
            });
            var dragRect = getRect(dragEl$1, false, true, true);
            multiDragElements.forEach(function (multiDragElement) {
              if (multiDragElement === dragEl$1) return;
              setRect(multiDragElement, dragRect);
            });
            folding = true;
            initialFolding = true;
          }
        }

        sortable.animateAll(function () {
          folding = false;
          initialFolding = false;

          if (_this2.options.animation) {
            multiDragElements.forEach(function (multiDragElement) {
              unsetRect(multiDragElement);
            });
          } // Remove all auxiliary multidrag items from el, if sorting enabled


          if (_this2.options.sort) {
            removeMultiDragElements();
          }
        });
      },
      dragOver: function dragOver(_ref8) {
        var target = _ref8.target,
            completed = _ref8.completed,
            cancel = _ref8.cancel;

        if (folding && ~multiDragElements.indexOf(target)) {
          completed(false);
          cancel();
        }
      },
      revert: function revert(_ref9) {
        var fromSortable = _ref9.fromSortable,
            rootEl = _ref9.rootEl,
            sortable = _ref9.sortable,
            dragRect = _ref9.dragRect;

        if (multiDragElements.length > 1) {
          // Setup unfold animation
          multiDragElements.forEach(function (multiDragElement) {
            sortable.addAnimationState({
              target: multiDragElement,
              rect: folding ? getRect(multiDragElement) : dragRect
            });
            unsetRect(multiDragElement);
            multiDragElement.fromRect = dragRect;
            fromSortable.removeAnimationState(multiDragElement);
          });
          folding = false;
          insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref10) {
        var sortable = _ref10.sortable,
            isOwner = _ref10.isOwner,
            insertion = _ref10.insertion,
            activeSortable = _ref10.activeSortable,
            parentEl = _ref10.parentEl,
            putSortable = _ref10.putSortable;
        var options = this.options;

        if (insertion) {
          // Clones must be hidden before folding animation to capture dragRectAbsolute properly
          if (isOwner) {
            activeSortable._hideClone();
          }

          initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location

          if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
            // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
            var dragRectAbsolute = getRect(dragEl$1, false, true, true);
            multiDragElements.forEach(function (multiDragElement) {
              if (multiDragElement === dragEl$1) return;
              setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
              // while folding, and so that we can capture them again because old sortable will no longer be fromSortable

              parentEl.appendChild(multiDragElement);
            });
            folding = true;
          } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out


          if (!isOwner) {
            // Only remove if not folding (folding will remove them anyways)
            if (!folding) {
              removeMultiDragElements();
            }

            if (multiDragElements.length > 1) {
              var clonesHiddenBefore = clonesHidden;

              activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden


              if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
                multiDragClones.forEach(function (clone) {
                  activeSortable.addAnimationState({
                    target: clone,
                    rect: clonesFromRect
                  });
                  clone.fromRect = clonesFromRect;
                  clone.thisAnimationDuration = null;
                });
              }
            } else {
              activeSortable._showClone(sortable);
            }
          }
        }
      },
      dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
        var dragRect = _ref11.dragRect,
            isOwner = _ref11.isOwner,
            activeSortable = _ref11.activeSortable;
        multiDragElements.forEach(function (multiDragElement) {
          multiDragElement.thisAnimationDuration = null;
        });

        if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
          clonesFromRect = _extends({}, dragRect);
          var dragMatrix = matrix(dragEl$1, true);
          clonesFromRect.top -= dragMatrix.f;
          clonesFromRect.left -= dragMatrix.e;
        }
      },
      dragOverAnimationComplete: function dragOverAnimationComplete() {
        if (folding) {
          folding = false;
          removeMultiDragElements();
        }
      },
      drop: function drop(_ref12) {
        var evt = _ref12.originalEvent,
            rootEl = _ref12.rootEl,
            parentEl = _ref12.parentEl,
            sortable = _ref12.sortable,
            dispatchSortableEvent = _ref12.dispatchSortableEvent,
            oldIndex = _ref12.oldIndex,
            putSortable = _ref12.putSortable;
        var toSortable = putSortable || this.sortable;
        if (!evt) return;
        var options = this.options,
            children = parentEl.children; // Multi-drag selection

        if (!dragStarted) {
          if (options.multiDragKey && !this.multiDragKeyDown) {
            this._deselectMultiDrag();
          }

          toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));

          if (!~multiDragElements.indexOf(dragEl$1)) {
            multiDragElements.push(dragEl$1);
            dispatchEvent({
              sortable: sortable,
              rootEl: rootEl,
              name: 'select',
              targetEl: dragEl$1,
              originalEvt: evt
            }); // Modifier activated, select from last to dragEl

            if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
              var lastIndex = index(lastMultiDragSelect),
                  currentIndex = index(dragEl$1);

              if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
                // Must include lastMultiDragSelect (select it), in case modified selection from no selection
                // (but previous selection existed)
                var n, i;

                if (currentIndex > lastIndex) {
                  i = lastIndex;
                  n = currentIndex;
                } else {
                  i = currentIndex;
                  n = lastIndex + 1;
                }

                for (; i < n; i++) {
                  if (~multiDragElements.indexOf(children[i])) continue;
                  toggleClass(children[i], options.selectedClass, true);
                  multiDragElements.push(children[i]);
                  dispatchEvent({
                    sortable: sortable,
                    rootEl: rootEl,
                    name: 'select',
                    targetEl: children[i],
                    originalEvt: evt
                  });
                }
              }
            } else {
              lastMultiDragSelect = dragEl$1;
            }

            multiDragSortable = toSortable;
          } else {
            multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
            lastMultiDragSelect = null;
            dispatchEvent({
              sortable: sortable,
              rootEl: rootEl,
              name: 'deselect',
              targetEl: dragEl$1,
              originalEvt: evt
            });
          }
        } // Multi-drag drop


        if (dragStarted && this.isMultiDrag) {
          // Do not "unfold" after around dragEl if reverted
          if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
            var dragRect = getRect(dragEl$1),
                multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
            if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
            toSortable.captureAnimationState();

            if (!initialFolding) {
              if (options.animation) {
                dragEl$1.fromRect = dragRect;
                multiDragElements.forEach(function (multiDragElement) {
                  multiDragElement.thisAnimationDuration = null;

                  if (multiDragElement !== dragEl$1) {
                    var rect = folding ? getRect(multiDragElement) : dragRect;
                    multiDragElement.fromRect = rect; // Prepare unfold animation

                    toSortable.addAnimationState({
                      target: multiDragElement,
                      rect: rect
                    });
                  }
                });
              } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
              // properly they must all be removed


              removeMultiDragElements();
              multiDragElements.forEach(function (multiDragElement) {
                if (children[multiDragIndex]) {
                  parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
                } else {
                  parentEl.appendChild(multiDragElement);
                }

                multiDragIndex++;
              }); // If initial folding is done, the elements may have changed position because they are now
              // unfolding around dragEl, even though dragEl may not have his index changed, so update event
              // must be fired here as Sortable will not.

              if (oldIndex === index(dragEl$1)) {
                var update = false;
                multiDragElements.forEach(function (multiDragElement) {
                  if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                    update = true;
                    return;
                  }
                });

                if (update) {
                  dispatchSortableEvent('update');
                }
              }
            } // Must be done after capturing individual rects (scroll bar)


            multiDragElements.forEach(function (multiDragElement) {
              unsetRect(multiDragElement);
            });
            toSortable.animateAll();
          }

          multiDragSortable = toSortable;
        } // Remove clones if necessary


        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
          multiDragClones.forEach(function (clone) {
            clone.parentNode && clone.parentNode.removeChild(clone);
          });
        }
      },
      nullingGlobal: function nullingGlobal() {
        this.isMultiDrag = dragStarted = false;
        multiDragClones.length = 0;
      },
      destroyGlobal: function destroyGlobal() {
        this._deselectMultiDrag();

        off(document, 'pointerup', this._deselectMultiDrag);
        off(document, 'mouseup', this._deselectMultiDrag);
        off(document, 'touchend', this._deselectMultiDrag);
        off(document, 'keydown', this._checkKeyDown);
        off(document, 'keyup', this._checkKeyUp);
      },
      _deselectMultiDrag: function _deselectMultiDrag(evt) {
        if (dragStarted) return; // Only deselect if selection is in this sortable

        if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable

        if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click

        if (evt && evt.button !== 0) return;

        while (multiDragElements.length) {
          var el = multiDragElements[0];
          toggleClass(el, this.options.selectedClass, false);
          multiDragElements.shift();
          dispatchEvent({
            sortable: this.sortable,
            rootEl: this.sortable.el,
            name: 'deselect',
            targetEl: el,
            originalEvt: evt
          });
        }
      },
      _checkKeyDown: function _checkKeyDown(evt) {
        if (evt.key === this.options.multiDragKey) {
          this.multiDragKeyDown = true;
        }
      },
      _checkKeyUp: function _checkKeyUp(evt) {
        if (evt.key === this.options.multiDragKey) {
          this.multiDragKeyDown = false;
        }
      }
    };
    return _extends(MultiDrag, {
      // Static methods & properties
      pluginName: 'multiDrag',
      utils: {
        /**
         * Selects the provided multi-drag item
         * @param  {HTMLElement} el    The element to be selected
         */
        select: function select(el) {
          var sortable = el.parentNode[expando];
          if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;

          if (multiDragSortable && multiDragSortable !== sortable) {
            multiDragSortable.multiDrag._deselectMultiDrag();

            multiDragSortable = sortable;
          }

          toggleClass(el, sortable.options.selectedClass, true);
          multiDragElements.push(el);
        },

        /**
         * Deselects the provided multi-drag item
         * @param  {HTMLElement} el    The element to be deselected
         */
        deselect: function deselect(el) {
          var sortable = el.parentNode[expando],
              index = multiDragElements.indexOf(el);
          if (!sortable || !sortable.options.multiDrag || !~index) return;
          toggleClass(el, sortable.options.selectedClass, false);
          multiDragElements.splice(index, 1);
        }
      },
      eventProperties: function eventProperties() {
        var _this3 = this;

        var oldIndicies = [],
            newIndicies = [];
        multiDragElements.forEach(function (multiDragElement) {
          oldIndicies.push({
            multiDragElement: multiDragElement,
            index: multiDragElement.sortableIndex
          }); // multiDragElements will already be sorted if folding

          var newIndex;

          if (folding && multiDragElement !== dragEl$1) {
            newIndex = -1;
          } else if (folding) {
            newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
          } else {
            newIndex = index(multiDragElement);
          }

          newIndicies.push({
            multiDragElement: multiDragElement,
            index: newIndex
          });
        });
        return {
          items: _toConsumableArray(multiDragElements),
          clones: [].concat(multiDragClones),
          oldIndicies: oldIndicies,
          newIndicies: newIndicies
        };
      },
      optionListeners: {
        multiDragKey: function multiDragKey(key) {
          key = key.toLowerCase();

          if (key === 'ctrl') {
            key = 'Control';
          } else if (key.length > 1) {
            key = key.charAt(0).toUpperCase() + key.substr(1);
          }

          return key;
        }
      }
    });
  }

  function insertMultiDragElements(clonesInserted, rootEl) {
    multiDragElements.forEach(function (multiDragElement, i) {
      var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];

      if (target) {
        rootEl.insertBefore(multiDragElement, target);
      } else {
        rootEl.appendChild(multiDragElement);
      }
    });
  }
  /**
   * Insert multi-drag clones
   * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
   * @param  {HTMLElement} rootEl
   */


  function insertMultiDragClones(elementsInserted, rootEl) {
    multiDragClones.forEach(function (clone, i) {
      var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];

      if (target) {
        rootEl.insertBefore(clone, target);
      } else {
        rootEl.appendChild(clone);
      }
    });
  }

  function removeMultiDragElements() {
    multiDragElements.forEach(function (multiDragElement) {
      if (multiDragElement === dragEl$1) return;
      multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
    });
  }

  Sortable.mount(new AutoScrollPlugin());
  Sortable.mount(Remove, Revert);

  Sortable.mount(new SwapPlugin());
  Sortable.mount(new MultiDragPlugin());

  return Sortable;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'Sortable', 'VueUtil'], definition);
  } else {
    context.VueSortable = definition(context.Vue, context.Sortable, context.VueUtil);
    delete context.VueSortable;
    // delete context.Sortable;
  }
})(this, function(Vue, Sortable, VueUtil) {
  'use strict';
  var toConsumableArray = function(arr) {
    if (VueUtil.isArray(arr)) {
      return arr;
    } else {
      var arrayfrom = function(arr) {
        var from = function(arrayLike) {
          if (!VueUtil.isDef(arrayLike)) return [];
          var items = Object(arrayLike);
          var mapFn = arguments.length > 1 ? arguments[1] : null;
          var T = null;
          if (VueUtil.isDef(mapFn)) {
            if (!VueUtil.isFunction(mapFn)) return [];
            if (arguments.length > 2) {
              T = arguments[2];
            }
          }
          var toLength = function(value) {
            var toInteger = function(value) {
              var number = Number(value);
              if (isNaN(number)) return 0;
              if (number === 0 || !isFinite(number)) return number;
              return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
            };
            var maxSafeInteger = Math.pow(2, 53) - 1;
            var len = toInteger(value);
            return Math.min(Math.max(len, 0), maxSafeInteger);
          };
          var len = toLength(items.length);
          var A = [];
          var k = 0;
          var kValue = null;
          while (k < len) {
            kValue = items[k];
            if (mapFn) {
              A.push(!VueUtil.isDef(T) ? mapFn(kValue, k) : mapFn.call(T, kValue, k));
            } else {
              A.push(kValue);
            }
            k += 1;
          }
          return A;
        };
        return from(arr);
      };
      return arrayfrom(arr);
    }
  };
  var emit = function(evtName, evtData) {
    var self = this;
    self.$nextTick(function() {
      self.$emit(evtName.toLowerCase(), evtData);
    });
  };
  var delegateAndEmit = function(evtName) {
    var self = this;
    return function(evtData) {
      if (self.realList !== null) {
        self['onDrag' + evtName](evtData);
      }
      emit.call(self, evtName, evtData);
    };
  };
  var eventsListened = ['Start', 'Add', 'Remove', 'Update', 'End'];
  var eventsToEmit = ['Choose', 'Sort', 'Filter', 'Clone'];
  var draggingElement = null;
  var VueSortable = {
    name: 'VueSortable',
    props: {
      options: Object,
      value: {
        type: Array,
        default: null
      },
      clone: {
        type: Function,
        default: function(original) {
          return original;
        }
      },
      element: {
        type: String,
        default: 'div'
      },
      move: {
        type: Function,
        default: null
      }
    },
    data: function() {
      return {
        componentMode: false
      };
    },
    render: function(createElement) {
      return createElement(this.element, null, this.$slots.default);
    },
    mounted: function() {
      var self = this;
      self.componentMode = self.element.toLowerCase() !== self.$el.nodeName.toLowerCase();
      var optionsAdded = {};
      VueUtil.loop(eventsListened, function(elt) {
        optionsAdded['on' + elt] = delegateAndEmit.call(self, elt);
      });
      VueUtil.loop(eventsToEmit, function(elt) {
        optionsAdded['on' + elt] = emit.bind(self, elt);
      });
      var options = VueUtil.merge({}, self.options, optionsAdded, {
        onMove: function(evt, originalEvent) {
          return self.onDragMove(evt, originalEvent);
        }
      });
      !VueUtil.isDef(options.draggable) && (options.draggable = '>*');
      self._sortable = new Sortable(self.rootContainer, options);
      self.computeIndexes();
    },
    beforeDestroy: function() {
      this._sortable.destroy();
    },
    computed: {
      rootContainer: function() {
        return this.$el;
      },
      isCloning: function() {
        return !!this.options && !!this.options.group && this.options.group.pull === 'clone';
      },
      realList: function() {
        return this.value;
      }
    },
    watch: {
      options: {
        handler: function(newOptionValue) {
          var readonlyProperties = VueUtil.map(VueUtil.mergeArray(['Move'], eventsListened, eventsToEmit), function(evt) {
            return 'on' + evt;
          });
          var sortable = this._sortable;
          VueUtil.ownPropertyLoop(newOptionValue, function(property) {
            if (readonlyProperties.indexOf(property) === -1) {
              sortable.option(property, newOptionValue[property]);
            }
          });
        },
        deep: true
      },
      realList: function() {
        this.computeIndexes();
      }
    },
    methods: {
      getChildrenNodes: function() {
        if (this.componentMode) {
          return this.$children[0].$slots.default;
        }
        return this.$slots.default;
      },
      computeIndexes: function() {
        var computeIndexes = function(slots, children) {
          if (!VueUtil.isArray(slots)) return [];
          var elmFromNodes = VueUtil.map(slots, function(elt) {
            return elt.elm;
          });
          var rawIndexes = VueUtil.map(VueUtil.mergeArray([], toConsumableArray(children)), function(elt) {
            return elmFromNodes.indexOf(elt);
          });
          return VueUtil.filter(rawIndexes, function(index) {
            return index !== -1;
          });
        };
        var self = this;
        self.$nextTick(function() {
          self.visibleIndexes = computeIndexes(self.getChildrenNodes(), self.rootContainer.children);
        });
      },
      getUnderlyingVm: function(htmlElt) {
        var computeVmIndex = function(vnodes, element) {
          if (VueUtil.isArray(vnodes)) {
            return VueUtil.map(vnodes, function(elt) {
              return elt.elm;
            }).indexOf(element);
          } else {
            return -1;
          }
        };
        var index = computeVmIndex(this.getChildrenNodes(), htmlElt);
        if (index === -1)
          return null;
        var element = this.realList[index];
        return {
          index: index,
          element: element
        };
      },
      getUnderlyingPotencialDraggableComponent: function(ref) {
        return ref.__vue__;
      },
      emitChanges: function(evt) {
        var self = this;
        self.$nextTick(function() {
          self.$emit('change', evt);
        });
      },
      alterList: function(onList) {
        var newList = VueUtil.mergeArray([], toConsumableArray(this.value));
        onList(newList);
        this.$emit('input', newList);
      },
      spliceList: function() {
        var _arguments = arguments;
        var spliceList = function(list) {
          return list.splice.apply(list, _arguments);
        };
        this.alterList(spliceList);
      },
      updatePosition: function(oldIndex, newIndex) {
        var updatePosition = function(list) {
          return list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
        };
        this.alterList(updatePosition);
      },
      getRelatedContextFromMoveEvent: function(ref) {
        var to = ref.to;
        var related = ref.related;
        var component = this.getUnderlyingPotencialDraggableComponent(to);
        if (!component) {
          return {
            component: component
          };
        }
        var list = component.realList;
        var context = {
          list: list,
          component: component
        };
        if (to !== related && list && component.getUnderlyingVm) {
          var destination = component.getUnderlyingVm(related);
          if (destination) {
            return VueUtil.merge(destination, context);
          }
        }
        return context;
      },
      getVmIndex: function(domIndex) {
        var indexes = this.visibleIndexes;
        var numberIndexes = indexes.length;
        return (domIndex > numberIndexes - 1) ? numberIndexes : indexes[domIndex];
      },
      getComponent: function() {
        return this.$slots.default[0].componentInstance;
      },
      onDragStart: function(evt) {
        this.context = this.getUnderlyingVm(evt.item);
        evt.item._underlying_vm_ = this.context.element;
        draggingElement = evt.item;
      },
      onDragAdd: function(evt) {
        var element = evt.item._underlying_vm_;
        if (this.isCloning) {
          element = this.clone(evt.item._underlying_vm_);
        }
        if (!VueUtil.isDef(element)) return;
        VueUtil.removeNode(evt.item);
        var newIndex = this.getVmIndex(evt.newIndex);
        this.spliceList(newIndex, 0, element);
        this.computeIndexes();
        var added = {
          element: element,
          newIndex: newIndex
        };
        this.emitChanges({
          added: added
        });
      },
      onDragRemove: function(evt) {
        VueUtil.insertNodeAt(this.rootContainer, evt.item, evt.oldIndex);
        if (this.isCloning) {
          VueUtil.removeNode(evt.clone);
          return;
        }
        var oldIndex = this.context.index;
        this.spliceList(oldIndex, 1);
        var removed = {
          element: this.context.element,
          oldIndex: oldIndex
        };
        this.emitChanges({
          removed: removed
        });
      },
      onDragUpdate: function(evt) {
        var oldIndex = this.context.index;
        var newIndex = this.getVmIndex(evt.newIndex);
        VueUtil.removeNode(evt.item);
        VueUtil.insertNodeAt(evt.from, evt.item, evt.oldIndex);
        this.updatePosition(oldIndex, newIndex);
        var moved = {
          element: this.context.element,
          oldIndex: oldIndex,
          newIndex: newIndex
        };
        this.emitChanges({
          moved: moved
        });
      },
      computeFutureIndex: function(relatedContext, evt) {
        if (!relatedContext.element) {
          return 0;
        }
        var domChildren = VueUtil.filter(VueUtil.mergeArray([], toConsumableArray(evt.to.children)), function(el) {
          return el.style['display'] !== 'none';
        });
        var currentDOMIndex = domChildren.indexOf(evt.related);
        var currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
        var draggedInList = domChildren.indexOf(draggingElement) != -1;
        return (draggedInList || !evt.willInsertAfter) ? currentIndex : currentIndex + 1;
      },
      onDragMove: function(evt) {
        var onMove = this.move;
        if (!onMove || !this.realList) {
          return true;
        }
        var relatedContext = this.getRelatedContextFromMoveEvent(evt);
        var draggedContext = this.context;
        var futureIndex = this.computeFutureIndex(relatedContext, evt);
        VueUtil.merge(draggedContext, {futureIndex: futureIndex});
        VueUtil.merge(evt, {relatedContext: relatedContext, draggedContext: draggedContext});
        return onMove(evt);
      },
      onDragEnd: function(evt) {
        this.computeIndexes();
        draggingElement = null;
      }
    }
  };
  Vue.component(VueSortable.name, VueSortable);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VuePopup = definition(context.Vue, context.VueUtil);
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var PopupManager = VueUtil.component.popupManager;
  VueUtil.on(document, 'keydown', function(event) {
    if (event.keyCode === 27) {
      if (PopupManager.modalStack.length > 0) {
        var topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
        if (!topItem) return;
        var instance = PopupManager.getInstance(topItem.id);
        if (instance.closeOnPressEscape) {
          instance.$emit('visible-change', false);
        }
      }
    }
  });
  var idSeed = 1;
  var VuePopup = {};
  VuePopup.model = {
    prop: 'visible',
    event: 'visible-change'
  };
  VuePopup.props = {
    visible: Boolean,
    openDelay: {},
    closeDelay: {},
    zIndex: {},
    closeOnPressEscape: {
      type: Boolean,
      default: true
    }
  };
  VuePopup.beforeMount = function() {
    this._popupId = 'popup-' + idSeed++;
    PopupManager.register(this._popupId, this);
  };
  VuePopup.beforeDestroy = function() {
    PopupManager.deregister(this._popupId);
    PopupManager.closeModal(this._popupId);
  };
  VuePopup.data = function() {
    return {
      opened: false
    };
  };
  VuePopup.watch = {
    visible: function(val) {
      var getDOM = function(dom) {
        if (dom.nodeType === 3) {
          dom = dom.nextElementSibling || dom.nextSibling;
          getDOM(dom);
        }
        return dom;
      };
      var self = this;
      if (val) {
        if (!self.opened) {
          self.$nextTick(function() {
            var dom = getDOM(self.$el);
            if (VueUtil.getStyle(dom, 'position') === 'static') {
              VueUtil.setStyle(dom, 'position', 'absolute');
            }
            dom.style.zIndex = PopupManager.nextZIndex();
            if (self.closeOnPressEscape)
              PopupManager.openModal(self._popupId, dom.style.zIndex);
          });
        }
      } else {
        PopupManager.closeModal(self._popupId);
        self.$nextTick(function() {
          if (self.opened && self.closeOnPressEscape) {
            var dom = getDOM(self.$el);
            PopupManager.openModal(self._popupId, dom.style.zIndex);
          }
        });
      }
    }
  };
  return VuePopup;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VuePopper = definition(context.Vue, context.VueUtil);
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var getOuterSizes = function(element) {
    var _display = element.style.display;
    var _visibility = element.style.visibility;
    element.style.visibility = 'hidden';
    element.style.display = 'block';
    var calcWidthToForceRepaint = element.offsetWidth;
    var styles = getComputedStyle(element);
    var x = element.offsetHeight + parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
    var y = element.offsetWidth + parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
    var result = {
      width: y,
      height: x
    };
    element.style.display = _display;
    element.style.visibility = _visibility;
    return result;
  };
  var getPopperClientRect = function(popperOffsets) {
    var offsets = VueUtil.merge({}, popperOffsets);
    offsets.right = offsets.left + offsets.width;
    offsets.bottom = offsets.top + offsets.height;
    return offsets;
  };
  var getArrayKeyIndex = function(arr, keyToFind) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === keyToFind) {
        return i;
      }
    }
    return null;
  };
  var getOffsetParent = function(element) {
    var offsetParent = element.offsetParent;
    return offsetParent === document.body || !offsetParent ? document.documentElement : offsetParent;
  };
  var setStyle = function(element, styles) {
    function is_numeric(n) {
      return (n !== '' && !isNaN(parseFloat(n)) && isFinite(n));
    }
    VueUtil.ownPropertyLoop(styles, function(prop) {
      var unit = '';
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  };
  var Popper = function(reference, popper, options) {
    var DEFAULTS = {
      placement: 'bottom',
      gpuAcceleration: true,
      offset: 0,
      boundariesElement: 'viewport',
      boundariesPadding: 5,
      preventOverflowOrder: ['left', 'right', 'top', 'bottom'],
      flipBehavior: 'flip',
      arrowElement: '[x-arrow]',
      modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],
      modifiersIgnored: [],
      forceAbsolute: false,
      removeOnDestroy: true
    };
    this._reference = reference.jquery ? reference[0] : reference;
    this.state = {};
    var isNotDefined = !VueUtil.isDef(popper);
    var isConfig = VueUtil.isObject(popper);
    if (isNotDefined || isConfig) {
      this._popper = this.parse(isConfig ? popper : {});
    } else {
      this._popper = popper.jquery ? popper[0] : popper;
    }
    this._options = VueUtil.merge({}, DEFAULTS, options);
    this._options.modifiers = VueUtil.map(this._options.modifiers, function(modifier) {
      if (this._options.modifiersIgnored.indexOf(modifier) !== -1)
        return;
      if (modifier === 'applyStyle') {
        this._popper.setAttribute('x-placement', this._options.placement);
      }
      return this.modifiers[modifier] || modifier;
    }.bind(this));
    this.state.position = this._getPosition(this._popper, this._reference);
    setStyle(this._popper, {
      position: this.state.position,
      top: 0
    });
    this._setupEventListeners();
    return this;
  };
  Popper.prototype.destroy = function() {
    this._popper.removeAttribute('x-placement');
    this._popper.style.left = '';
    this._popper.style.position = '';
    this._popper.style.top = '';
    this._popper.style.transform = '';
    this._removeEventListeners();
    if (this._options.removeOnDestroy) {
      VueUtil.removeNode(this._popper);
    }
    return this;
  };
  Popper.prototype.update = function() {
    var data = {
      instance: this,
      styles: {}
    };
    data.placement = this._options.placement;
    data._originalPlacement = this._options.placement;
    this._options.autoWidth && setStyle(this._popper, {'width': this._reference.offsetWidth});
    data.offsets = this._getOffsets(this._popper, this._reference, data.placement);
    data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);
    data = this.runModifiers(data, this._options.modifiers);
    if (VueUtil.isFunction(this.state.updateCallback)) {
      this.state.updateCallback(data);
    }
  };
  Popper.prototype.onCreate = function(callback) {
    callback(this);
    return this;
  };
  Popper.prototype.onUpdate = function(callback) {
    this.state.updateCallback = callback;
    return this;
  };
  Popper.prototype.parse = function(config) {
    var defaultConfig = {
      tagName: 'div',
      classNames: ['popper'],
      attributes: [],
      parent: document.body,
      content: '',
      contentType: 'text',
      arrowTagName: 'div',
      arrowClassNames: ['popper__arrow'],
      arrowAttributes: ['x-arrow']
    };
    config = VueUtil.merge({}, defaultConfig, config);
    var d = document;
    var popper = d.createElement(config.tagName);
    addClassNames(popper, config.classNames);
    addAttributes(popper, config.attributes);
    if (config.contentType === 'node') {
      popper.appendChild(config.content.jquery ? config.content[0] : config.content);
    } else if (config.contentType === 'html') {
      popper.innerHTML = config.content;
    } else {
      popper.textContent = config.content;
    }
    if (config.arrowTagName) {
      var arrow = d.createElement(config.arrowTagName);
      addClassNames(arrow, config.arrowClassNames);
      addAttributes(arrow, config.arrowAttributes);
      popper.appendChild(arrow);
    }
    var parent = config.parent.jquery ? config.parent[0] : config.parent;
    if (VueUtil.isString(parent)) {
      parent = d.querySelector(config.parent);
      if (!VueUtil.isDef(parent)) {
        throw 'ERROR: the given \'parent\' doesn\'t exists!';
      }
    }
    if (VueUtil.isNodeList(parent)) {
      parent = parent[0];
    }
    parent.appendChild(popper);
    return popper;
    function addClassNames(element, classNames) {
      VueUtil.loop(classNames, function(className) {
        element.classList.add(className);
      });
    }
    function addAttributes(element, attributes) {
      VueUtil.loop(attributes, function(attribute) {
        element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');
      });
    }
  };
  Popper.prototype._getPosition = function(popper, reference) {
    if (this._options.forceAbsolute) {
      return 'absolute';
    }
    var isFixed = function(element) {
      if (element === document.body) return false;
      var elementPosition = VueUtil.getStyle(element, 'position');
      if (elementPosition === 'fixed' || elementPosition === 'relative') return true;
      return element.parentNode ? isFixed(element.parentNode) : element;
    };
    var isParentFixed = isFixed(reference);
    return isParentFixed ? 'fixed' : 'absolute';
  };
  Popper.prototype._getOffsets = function(popper, reference, placement) {
    placement = placement.split('-')[0];
    var popperOffsets = {};
    popperOffsets.position = this.state.position;
    var getBoundingClientRect = function(element) {
      var rect = element.getBoundingClientRect();
      var isIE = navigator.userAgent.indexOf('MSIE') != -1;
      var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;
      return {
        left: rect.left,
        top: rectTop,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.right - rect.left,
        height: rect.bottom - rectTop
      };
    };
    var getOffsetRectRelativeToCustomParent = function(element, parent, fixed) {
      var elementRect = getBoundingClientRect(element);
      var parentRect = getBoundingClientRect(parent);
      if (fixed) {
        var scrollParent = VueUtil.component.getScrollParent(parent);
        parentRect.top += scrollParent.scrollTop;
        parentRect.bottom += scrollParent.scrollTop;
        parentRect.left += scrollParent.scrollLeft;
        parentRect.right += scrollParent.scrollLeft;
      }
      var rect = {
        top: elementRect.top - parentRect.top,
        left: elementRect.left - parentRect.left,
        bottom: (elementRect.top - parentRect.top) + elementRect.height,
        right: (elementRect.left - parentRect.left) + elementRect.width,
        width: elementRect.width,
        height: elementRect.height
      };
      return rect;
    };
    var isParentFixed = popperOffsets.position === 'fixed';
    var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed);
    var popperRect = getOuterSizes(popper);
    if (['right', 'left'].indexOf(placement) !== -1) {
      popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;
      if (placement === 'left') {
        popperOffsets.left = referenceOffsets.left - popperRect.width;
      } else {
        popperOffsets.left = referenceOffsets.right;
      }
    } else {
      popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;
      if (placement === 'top') {
        popperOffsets.top = referenceOffsets.top - popperRect.height;
      } else {
        popperOffsets.top = referenceOffsets.bottom;
      }
    }
    popperOffsets.width = popperRect.width;
    popperOffsets.height = popperRect.height;
    return {
      popper: popperOffsets,
      reference: referenceOffsets
    };
  };
  Popper.prototype._setupEventListeners = function() {
    this.state.updateBound = this.update.bind(this);
    VueUtil.addResizeListener(this.state.updateBound);
    if (this._options.boundariesElement !== 'window') {
      var target = VueUtil.component.getScrollParent(this._reference);
      if (target === document.body || target === document.documentElement) {
        target = document;
      }
      VueUtil.on(target, 'scroll', this.state.updateBound);
    }
  };
  Popper.prototype._removeEventListeners = function() {
    VueUtil.removeResizeListener(this.state.updateBound);
    if (this._options.boundariesElement !== 'window') {
      var target = VueUtil.component.getScrollParent(this._reference);
      if (target === document.body || target === document.documentElement) {
        target = document;
      }
      VueUtil.off(target, 'scroll', this.state.updateBound);
    }
    this.state.updateBound = null;
  };
  Popper.prototype._getBoundaries = function(data, padding, boundariesElement) {
    var getOffsetRect = function(element) {
      var elementRect = {
        width: element.offsetWidth,
        height: element.offsetHeight,
        left: element.offsetLeft,
        top: element.offsetTop
      };
      elementRect.right = elementRect.left + elementRect.width;
      elementRect.bottom = elementRect.top + elementRect.height;
      return elementRect;
    };
    var boundaries = {};
    var width, height;
    if (boundariesElement === 'window') {
      var body = document.body;
      var html = document.documentElement;
      height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
      width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
      boundaries = {
        top: 0,
        right: width,
        bottom: height,
        left: 0
      };
    } else if (boundariesElement === 'viewport') {
      var offsetParent = getOffsetParent(this._popper);
      var scrollParent = VueUtil.component.getScrollParent(this._popper);
      var offsetParentRect = getOffsetRect(offsetParent);
      var getScrollTopValue = function(element) {
        return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;
      };
      var getScrollLeftValue = function(element) {
        return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;
      };
      var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);
      var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);
      boundaries = {
        top: 0 - (offsetParentRect.top - scrollTop),
        right: document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),
        bottom: document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),
        left: 0 - (offsetParentRect.left - scrollLeft)
      };
    } else {
      if (getOffsetParent(this._popper) === boundariesElement) {
        boundaries = {
          top: 0,
          left: 0,
          right: boundariesElement.clientWidth,
          bottom: boundariesElement.clientHeight
        };
      } else {
        boundaries = getOffsetRect(boundariesElement);
      }
    }
    boundaries.left += padding;
    boundaries.right -= padding;
    boundaries.top = boundaries.top + padding;
    boundaries.bottom = boundaries.bottom - padding;
    return boundaries;
  };
  Popper.prototype.runModifiers = function(data, modifiers, ends) {
    var modifiersToRun = VueUtil.mergeArray([], modifiers);
    if (VueUtil.isDef(ends)) {
      modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));
    }
    VueUtil.loop(modifiersToRun, function(modifier) {
      if (VueUtil.isFunction(modifier)) {
        data = modifier.call(this, data);
      }
    }
      .bind(this));
    return data;
  };
  Popper.prototype.isModifierRequired = function(requesting, requested) {
    var index = getArrayKeyIndex(this._options.modifiers, requesting);
    return !!VueUtil.filter(this._options.modifiers.slice(0, index), function(modifier) {
      return modifier === requested;
    }).length;
  };
  Popper.prototype.modifiers = {};
  Popper.prototype.modifiers.applyStyle = function(data) {
    var styles = {
      position: data.offsets.popper.position
    };
    var left = Math.round(data.offsets.popper.left);
    var top = Math.round(data.offsets.popper.top);
    var prefixedProperty;
    if (this._options.gpuAcceleration && (prefixedProperty = 'transform')) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles.top = 0;
      styles.left = 0;
    } else {
      styles.left = left;
      styles.top = top;
    }
    VueUtil.merge(styles, data.styles);
    setStyle(this._popper, styles);
    this._popper.setAttribute('x-placement', data.placement);
    if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {
      setStyle(data.arrowElement, data.offsets.arrow);
    }
    return data;
  };
  Popper.prototype.modifiers.shift = function(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftVariation = placement.split('-')[1];
    if (shiftVariation) {
      var reference = data.offsets.reference;
      var popper = getPopperClientRect(data.offsets.popper);
      var shiftOffsets = {
        y: {
          start: {
            top: reference.top
          },
          end: {
            top: reference.top + reference.height - popper.height
          }
        },
        x: {
          start: {
            left: reference.left
          },
          end: {
            left: reference.left + reference.width - popper.width
          }
        }
      };
      var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';
      data.offsets.popper = VueUtil.merge(popper, shiftOffsets[axis][shiftVariation]);
    }
    return data;
  };
  Popper.prototype.modifiers.preventOverflow = function(data) {
    var order = this._options.preventOverflowOrder;
    var popper = getPopperClientRect(data.offsets.popper);
    var check = {
      left: function() {
        var left = popper.left;
        if (popper.left < data.boundaries.left) {
          left = Math.max(popper.left, data.boundaries.left);
        }
        return {
          left: left
        };
      },
      right: function() {
        var left = popper.left;
        if (popper.right > data.boundaries.right) {
          left = Math.min(popper.left, data.boundaries.right - popper.width);
        }
        return {
          left: left
        };
      },
      top: function() {
        var top = popper.top;
        if (popper.top < data.boundaries.top) {
          top = Math.max(popper.top, data.boundaries.top);
        }
        return {
          top: top
        };
      },
      bottom: function() {
        var top = popper.top;
        if (popper.bottom > data.boundaries.bottom) {
          top = Math.min(popper.top, data.boundaries.bottom - popper.height);
        }
        return {
          top: top
        };
      }
    };
    VueUtil.loop(order, function(direction) {
      data.offsets.popper = VueUtil.merge(popper, check[direction]());
    });
    return data;
  };
  Popper.prototype.modifiers.keepTogether = function(data) {
    var popper = getPopperClientRect(data.offsets.popper);
    var reference = data.offsets.reference;
    var f = Math.floor;
    if (popper.right < f(reference.left)) {
      data.offsets.popper.left = f(reference.left) - popper.width;
    }
    if (popper.left > f(reference.right)) {
      data.offsets.popper.left = f(reference.right);
    }
    if (popper.bottom < f(reference.top)) {
      data.offsets.popper.top = f(reference.top) - popper.height;
    }
    if (popper.top > f(reference.bottom)) {
      data.offsets.popper.top = f(reference.bottom);
    }
    return data;
  };
  Popper.prototype.modifiers.flip = function(data) {
    if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {
      return data;
    }
    if (data.flipped && data.placement === data._originalPlacement) {
      return data;
    }
    var getOppositePlacement = function(placement) {
      var hash = {
        left: 'right',
        right: 'left',
        bottom: 'top',
        top: 'bottom'
      };
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash[matched];
      });
    };
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];
    if (this._options.flipBehavior === 'flip') {
      flipOrder = [placement, placementOpposite];
    } else {
      flipOrder = this._options.flipBehavior;
    }
    VueUtil.loop(flipOrder, function(step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return;
      }
      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = getPopperClientRect(data.offsets.popper);
      var a = ['right', 'bottom'].indexOf(placement) !== -1;
      if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {
        data.flipped = true;
        data.placement = flipOrder[index + 1];
        if (variation) {
          data.placement += '-' + variation;
        }
        data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;
        data = this.runModifiers(data, this._options.modifiers, this._flip);
      }
    }.bind(this));
    return data;
  };
  Popper.prototype.modifiers.offset = function(data) {
    var offset = this._options.offset;
    var popper = data.offsets.popper;
    if (data.placement.indexOf('left') !== -1) {
      popper.top -= offset;
    } else if (data.placement.indexOf('right') !== -1) {
      popper.top += offset;
    } else if (data.placement.indexOf('top') !== -1) {
      popper.left -= offset;
    } else if (data.placement.indexOf('bottom') !== -1) {
      popper.left += offset;
    }
    return data;
  };
  Popper.prototype.modifiers.arrow = function(data) {
    var arrow = this._options.arrowElement;
    if (VueUtil.isString(arrow)) {
      arrow = this._popper.querySelector(arrow);
    }
    if (!arrow || !this._popper.contains(arrow) || !this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {
      return data;
    }
    var arrowStyle = {};
    var placement = data.placement.split('-')[0];
    var popper = getPopperClientRect(data.offsets.popper);
    var reference = data.offsets.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var side = isVertical ? 'top' : 'left';
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowSize = getOuterSizes(arrow)[len];
    if (reference[opSide] - arrowSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
    }
    if (reference[side] + arrowSize > popper[opSide]) {
      data.offsets.popper[side] += (reference[side] + arrowSize) - popper[opSide];
    }
    var center = reference[side] + (reference[len] / 2) - (arrowSize / 2);
    var sideValue = center - popper[side];
    sideValue = Math.max(Math.min(popper[len] - arrowSize - 3, sideValue), 0);
    arrowStyle[side] = sideValue;
    arrowStyle[altSide] = '';
    data.offsets.arrow = arrowStyle;
    data.arrowElement = arrow;
    return data;
  };
  var VuePopper = {
    props: {
      placement: {
        type: String,
        default: 'bottom'
      },
      reference: {},
      popper: {},
      offset: {
        default: 0
      },
      value: Boolean,
      visibleArrow: Boolean,
      autoWidth: Boolean,
      transition: String,
      append: {},
      popperOptions: {
        type: Object,
        default: function() {
          return {
            boundariesPadding: 5,
            gpuAcceleration: false
          };
        }
      },
      appendToDirectParent: Boolean  //append to referenceElm's direct parentNode
    },
    data: function() {
      return {
        showPopper: false
      };
    },
    watch: {
      value: {
        immediate: true,
        handler: function(val) {
          this.showPopper = val;
        }
      },
      showPopper: function(val) {
        if (val) this.$nextTick(this.updatePopper);
        this.$emit('input', val);
      }
    },
    methods: {
      stop: function(e) {
        e.stopPropagation();
      },
      findeAbsoluteParent: function(element) {
        if (element === document.body) return;
        var elementPosition = VueUtil.getStyle(element, 'position');
        if (elementPosition === 'absolute' && element.parentNode) this.appendElement = element.parentNode;
        this.findeAbsoluteParent(element.parentNode);
      },
      createPopper: function() {
        var self = this;
        self.currentPlacement = self.currentPlacement || self.placement;
        if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(self.currentPlacement)) return;
        var options = self.popperOptions || {};
        var popper = self.popperElm = self.popperElm || self.popper || self.$refs.popper;
        var reference = self.referenceElm = self.referenceElm || self.reference || self.$refs.reference;
        if (!reference && self.$slots.reference && self.$slots.reference[0]) reference = self.referenceElm = self.$slots.reference[0].elm;
        if (!popper || !reference) return;
        if (self.visibleArrow) self.appendArrow(popper);
        if (VueUtil.isElement(self.append)) {
          self.appendElement = self.append;
        } else if(self.appendToDirectParent) {
          self.appendElement = self.referenceElm.parentNode;
        }else {
          self.appendElement = self.referenceElm.parentNode;
          self.findeAbsoluteParent(self.referenceElm);
        }
        self.appendElement.appendChild(self.popperElm);
        self.popperElm.style.visibility = 'hidden';
        if (self.popperJS && self.popperJS.destroy) self.popperJS.destroy();
        options.placement = self.currentPlacement;
        options.offset = self.offset;
        options.autoWidth = self.autoWidth;
        self.popperJS = new Popper(reference, popper, options);
        self.popperJS.onCreate(function() {
          self.$emit('created', self);
          self.resetTransformOrigin();
          self.$nextTick(function() {
            self.updatePopper();
            self.popperElm.style.visibility = '';
          });
        });
        if (VueUtil.isFunction(options.onUpdate)) {
          self.popperJS.onUpdate(options.onUpdate);
        }
        self.popperJS._popper.style.zIndex = VueUtil.nextZIndex();
        !VueUtil.isIE && VueUtil.on(self.popperElm, 'click', self.stop);
        self.popperJS._popper.editor = self;
      },
      updatePopper: function() {
        this.popperJS ? this.popperJS.update() : this.createPopper();
      },
      destroyPopper: function() {
        if (this.showPopper || !this.popperJS) return;
        this.popperJS.destroy();
        this.popperJS = null;
      },
      resetTransformOrigin: function() {
        var placementMap = {
          top: 'bottom',
          bottom: 'top',
          left: 'right',
          right: 'left'
        };
        var placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];
        var origin = placementMap[placement];
        this.popperJS._popper.style.transformOrigin = ['top', 'bottom'].indexOf(placement) !== -1 ? 'center ' + origin : origin + ' center';
      },
      appendArrow: function(element) {
        if (this.appended) return;
        this.appended = true;
        var arrow = document.createElement('div');
        arrow.setAttribute('x-arrow', '');
        arrow.className = 'popper__arrow';
        element.appendChild(arrow);
      }
    },
    beforeDestroy: function() {
      !VueUtil.isIE && VueUtil.off(this.popperElm, 'click', this.stop);
      this.destroyPopper();
    }
  };
  return VuePopper;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueScrollbar = definition(context.Vue, context.VueUtil);
    delete context.VueScrollbar;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var Bar = {
    name: 'Bar',
    props: {
      vertical: Boolean,
      size: Number,
      move: Number,
      disSize: Number
    },
    computed: {
      bar: function() {
        var BAR_MAP = {
          vertical: {
            offset: 'offsetHeight',
            scroll: 'scrollTop',
            scrollSize: 'scrollHeight',
            size: 'height',
            key: 'vertical',
            axis: 'Y',
            client: 'clientY',
            direction: 'top'
          },
          horizontal: {
            offset: 'offsetWidth',
            scroll: 'scrollLeft',
            scrollSize: 'scrollWidth',
            size: 'width',
            key: 'horizontal',
            axis: 'X',
            client: 'clientX',
            direction: 'left'
          }
        };
        return BAR_MAP[this.vertical ? 'vertical' : 'horizontal'];
      },
      wrap: function() {
        return this.$parent.wrap;
      }
    },
    render: function(createElement) {
      var self = this;
      var move = self.move;
      var size = self.size;
      var bar = self.bar;
      var renderThumbStyle = function(obj) {
        var move = obj.move;
        var size = obj.size;
        var bar = obj.bar;
        if (size === 0) move = 0;
        var style = {};
        if (bar.axis === 'Y') {
          style.marginTop = move + 'px';
        }
        if (bar.axis === 'X') {
          style.marginLeft = move + 'px';
        }
        style[bar.size] = size + 'px';
        return style;
      };
      return createElement('div', {
        class: ['vue-scrollbar__bar', 'is-' + bar.key],
        on: {
          mousedown: self.clickTrackHandler
        }
      }, [createElement('div', {
        ref: 'thumb',
        class: 'vue-scrollbar__thumb',
        on: {
          mousedown: self.clickThumbHandler,
          touchstart: self.clickThumbHandler,
        },
        style: renderThumbStyle({
          size: size,
          move: move,
          bar: bar
        })
      }, [])]);
    },
    methods: {
      clickThumbHandler: function(e) {
        this[this.bar.axis] = e.currentTarget[this.bar.offset] - ((e[this.bar.client] || e.touches[0][this.bar.client]) - e.currentTarget.getBoundingClientRect()[this.bar.direction]);
        this.startDrag(e);
      },
      clickTrackHandler: function(e) {
        var offset = Math.abs(e.target.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]);
        var thumbHalf = this.$refs.thumb[this.bar.offset] / 2;
        this.wrap[this.bar.scroll] = (offset - thumbHalf) / (this.$el[this.bar.offset] + this.disSize) * this.wrap[this.bar.scrollSize];
      },
      startDrag: function(e) {
        e.stopImmediatePropagation();
        VueUtil.addTouchMove(document, this.mouseMoveDocumentHandler);
        VueUtil.addTouchEnd(document, this.mouseUpDocumentHandler);
        document.onselectstart = function() {
          return false;
        };
      },
      mouseMoveDocumentHandler: function(e) {
        var prevPage = this[this.bar.axis];
        if (!prevPage) return;
        var offset = (this.$el.getBoundingClientRect()[this.bar.direction] - (e[this.bar.client] || e.touches[0][this.bar.client])) * -1;
        var thumbClickPosition = this.$refs.thumb[this.bar.offset] - prevPage;
        this.wrap[this.bar.scroll] = (offset - thumbClickPosition) / (this.$el[this.bar.offset] + this.disSize) * this.wrap[this.bar.scrollSize];
      },
      mouseUpDocumentHandler: function(e) {
        this[this.bar.axis] = 0;
        VueUtil.removeTouchMove(document, this.mouseMoveDocumentHandler);
        VueUtil.removeTouchEnd(document, this.mouseUpDocumentHandler);
        document.onselectstart = null;
      }
    }
  };
  var VueScrollbar = {
    name: 'VueScrollbar',
    components: {
      Bar: Bar
    },
    props: {
      wrapClass: {},
      viewClass: {},
      height: Number,
      width: Number,
      noresize: Boolean,
      tag: {
        type: String,
        default: 'div'
      }
    },
    data: function() {
      return {
        sizeWidth: 0,
        sizeHeight: 0,
        moveX: 0,
        moveY: 0,
        disSizeX: 0,
        disSizeY: 0
      };
    },
    computed: {
      wrap: function() {
        return this.$refs.wrap;
      },
      resizeElement: function() {
        var view = this.$refs.resize;
        if (VueUtil.isDef(view) && VueUtil.isElement(view.$el)) {
          return view.$el;
        }
        return view;
      },
      mouseWheelEvent: function() {
        return VueUtil.isFirefox ? 'DOMMouseScroll' : 'mousewheel';
      },
    },
    render: function(createElement) {
      var self = this;
      var viewHeight = null;
      var viewWidth = null;
      if (VueUtil.isNumber(self.height)) {
        viewHeight =  self.height + 'px';
      }
      if (VueUtil.isNumber(self.width)) {
        viewWidth =  self.width + 'px';
      }
      var view = createElement(self.tag, {
        class: ['vue-scrollbar__view', self.viewClass],
        ref: 'resize'
      }, [self.$slots.default]);
      var wrap = createElement('div', {
        ref: 'wrap',
        style: {height: viewHeight, width: viewWidth},
        on: {
          scroll: self.handleScroll
        },
        class: [self.wrapClass, 'vue-scrollbar__wrap']
      }, [view]);
      var nodes = [wrap, createElement(Bar, {
        style: {width: viewWidth},
        attrs: {
          move: self.moveX,
          size: self.sizeWidth,
          disSize: self.disSizeX
        }
      }, []), createElement(Bar, {
        style: {height: viewHeight},
        attrs: {
          vertical: true,
          move: self.moveY,
          size: self.sizeHeight,
          disSize: self.disSizeY
        }
      }, [])];
      return createElement('div', {
        class: 'vue-scrollbar'
      }, nodes);
    },
    methods: {
      isScrollCancel: function(el) {
        if (el === this.wrap) return false;
        var overflowY = VueUtil.getStyle(el, 'overflowY');
        if (['auto', 'scroll'].indexOf(overflowY) !== -1 && el.scrollHeight > el.clientHeight) return true;
        return this.isScrollCancel(el.parentElement);
      },
      scrollMouseWheel: function(e) {
        if (this.isScrollCancel(e.target)) return;
        e.stopPropagation();
        e.preventDefault();
        var wheelDelta = e.wheelDelta || -e.detail;
        var scrollTop = this.wrap.scrollTop;
        var wheel = 90;
        if (wheelDelta < 0) {
          scrollTop += wheel;
        } else {
          scrollTop -= wheel;
        }
        this.wrap.scrollTop = scrollTop;
      },
      touchStart: function(e) {
        if (this.isScrollCancel(e.target)) return;
        e.stopImmediatePropagation();
        VueUtil.addClass(this.$el, 'is-touch');
        var wrap = this.wrap;
        var touches = e.touches[0];
        var tocuhPlace = this.tocuhPlace;
        if (!VueUtil.isDef(tocuhPlace)) {
          tocuhPlace = this.tocuhPlace = {};
        }
        tocuhPlace.startTime = e.timeStamp;
        tocuhPlace.startY = wrap.scrollTop;
        tocuhPlace.tocuhX = touches.pageX;
        tocuhPlace.tocuhY = touches.pageY;
        clearInterval(tocuhPlace.timer);
        VueUtil.on(document, 'touchmove', this.touchMove);
        VueUtil.on(document, 'touchend', this.touchEnd);
      },
      touchMove: function(e) {
        VueUtil.addClass(this.$el, 'touching');
        var touches = e.touches[0];
        var wrap = this.wrap;
        var tocuhPlace = this.tocuhPlace;
        var scrollLeft = tocuhPlace.tocuhX - touches.pageX;
        var scrollTop = tocuhPlace.tocuhY - touches.pageY;
        wrap.scrollLeft = wrap.scrollLeft + scrollLeft;
        wrap.scrollTop = wrap.scrollTop + scrollTop;
        tocuhPlace.tocuhX = touches.pageX;
        tocuhPlace.tocuhY = touches.pageY;
      },
      touchEnd: function(e) {
        var self = this;
        var wrap = this.wrap;
        var tocuhPlace = this.tocuhPlace;
        var timeStamp = e.timeStamp - tocuhPlace.startTime;
        if (timeStamp <= 200) {
          var moveY = Math.floor(((wrap.scrollTop - tocuhPlace.startY) * 100 / timeStamp) / 4);
          tocuhPlace.timer = setInterval(function() {
            var tmpScrollTop = wrap.scrollTop;
            wrap.scrollTop = wrap.scrollTop + moveY;
            moveY > 0 ? moveY-- : moveY++;
            if (moveY === 0 || wrap.scrollTop === tmpScrollTop) {
              VueUtil.removeClass(self.$el, 'touching');
              clearInterval(tocuhPlace.timer);
            }
          }, 66);
        } else {
          VueUtil.removeClass(this.$el, 'touching');
        }
        VueUtil.off(document, 'touchmove',this.touchMove);
        VueUtil.off(document, 'touchend', this.touchEnd);
      },
      handleScroll: VueUtil.throttle(function(e) {
        if (!VueUtil.isDef(e.touches)) VueUtil.removeClass(this.$el, 'is-touch');
        this.update();
        var wrap = this.wrap;
        var moveY = wrap.scrollTop / wrap.scrollHeight * wrap.clientHeight;
        var moveX = wrap.scrollLeft / wrap.scrollWidth * wrap.clientWidth;
        var sizeHeight = this.sizeHeight;
        var sizeWidth = this.sizeWidth;
        var minHeight = wrap.clientHeight * 0.1;
        var minWidth = wrap.clientWidth * 0.1;
        if (sizeHeight < minHeight && sizeHeight !== 0) {
          moveY = wrap.scrollTop / wrap.scrollHeight * (wrap.clientHeight - minHeight + sizeHeight);
          this.sizeHeight = minHeight;
          this.disSizeY = sizeHeight - minHeight;
        }
        if (sizeWidth < minWidth && sizeWidth !== 0) {
          moveX = wrap.scrollLeft / wrap.scrollWidth * (wrap.clientHeight - minWidth + sizeWidth);
          this.sizeWidth = minWidth;
          this.disSizeX = sizeWidth - minWidth;
        }
        if (this.moveY !== moveY) {
          this.moveY = moveY;
          var isTop = (wrap.scrollTop === 0);
          var isBottom = (wrap.scrollHeight - wrap.scrollTop === wrap.clientHeight);
          this.$emit('scrollY', e, wrap.scrollTop, isTop, isBottom);
        }
        if (this.moveX !== moveX) {
          this.moveX = moveX;
          var isLeft = (wrap.scrollLeft === 0);
          var isRight = (wrap.scrollWidth - wrap.scrollLeft === wrap.clientWidth);
          this.$emit('scrollX', e, wrap.scrollLeft, isLeft, isRight);
        }
      }),
      update: function() {
        var wrap = this.wrap;
        var heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
        var widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;
        var sizeHeight = heightPercentage < 100 ? wrap.clientHeight * heightPercentage / 100 : 0;
        var sizeWidth = widthPercentage < 100 ? wrap.clientWidth * widthPercentage / 100 : 0;
        this.sizeHeight = sizeHeight;
        this.sizeWidth = sizeWidth;
        this.disSizeX = 0;
        this.disSizeY = 0;
      },
      goTop: function() {
        this.wrap.scrollTop = 0;
      }
    },
    mounted: function() {
      VueUtil.on(this.wrap, this.mouseWheelEvent, this.scrollMouseWheel);
      VueUtil.on(this.wrap, 'touchstart', this.touchStart);
      VueUtil.addHoverListener(this.wrap, this.handleScroll);
      !this.noresize && this.resizeElement && VueUtil.addResizeListener(this.resizeElement, this.update);
    },
    beforeDestroy: function() {
      VueUtil.off(this.wrap, this.mouseWheelEvent, this.scrollMouseWheel);
      VueUtil.off(this.wrap, 'touchstart', this.touchStart);
      VueUtil.removeHoverListener(this.wrap, this.handleScroll);
      !this.noresize && this.resizeElement && VueUtil.removeResizeListener(this.resizeElement, this.update);
    }
  };
  Vue.component(VueScrollbar.name, VueScrollbar);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueRow = definition(context.Vue);
    delete context.VueRow;
  }
})(this, function(Vue) {
  'use strict';
  var VueRow = {
    template: '<div :style="style" :class="[\'vue-row\', justify !== \'start\' ? \'is-justify-\' + justify : \'\', align !== \'top\' ? \'is-align-\' + align : \'\', {\'vue-row--flex\': type === \'flex\'}]"><slot></slot></div>',
    name: 'VueRow',
    props: {
      gutter: Number,
      type: String,
      justify: {
        type: String,
        default: 'start'
      },
      align: {
        type: String,
        default: 'top'
      }
    },
    computed: {
      style: function() {
        var ret = {};
        if (this.gutter) {
          ret.marginLeft = this.gutter / 2 + 'px';
          ret.marginRight = ret.marginLeft;
        }
        return ret;
      }
    }
  };
  Vue.component(VueRow.name, VueRow);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCol = definition(context.Vue, context.VueUtil);
    delete context.VueCol;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCol = {
    name: 'VueCol',
    props: {
      span: {
        type: Number,
        default: 24
      },
      offset: Number,
      pull: Number,
      push: Number,
      xs: [Number, Object],
      sm: [Number, Object],
      md: [Number, Object],
      lg: [Number, Object]
    },
    computed: {
      gutter: function() {
        return this.$parent.gutter;
      },
      style: function() {
        var ret = {};
        if (this.gutter) {
          ret.paddingLeft = this.gutter / 2 + 'px';
          ret.paddingRight = ret.paddingLeft;
        }
        return ret;
      }
    },
    render: function(createElement) {
      var self = this;
      var classList = [];
      VueUtil.loop(['span', 'offset', 'pull', 'push'], function(prop) {
        if (VueUtil.isDef(self[prop])) {
          classList.push(prop !== 'span' ? 'vue-col-' + prop + '-' + self[prop] : 'vue-col-' + self[prop]);
        }
      });
      VueUtil.loop(['xs', 'sm', 'md', 'lg'], function(size) {
        if (VueUtil.isNumber(self[size])) {
          classList.push('vue-col-' + size + '-' + self[size]);
        } else if (VueUtil.isObject(self[size])) {
          var props = self[size];
          VueUtil.ownPropertyLoop(props, function(prop) {
            classList.push(prop !== 'span' ? 'vue-col-' + size + '-' + prop + '-' + props[prop] : 'vue-col-' + size + '-' + props[prop]);
          });
        }
      });
      return createElement('div', {
        class: ['vue-col', classList],
        style: self.style
      }, [this.$slots.default]);
    }
  };
  Vue.component(VueCol.name, VueCol);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['VueUtil'], definition);
  } else {
    context.VueValidator = definition(context.VueUtil);
  }
})(this, function(VueUtil) {
  'use strict';
  var newMessages = function() {
    return {
      default: 'Validation Error'
    };
  };
  var isEmptyValue = function(value, type) {
    if (!VueUtil.isDef(value)) {
      return true;
    }
    if (type === 'array' && VueUtil.isArray(value) && !value.length) {
      return true;
    }
    var isNativeStringType = function(type) {
      return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'pattern' || type === 'ipv4';
    };
    if (isNativeStringType(type) && VueUtil.isString(value) && !value) {
      return true;
    }
    return false;
  };
  var rulesEnumerable = function(rule, value, source, errors, options) {
    var ENUM = 'enum';
    rule[ENUM] = VueUtil.isArray(rule[ENUM]) ? rule[ENUM] : [];
    if (rule[ENUM].indexOf(value) === -1) {
      errors.push(options.messages.default);
    }
  };
  var rulesPattern = function(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        if (!rule.pattern.test(value)) {
          errors.push(options.messages.default);
        }
      } else if (VueUtil.isString(rule.pattern)) {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(options.messages.default);
        }
      }
    }
  };
  var rulesRange = function(rule, value, source, errors, options) {
    var len = VueUtil.isNumber(rule.len);
    var min = VueUtil.isNumber(rule.min);
    var max = VueUtil.isNumber(rule.max);
    var val = value;
    var key = null;
    var num = rule.type == 'number' || VueUtil.isNumber(value);
    var str = rule.type == 'number' ? false : VueUtil.isString(value);
    var arr = VueUtil.isArray(value);
    if (num) {
      key = 'number';
    } else if (str) {
      key = 'string';
    } else if (arr) {
      key = 'array';
    }
    if (!key) {
      return false;
    }
    if (str || arr) {
      val = value.length;
    }
    if (len) {
      if (val !== rule.len) {
        errors.push(options.messages.default);
      }
    } else if (min && !max && val < rule.min) {
      errors.push(options.messages.default);
    } else if (max && !min && val > rule.max) {
      errors.push(options.messages.default);
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(options.messages.default);
    }
  };
  var rulesRequired = function(rule, value, source, errors, options, type) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
      errors.push(options.messages.default);
    }
  };
  var rulesType = function(rule, value, source, errors, options) {
    var pattern = {
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
      url: new RegExp('^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$', 'i'),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
      ipv4: new RegExp('\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b'),
    };
    var types = {
      integer: function(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      float: function(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function(value) {
        return VueUtil.isArray(value);
      },
      regexp: function(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e) {
          throw e;
        }
      },
      date: function(value) {
        return VueUtil.isFunction(value.getTime) && VueUtil.isFunction(value.getMonth) && VueUtil.isFunction(value.getYear);
      },
      number: function(value) {
        return VueUtil.isNumberStr(value);
      },
      object: function(value) {
        return VueUtil.isObject(value);
      },
      method: function(value) {
        return VueUtil.isFunction(value);
      },
      email: function(value) {
        return VueUtil.isString(value) && !!value.match(pattern.email) && value.length < 255;
      },
      url: function(value) {
        return VueUtil.isString(value) && !!value.match(pattern.url);
      },
      hex: function(value) {
        return VueUtil.isString(value) && !!value.match(pattern.hex);
      },
      ipv4: function(value) {
        return VueUtil.isString(value) && !!value.match(pattern.ipv4);
      }
    };
    if (rule.required && !VueUtil.isDef(value)) {
      rulesRequired(rule, value, source, errors, options);
      return;
    }
    var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex', 'ipv4'];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) !== -1) {
      if (!types[ruleType](value)) {
        errors.push(options.messages.default);
      }
    } else if (ruleType && typeof (value) !== ruleType) {
      errors.push(options.messages.default);
    }
  };
  var rulesWhitespace = function(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === '') {
      errors.push(options.messages.default);
    }
  };
  var rules = {
    enum: rulesEnumerable,
    pattern: rulesPattern,
    range: rulesRange,
    required: rulesRequired,
    type: rulesType,
    whitespace: rulesWhitespace
  };
  var validtorDate = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
        if (value) {
          rules.range(rule, value.getTime(), source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var validtorBoolean = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (VueUtil.isDef(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorArray = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value, 'array') && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, 'array');
      if (!isEmptyValue(value, 'array')) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorType = function(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorString = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value, 'string') && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, 'string');
      if (!isEmptyValue(value, 'string')) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var validtorRequired = function(rule, value, callback, source, options) {
    var errors = [];
    var type = VueUtil.isArray(value) ? 'array' : typeof value;
    rules.required(rule, value, source, errors, options, type);
    callback(errors);
  };
  var validtorRegexp = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorPattern = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value, 'string') && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, 'string')) {
        rules.pattern(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorObject = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (VueUtil.isDef(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorNumber = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (VueUtil.isDef(value)) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorMethod = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (VueUtil.isDef(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorEnumerable = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value) {
        rules['enum'](rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validators = {
    string: validtorString,
    method: validtorMethod,
    number: validtorNumber,
    boolean: validtorBoolean,
    regexp: validtorRegexp,
    integer: validtorNumber,
    float: validtorNumber,
    array: validtorArray,
    object: validtorObject,
    enum: validtorEnumerable,
    pattern: validtorPattern,
    email: validtorType,
    url: validtorType,
    date: validtorDate,
    hex: validtorType,
    ipv4: validtorType,
    required: validtorRequired
  };
  var Schema = function(descriptor) {
    this.rules = null;
    this._messages = newMessages();
    this.define(descriptor);
  };
  Schema.prototype = {
    messages: function(messages) {
      return VueUtil.merge(this._messages, messages);
    },
    define: function(rules) {
      if (!rules) {
        throw 'No rules';
      }
      if (!VueUtil.isObject(rules)) {
        throw 'Rules must be an object';
      }
      var self = this;
      self.rules = {};
      VueUtil.ownPropertyLoop(rules, function(z) {
        var item = rules[z];
        self.rules[z] = VueUtil.isArray(item) ? item : [item];
      });
    },
    validate: function(source_, o, oc) {
      var source = source_;
      var options = o || {};
      var callback = oc;
      if (VueUtil.isFunction(options)) {
        callback = options;
        options = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      function complete(results) {
        var i;
        var field;
        var errors = [];
        var fields = {};
        function add(e) {
          if (VueUtil.isArray(e)) {
            errors = errors.concat.apply(errors, e);
          } else {
            errors.push(e);
          }
        }
        i = results.length;
        while (i--) {
          add(results[i]);
        }
        if (!errors.length) {
          errors = null;
          fields = null;
        } else {
          i = errors.length;
          while (i--) {
            field = errors[i].field;
            fields[field] = fields[field] || [];
            fields[field].push(errors[i]);
          }
        }
        callback(errors, fields);
      }
      options.messages = VueUtil.merge(this.messages(), options.messages);
      var self = this;
      var arr;
      var value;
      var series = {};
      var keys = options.keys || Object.keys(self.rules);
      VueUtil.loop(keys, function(z) {
        arr = self.rules[z];
        value = source[z];
        VueUtil.loop(arr, function(r) {
          var rule = r;
          if (VueUtil.isFunction(rule.transform)) {
            if (source === source_) {
              source = VueUtil.merge({}, source);
            }
            value = source[z] = rule.transform(value);
          }
          if (VueUtil.isFunction(rule)) {
            rule = {
              validator: rule,
            };
          } else {
            rule = VueUtil.merge({}, rule);
          }
          rule.validator = self.getValidationMethod(rule);
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = self.getType(rule);
          if (!rule.validator) {
            return;
          }
          series[z] = series[z] || [];
          series[z].push({
            rule: rule,
            value: value,
            source: source,
            field: z,
          });
        });
      });
      var errorFields = {};
      var asyncMap = function(objArr, option, func, callback) {
        var flattenObjArr = function(objArr) {
          var ret = [];
          VueUtil.ownPropertyLoop(objArr, function(k) {
            ret.push.apply(ret, objArr[k]);
          });
          return ret;
        };
        var asyncSerialArray = function(arr, func, callback) {
          var index = 0;
          var arrLength = arr.length;
          function next(errors) {
            if (errors && errors.length) {
              callback(errors);
              return;
            }
            var original = index;
            index = index + 1;
            if (original < arrLength) {
              func(arr[original], next);
            } else {
              callback([]);
            }
          }
          next([]);
        };
        if (option.first) {
          var flattenArr = flattenObjArr(objArr);
          return asyncSerialArray(flattenArr, func, callback);
        }
        var firstFields = option.firstFields || [];
        if (firstFields === true) {
          firstFields = Object.keys(objArr);
        }
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total = 0;
        var results = [];
        var next = function(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
          }
        };
        VueUtil.loop(objArrKeys, function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            var asyncParallelArray = function(arr, func, callback) {
              var results = [];
              var total = 0;
              var arrLength = arr.length;
              function count(errors) {
                results.push.apply(results, errors);
                total++;
                if (total === arrLength) {
                  callback(results);
                }
              }
              VueUtil.loop(arr, function(a) {
                func(a, count);
              });
            };
            asyncParallelArray(arr, func, next);
          }
        });
      };
      asyncMap(series, options, function(data, doIt) {
        var rule = data.rule;
        var deep = (VueUtil.isObject(rule.type) || VueUtil.isArray(rule.type)) && (VueUtil.isObject(rule.fields) || VueUtil.isObject(rule.defaultField));
        deep = deep && (rule.required || (!rule.required && data.value));
        rule.field = data.field;
        function addFullfield(key, schema) {
          return VueUtil.merge({}, schema, {
            fullField: rule.fullField + '.' + key
          });
        }
        function cb() {
          var errors = arguments.length > 0 && VueUtil.isDef(arguments[0]) ? arguments[0] : [];
          var complementError = function(rule) {
            return function(oe) {
              if (oe && oe.message) {
                oe.field = oe.field || rule.fullField;
                return oe;
              }
              return {
                message: oe,
                field: oe.field || rule.fullField,
              };
            };
          };
          if (!VueUtil.isArray(errors)) {
            errors = [errors];
          }
          if (errors.length && rule.message) {
            errors = VueUtil.mergeArray([], rule.message);
          }
          errors = VueUtil.map(errors, complementError(rule));
          if (options.first && errors.length) {
            errorFields[rule.field] = 1;
            return doIt(errors);
          }
          if (!deep) {
            doIt(errors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message) {
                errors = VueUtil.map(VueUtil.mergeArray([], rule.message), complementError(rule));
              } else if (options.error) {
                errors = [options.error(rule, options.messages.default)];
              } else {
                errors = [];
              }
              return doIt(errors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              VueUtil.ownPropertyLoop(data.value, function(k) {
                fieldsSchema[k] = rule.defaultField;
              });
            }
            fieldsSchema = VueUtil.merge({}, fieldsSchema, data.rule.fields);
            VueUtil.ownPropertyLoop(fieldsSchema, function(f) {
              var fieldSchema = VueUtil.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
              fieldsSchema[f] = VueUtil.map(fieldSchema, addFullfield.bind(null, f));
            });
            var schema = new Schema(fieldsSchema);
            schema.messages(options.messages);
            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }
            schema.validate(data.value, data.rule.options || options, function(errs) {
              doIt(errs && errs.length ? VueUtil.mergeArray(errors, errs) : errs);
            });
          }
        }
        var res = rule.validator(rule, data.value, cb, data.source, options);
        if (res && res.then) {
          res.then(function() {cb();}, function(e) {cb(e);});
        }
      }, function(results) {
        complete(results);
      });
    },
    getType: function(rule) {
      if (!VueUtil.isDef(rule.type) && (rule.pattern instanceof RegExp)) {
        rule.type = 'pattern';
      }
      if (!VueUtil.isFunction(rule.validator) && (rule.type && !validators.hasOwnProperty(rule.type))) {
        throw 'Unknown rule type ' + rule.type;
      }
      return rule.type || 'string';
    },
    getValidationMethod: function(rule) {
      if (VueUtil.isFunction(rule.validator)) {
        return rule.validator;
      }
      var keys = Object.keys(rule);
      var messageIndex = keys.indexOf('message');
      if (messageIndex !== -1) {
        keys.splice(messageIndex, 1);
      }
      if (keys.length === 1 && keys[0] === 'required') {
        return validators.required;
      }
      return validators[this.getType(rule)] || false;
    },
  };
  Schema.register = function register(type, validator) {
    if (!VueUtil.isFunction(validator)) {
      throw 'Cannot register a validator by type, validator is not a function';
    }
    validators[type] = validator;
  };
  Schema.messages = newMessages();
  return Schema;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueForm = definition(context.Vue, context.VueUtil);
    delete context.VueForm;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueForm = {
    template: '<form :class="[\'vue-form\', labelPosition ? \'vue-form--label-\' + labelPosition : \'\', {\'vue-form--inline\': inline}]"><slot></slot><input style="display:none" /></form>',
    name: 'VueForm',
    props: {
      model: Object,
      rules: Object,
      labelPosition: String,
      labelWidth: String,
      labelSuffix: {
        type: String,
        default: ''
      },
      inline: Boolean,
      showMessage: {
        type: Boolean,
        default: true
      },
      labelResponsive: {
        type: Boolean,
        default: true
      },
      notifyMessage: Boolean,
      customMessageMethod: Function
    },
    watch: {
      rules: function() {
        this.validate();
      }
    },
    data: function() {
      return {
        fields: [],
        initModel: {}
      };
    },
    created: function() {
      this.$on('vue.form.addField', function(field) {
        if (field) {
          this.fields.push(field);
        }
      });
      this.$on('vue.form.removeField', function(field) {
        if (field.prop) {
          this.fields.splice(this.fields.indexOf(field), 1);
        }
      });
    },
    methods: {
      initValue: function() {
        this.initModel = VueUtil.cloneDeep(this.model);
      },
      isModify: function() {
        var modifyFLg = false;
        VueUtil.loop(this.fields, function(field) {
          if (modifyFLg) return;
          modifyFLg = field.isModify();
        });
        return modifyFLg;
      },
      resetFields: function() {
        VueUtil.loop(this.fields, function(field) {
          field.resetField();
        });
      },
      validate: function(callback) {
        var self = this;
        self.$nextTick(function(){
          var valid = true;
          var count = 0;
          var errorMsgs = [];
          VueUtil.loop(self.fields, function(field, index) {
            field.validate('', function(errors) {
              if (errors) {
                valid = false;
                errorMsgs.push(errors);
              }
              if (VueUtil.isFunction(callback) && ++count === self.fields.length) {
                callback(valid);
              }
            });
          });
          if (errorMsgs.length > 0) {
            if (VueUtil.isFunction(self.customMessageMethod)) {
              self.customMessageMethod(errorMsgs);
            } else if (self.notifyMessage) {
              var createElement = self.$createElement;
              self.$notify.error({
                message: createElement('div', null, [self._l(errorMsgs, function(errorMsg, errorIndex) {
                  return [createElement('span', {key: errorIndex}, [errorMsg]), createElement('br', null, [])];
                })]),
                duration: 0
              });
            }
          }
        });
      },
      validateField: function(prop, cb) {
        var field = VueUtil.filter(this.fields, function(field) {
          return (field.prop === prop);
        })[0];
        if (!field) {
          throw 'must call validateField with valid prop string!';
        }
        field.validate('', cb);
      }
    },
    mounted: function() {
      this.initValue();
    }
  };
  Vue.component(VueForm.name, VueForm);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VueValidator'], definition);
  } else {
    context.VueFormItem = definition(context.Vue, context.VueUtil, context.VueValidator);
    delete context.VueFormItem;
    delete context.VueValidator;
  }
})(this, function(Vue, VueUtil, VueValidator) {
  'use strict';
  var VueFormItem = {
    template: '<div :class="[\'vue-form-item\', {\'is-notify\': form.notifyMessage || form.customMessageMethod,\'is-error\': validateState === \'error\',\'is-validating\': validateState === \'validating\',\'is-required\': isRequired || required}]"><label :for="prop" :class="[\'vue-form-item__label\', {\'is-responsive\': resetIsResponsive()}]" :style="labelStyle" v-if="label" ref="label">{{label + form.labelSuffix}}</label><div class="vue-form-item__content" :style="contentStyle" ref="content"><slot></slot><div class="vue-form-item__error" v-if="validateState === \'error\' && showMessage && form.showMessage && !form.notifyMessage && !form.customMessageMethod">{{validateMessage}}</div></div></div>',
    name: 'VueFormItem',
    mixins: [VueUtil.component.emitter],
    props: {
      label: String,
      labelWidth: String,
      prop: String,
      required: Boolean,
      rules: [Object, Array],
      error: String,
      validateStatus: String,
      showMessage: {
        type: Boolean,
        default: true
      }
    },
    watch: {
      error: function(value) {
        this.validateMessage = value;
        this.validateState = 'error';
      },
      validateStatus: function(value) {
        this.validateState = value;
      },
      label: {
        immediate: true,
        handler: function(val) {
          var self = this;
          if (VueUtil.isDef(val)) {
            self.$nextTick(function() {
              VueUtil.removeResizeListener(self.form.$el, self.resetLabelWidth);
              VueUtil.addResizeListener(self.form.$el, self.resetLabelWidth);
            });
          } else {
            self.$nextTick(function() {
              VueUtil.removeResizeListener(self.form.$el, self.resetLabelWidth);
            });
          }
        }
      }
    },
    computed: {
      labelStyle: function() {
        var ret = {};
        var labelStyleWidth = this.labelStyleWidth();
        if (labelStyleWidth) {
          ret.width = labelStyleWidth;
        }
        return ret;
      },
      contentStyle: function() {
        var ret = {};
        var labelStyleWidth = this.labelStyleWidth();
        if (labelStyleWidth) {
          ret.marginLeft = labelStyleWidth;
        }
        return ret;
      },
      form: function() {
        var parent = this.$parent;
        while (parent.$options.name !== 'VueForm') {
          parent = parent.$parent;
        }
        return parent;
      },
      fieldValue: {
        cache: false,
        get: function() {
          var model = this.form.model;
          if (!model || !this.prop) {
            return;
          }
          var path = this.prop;
          if (path.indexOf(':') !== -1) {
            path = path.replace(/:/, '.');
          }
          return this.getPropByPath(model, path).v;
        }
      },
      isRequired: function() {
        var self = this;
        var res = false;
        var rules = self.getRules();
        VueUtil.loop(rules, function(rule) {
          if (rule.required) {
            res = true;
            return false;
          }
        });
        return res;
      },
      initialValue: function() {
        var model = this.form.initModel;
        var path = this.prop;
        if (path.indexOf(':') !== -1) {
          path = path.replace(/:/, '.');
        }
        var prop = this.getPropByPath(model, path);

        return prop.o[prop.k];
      }
    },
    data: function() {
      return {
        validateState: '',
        validateMessage: '',
        validateDisabled: false,
        validator: {},
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
        screenWidth:document.body.clientWidth
      };
    },
    methods: {
      getPropByPath: function(obj, path) {
        var tempObj = obj;
        path = path.replace(/\[(\w+)\]/g, '.$1');
        path = path.replace(/^\./, '');
        var keyArr = path.split('.');
        for (var i = 0, len = keyArr.length; i < len - 1; ++i) {
          var key = keyArr[i];
          tempObj = tempObj[key];
          if (!VueUtil.isDef(tempObj)) {
            throw 'please transfer a valid prop path to form item!';
          }
        }
        return {
          o: tempObj,
          k: keyArr[i],
          v: tempObj[keyArr[i]]
        };
      },
      labelStyleWidth: function() {
        if (this.form.labelPosition === 'top' || (this.form.labelResponsive && VueUtil.getStyle(this.$refs.label, 'display') === 'inline-block')) return '';
        var labelWidth = this.labelWidth || this.form.labelWidth;
        return labelWidth;
      },
      resetLabelWidth: function() {
        var labelStyleWidth = this.labelStyleWidth();
        if(this.isMobile && this.$refs.label){
            var oldLabelWidth = labelStyleWidth ? Number.parseFloat(labelStyleWidth.split('px')[0]) : undefined;
            if(oldLabelWidth)
              this.$refs.label.style.width = '';
            var textWidth = this.$refs.label.offsetWidth;
            var widthScale = textWidth / this.screenWidth;
            if(!oldLabelWidth && widthScale <=0.3)
              labelStyleWidth = '30%';
            if((!oldLabelWidth && widthScale > 0.3) || (oldLabelWidth && textWidth > oldLabelWidth)){
              this.$refs.label.style.padding = '10px 10px 0 10px';
              this.$refs.content.style.marginLeft = '';
              return;
            }
        }
        this.$refs.label && (this.$refs.label.style.width = labelStyleWidth);
        this.$refs.content && (this.$refs.content.style.marginLeft = labelStyleWidth);
      },
      resetIsResponsive:function(){
        var isResponsiveCss = this.form.labelResponsive;
        if(this.isMobile){
          isResponsiveCss = false;
        }
        return isResponsiveCss;
      },
      validate: function(trigger, callback) {
        var self = this;
        var noop = function() {};
        if (VueUtil.isFunction(self.form.customMessageMethod)) {
          noop = self.form.customMessageMethod;
        } else if (self.form.notifyMessage) {
          noop = function(errorMsg) {
            if (errorMsg) {
              self.$notify.error({message: errorMsg});
            }
          };
        }
        callback = callback || noop;
        var rules = self.getFilteredRule(trigger);
        if (!rules || rules.length === 0) {
          self.validateState = '';
          self.validateMessage = '';
          callback();
          return true;
        }
        self.validateState = 'validating';
        var descriptor = {};
        descriptor[self.prop] = rules;
        var validator = new VueValidator(descriptor);
        var model = {};
        model[self.prop] = self.fieldValue;
        validator.validate(model, {
          firstFields: true
        }, function(errors, fields) {
          self.validateState = !errors ? 'success' : 'error';
          self.validateMessage = errors ? errors[0].message : '';
          callback(self.validateMessage);
        });
      },
      resetField: function() {
        this.validateState = '';
        this.validateMessage = '';
        var model = this.form.model;
        var value = this.fieldValue;
        var path = this.prop;
        if (path.indexOf(':') !== -1) {
          path = path.replace(/:/, '.');
        }
        var prop = this.getPropByPath(model, path);
        this.validateDisabled = true;
        var self = this;
        setTimeout(function() {
          self.validateDisabled = false;
        }, 100);
        if (Array.isArray(value) && this.initialValue) {
          prop.o[prop.k] = [].concat(this.initialValue);
        } else {
          prop.o[prop.k] = this.initialValue;
        }

        this.broadcast('VueTimeSelect', 'fieldReset', this.initialValue);
      },
      isModify: function() {
        this.validateState = '';
        this.validateMessage = '';
        var model = this.form.model;
        var value = this.fieldValue;
        var path = this.prop;
        if (path.indexOf(':') !== -1) {
          path = path.replace(/:/, '.');
        }
        var prop = this.getPropByPath(model, path);
        return (prop.o[prop.k] !== this.initialValue);
      },
      getRules: function() {
        var formRules = this.form.rules;
        var selfRuels = this.rules;
        formRules = formRules ? formRules[this.prop] : [];
        return VueUtil.mergeArray([], (selfRuels || formRules || []));
      },
      getFilteredRule: function(trigger) {
        var rules = this.getRules();
        return VueUtil.filter(rules, function(rule) {
          return !rule.trigger || rule.trigger.indexOf(trigger) !== -1;
        });
      },
      onFieldBlur: function() {
        this.validate('blur');
      },
      onFieldChange: function() {
        if (this.validateDisabled) {
          this.validateDisabled = false;
          return;
        }
        this.validate('change');
      }
    },
    mounted: function() {
      var self = this;
      if (self.prop) {
        self.dispatch('VueForm', 'vue.form.addField', [self]);
        var rules = self.getRules();
        if (rules.length) {
          self.$on('vue.form.blur', self.onFieldBlur);
          self.$on('vue.form.change', self.onFieldChange);
        }
      }
    },
    beforeDestroy: function() {
      this.dispatch('VueForm', 'vue.form.removeField', [this]);
      VueUtil.removeResizeListener(this.form.$el, this.resetLabelWidth);
    }
  };
  Vue.component(VueFormItem.name, VueFormItem);
});

(function webpackUniversalModuleDefinition(root, factory) {
    if(typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if(typeof define === 'function' && define.amd)
        define([], factory);
    else if(typeof exports === 'object')
        exports['Cleave'] = factory();
    else
        root['Cleave'] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = '';

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

    /* WEBPACK VAR INJECTION */(function(global) {'use strict';

    /**
     * Construct a new Cleave instance by passing the configuration object
     *
     * @param {String | HTMLElement} element
     * @param {Object} opts
     */
    var Cleave = function (element, opts) {
        var owner = this;

        if (typeof element === 'string') {
            owner.element = document.querySelector(element);
        } else {
            owner.element = ((typeof element.length !== 'undefined') && element.length > 0) ? element[0] : element;
        }

        if (!owner.element) {
            throw new Error('[cleave.js] Please check the element');
        }

        opts.initValue = owner.element.value;

        owner.properties = Cleave.DefaultProperties.assign({}, opts);

        owner.init();
    };

    Cleave.prototype = {
        init: function () {
            var owner = this, pps = owner.properties;

            // no need to use this lib
            if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && (pps.blocksLength === 0 && !pps.prefix)) {
                owner.onInput(pps.initValue);

                return;
            }

            pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);

            owner.isAndroid = Cleave.Util.isAndroid();
            owner.lastInputValue = '';

            owner.onChangeListener = owner.onChange.bind(owner);
            owner.onKeyDownListener = owner.onKeyDown.bind(owner);
            owner.onFocusListener = owner.onFocus.bind(owner);
            owner.onCutListener = owner.onCut.bind(owner);
            owner.onCopyListener = owner.onCopy.bind(owner);

            owner.element.addEventListener('input', owner.onChangeListener);
            owner.element.addEventListener('keydown', owner.onKeyDownListener);
            owner.element.addEventListener('focus', owner.onFocusListener);
            owner.element.addEventListener('cut', owner.onCutListener);
            owner.element.addEventListener('copy', owner.onCopyListener);


            owner.initPhoneFormatter();
            owner.initDateFormatter();
            owner.initTimeFormatter();
            owner.initNumeralFormatter();

            // avoid touch input field if value is null
            // otherwise Firefox will add red box-shadow for <input required />
            if (pps.initValue || (pps.prefix && !pps.noImmediatePrefix)) {
                owner.onInput(pps.initValue);
            }
        },

        initNumeralFormatter: function () {
            var owner = this, pps = owner.properties;

            if (!pps.numeral) {
                return;
            }

            pps.numeralFormatter = new Cleave.NumeralFormatter(
                pps.numeralDecimalMark,
                pps.numeralIntegerScale,
                pps.numeralDecimalScale,
                pps.numeralThousandsGroupStyle,
                pps.numeralPositiveOnly,
                pps.stripLeadingZeroes,
                pps.delimiter
            );
        },

        initTimeFormatter: function() {
            var owner = this, pps = owner.properties;

            if (!pps.time) {
                return;
            }

            pps.timeFormatter = new Cleave.TimeFormatter(pps.timePattern);
            pps.blocks = pps.timeFormatter.getBlocks();
            pps.blocksLength = pps.blocks.length;
            pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
        },

        initDateFormatter: function () {
            var owner = this, pps = owner.properties;

            if (!pps.date) {
                return;
            }

            pps.dateFormatter = new Cleave.DateFormatter(pps.datePattern);
            pps.blocks = pps.dateFormatter.getBlocks();
            pps.blocksLength = pps.blocks.length;
            pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
        },

        initPhoneFormatter: function () {
            var owner = this, pps = owner.properties;

            if (!pps.phone) {
                return;
            }

            // Cleave.AsYouTypeFormatter should be provided by
            // external google closure lib
            try {
                pps.phoneFormatter = new Cleave.PhoneFormatter(
                    new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode),
                    pps.delimiter
                );
            } catch (ex) {
                throw new Error('[cleave.js] Please include phone-type-formatter.{country}.js lib');
            }
        },

        onKeyDown: function (event) {
            var owner = this, pps = owner.properties,
                charCode = event.which || event.keyCode,
                Util = Cleave.Util,
                currentValue = owner.element.value;

            if (charCode === 229
                && Util.isAndroidBackspaceKeydown(owner.lastInputValue, currentValue)
            ) {
                charCode = 8;
            }

            owner.lastInputValue = currentValue;

            // hit backspace when last character is delimiter
            if (charCode === 8 && Util.isDelimiter(currentValue.slice(-pps.delimiterLength), pps.delimiter, pps.delimiters)) {
                pps.backspace = true;

                return;
            }

            pps.backspace = false;
        },

        onChange: function () {
            this.onInput(this.element.value);
        },

        onFocus: function () {
            var owner = this,
                pps = owner.properties;

            Cleave.Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);
        },

        onCut: function (e) {
            this.copyClipboardData(e);
            this.onInput('');
        },

        onCopy: function (e) {
            this.copyClipboardData(e);
        },

        copyClipboardData: function (e) {
            var owner = this,
                pps = owner.properties,
                Util = Cleave.Util,
                inputValue = owner.element.value,
                textToCopy = '';

            if (!pps.copyDelimiter) {
                textToCopy = Util.stripDelimiters(inputValue, pps.delimiter, pps.delimiters);
            } else {
                textToCopy = inputValue;
            }

            try {
                if (e.clipboardData) {
                    e.clipboardData.setData('Text', textToCopy);
                } else {
                    window.clipboardData.setData('Text', textToCopy);
                }

                e.preventDefault();
            } catch (ex) {
                //  empty
            }
        },

        onInput: function (value) {
            var owner = this, pps = owner.properties,
                Util = Cleave.Util;

            // case 1: delete one more character "4"
            // 1234*| -> hit backspace -> 123|
            // case 2: last character is not delimiter which is:
            // 12|34* -> hit backspace -> 1|34*
            // note: no need to apply this for numeral mode
            if (!pps.numeral && pps.backspace && !Util.isDelimiter(value.slice(-pps.delimiterLength), pps.delimiter, pps.delimiters)) {
                value = Util.headStr(value, value.length - pps.delimiterLength);
            }

          //修改Cleave.js源码，添加非官方customFormatter参数，如果更新cleavejs需要对应修改此处以及上面的customFormatter参数声明。
          if (pps.formatter) {
            value = pps.formatter(value);
          }

            // phone formatter
            if (pps.phone) {
                if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
                    pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);
                } else {
                    pps.result = pps.phoneFormatter.format(value);
                }
                owner.updateValueState();

                return;
            }

            // numeral formatter
            if (pps.numeral) {
                if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
                    pps.result = pps.prefix + pps.numeralFormatter.format(value);
                } else {
                    pps.result = pps.numeralFormatter.format(value);
                }
                owner.updateValueState();

                return;
            }

            // date
            if (pps.date) {
                value = pps.dateFormatter.getValidatedDate(value);
            }

            // time
            if (pps.time) {
                value = pps.timeFormatter.getValidatedTime(value);
            }

            // strip delimiters
            value = Util.stripDelimiters(value, pps.delimiter, pps.delimiters);

            // strip prefix
            value = Util.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength, pps.result);

            // strip non-numeric characters
            value = pps.numericOnly ? Util.strip(value, /[^\d]/g) : value;

            // convert case
            value = pps.uppercase ? value.toUpperCase() : value;
            value = pps.lowercase ? value.toLowerCase() : value;

            // prefix
            if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
                value = pps.prefix + value;

                // no blocks specified, no need to do formatting
                if (pps.blocksLength === 0) {
                    pps.result = value;
                    owner.updateValueState();

                    return;
                }
            }

            // update credit card props
            if (pps.creditCard) {
                owner.updateCreditCardPropsByValue(value);
            }

            // strip over length characters
            value = pps.maxLength > 0 ? Util.headStr(value, pps.maxLength) : value;

            // apply blocks
            pps.result = Util.getFormattedValue(
                value,
                pps.blocks, pps.blocksLength,
                pps.delimiter, pps.delimiters, pps.delimiterLazyShow
            );

            owner.updateValueState();
        },

        updateCreditCardPropsByValue: function (value) {
            var owner = this, pps = owner.properties,
                Util = Cleave.Util,
                creditCardInfo;

            // At least one of the first 4 characters has changed
            if (Util.headStr(pps.result, 4) === Util.headStr(value, 4)) {
                return;
            }

            creditCardInfo = Cleave.CreditCardDetector.getInfo(value, pps.creditCardStrictMode);

            pps.blocks = creditCardInfo.blocks;
            pps.blocksLength = pps.blocks.length;
            pps.maxLength = Util.getMaxLength(pps.blocks);

            // credit card type changed
            if (pps.creditCardType !== creditCardInfo.type) {
                pps.creditCardType = creditCardInfo.type;

                pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);
            }
        },

        updateValueState: function () {
            var owner = this,
                Util = Cleave.Util,
                pps = owner.properties;

            if (!owner.element) {
                return;
            }

            var endPos = owner.element.selectionEnd;
            var oldValue = owner.element.value;
            var newValue = pps.result;

            endPos = Util.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);

            // fix Android browser type="text" input field
            // cursor not jumping issue
            if (owner.isAndroid) {
                window.setTimeout(function () {
                    owner.element.value = newValue;
                    Util.setSelection(owner.element, endPos, pps.document, false);
                    owner.callOnValueChanged();
                }, 1);

                return;
            }

            owner.element.value = newValue;
            Util.setSelection(owner.element, endPos, pps.document, false);
            owner.callOnValueChanged();
        },

        callOnValueChanged: function () {
            var owner = this,
                pps = owner.properties;

            pps.onValueChanged.call(owner, {
                target: {
                    value: pps.result,
                    rawValue: owner.getRawValue()
                }
            });
        },

        setPhoneRegionCode: function (phoneRegionCode) {
            var owner = this, pps = owner.properties;

            pps.phoneRegionCode = phoneRegionCode;
            owner.initPhoneFormatter();
            owner.onChange();
        },

        setRawValue: function (value) {
            var owner = this, pps = owner.properties;

            value = value !== undefined && value !== null ? value.toString() : '';

            if (pps.numeral) {
                value = value.replace('.', pps.numeralDecimalMark);
            }

            pps.backspace = false;

            owner.element.value = value;
            owner.onInput(value);
        },

        getRawValue: function () {
            var owner = this,
                pps = owner.properties,
                Util = Cleave.Util,
                rawValue = owner.element.value;

            if (pps.rawValueTrimPrefix) {
                rawValue = Util.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result);
            }

            if (pps.numeral) {
                rawValue = pps.numeralFormatter.getRawValue(rawValue);
            } else {
                rawValue = Util.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);
            }

            return rawValue;
        },

        getISOFormatDate: function () {
            var owner = this,
                pps = owner.properties;

            return pps.date ? pps.dateFormatter.getISOFormatDate() : '';
        },

        getFormattedValue: function () {
            return this.element.value;
        },

        destroy: function () {
            var owner = this;

            owner.element.removeEventListener('input', owner.onChangeListener);
            owner.element.removeEventListener('keydown', owner.onKeyDownListener);
            owner.element.removeEventListener('focus', owner.onFocusListener);
            owner.element.removeEventListener('cut', owner.onCutListener);
            owner.element.removeEventListener('copy', owner.onCopyListener);
        },

        toString: function () {
            return '[Cleave Object]';
        }
    };

    Cleave.NumeralFormatter = __webpack_require__(1);
    Cleave.DateFormatter = __webpack_require__(2);
    Cleave.TimeFormatter = __webpack_require__(3);
    Cleave.PhoneFormatter = __webpack_require__(4);
    Cleave.CreditCardDetector = __webpack_require__(5);
    Cleave.Util = __webpack_require__(6);
    Cleave.DefaultProperties = __webpack_require__(7);

    // for angular directive
    ((typeof global === 'object' && global) ? global : window)['Cleave'] = Cleave;

    // CommonJS
    module.exports = Cleave;

    /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())));

/***/ }),
/* 1 */
/***/ (function(module, exports) {

    'use strict';

    var NumeralFormatter = function (numeralDecimalMark,
                                     numeralIntegerScale,
                                     numeralDecimalScale,
                                     numeralThousandsGroupStyle,
                                     numeralPositiveOnly,
                                     stripLeadingZeroes,
                                     delimiter) {
        var owner = this;

        owner.numeralDecimalMark = numeralDecimalMark || '.';
        owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;
        owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;
        owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;
        owner.numeralPositiveOnly = !!numeralPositiveOnly;
        owner.stripLeadingZeroes = stripLeadingZeroes !== false;
        owner.delimiter = (delimiter || delimiter === '') ? delimiter : ',';
        owner.delimiterRE = delimiter ? new RegExp('\\' + delimiter, 'g') : '';
    };

    NumeralFormatter.groupStyle = {
        thousand: 'thousand',
        lakh:     'lakh',
        wan:      'wan',
        none:     'none'    
    };

    NumeralFormatter.prototype = {
        getRawValue: function (value) {
            return value.replace(this.delimiterRE, '').replace(this.numeralDecimalMark, '.');
        },

        format: function (value) {
            var owner = this, parts, partInteger, partDecimal = '';

            // strip alphabet letters
            value = value.replace(/[A-Za-z]/g, '')
                // replace the first decimal mark with reserved placeholder
                .replace(owner.numeralDecimalMark, 'M')

                // strip non numeric letters except minus and "M"
                // this is to ensure prefix has been stripped
                .replace(/[^\dM-]/g, '')

                // replace the leading minus with reserved placeholder
                .replace(/^\-/, 'N')

                // strip the other minus sign (if present)
                .replace(/\-/g, '')

                // replace the minus sign (if present)
                .replace('N', owner.numeralPositiveOnly ? '' : '-')

                // replace decimal mark
                .replace('M', owner.numeralDecimalMark);

            // strip any leading zeros
            if (owner.stripLeadingZeroes) {
                value = value.replace(/^(-)?0+(?=\d)/, '$1');
            }

            partInteger = value;

            if (value.indexOf(owner.numeralDecimalMark) >= 0) {
                parts = value.split(owner.numeralDecimalMark);
                partInteger = parts[0];
                partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);
            }

            if (owner.numeralIntegerScale > 0) {
              partInteger = partInteger.slice(0, owner.numeralIntegerScale + (value.slice(0, 1) === '-' ? 1 : 0));
            }

            switch (owner.numeralThousandsGroupStyle) {
            case NumeralFormatter.groupStyle.lakh:
                partInteger = partInteger.replace(/(\d)(?=(\d\d)+\d$)/g, '$1' + owner.delimiter);

                break;

            case NumeralFormatter.groupStyle.wan:
                partInteger = partInteger.replace(/(\d)(?=(\d{4})+$)/g, '$1' + owner.delimiter);

                break;

            case NumeralFormatter.groupStyle.thousand:
                partInteger = partInteger.replace(/(\d)(?=(\d{3})+$)/g, '$1' + owner.delimiter);

                break;
            }

            return partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : '');
        }
    };

    module.exports = NumeralFormatter;


/***/ }),
/* 2 */
/***/ (function(module, exports) {

    'use strict';

    var DateFormatter = function (datePattern) {
        var owner = this;

        owner.date = [];
        owner.blocks = [];
        owner.datePattern = datePattern;
        owner.initBlocks();
    };

    DateFormatter.prototype = {
        initBlocks: function () {
            var owner = this;
            owner.datePattern.forEach(function (value) {
                if (value === 'Y') {
                    owner.blocks.push(4);
                } else {
                    owner.blocks.push(2);
                }
            });
        },

        getISOFormatDate: function () {
            var owner = this,
                date = owner.date;

            return date[2] ? (
                date[2] + '-' + owner.addLeadingZero(date[1]) + '-' + owner.addLeadingZero(date[0])
            ) : '';
        },

        getBlocks: function () {
            return this.blocks;
        },

        getValidatedDate: function (value) {
            var owner = this, result = '';

            value = value.replace(/[^\d]/g, '');

            owner.blocks.forEach(function (length, index) {
                if (value.length > 0) {
                    var sub = value.slice(0, length),
                        sub0 = sub.slice(0, 1),
                        rest = value.slice(length);

                    switch (owner.datePattern[index]) {
                    case 'd':
                        if (sub === '00') {
                            sub = '01';
                        } else if (parseInt(sub0, 10) > 3) {
                            sub = '0' + sub0;
                        } else if (parseInt(sub, 10) > 31) {
                            sub = '31';
                        }

                        break;

                    case 'm':
                        if (sub === '00') {
                            sub = '01';
                        } else if (parseInt(sub0, 10) > 1) {
                            sub = '0' + sub0;
                        } else if (parseInt(sub, 10) > 12) {
                            sub = '12';
                        }

                        break;
                    }

                    result += sub;

                    // update remaining string
                    value = rest;
                }
            });

            return this.getFixedDateString(result);
        },

        getFixedDateString: function (value) {
            var owner = this, datePattern = owner.datePattern, date = [],
                dayIndex = 0, monthIndex = 0, yearIndex = 0,
                dayStartIndex = 0, monthStartIndex = 0, yearStartIndex = 0,
                day, month, year, fullYearDone = false;

            // mm-dd || dd-mm
            if (value.length === 4 && datePattern[0].toLowerCase() !== 'y' && datePattern[1].toLowerCase() !== 'y') {
                dayStartIndex = datePattern[0] === 'd' ? 0 : 2;
                monthStartIndex = 2 - dayStartIndex;
                day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
                month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);

                date = this.getFixedDate(day, month, 0);
            }

            // yyyy-mm-dd || yyyy-dd-mm || mm-dd-yyyy || dd-mm-yyyy || dd-yyyy-mm || mm-yyyy-dd
            if (value.length === 8) {
                datePattern.forEach(function (type, index) {
                    switch (type) {
                    case 'd':
                        dayIndex = index;
                        break;
                    case 'm':
                        monthIndex = index;
                        break;
                    default:
                        yearIndex = index;
                        break;
                    }
                });

                yearStartIndex = yearIndex * 2;
                dayStartIndex = (dayIndex <= yearIndex) ? dayIndex * 2 : (dayIndex * 2 + 2);
                monthStartIndex = (monthIndex <= yearIndex) ? monthIndex * 2 : (monthIndex * 2 + 2);

                day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
                month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
                year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);

                fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;

                date = this.getFixedDate(day, month, year);
            }

            owner.date = date;

            return date.length === 0 ? value : datePattern.reduce(function (previous, current) {
                switch (current) {
                case 'd':
                    return previous + owner.addLeadingZero(date[0]);
                case 'm':
                    return previous + owner.addLeadingZero(date[1]);
                default:
                    return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2]) : '');
                }
            }, '');
        },

        getFixedDate: function (day, month, year) {
            day = Math.min(day, 31);
            month = Math.min(month, 12);
            year = parseInt((year || 0), 10);

            if ((month < 7 && month % 2 === 0) || (month > 8 && month % 2 === 1)) {
                day = Math.min(day, month === 2 ? (this.isLeapYear(year) ? 29 : 28) : 30);
            }

            return [day, month, year];
        },

        isLeapYear: function (year) {
            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
        },

        addLeadingZero: function (number) {
            return (number < 10 ? '0' : '') + number;
        },

        addLeadingZeroForYear: function (number) {
            return (number < 10 ? '000' : (number < 100 ? '00' : (number < 1000 ? '0' : ''))) + number;
        }
    };

    module.exports = DateFormatter;



/***/ }),
/* 3 */
/***/ (function(module, exports) {

    'use strict';

    var TimeFormatter = function (timePattern) {
        var owner = this;

        owner.time = [];
        owner.blocks = [];
        owner.timePattern = timePattern;
        owner.initBlocks();
    };

    TimeFormatter.prototype = {
        initBlocks: function () {
            var owner = this;
            owner.timePattern.forEach(function () {
                owner.blocks.push(2);
            });
        },

        getISOFormatTime: function () {
            var owner = this,
                time = owner.time;

            return time[2] ? (
                owner.addLeadingZero(time[0]) + ':' + owner.addLeadingZero(time[1]) + ':' + owner.addLeadingZero(time[2])
            ) : '';
        },

        getBlocks: function () {
            return this.blocks;
        },

        getValidatedTime: function (value) {
            var owner = this, result = '';

            value = value.replace(/[^\d]/g, '');

            owner.blocks.forEach(function (length, index) {
                if (value.length > 0) {
                    var sub = value.slice(0, length),
                        sub0 = sub.slice(0, 1),
                        rest = value.slice(length);

                    switch (owner.timePattern[index]) {

                    case 'h':
                        if (parseInt(sub0, 10) > 2) {
                            sub = '0' + sub0;
                        } else if (parseInt(sub, 10) > 23) {
                            sub = '23';
                        }

                        break;

                    case 'm':
                    case 's':
                        if (parseInt(sub0, 10) > 5) {
                            sub = '0' + sub0;
                        } else if (parseInt(sub, 10) > 60) {
                            sub = '60';
                        }
                        break;
                    }

                    result += sub;

                    // update remaining string
                    value = rest;
                }
            });

            return this.getFixedTimeString(result);
        },

        getFixedTimeString: function (value) {
            var owner = this, timePattern = owner.timePattern, time = [],
                secondIndex = 0, minuteIndex = 0, hourIndex = 0,
                secondStartIndex = 0, minuteStartIndex = 0, hourStartIndex = 0,
                second, minute, hour;

            if (value.length === 6) {
                timePattern.forEach(function (type, index) {
                    switch (type) {
                    case 's':
                        secondIndex = index * 2;
                        break;
                    case 'm':
                        minuteIndex = index * 2;
                        break;
                    case 'h':
                        hourIndex = index * 2;
                        break;
                    }
                });

                hourStartIndex = hourIndex;
                minuteStartIndex = minuteIndex;
                secondStartIndex = secondIndex;

                second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);
                minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
                hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);

                time = this.getFixedTime(hour, minute, second);
            }

            if (value.length === 4 && owner.timePattern.indexOf('s') < 0) {
                timePattern.forEach(function (type, index) {
                    switch (type) {
                    case 'm':
                        minuteIndex = index * 2;
                        break;
                    case 'h':
                        hourIndex = index * 2;
                        break;
                    }
                });

                hourStartIndex = hourIndex;
                minuteStartIndex = minuteIndex;

                second = 0;
                minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
                hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);

                time = this.getFixedTime(hour, minute, second);
            }

            owner.time = time;

            return time.length === 0 ? value : timePattern.reduce(function (previous, current) {
                switch (current) {
                case 's':
                    return previous + owner.addLeadingZero(time[2]);
                case 'm':
                    return previous + owner.addLeadingZero(time[1]);
                case 'h':
                    return previous + owner.addLeadingZero(time[0]);
                }
            }, '');
        },

        getFixedTime: function (hour, minute, second) {
            second = Math.min(parseInt(second || 0, 10), 60);
            minute = Math.min(minute, 60);
            hour = Math.min(hour, 60);

            return [hour, minute, second];
        },

        addLeadingZero: function (number) {
            return (number < 10 ? '0' : '') + number;
        }
    };

    module.exports = TimeFormatter;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

    'use strict';

    var PhoneFormatter = function (formatter, delimiter) {
        var owner = this;

        owner.delimiter = (delimiter || delimiter === '') ? delimiter : ' ';
        owner.delimiterRE = delimiter ? new RegExp('\\' + delimiter, 'g') : '';

        owner.formatter = formatter;
    };

    PhoneFormatter.prototype = {
        setFormatter: function (formatter) {
            this.formatter = formatter;
        },

        format: function (phoneNumber) {
            var owner = this;

            owner.formatter.clear();

            // only keep number and +
            phoneNumber = phoneNumber.replace(/[^\d+]/g, '');

            // strip non-leading +
            phoneNumber = phoneNumber.replace(/^\+/, 'B').replace(/\+/g, '').replace('B', '+');

            // strip delimiter
            phoneNumber = phoneNumber.replace(owner.delimiterRE, '');

            var result = '', current, validated = false;

            for (var i = 0, iMax = phoneNumber.length; i < iMax; i++) {
                current = owner.formatter.inputDigit(phoneNumber.charAt(i));

                // has ()- or space inside
                if (/[\s()-]/g.test(current)) {
                    result = current;

                    validated = true;
                } else {
                    if (!validated) {
                        result = current;
                    }
                    // else: over length input
                    // it turns to invalid number again
                }
            }

            // strip ()
            // e.g. US: 7161234567 returns (716) 123-4567
            result = result.replace(/[()]/g, '');
            // replace library delimiter with user customized delimiter
            result = result.replace(/[\s-]/g, owner.delimiter);

            return result;
        }
    };

    module.exports = PhoneFormatter;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

    'use strict';

    var CreditCardDetector = {
        blocks: {
            uatp:          [4, 5, 6],
            amex:          [4, 6, 5],
            diners:        [4, 6, 4],
            discover:      [4, 4, 4, 4],
            mastercard:    [4, 4, 4, 4],
            dankort:       [4, 4, 4, 4],
            instapayment:  [4, 4, 4, 4],
            jcb15:         [4, 6, 5],
            jcb:           [4, 4, 4, 4],
            maestro:       [4, 4, 4, 4],
            visa:          [4, 4, 4, 4],
            mir:           [4, 4, 4, 4],
            unionPay:      [4, 4, 4, 4],
            general:       [4, 4, 4, 4],
            generalStrict: [4, 4, 4, 7]
        },

        re: {
            // starts with 1; 15 digits, not starts with 1800 (jcb card)
            uatp: /^(?!1800)1\d{0,14}/,

            // starts with 34/37; 15 digits
            amex: /^3[47]\d{0,13}/,

            // starts with 6011/65/644-649; 16 digits
            discover: /^(?:6011|65\d{0,2}|64[4-9]\d?)\d{0,12}/,

            // starts with 300-305/309 or 36/38/39; 14 digits
            diners: /^3(?:0([0-5]|9)|[689]\d?)\d{0,11}/,

            // starts with 51-55/2221–2720; 16 digits
            mastercard: /^(5[1-5]\d{0,2}|22[2-9]\d{0,1}|2[3-7]\d{0,2})\d{0,12}/,

            // starts with 5019/4175/4571; 16 digits
            dankort: /^(5019|4175|4571)\d{0,12}/,

            // starts with 637-639; 16 digits
            instapayment: /^63[7-9]\d{0,13}/,

            // starts with 2131/1800; 15 digits
            jcb15: /^(?:2131|1800)\d{0,11}/,

            // starts with 2131/1800/35; 16 digits
            jcb: /^(?:35\d{0,2})\d{0,12}/,

            // starts with 50/56-58/6304/67; 16 digits
            maestro: /^(?:5[0678]\d{0,2}|6304|67\d{0,2})\d{0,12}/,

            // starts with 22; 16 digits
            mir: /^220[0-4]\d{0,12}/,

            // starts with 4; 16 digits
            visa: /^4\d{0,15}/,

            // starts with 62; 16 digits
            unionPay: /^62\d{0,14}/
        },

        getInfo: function (value, strictMode) {
            var blocks = CreditCardDetector.blocks,
                re = CreditCardDetector.re;

            // Some credit card can have up to 19 digits number.
            // Set strictMode to true will remove the 16 max-length restrain,
            // however, I never found any website validate card number like
            // this, hence probably you don't want to enable this option.
            strictMode = !!strictMode;

            for (var key in re) {
                if (re[key].test(value)) {
                    var block;

                    if (strictMode) {
                        block = blocks.generalStrict;
                    } else {
                        block = blocks[key];
                    }

                    return {
                        type: key,
                        blocks: block
                    };
                }
            }

            return {
                type:   'unknown',
                blocks: strictMode ? blocks.generalStrict : blocks.general
            };
        }
    };

    module.exports = CreditCardDetector;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

    'use strict';

    var Util = {
        noop: function () {
        },

        strip: function (value, re) {
            return value.replace(re, '');
        },

        isDelimiter: function (letter, delimiter, delimiters) {
            // single delimiter
            if (delimiters.length === 0) {
                return letter === delimiter;
            }

            // multiple delimiters
            return delimiters.some(function (current) {
                if (letter === current) {
                    return true;
                }
            });
        },

        getDelimiterREByDelimiter: function (delimiter) {
            return new RegExp(delimiter.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1'), 'g');
        },

        getNextCursorPosition: function (prevPos, oldValue, newValue, delimiter, delimiters) {
          // If cursor was at the end of value, just place it back.
          // Because new value could contain additional chars.
          if (oldValue.length === prevPos) {
              return newValue.length;
          }

          return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter ,delimiters);
        },

        getPositionOffset: function (prevPos, oldValue, newValue, delimiter, delimiters) {
            var oldRawValue, newRawValue, lengthOffset;

            oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);
            newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);
            lengthOffset = oldRawValue.length - newRawValue.length;

            return (lengthOffset !== 0) ? (lengthOffset / Math.abs(lengthOffset)) : 0;
        },

        stripDelimiters: function (value, delimiter, delimiters) {
            var owner = this;

            // single delimiter
            if (delimiters.length === 0) {
                var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : '';

                return value.replace(delimiterRE, '');
            }

            // multiple delimiters
            delimiters.forEach(function (current) {
                value = value.replace(owner.getDelimiterREByDelimiter(current), '');
            });

            return value;
        },

        headStr: function (str, length) {
            return str.slice(0, length);
        },

        getMaxLength: function (blocks) {
            return blocks.reduce(function (previous, current) {
                return previous + current;
            }, 0);
        },

        // strip value by prefix length
        // for prefix: PRE
        // (PRE123, 3) -> 123
        // (PR123, 3) -> 23 this happens when user hits backspace in front of "PRE"
        getPrefixStrippedValue: function (value, prefix, prefixLength, prevValue) {
            if (value.slice(0, prefixLength) !== prefix) {

                // Check whether if it is a deletion
                if (value.length < prevValue.length) {
                    value = value.length > prefixLength ? prevValue : prefix;
                } else {
                    var diffIndex = this.getFirstDiffIndex(prefix, value.slice(0, prefixLength));
                    value = prefix + value.slice(diffIndex, diffIndex + 1) + value.slice(prefixLength + 1);
                }
            }

            return value.slice(prefixLength);
        },

        getFirstDiffIndex: function (prev, current) {
            var index = 0;

            while (prev.charAt(index) === current.charAt(index)) {
                if (prev.charAt(index++) === '') {
                    return -1;
                }
            }

            return index;
        },

        getFormattedValue: function (value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {
            var result = '',
                multipleDelimiters = delimiters.length > 0,
                currentDelimiter;

            // no options, normal input
            if (blocksLength === 0) {
                return value;
            }

            blocks.forEach(function (length, index) {
                if (value.length > 0) {
                    var sub = value.slice(0, length),
                        rest = value.slice(length);

                    if (multipleDelimiters) {
                        currentDelimiter = delimiters[delimiterLazyShow ? (index - 1) : index] || currentDelimiter;
                    } else {
                        currentDelimiter = delimiter;
                    }

                    if (delimiterLazyShow) {
                        if (index > 0) {
                            result += currentDelimiter;
                        }

                        result += sub;
                    } else {
                        result += sub;

                        if (sub.length === length && index < blocksLength - 1) {
                            result += currentDelimiter;
                        }
                    }

                    // update remaining string
                    value = rest;
                }
            });

            return result;
        },

        // move cursor to the end
        // the first time user focuses on an input with prefix
        fixPrefixCursor: function (el, prefix, delimiter, delimiters) {
            if (!el) {
                return;
            }

            var val = el.value,
                appendix = delimiter || (delimiters[0] || ' ');

            if (!el.setSelectionRange || !prefix || (prefix.length + appendix.length) < val.length) {
                return;
            }

            var len = val.length * 2;

            // set timeout to avoid blink
            setTimeout(function () {
                el.setSelectionRange(len, len);
            }, 1);
        },

        setSelection: function (element, position, doc) {
            if (element !== this.getActiveElement(doc)) {
                return;
            }

            // cursor is already in the end
            if (element && element.value.length <= position) {
              return;
            }

            if (element.createTextRange) {
                var range = element.createTextRange();

                range.move('character', position);
                range.select();
            } else {
                try {
                    element.setSelectionRange(position, position);
                } catch (e) {
                    // eslint-disable-next-line
                    console.warn('The input element type does not support selection');
                }
            }
        },
        
        getActiveElement: function(parent) {
            var activeElement = parent.activeElement;
            if (activeElement && activeElement.shadowRoot) {
                return this.getActiveElement(activeElement.shadowRoot);
            }
            return activeElement;
        },

        isAndroid: function () {
            return navigator && /android/i.test(navigator.userAgent);
        },

        // On Android chrome, the keyup and keydown events
        // always return key code 229 as a composition that
        // buffers the user’s keystrokes
        // see https://github.com/nosir/cleave.js/issues/147
        isAndroidBackspaceKeydown: function (lastInputValue, currentInputValue) {
            if (!this.isAndroid() || !lastInputValue || !currentInputValue) {
                return false;
            }

            return currentInputValue === lastInputValue.slice(0, -1);
        }
    };

    module.exports = Util;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

    /* WEBPACK VAR INJECTION */(function(global) {'use strict';

    /**
     * Props Assignment
     *
     * Separate this, so react module can share the usage
     */
    var DefaultProperties = {
        // Maybe change to object-assign
        // for now just keep it as simple
        assign: function (target, opts) {
            target = target || {};
            opts = opts || {};

            // credit card
            target.creditCard = !!opts.creditCard;
            target.creditCardStrictMode = !!opts.creditCardStrictMode;
            target.creditCardType = '';
            target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || (function () {});

            // phone
            target.phone = !!opts.phone;
            target.phoneRegionCode = opts.phoneRegionCode || 'AU';
            target.phoneFormatter = {};

            // time
            target.time = !!opts.time;
            target.timePattern = opts.timePattern || ['h', 'm', 's'];
            target.timeFormatter = {};

            // date
            target.date = !!opts.date;
            target.datePattern = opts.datePattern || ['d', 'm', 'Y'];
            target.dateFormatter = {};

            // numeral
            target.numeral = !!opts.numeral;
            target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;
            target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;
            target.numeralDecimalMark = opts.numeralDecimalMark || '.';
            target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || 'thousand';
            target.numeralPositiveOnly = !!opts.numeralPositiveOnly;
            target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;

            // others
            target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;

            target.uppercase = !!opts.uppercase;
            target.lowercase = !!opts.lowercase;

          target.formatter = typeof opts.customFormatter === 'function' ? opts.customFormatter : null;

            target.prefix = (target.creditCard || target.date) ? '' : (opts.prefix || '');
            target.noImmediatePrefix = !!opts.noImmediatePrefix;
            target.prefixLength = target.prefix.length;
            target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;
            target.copyDelimiter = !!opts.copyDelimiter;

            target.initValue = (opts.initValue !== undefined && opts.initValue !== null) ? opts.initValue.toString() : '';

            target.delimiter =
                (opts.delimiter || opts.delimiter === '') ? opts.delimiter :
                    (opts.date ? '/' :
                        (opts.time ? ':' :
                            (opts.numeral ? ',' :
                                (opts.phone ? ' ' :
                                    ' '))));
            target.delimiterLength = target.delimiter.length;
            target.delimiterLazyShow = !!opts.delimiterLazyShow;
            target.delimiters = opts.delimiters || [];

            target.blocks = opts.blocks || [];
            target.blocksLength = target.blocks.length;

            target.root = (typeof global === 'object' && global) ? global : window;
            target.document = opts.document || target.root.document;

            target.maxLength = 0;

            target.backspace = false;
            target.result = '';

            target.onValueChanged = opts.onValueChanged || (function () {});

            return target;
        }
    };

    module.exports = DefaultProperties;

    /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())));

/***/ })
/******/ ]);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'Cleave'], definition);
  } else {
    context.VueInput = definition(context.Vue, context.VueUtil, context.Cleave);
    delete context.VueInput;
    delete context.Cleave;
  }
})(this, function(Vue, VueUtil, Cleave) {
  'use strict';

  var hiddenTextarea;
  var HIDDEN_STYLE = '\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n';
  var CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

  function calculateNodeStyling(targetElement) {
    var style = window.getComputedStyle(targetElement);
    var boxSizing = style.getPropertyValue('box-sizing');
    var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
    var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
    var contextStyle = CONTEXT_STYLE.map(function (name) {
      return ''.concat(name, ':').concat(style.getPropertyValue(name));
    }).join(';');
    return {
      contextStyle: contextStyle,
      paddingSize: paddingSize,
      borderSize: borderSize,
      boxSizing: boxSizing
    };
  }

  function calcTextareaHeight(targetElement) {
    var minRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var maxRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement('textarea');
      document.body.appendChild(hiddenTextarea);
    }

    var _calculateNodeStyling = calculateNodeStyling(targetElement),
        paddingSize = _calculateNodeStyling.paddingSize,
        borderSize = _calculateNodeStyling.borderSize,
        boxSizing = _calculateNodeStyling.boxSizing,
        contextStyle = _calculateNodeStyling.contextStyle;

    hiddenTextarea.setAttribute('style', ''.concat(contextStyle, ';').concat(HIDDEN_STYLE));
    hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';
    var height = hiddenTextarea.scrollHeight;
    var result = {};

    if (boxSizing === 'border-box') {
      height = height + borderSize;
    } else if (boxSizing === 'content-box') {
      height = height - paddingSize;
    }

    hiddenTextarea.value = '';
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

    if (minRows !== null) {
      var minHeight = singleRowHeight * minRows;

      if (boxSizing === 'border-box') {
        minHeight = minHeight + paddingSize + borderSize;
      }

      height = Math.max(minHeight, height);
      result.minHeight = ''.concat(minHeight, 'px');
    }

    if (maxRows !== null) {
      var maxHeight = singleRowHeight * maxRows;

      if (boxSizing === 'border-box') {
        maxHeight = maxHeight + paddingSize + borderSize;
      }

      height = Math.min(maxHeight, height);
    }

    result.height = ''.concat(height, 'px');
    hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
    hiddenTextarea = null;
    return result;
  }

  var VueInput = {
    template: 
    '<div :class="[type === \'textarea\' ? \'vue-textarea\' : \'vue-input\', size ? \'vue-input--\' + size : \'\', {\'is-disabled\': disabled, '+
    '     \'vue-input-group\': $slots.prepend || $slots.append, \'vue-input-group--append\': $slots.append, \'vue-input-group--prepend\': $slots.prepend,'+
    '     \'is-readonly\': readonly, \'vue-input--prefix\': $slots.prefix || prefixIcon'+
    '     }, size&& ($slots.prefix || prefixIcon) ? \'vue-input--prefix--\' + size : \'\']" >'+

    '    <template v-if="type !== \'textarea\'">'+
    '        <div class="vue-input-group__prepend" v-if="$slots.prepend">'+
    '            <slot name="prepend"></slot>'+
    '        </div>'+
    '        <slot name="icon">'+
    '            <i :class="[\'vue-input__icon\', icon, size ? \'vue-icon--\' + size : \'\', onIconClick ? \'is-clickable\' : \'\']" v-if="icon" @click="handleIconClick" ref="icon"></i>'+
    '        </slot>'+
    '        <input :style="inputStyle" v-if="type !== \'textarea\'" class="vue-input__inner" :pattern="isMobile && keyBoardType==\'onlynumber\' ? \'[0-9]*\' : null" :type="isMobile && keyBoardType ? keyBoardType==\'onlynumber\'?\'number\':keyBoardType : type==\'number\' ? \'input\' : type" :name="name" '+
    '               :placeholder="placeholder" :disabled="disabled" :readonly="readonly" :maxlength="maxlength" '+
    '               :minlength="minlength" :autocomplete="autoComplete" :autofocus="autofocus" :tabindex="tabindex" '+
    '               :min="min" :max="max" :form="form" :value="currentValue" ref="input" @input="handleInput" '+
    '               @focus="handleFocus" @blur="handleBlur" @change="handleChange" @compositionstart="handleComposition" '+
    '               @compositionupdate="handleComposition" @compositionend="handleComposition">'+
    
    '        <span class="vue-input__prefix" v-if="$slots.prefix || prefixIcon"> '+
    '          <slot name="prefix"></slot> '+
    '          <i class="vue-input__icon" '+
    '             v-if="prefixIcon" '+
    '             :class="[prefixIcon,size ? \'vue-icon--\' + size : \'\']"> '+
    '          </i> '+
    '        </span> '+

    '        <i class="vue-input__icon vue-icon-loading" v-if="validating"></i>'+
    '        <div class="vue-input-group__append" v-if="$slots.append">'+
    '            <slot name="append"></slot>'+
    '        </div>'+
    '    </template>'+
    '    <textarea v-else class="vue-textarea__inner" :value="currentValue" @input="handleInput" ref="textarea" '+
    '             :name="name" :placeholder="placeholder" :disabled="disabled" :style="textareaStyle" :readonly="readonly" '+
    '             :rows="rows" :form="form" :autofocus="autofocus" :tabindex="tabindex" :maxlength="maxlength" :minlength="minlength" '+
    '             @focus="handleFocus" @blur="handleBlur" @change="handleChange" @compositionstart="handleComposition" @compositionupdate="handleComposition" '+
    '             @compositionend="handleComposition"></textarea>'+
    '</div>',
    name: 'VueInput',
    mixins: [VueUtil.component.emitter],
    data: function() {
      return {
        currentValue: this.value,
        textareaCalcStyle: {},
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
      };
    },
    props: {
      type: {
        type: String,
        default: 'text'
      },
      value: [String, Number],
      maxlength: Number,
      minlength: Number,
      placeholder: String,
      disabled: Boolean,
      size: String,
      prefixIcon: String,
      icon: String,
      rows: {
        type: Number,
        default: 2
      },
      cleave: {
        type: Object,
        default: function() {return null;}
      },
      autosize: {
        type: [Boolean, Object],
        default: false
      },
      autoComplete: {
        type: String,
        default: 'off'
      },
      name: String,
      readonly: Boolean,
      max: {},
      min: {},
      resize: String,
      autofocus: Boolean,
      textAlign: String,
      form: String,
      onIconClick: Function,
      tabindex: Number, //tabindex 的最大值不应超过 32767。如果没有指定，它的默认值为 0。
      noime: Boolean,
      validateEvent: {
        type: Boolean,
        default: true
      },
      keyBoardType:String
    },
    computed: {
      textareaStyle: function () {
        return VueUtil.merge({}, this.textareaCalcStyle, {
          resize: this.resize
        });
      },
      validating: function() {
        return this.$parent.validateState === 'validating';
      },
      inputStyle: function() {
        var style={};
        if (['center', 'right'].indexOf(this.textAlign) !== -1) {
          style.textAlign = this.textAlign;
        }
        return style;
      }
    },
    watch: {
      'value': function(val) {
        this.setCurrentValue(val, true);
      }
    },
    methods: {
      focus: function() {
        if (this.type !== 'textarea') {
          this.$refs.input.focus();
        } else {
          this.$refs.textarea.focus();
        }
      },
      handleChange: function(event) {
        this.$emit('change', event.target.value);
      },
      handleBlur: function(event) {
        this.$emit('blur', event);
        if (this.validateEvent) {
          this.dispatch('VueFormItem', 'vue.form.blur', [this.currentValue]);
        }
      },
      inputSelect: function() {
        this.$refs.input.select();
      },
      resizeTextarea: function () {
        var autosize = this.autosize,
            type = this.type;
        if (type !== 'textarea') return;
    
        if (!autosize) {
          this.textareaCalcStyle = {
            minHeight: calcTextareaHeight(this.$refs.textarea).minHeight
          };
          return;
        }
    
        var minRows = autosize.minRows;
        var maxRows = autosize.maxRows;
        this.textareaCalcStyle = calcTextareaHeight(this.$refs.textarea, minRows, maxRows);
      },
      handleFocus: function(event) {
        this.$emit('focus', event);
      },
      handleComposition: function(event) {
        if (event.type === 'compositionend') {
          this.handleInput(event);
        }
      },
      handleInput: function(event) {
        if (this.noime) {
          if(!event.isComposing) {
            this.setCurrentValue(event.target.value);
          } else {
            this.setCurrentValue(this.currentValue,true);
          }
        } else {
          this.setCurrentValue(event.target.value);
        }
      },
      handleIconClick: function(event) {
        if (this.onIconClick) {
          this.onIconClick(event);
        }
        this.$emit('click', event);
      },
      setCurrentValue: function(value, watchFlg) {
        if (!VueUtil.isDef(value)) value = '';
        var self = this;
        if (value === self.currentValue && !watchFlg)
          return;
        self.$nextTick(function() {
          self.resizeTextarea();
        });
        if (self.type !== 'textarea' && self.cleave !== null) {
          var endPos = self.$refs.input.selectionEnd;
          self.$refs.input.value = value;
          var cleaveObj = new Cleave(self.$refs.input, self.cleave);
          self.currentValue = cleaveObj.getFormattedValue();
          if (cleaveObj.getFormattedValue().length >= value.length && !watchFlg) { 
            self.currentValue = value;
          }
          value = cleaveObj.getRawValue();
          cleaveObj.destroy && cleaveObj.destroy();

          var pos = Cleave.Util.getNextCursorPosition(endPos, self.currentValue, cleaveObj.properties.result, cleaveObj.properties.delimiter, cleaveObj.properties.delimiters);
          if (document.activeElement == self.$refs.input) {
            self.$refs.input.setSelectionRange(pos, pos);
          }
          
        } else {
          self.currentValue = value;
        }
        if (self.type == 'number' && VueUtil.isNumberStr(value)) {
          value = parseFloat(value);
        }
        if (!watchFlg) {
          self.$emit('input', value);
        }
        if (self.validateEvent) {
          self.dispatch('VueFormItem', 'vue.form.change', [value]);
        }
      }
    },
    created: function() {
      this.$on('inputSelect', this.inputSelect);
    },
    mounted: function() {
      this.setCurrentValue(this.currentValue, true);
      this.resizeTextarea();
    }
  };
  Vue.component(VueInput.name, VueInput);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueAlert = definition(context.Vue);
    delete context.VueAlert;
  }
})(this, function(Vue) {
  'use strict';
  var VueAlert = {
    template: '<div :class="[\'vue-alert\', typeClass]" v-if="visible"><i :class="[\'vue-alert__icon\', iconClass, \'is-big\']" v-if="showIcon"></i><div class="vue-alert__content"><span class="vue-alert__title is-bold" v-if="title">{{title}}</span><div class="vue-alert__description"><slot></slot></div><i :class="[\'vue-alert__closebtn\', {\'is-customed\': closeText !== \'\', \'vue-icon-close\': closeText === \'\'}]" v-if="closable" @click="close()">{{closeText}}</i></div></div>',
    name: 'VueAlert',
    props: {
      title: {
        type: String,
        default: ''
      },
      description: {
        type: String,
        default: ''
      },
      type: {
        type: String,
        default: 'info'
      },
      closable: {
        type: Boolean,
        default: true
      },
      closeText: {
        type: String,
        default: ''
      },
      showIcon: Boolean,
      dark: Boolean
    },
    data: function() {
      return {
        visible: true
      };
    },
    methods: {
      close: function() {
        this.visible = false;
        this.$emit('close');
      }
    },
    computed: {
      typeClass: function() {
        if (this.dark) {
          return 'vue-alert--' + this.type + '-dark';
        }
        return 'vue-alert--' + this.type;
      },
      iconClass: function() {
        var TYPE_CLASSES_MAP = {
          'success': 'vue-icon-success',
          'warning': 'vue-icon-warning',
          'error': 'vue-icon-error'
        };
        return TYPE_CLASSES_MAP[this.type] || 'vue-icon-information';
      }
    }
  };
  Vue.component(VueAlert.name, VueAlert);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopup', 'VueUtil'], definition);
  } else {
    context.VueAside = definition(context.Vue, context.VuePopup, context.VueUtil);
    delete context.VueAside;
  }
})(this, function(Vue, VuePopup, VueUtil) {
  'use strict';
  var VueAside = {
    template: '<div v-show="visibleaside" :class="[{\'vue-aside-outter\': true, \'vue-aside__static\':relative}]"><div v-show="visibleaside" :class="[\'vue-aside__wrapper\', {\'vue-aside__absolute\':relative}, {\'is-cleanness\': cleannessModal}]" @click.self="handleWrapperClick"></div><transition :name="transitionName"><div v-show="visibleaside" :class="[\'vue-aside\', {\'vue-aside__absolute\':relative}, sizeClass, customClass, positionClass]" ref="aside"><div class="vue-aside__header"><span class="vue-aside__title" v-if="showTitle && !$slots.header">{{title}}</span><slot name="header"></slot><div v-if="showClose" class="vue-aside__headerbtn"><i class="vue-aside__close vue-icon-close" @click=\'handleClose\'></i></div></div><div class="vue-aside__body"><slot></slot></div><div class="vue-aside__footer" v-if="$slots.footer"><slot name="footer"></slot></div></div></transition></div>',
    name: 'VueAside',
    mixins: [VuePopup],
    data: function() {
      return {
        visibleaside: false
      };
    },
    props: {
      title: {
        type: String,
        default: ''
      },
      closeOnClickModal: Boolean,
      closeOnPressEscape: {
        type: Boolean,
        default: true
      },
      showClose: Boolean,
      size: {
        type: String,
        default: 'small'
      },
      position: {
        type: String,
        default: 'right'
      },
      relative: Boolean,
      transition: {
        type: Boolean,
        default: true
      },
      customClass: {
        type: String,
        default: ''
      },
      cleannessModal: Boolean,
      beforeClose: Function
    },
    watch: {
      visibleaside: function(val) {
        if (val) {
          this.opened = true;
          this.$emit('open');
          VueUtil.on(this.$el, 'scroll', this.updatePopper);
          var refsAside = this.$refs.aside;
          this.$nextTick(function() {
            refsAside.scrollTop = 0;
          });
        } else {
          this.opened = false;
          VueUtil.off(this.$el, 'scroll', this.updatePopper);
          this.$emit('close');
        }
      },
      visible: function(val) {
        if (val) {
          this.visibleaside = val;
        } else {
          if (VueUtil.isFunction(this.beforeClose)) {
            var self = this;
            var done = function(resolve) {
              if (!VueUtil.isDef(resolve)) resolve = true;
              if (resolve) {
                self.$nextTick(function() {
                  self.visibleaside = val;
                });
              } else {
                self.$emit('visible-change', true);
              }
            };
            self.beforeClose(done);
          } else {
            this.visibleaside = val;
          }
        }
      }
    },
    computed: {
      showTitle: function() {
        return VueUtil.trim(this.title) === '' ? false : true;
      },
      sizeClass: function() {
        return 'vue-aside--' + this.size;
      },
      positionClass: function() {
        var position = this.position;
        if (['left','right','top','bottom'].indexOf(position) === -1) {
          position = 'right';
        }
        return 'vue-aside-' + position;
      },
      transitionName: function() {
        if (!this.transition) return '';
        var position = this.position;
        if (['left','right','top','bottom'].indexOf(position) === -1) {
          position = 'right';
        }
        return 'aside-' + position;
      }
    },
    methods: {
      handleWrapperClick: function() {
        if (!this.closeOnClickModal) return;
        this.handleClose();
      },
      handleClose: function() {
        this.$emit('visible-change', false);
      }
    }
  };
  Vue.component(VueAside.name, VueAside);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VuePopper'], definition);
  } else {
    context.VueAutocomplete = definition(context.Vue, context.VueUtil, context.VuePopper);
    delete context.VueAutocomplete;
  }
})(this, function(Vue, VueUtil, VuePopper) {
  'use strict';
  var VueAutocompleteSuggestions = {
    template: '<transition @after-leave="destroyPopper"><div v-show="showPopper" :class="[\'vue-autocomplete-suggestion\', {\'is-loading\': $parent.loading}]" :style="{width: dropdownWidth}"><ul class="vue-autocomplete-suggestion__wrap" ref="suggestion"><li v-if="$parent.loading"><i class="vue-icon-loading"></i></li><template v-for="(item, index) in suggestions" v-else><li ref="suggestionList" v-if="!$parent.customItem" :class="{\'highlighted\': $parent.highlightedIndex === index}" @click="select(item)">{{item[props.label]}}</li><component v-else :class="{\'highlighted\': $parent.highlightedIndex === index}" @click="select(item)" :is="$parent.customItem" :item="item" :index="index"></component></template></ul></div></transition>',
    mixins: [VuePopper, VueUtil.component.emitter],
    name: 'VueAutocompleteSuggestions',
    data: function() {
      return {
        dropdownWidth: ''
      };
    },
    props: {
      props: Object,
      suggestions: Array
    },
    methods: {
      select: function(item) {
        this.dispatch('VueAutocomplete', 'item-click', item);
      }
    },
    updated: function() {
      var self = this;
      self.$nextTick(function() {
        self.updatePopper();
      });
    },
    mounted: function() {
      this.$parent.popperElm = this.popperElm = this.$el;
      this.referenceElm = this.$parent.$refs.input.$refs.input;
    },
    created: function() {
      var self = this;
      self.$on('visible', function(val, inputWidth) {
        self.dropdownWidth = inputWidth + 'px';
        self.showPopper = val;
      });
    }
  };
  var VueAutocomplete = {
    template: '<div class="vue-autocomplete" v-clickoutside="close" v-scrolling="close"><vue-input :text-align="textAlign" :autofocus="autofocus" :tabindex="tabindex" ref="input" v-bind="$props" @compositionstart.native="handleComposition" @compositionupdate.native="handleComposition" @compositionend.native="handleComposition" @input="handleInput" @focus="handleFocus" @keydown.up.native.prevent="highlight(highlightedIndex - 1)" @keydown.down.native.prevent="highlight(highlightedIndex + 1)" @keydown.enter.native.prevent="handleKeyEnter" @keydown.native.tab="close"><template slot="prepend" v-if="$slots.prepend"><slot name="prepend"></slot></template><template slot="append" v-if="$slots.append"><slot name="append"></slot></template></vue-input><vue-autocomplete-suggestions :props="props" :class="[popperClass ? popperClass : \'\']" ref="suggestions" :suggestions="suggestions" v-if="suggestionVisible"></vue-autocomplete-suggestions></div>',
    name: 'VueAutocomplete',
    mixins: [VueUtil.component.emitter],
    components: {
      VueAutocompleteSuggestions: VueAutocompleteSuggestions
    },
    directives: {
      Clickoutside: VueUtil.component.clickoutside(),
      Scrolling: VueUtil.component.scrolling
    },
    props: {
      props: {
        type: Object,
        default: function() {
          return {
            label: 'value',
            value: 'value'
          };
        }
      },
      popperClass: String,
      placeholder: String,
      disabled: Boolean,
      name: String,
      size: String,
      value: String,
      autofocus: Boolean,
      tabindex: Number,
      textAlign: String,
      fetchSuggestions: Function,
      triggerOnFocus: {
        type: Boolean,
        default: true
      },
      customItem: String,
      icon: String,
      onIconClick: Function
    },
    data: function() {
      return {
        suggestions: [],
        loading: false,
        highlightedIndex: -1,
        activated: false
      };
    },
    computed: {
      suggestionVisible: function() {
        var suggestions = this.suggestions;
        var isValidData = VueUtil.isArray(suggestions) && suggestions.length > 0;
        return (isValidData || this.loading) && this.activated;
      }
    },
    watch: {
      suggestionVisible: function(val) {
        var self = this;
        self.$nextTick(function() {
          self.broadcast('VueAutocompleteSuggestions', 'visible', [val, self.$refs.input.$refs.input.offsetWidth]);
        });
      }
    },
    methods: {
      focus: function() {
        this.$refs.input.focus();
      },
      getData: function(queryString) {
        var self = this;
        self.loading = true;
        self.fetchSuggestions && self.fetchSuggestions(queryString, function(suggestions) {
          self.loading = false;
          if (VueUtil.isArray(suggestions)) {
            self.suggestions = suggestions;
          } else {
            throw 'autocomplete suggestions must be an array';
          }
        });
      },
      handleComposition: function(event) {
        if (event.type === 'compositionend') {
          this.isOnComposition = false;
          this.handleChange(event.data);
        } else {
          this.isOnComposition = true;
        }
      },
      handleInput: function(value) {
        this.handleChange(value);
      },
      handleChange: function(value) {
        this.$emit('input', value);
        if (this.isOnComposition || (!this.triggerOnFocus && !value)) {
          this.suggestions = [];
          return;
        }
        this.getData(value);
      },
      handleFocus: function() {
        this.activated = true;
        if (this.triggerOnFocus) {
          this.getData(this.value);
        }
      },
      close: function() {
        this.activated = false;
      },
      handleKeyEnter: function() {
        if (this.suggestionVisible && this.highlightedIndex >= 0 && this.highlightedIndex < this.suggestions.length) {
          this.select(this.suggestions[this.highlightedIndex]);
        }
      },
      select: function(item) {
        var self = this;
        self.$emit('input', item[self.props.value]);
        self.$emit('select', item);
        self.suggestions = [];
      },
      highlight: function(index) {
        if (!this.suggestionVisible || this.loading) return;
        if (index < 0) index = 0;
        if (index >= this.suggestions.length) {
          index = this.suggestions.length - 1;
        }
        var suggestion = this.$refs.suggestions.$refs.suggestion;
        var suggestionList = this.$refs.suggestions.$refs.suggestionList;
        var highlightItem = suggestionList[index];
        var scrollTop = suggestion.scrollTop;
        var offsetTop = highlightItem.offsetTop;
        if (offsetTop + highlightItem.scrollHeight > (scrollTop + suggestion.clientHeight)) {
          suggestion.scrollTop += highlightItem.scrollHeight;
        }
        if (offsetTop < scrollTop) {
          suggestion.scrollTop -= highlightItem.scrollHeight;
        }
        this.highlightedIndex = index;
      }
    },
    mounted: function() {
      var self = this;
      self.isOnComposition = false;
      self.$on('item-click', function(item) {
        self.select(item);
      });
    },
    beforeDestroy: function() {
      if(this.$refs.suggestions) {
        this.$refs.suggestions.popperJS && this.$refs.suggestions.popperJS.destroy();
        this.$refs.suggestions.$destroy();
      }
    }
  };
  Vue.component(VueAutocomplete.name, VueAutocomplete);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueButtonGroup = definition(context.Vue);
    delete context.VueButtonGroup;
  }
})(this, function(Vue) {
  'use strict';
  var VueButtonGroup = {
    template: '<div class="vue-button-group"><slot></slot></div>',
    name: 'VueButtonGroup'
  };
  Vue.component(VueButtonGroup.name, VueButtonGroup);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueButton = definition(context.Vue);
    delete context.VueButton;
  }
})(this, function(Vue) {
  'use strict';
  var VueButton = {
    template: '<button @dblclick.stop :disabled="disabled || loading" @click="handleClick" :autofocus="autofocus" :tabindex="tabindex" :type="nativeType" :class="[\'vue-button\', type ? \'vue-button--\' + type : \'\', size ? \'vue-button--\' + size : \'\', {\'is-disabled\': disabled, \'is-loading\': loading, \'is-plain\': plain, \'is-circle\': circle}]"><i class="vue-icon-loading" v-if="loading"></i><i :class="icon" v-if="icon && !loading"></i><span v-if="$slots.default"><slot></slot></span></button>',
    name: 'VueButton',
    props: {
      type: {
        type: String,
        default: 'default'
      },
      size: String,
      icon: {
        type: String,
        default: ''
      },
      nativeType: {
        type: String,
        default: 'button'
      },
      loading: Boolean,
      disabled: Boolean,
      plain: Boolean,
      circle: Boolean,
      autofocus: Boolean,
      tabindex: Number
    },
    methods: {
      focus: function() {
        this.$el.focus();
      },
      handleClick: function(evt) {
        this.$emit('click', evt);
      }
    }
  };
  Vue.component(VueButton.name, VueButton);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCheckboxGroup = definition(context.Vue, context.VueUtil);
    delete context.VueCheckboxGroup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCheckboxGroup = {
    template: '<div class="vue-checkbox-group"><slot></slot></div>',
    name: 'VueCheckboxGroup',
    mixins: [VueUtil.component.emitter],
    props: {
      value: {},
      min: Number,
      max: Number,
      size: String,
      fill: String,
      textColor: String,
      disabled: Boolean,
      tabindex: {
        type: Number,
        default: 0
      }
    },
    methods: {
      focus: function() {
        var check = this.$el.querySelector('label:not([style*="display:none"]):not([style*="display: none"]) input[type="checkbox"]:not([disabled=disabled])');
        if(check) {
          check.focus();
        }
      }
    },
    watch: {
      value: function(value) {
        this.dispatch('VueFormItem', 'vue.form.change', [value]);
      }
    }
  };
  Vue.component(VueCheckboxGroup.name, VueCheckboxGroup);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCheckboxButton = definition(context.Vue, context.VueUtil);
    delete context.VueCheckboxButton;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCheckboxButton = {
    template: '<label :class="[\'vue-checkbox-button\', size ? \'vue-checkbox-button--\' + size : \'\', {\'is-disabled\': isDisabled}, {\'is-checked\': isChecked}, {\'is-focus\': isFocus}]"><input v-if="trueLabel || falseLabel" class="vue-checkbox-button__original" type="checkbox" :name="name" :disabled="isDisabled" :true-value="trueLabel" :false-value="falseLabel" v-model="model" @change="handleChange" :tabindex="tabIndex" @focus="isFocus = true" @blur="isFocus = false"><input v-else class="vue-checkbox-button__original" type="checkbox" :name="name" :disabled="isDisabled" :value="label" v-model="model" @change="handleChange" :tabindex="tabIndex" @focus="isFocus = true" @blur="isFocus = false"><span class="vue-checkbox-button__inner" v-if="$slots.default || label" :style="isChecked ? activeStyle : null"><slot>{{label}}</slot></span></label>',
    name: 'VueCheckboxButton',
    mixins: [VueUtil.component.emitter],
    data: function() {
      return {
        selfModel: false,
        isFocus: false
      };
    },
    props: {
      value: {},
      label: {},
      disabled: Boolean,
      checked: Boolean,
      name: String,
      trueLabel: [String, Number],
      falseLabel: [String, Number],
      tabindex: {
        type: Number,
        default: 0
      }
    },
    computed: {
      model: {
        get: function() {
          return this._checkboxGroup ? this.store : VueUtil.isDef(this.value) ? this.value : this.selfModel;
        },
        set: function(val) {
          if (this._checkboxGroup) {
            var isLimitExceeded = false;
            (VueUtil.isDef(this._checkboxGroup.min) && val.length < this._checkboxGroup.min && (isLimitExceeded = true));
            (VueUtil.isDef(this._checkboxGroup.max) && val.length > this._checkboxGroup.max && (isLimitExceeded = true));
            isLimitExceeded === false && this.dispatch('VueCheckboxGroup', 'input', [val]);
          } else if (VueUtil.isDef(this.value)) {
            this.$emit('input', val);
          } else {
            this.selfModel = val;
          }
        }
      },
      isChecked: function() {
        if (VueUtil.isBoolean(this.model)) {
          return this.model;
        } else if (VueUtil.isArray(this.model)) {
          return this.model.indexOf(this.label) !== -1;
        } else if (VueUtil.isDef(this.model)) {
          return this.model === this.trueLabel;
        }
      },
      _checkboxGroup: function() {
        var parent = this.$parent;
        while (parent) {
          if (parent.$options.name !== 'VueCheckboxGroup') {
            parent = parent.$parent;
          } else {
            return parent;
          }
        }
        return false;
      },
      isLimitDisabled: function isLimitDisabled() {
        var max = this._checkboxGroup.max;
        var min = this._checkboxGroup.min;
        return !!(max || min) && this.model.length >= max && !this.isChecked || this.model.length <= min && this.isChecked;
      },
      isDisabled: function() {

        return this._checkboxGroup
          ? this._checkboxGroup.disabled || this.disabled || this.isLimitDisabled
          : this.disabled;

      },
      store: function() {
        return this._checkboxGroup ? this._checkboxGroup.value : this.value;
      },
      activeStyle: function() {
        return {
          backgroundColor: this._checkboxGroup.fill || '',
          borderColor: this._checkboxGroup.fill || '',
          color: this._checkboxGroup.textColor || '',
          'box-shadow': '-1px 0 0 0 ' + this._checkboxGroup.fill
        };
      },
      size: function() {
        return this._checkboxGroup.size;
      },
      tabIndex: function() {
        return this._checkboxGroup ? this._checkboxGroup.tabindex : this.tabindex;
      }
    },
    methods: {
      addToStore: function() {
        if (VueUtil.isArray(this.model)
          && this.model.indexOf(this.label) === -1) {
          this.model.push(this.label);
        } else {
          this.model = this.trueLabel || true;
        }
      },
      handleChange: function(ev) {
        var self = this;
        self.$emit('change', ev);
        if (self._checkboxGroup) {
          self.$nextTick(function() {
            self.dispatch('VueCheckboxGroup', 'change', [self._checkboxGroup.value]);
          });
        }
      },
      focus: function() {
        this.$el.querySelector('input').focus();
      }
    },
    created: function() {
      this.checked && this.addToStore();
    }
  };
  Vue.component(VueCheckboxButton.name, VueCheckboxButton);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCheckbox = definition(context.Vue, context.VueUtil);
    delete context.VueCheckbox;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCheckbox = {
    template: '<label class="vue-checkbox"><span :class="[\'vue-checkbox__input\', {\'is-disabled\': isDisabled, \'is-checked\': isChecked, \'is-indeterminate\': indeterminate, \'is-focus\': isFocus}]"><span class="vue-checkbox__inner"></span><input v-if="trueLabel || falseLabel" class="vue-checkbox__original" z-index="0" type="checkbox" :name="name" :disabled="isDisabled" :true-value="trueLabel" :false-value="falseLabel" v-model="model" @change="handleChange" :tabindex="tabIndex" @focus="isFocus = true" @blur="isFocus = false"><input v-else class="vue-checkbox__original" type="checkbox" :disabled="isDisabled" :value="label" :name="name" v-model="model" @change="handleChange" :tabindex="tabIndex"  @focus="isFocus = true" @blur="isFocus = false"></span><span class="vue-checkbox__label" v-if="$slots.default || label"><slot></slot><template v-if="!$slots.default">{{label}}</template></span></label>',
    name: 'VueCheckbox',
    mixins: [VueUtil.component.emitter],
    data: function() {
      return {
        selfModel: false,
        isFocus: false
      };
    },
    computed: {
      model: {
        get: function() {
          return this.isGroup ? this.store : VueUtil.isDef(this.value) ? this.value : this.selfModel;
        },
        set: function(val) {
          if (this.isGroup) {
            var isLimitExceeded = false;
            (VueUtil.isDef(this._checkboxGroup.min) && val.length < this._checkboxGroup.min && (isLimitExceeded = true));
            (VueUtil.isDef(this._checkboxGroup.max) && val.length > this._checkboxGroup.max && (isLimitExceeded = true));
            isLimitExceeded === false && this.dispatch('VueCheckboxGroup', 'input', [val]);
          } else {
            this.$emit('input', val);
            this.selfModel = val;
          }
        }
      },
      isChecked: function() {
        if (VueUtil.isBoolean(this.model)) {
          return this.model;
        } else if (VueUtil.isArray(this.model)) {
          return this.model.indexOf(this.label) !== -1;
        } else if (VueUtil.isDef(this.model)) {
          return this.model === this.trueLabel;
        }
      },
      isDisabled: function() {
        return this.isGroup
          ? this._checkboxGroup.disabled || this.disabled || (this.elForm || {}).disabled
          : this.disabled || (this.elForm || {}).disabled;
      },
      isGroup: function() {
        var parent = this.$parent;
        while (parent) {
          if (parent.$options.name !== 'VueCheckboxGroup') {
            parent = parent.$parent;
          } else {
            this._checkboxGroup = parent;
            return true;
          }
        }
        return false;
      },
      store: function() {
        return this._checkboxGroup ? this._checkboxGroup.value : this.value;
      },
      tabIndex: function() {
        return this._checkboxGroup ? this._checkboxGroup.tabindex : this.tabindex;
      }
    },
    props: {
      value: {},
      label: {},
      indeterminate: Boolean,
      disabled: Boolean,
      checked: Boolean,
      name: String,
      trueLabel: [String, Number],
      falseLabel: [String, Number],
      tabindex: {
        type: Number,
        default: 0
      }
    },
    methods: {
      addToStore: function() {
        if (VueUtil.isArray(this.model) && this.model.indexOf(this.label) === -1) {
          this.model.push(this.label);
        } else {
          this.model = this.trueLabel || true;
        }
      },
      handleChange: function(ev) {
        var self = this;
        self.$emit('change', ev);
        if (self.isGroup) {
          self.$nextTick(function(ev) {
            self.dispatch('VueCheckboxGroup', 'change', [self._checkboxGroup.value]);
          });
        }
      },
      focus: function() {
        this.$el.querySelector('input').focus();
      }
    },
    created: function() {
      this.checked && this.addToStore();
    }
  };
  Vue.component(VueCheckbox.name, VueCheckbox);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopup', 'VueUtil'], definition);
  } else {
    context.VueDialog = definition(context.Vue, context.VuePopup, context.VueUtil);
    delete context.VueDialog;
  }
})(this, function(Vue, VuePopup, VueUtil) {
  'use strict';
  var VueDialog = {
    template: '<div><div :class="[\'vue-dialog__wrapper\', {\'is-cleanness\': cleannessModal}]" v-show="visibledialog&&size!==\'full\'" @click.self="handleWrapperClick"></div><transition name="dialog-fade"><div v-draggable v-show="visibledialog" :move-out="moveOut" :draggable-cancel-selector="draggableCancelSelector" :class="[\'vue-dialog\', sizeClass, customClass]" ref="dialog" :style="style"><div class="vue-dialog__header"><span class="vue-dialog__title" v-if="showTitle && !$slots.header">{{title}}</span><slot name="header"></slot><div class="vue-dialog__headerbtn" v-if="showClose"><i class="vue-dialog__close vue-icon-close" @click=\'handleClose\'></i></div></div><div class="vue-dialog__body"><slot></slot></div><div class="vue-dialog__footer" v-if="$slots.footer"><slot name="footer"></slot></div></div></transition></div>',
    name: 'VueDialog',
    mixins: [VuePopup],
    data: function() {
      return {
        visibledialog: false
      };
    },
    props: {
      title: {
        type: String,
        default: ''
      },
      closeOnClickModal: Boolean,
      closeOnPressEscape: {
        type: Boolean,
        default: true
      },
      showClose: Boolean,
      size: {
        type: String,
        default: 'small'
      },
      customClass: {
        type: String,
        default: ''
      },
      top: {
        type: String,
        default: '15%'
      },
      cleannessModal: Boolean,
      beforeClose: Function,
      draggable: {
        type: Boolean,
        default: true
      },
      moveOut: {
        type: Boolean,
        default: false
      },
    },
    watch: {
      visibledialog: function(val) {
        if (val) {
          this.opened = true;
          this.$emit('open');
          VueUtil.on(this.$el, 'scroll', this.updatePopper);
          var refsDialog = this.$refs.dialog;
          this.$nextTick(function() {
            refsDialog.scrollTop = 0;
          });
        } else {
          this.opened = false;
          VueUtil.off(this.$el, 'scroll', this.updatePopper);
          this.$emit('close');
        }
      },
      visible: function(val) {
        if (val) {
          this.visibledialog = val;
        } else {
          if (VueUtil.isFunction(this.beforeClose)) {
            var self = this;
            var done = function(resolve) {
              if (!VueUtil.isDef(resolve)) resolve = true;
              if (resolve) {
                self.$nextTick(function() {
                  self.visibledialog = val;
                });
              } else {
                self.$emit('visible-change', true);
              }
            };
            self.beforeClose(done);
          } else {
            this.visibledialog = val;
          }
        }
      }
    },
    computed: {
      showTitle: function() {
        return VueUtil.trim(this.title) === '' ? false : true;
      },
      sizeClass: function() {
        return 'vue-dialog--' + this.size;
      },
      style: function() {
        return this.size === 'full' ? {} : {'top': this.top};
      },
      draggableCancelSelector: function() {
        return (this.size === 'full' || this.draggable === false) ? '.vue-dialog' : '.vue-dialog__headerbtn, .vue-dialog__body, .vue-dialog__footer';
      }
    },
    methods: {
      handleWrapperClick: function() {
        if (!this.closeOnClickModal) return;
        this.handleClose();
      },
      handleClose: function() {
        this.$emit('visible-change', false);
      }
    }
  };
  Vue.component(VueDialog.name, VueDialog);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueLoading = definition(context.Vue, context.VueUtil);
    delete context.VueLoading;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var directive = function() {
    var VueLoading = Vue.extend({
      template: '<transition @after-leave="handleAfterLeave"><div v-show="visible" :class="[\'vue-loading-mask\', customClass, {\'is-fullscreen\': fullscreen}]"><div class="vue-loading-spinner"><svg class="circular" viewBox="25 25 50 50"><circle class="path" cx="50" cy="50" r="20" fill="none"/></svg><p v-if="text" class="vue-loading-text">{{text}}</p></div></div></transition>',
      data: function() {
        return {
          text: null,
          fullscreen: true,
          visible: false,
          customClass: ''
        };
      },
      methods: {
        handleAfterLeave: function() {
          this.$emit('after-leave');
        }
      }
    });
    var insertDom = function(parent, el, binding) {
      if (!el.domVisible) {
        VueUtil.ownPropertyLoop(el.maskStyle, function(property) {
          el.mask.style[property] = el.maskStyle[property];
        });
        if (el.originalPosition !== 'absolute') {
          parent.style.position = 'relative';
        }
        if (binding.modifiers.fullscreen && binding.modifiers.lock) {
          parent.style.overflow = 'hidden';
        }
        parent.appendChild(el.mask);
        el.domVisible = true;
        el.instance.visible = true;
        el.domInserted = true;
        Vue.nextTick(function() {
          if (binding.modifiers.fullscreen) {
            el.instance.$el.focus();
          }
        });
      }
    };
    var toggleLoading = function(el, binding) {
      if (binding.value) {
        if (binding.modifiers.fullscreen) {
          el.originalPosition = document.body.style.position;
          el.originalOverflow = document.body.style.overflow;
          VueUtil.addClass(el.mask, 'is-fullscreen');
          insertDom(document.body, el, binding);
        } else {
          VueUtil.removeClass(el.mask, 'is-fullscreen');
          if (binding.modifiers.body) {
            el.originalPosition = document.body.style.position;
            VueUtil.loop(['top', 'left'], function(property) {
              var scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
              el.maskStyle[property] = el.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';
            });
            VueUtil.loop(['height', 'width'], function(property) {
              el.maskStyle[property] = el.getBoundingClientRect()[property] + 'px';
            });
            insertDom(document.body, el, binding);
          } else {
            el.originalPosition = el.style.position;
            insertDom(el, el, binding);
          }
        }
      } else {
        if (el.domVisible) {
          el.instance.$once('after-leave', function() {
            el.domVisible = false;
            if (binding.modifiers.fullscreen && el.originalOverflow !== 'hidden') {
              document.body.style.overflow = el.originalOverflow;
            }
            if (binding.modifiers.fullscreen || binding.modifiers.body) {
              document.body.style.position = el.originalPosition;
            } else {
              el.style.position = el.originalPosition;
            }
          });
          el.instance.visible = false;
        }
      }
    };
    var doKeyDown = function(e) {
      document.querySelector('.vue-loading-mask').focus();
      e.preventDefault();
      return false;
    };
    
    var bindEvent = function(el, binding) {
      if (binding.value) {
        VueUtil.on(el, 'keydown', doKeyDown);
      } else {
        VueUtil.off(el, 'keydown', doKeyDown);
      }
    };
    Vue.directive('loading', {
      bind: function(el, binding) {
        var mask = new VueLoading({
          el: document.createElement('div'),
          data: {
            text: el.getAttribute('vue-loading-text'),
            fullscreen: !!binding.modifiers.fullscreen,
            customClass: el.getAttribute('vue-loading-class'),
          }
        });
        el.instance = mask;
        el.mask = mask.$el;
        el.maskStyle = {};
        toggleLoading(el, binding);
      },
      update: function(el, binding) {
        if (binding.oldValue !== binding.value) {
          toggleLoading(el, binding);
          bindEvent(el, binding);
        }
      },
      unbind: function(el, binding) {
        if (el.domInserted) {
          el.instance.$destroy();
          VueUtil.off(document, 'keydown', doKeyDown);
        }
      }
    });
  };
  Vue.use(directive);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueMenuItemGroup = definition(context.Vue, context.VueUtil);
    delete context.VueMenuItemGroup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueMenuItemGroup = {
    template: '<li class="vue-menu-item-group"><div class="vue-menu-item-group__title" :style="{paddingLeft: levelPadding + \'px\'}" v-if="showTitle"><template v-if="!$slots.title">{{title}}</template><slot v-else name="title"></slot></div><ul><slot></slot></ul></li>',
    name: 'VueMenuItemGroup',
    inject: ['rootMenu'],
    props: {
      title: {
        type: String,
        default: ''
      }
    },
    data: function() {
      return {
        paddingLeft: 20
      };
    },
    computed: {
      showTitle: function() {
        if (VueUtil.trim(this.title) === '' && !this.$slots.title) {
          return false;
        }
        return true;
      },
      levelPadding: function() {
        var padding = 10;
        var parent = this.$parent;
        if (this.rootMenu.collapse) return 20;
        while (parent && parent.$options.name !== 'VueMenu') {
          if (parent.$options.name === 'VueSubmenu') {
            padding += 20;
          }
          parent = parent.$parent;
        }
        padding === 10 && (padding = 20);
        return padding;
      }
    }
  };
  Vue.component(VueMenuItemGroup.name, VueMenuItemGroup);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueMenuItem = definition(context.Vue, context.VueUtil);
    delete context.VueMenuItem;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueMenuItem = {
    // template: '<li :style="paddingStyle" @click="handleClick" @mouseenter="onMouseEnter" @mouseleave="onMouseLeave" :class="[\'vue-menu-item\', {\'is-active\': active, \'is-disabled\': disabled}]"><template v-else><slot></slot></template></li>',
    template: '<li class="vue-menu-item"'
    + '    :style="[paddingStyle]"'
    + '    :class="{'
    + '      \'is-active\': active,'
    + '      \'is-disabled\': disabled'
    + '    }"'
    + '    @click="handleClick"'
    + '  >'
    + '    <vue-tooltip'
    + '      v-if="parentMenu.$options.name === \'VueMenu\' && rootMenu.collapse && $slots.title"'
    + '      effect="dark"'
    + '      placement="right">'
    + '      <div slot="content"><slot name="title"></slot></div>'
    + '      <div style="position: absolute;left: 0;top: 0;height: 100%;width: 100%;display: inline-block;box-sizing: border-box;padding: 0 20px;">'
    + '        <slot></slot>'
    + '      </div>'
    + '    </vue-tooltip>'
    + '    <template v-else>'
    + '      <slot></slot>'
    + '      <slot name="title"></slot>'
    + '    </template>'
    + '  </li>',
    name: 'VueMenuItem',
    mixins: [VueUtil.component.menumixin, VueUtil.component.emitter],
    props: {
      index: {
        type: String,
        required: true
      },
      route: {
        type: Object,
        required: false
      },
      disabled: Boolean
    },
    computed: {
      active: function() {
        return this.index === this.rootMenu.activedIndex;
      }
    },
    methods: {
      handleClick: function() {
        this.dispatch('VueMenu', 'item-click', this);
      }
    },
    created: function() {
      this.parentMenu.addItem(this);
      this.rootMenu.addItem(this);
    },
    beforeDestroy: function() {
      this.parentMenu.removeItem(this);
      this.rootMenu.removeItem(this);
    }
  };
  Vue.component(VueMenuItem.name, VueMenuItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueMenu = definition(context.Vue, context.VueUtil);
    delete context.VueMenu;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueMenu = {
    template: '<ul :class="[\'vue-menu\', {\'vue-menu--horizontal\': mode === \'horizontal\', \'vue-menu--dark\': theme === \'dark\', \'vue-menu--collapse\': collapse}]"><slot></slot></ul>',
    name: 'VueMenu',
    mixins: [VueUtil.component.emitter],
    props: {
      collapse: Boolean,
      mode: {
        type: String,
        default: 'vertical'
      },
      defaultActive: {
        type: String,
        default: ''
      },
      defaultOpeneds: Array,
      theme: {
        type: String,
        default: 'light'
      },
      uniqueOpened: Boolean,
      router: Boolean,
      menuTrigger: {
        type: String,
        default: 'hover'
      }
    },

    provide: function() {
      return {
        rootMenu: this
      };
    },
    
    data: function() {
      return {
        activedIndex: this.defaultActive,
        openedMenus: VueUtil.mergeArray([], this.defaultOpeneds),
        items: {},
        submenus: {}
      };
    },
    watch: {
      defaultActive: function(value) {
        var item = this.items[value];
        if (!item) return;
        this.activedIndex = value;
        this.initOpenedMenu();
      },

      defaultOpeneds: function(value) {
        if (!this.collapse) {
          this.openedMenus = value;
        }
      },

      collapse: function(value) {
        if (value) this.openedMenus = [];
        this.broadcast('VueSubmenu', 'toggle-collapse', value);
      },

      '$route': {
        immediate: true,
        handler: function(value) {
          if (this.router) {
            var item = this.items[value.path];
            if (!item) return;
            this.activedIndex = value.path;
            this.initOpenedMenu();
          }
        }
      }
    },
    computed: {
      isMenuPopup: function() {
        return this.mode === 'horizontal' || (this.mode === 'vertical' && this.collapse);
      }
    },
    methods: {
      addItem: function(item) {
        this.items[item.index] = item;
      },
      removeItem: function(item) {
        delete this.items[item.index];
      },
      addSubmenu: function(item) {
        this.submenus[item.index] = item;
      },
      removeSubmenu: function(item) {
        delete this.submenus[item.index];
      },
      openMenu: function(index, indexPath) {
        var openedMenus = this.openedMenus;
        if (openedMenus.indexOf(index) !== -1)
          return;
        if (this.uniqueOpened) {
          this.openedMenus = VueUtil.filter(openedMenus, function(index) {
            return indexPath.indexOf(index) !== -1;
          });
        }
        this.openedMenus.push(index);
      },
      closeMenu: function(index, indexPath) {
        var i = this.openedMenus.indexOf(index);
        if (i !== -1) {
          this.openedMenus.splice(i, 1);
        }
      },
      handleSubmenuClick: function(submenu) {
        var isOpened = this.openedMenus.indexOf(submenu.index) !== -1;
        if (isOpened) {
          this.closeMenu(submenu.index, submenu.indexPath);
          this.$emit('close', submenu.index, submenu.indexPath);
        } else {
          this.openMenu(submenu.index, submenu.indexPath);
          this.$emit('open', submenu.index, submenu.indexPath);
        }
      },
      handleItemClick: function(item) {
        this.$emit('select', item.index, item.indexPath, item);

        if (this.mode === 'horizontal' || this.collapse) {
          this.openedMenus = [];
        }

        if (this.router) {
          this.routeToItem(item);
        } else {
          this.activedIndex = item.index;
        }
      },
      initOpenedMenu: function() {
        var self = this;
        var index = self.activedIndex;
        var activeItem = self.items[index];
        if (!activeItem || this.mode === 'horizontal' || this.collapse) return;
        var indexPath = activeItem.indexPath;
        VueUtil.loop(indexPath, function(index) {
          var submenu = self.submenus[index];
          submenu && self.openMenu(index, submenu.indexPath);
        });
      },
      routeToItem: function(item) {
        var route = item.route || item.index;
        try {
          this.$router.push(route);
        } catch (e) {
          throw e;
        }
      }
    },
    mounted: function() {
      this.initOpenedMenu();
      this.$on('item-click', this.handleItemClick);
      this.$on('submenu-click', this.handleSubmenuClick);
    }
  };
  Vue.component(VueMenu.name, VueMenu);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueRadioGroup = definition(context.Vue, context.VueUtil);
    delete context.VueRadioGroup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var keyCode = Object.freeze({
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40
  });

  var VueRadioGroup = {
    template: '<div class="vue-radio-group" role="radiogroup" @keydown="handleKeydown"><slot></slot></div>',
    name: 'VueRadioGroup',
    mixins: [VueUtil.component.emitter],
    props: {
      value: {},
      size: String,
      fill: String,
      textColor: String,
      disabled: Boolean,
      tabindex: {
        type: Number,
        default: 0
      }
    },
    watch: {
      value: function(value) {
        this.$emit('change', value);
        this.dispatch('VueFormItem', 'vue.form.change', [this.value]);
      }
    },
    methods: {
      handleKeydown: function handleKeydown(e) {
        // 左右上下按键 可以在radio组内切换不同选项
        var target = e.target;
        var className = target.nodeName === 'INPUT' ? '[type=radio]' : '[role=radio]:not(.is-disabled)';
        var radios = this.$el.querySelectorAll(className);
        var length = radios.length;
        var index = [].indexOf.call(radios, target);
        var roleRadios = this.$el.querySelectorAll('[role=radio]:not(.is-disabled)');
    
        switch (e.keyCode) {
          case keyCode.LEFT:
          case keyCode.UP:
            e.stopPropagation();
            e.preventDefault();
    
            if (index === 0) {
              roleRadios[length - 1].click();
              roleRadios[length - 1].focus();
            } else {
              roleRadios[index - 1].click();
              roleRadios[index - 1].focus();
            }
    
            break;
    
          case keyCode.RIGHT:
          case keyCode.DOWN:
            e.stopPropagation();
            e.preventDefault();

            if (index === length - 1) {
              roleRadios[0].click();
              roleRadios[0].focus();
            } else {
              roleRadios[index + 1].click();
              roleRadios[index + 1].focus();
            }
    
            break;
    
          default:
            break;
        }
      },
      handleTabindex: function() {
        var radios = this.$el.querySelectorAll('[type=radio]');
        var firstLabel = this.$el.querySelectorAll('[role=radio]')[0];

        if (![].some.call(radios, function (radio) {
          return radio.checked;
        }) && firstLabel) {
          firstLabel.tabIndex = this.tabindex;
        }
      },
      focus: function() {
        var radio = this.$el.querySelector('label:not([style*="display:none"]):not([style*="display: none"]):not([tabindex="-1"]) input[type="radio"]:not([disabled=disabled])');
        if(radio) {
          radio.focus();
        }
      }
    },
    mounted: function() {
      this.handleTabindex();
      this.$on('radioChange', this.handleTabindex);
    }
  };
  Vue.component(VueRadioGroup.name, VueRadioGroup);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueRadioButton = definition(context.Vue);
    delete context.VueRadioButton;
  }
})(this, function(Vue) {
  'use strict';
  var VueRadioButton = {
    template: '<label role="radio" :class="[\'vue-radio-button\', size ? \'vue-radio-button--\' + size : \'\', {\'is-active\': value === label}, {\'is-disabled\': isDisabled}, {\'is-focus\': isFocus}]" :tabindex="tabIndex"><input class="vue-radio-button__original" :value="label" type="radio" v-model="value" :name="name" :tabindex="-1" @focus="isFocus = true" @blur="isFocus = false" :disabled="isDisabled"><span class="vue-radio-button__inner" :style="value === label ? activeStyle : null"><slot></slot><template v-if="!$slots.default">{{label}}</template></span></label>',
    name: 'VueRadioButton',
    data: function() {
      return {
        isFocus: false
      };
    },
    props: {
      label: {},
      disabled: Boolean,
      name: String,
      tabindex: {
        type: Number,
        default: 0
      }
    },
    computed: {
      value: {
        get: function() {
          return this._radioGroup.value;
        },
        set: function(value) {
          this._radioGroup.$emit('input', value);
        }
      },
      _radioGroup: function() {
        var parent = this.$parent;
        while (parent) {
          if (parent.$options.name !== 'VueRadioGroup') {
            parent = parent.$parent;
          } else {
            return parent;
          }
        }
        return false;
      },
      activeStyle: function() {
        return {
          backgroundColor: this._radioGroup.fill || '',
          borderColor: this._radioGroup.fill || '',
          boxShadow: this._radioGroup.fill ? '-1px 0 0 0 ' + this._radioGroup.fill : '',
          color: this._radioGroup.textColor || ''
        };
      },
      size: function() {
        return this._radioGroup.size;
      },
      isDisabled: function() {
        return this.disabled || this._radioGroup.disabled;
      },
      tabIndex: function() {
        return (this.isDisabled || (this._radioGroup && this.value !== this.label)) ? -1 : this.isGroup ? this._radioGroup.tabindex : this.tabindex;
      }
    }
  };
  Vue.component(VueRadioButton.name, VueRadioButton);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopper', 'VueUtil'], definition);
  } else {
    context.VueTooltip = definition(context.Vue, context.VuePopper, context.VueUtil);
    delete context.VueTooltip;
  }
})(this, function(Vue, VuePopper, VueUtil) {
  'use strict';
  
  
  var VueTooltip = {
    name: 'VueTooltip',
    mixins: [VuePopper],
    props: {
      disabled: Boolean,
      effect: String,
      popperClass: String,
      content: String,
      visibleArrow: {
        default: true
      },
      options: {
        default: function() {
          return {
            boundariesPadding: 10,
            gpuAcceleration: false
          };
        }
      },
      enterable: Boolean
    },
    beforeCreate: function() {
      var self = this;

      var opt = {
        data: {node: ''},
        render: function(createElement) {
          return this.node;
        }
      };

      if(Vue.i18n) opt.i18n = Vue.i18n;
      self.popperVM = new Vue(opt).$mount();
    },
    beforeDestroy: function() {
      this.popperVM.$destroy();
    },
    render: function(createElement) {
      var self = this;
      var effect = self.effect === 'light' ? 'light' : 'dark';
      if (self.popperVM) {
        self.popperVM.node = createElement('transition', {
          attrs: {
            name: 'tooltip-fade'
          },
          on: {
            afterLeave: self.destroyPopper
          }
        }, [createElement('div', {
          on: {
            mouseleave: function() {
              self.setExpectedState(false);
              self.debounceClose();
            },
            mouseenter: function() {
              self.setExpectedState(true);
            }
          },
          ref: 'popper',
          directives: [{
            name: 'show',
            value: !self.disabled && self.showPopper
          }],
          class: ['vue-tooltip__popper', 'is-' + effect, self.popperClass]
        }, [self.$slots.content || self.content])]);
      }
      if (!self.$slots.default || !self.$slots.default.length) return self.$slots.default;
      var getFirstComponentChild = function(children) {
        return VueUtil.filter(children, function(c) {
          return c && c.tag;
        })[0];
      };
      var vnode = getFirstComponentChild(self.$slots.default);
      if (!vnode) return vnode;
      var data = vnode.data = vnode.data || {};
      var on = vnode.data.on = vnode.data.on || {};


      if(!data.bindToolTipEvent) {

        data.bindToolTipEvent = 'binded';
        
        on.mouseover = self.addEventHandle(on.mouseover, function (e) {

          if (e.currentTarget === e.target) {
            self.setExpectedState(true);
            self.handleShowPopper();
          }

          var b = e.currentTarget.getBoundingClientRect();
          var clientX = Math.floor(e.clientX);
          var clientY = Math.floor(e.clientY);
          
          var offset = 2;
          var top = Math.floor(b.top) - offset;
          var bottom = Math.floor(b.bottom) + offset;
          var left = Math.floor(b.left) - offset;
          var right = Math.floor(b.right) + offset;


          if (top <= clientY && bottom >= clientY && left <= clientX && right >= clientX) {
            self.setExpectedState(true);
            self.handleShowPopper();
          }
        });
        on.mouseleave = self.addEventHandle(on.mouseleave, function (e) {
          self.setExpectedState(false);
          self.debounceClose();
        });
      }

      data.staticClass = self.concatClass(data.staticClass, 'vue-tooltip');
      return vnode;
    },
    mounted: function() {
      this.referenceElm = this.$el;
    },
    methods: {
      debounceClose: VueUtil.debounce(function() {
        this.handleClosePopper();
      }),
      addEventHandle: function(old, fn) {
        return old ? VueUtil.isArray(old) ? VueUtil.mergeArray(old, fn) : [old, fn] : fn;
      },
      concatClass: function(a, b) {
        if (a && a.indexOf(b) !== -1) return a;
        return a ? b ? (a + ' ' + b) : a : (b || '');
      },
      handleShowPopper: function() {
        var self = this;
        if (!self.expectedState) return;
        self.showPopper = true;
      },
      handleClosePopper: function() {
        if (this.enterable && this.expectedState) return;
        this.showPopper = false;
      },
      setExpectedState: function(expectedState) {
        this.expectedState = expectedState;
      }
    }
  };
  Vue.component(VueTooltip.name, VueTooltip);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueRadio = definition(context.Vue, context.VueUtil);
    delete context.VueRadio;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueRadio = {
    template: '<label role="radio" @keydown.space.stop.prevent="model = isDisabled ? model : label" :tabindex="tabIndex" class="vue-radio" :class="[{\'is-disabled\': isDisabled}]"><span :class="[\'vue-radio__input\', {\'is-disabled\': isDisabled, \'is-checked\': model === label, \'is-focus\': isFocus}]"><span class="vue-radio__inner"></span><input class="vue-radio__original" :value="label" type="radio" v-model="model" @focus="isFocus=true" @blur="isFocus=false" :name="name" :disabled="isDisabled" tabindex="-1"></span><span class="vue-radio__label"><slot></slot><template v-if="!$slots.default">{{label}}</template></span></label>',
    name: 'VueRadio',
    mixins: [VueUtil.component.emitter],
    props: {
      value: {},
      label: {},
      disabled: Boolean,
      name: String,
      tabindex: {
        type: Number,
        default: 0
      }
    },
    data: function() {
      return {
        isFocus: false
      };
    },
    computed: {
      isGroup: function() {
        var parent = this.$parent;
        while (parent) {
          if (parent.$options.name !== 'VueRadioGroup') {
            parent = parent.$parent;
          } else {
            this._radioGroup = parent;
            return true;
          }
        }
        return false;
      },
      model: {
        get: function() {
          return this.isGroup ? this._radioGroup.value : this.value;
        },
        set: function(val) {
          if (this.isGroup) {
            this.dispatch('VueRadioGroup', 'input', [val]);
          } else {
            this.$emit('input', val);
          }
        }
      },
      isDisabled: function() {
        return this.isGroup ? this._radioGroup.disabled || this.disabled : this.disabled;
      },
      tabIndex: function() {
        return (this.isDisabled || (this.isGroup && this.model !== this.label)) ? -1 : this.isGroup ? this._radioGroup.tabindex : this.tabindex;
      }
    }, 
    destroyed: function() {
      this.isGroup && this._radioGroup.$emit('radioChange');
    },
    mounted: function() {
      this.isGroup && this._radioGroup.$emit('radioChange');
    },
    methods: {
      focus: function() {
        this.$el.querySelector('input').focus();
      }
    }
  };
  Vue.component(VueRadio.name, VueRadio);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueSubmenu = definition(context.Vue, context.VueUtil);
    delete context.VueSubmenu;
  }
})(this, function(Vue, VueUtil) {
  'use strict';

  var VueSubMenu = {
    //template: '<li :class="{\'vue-submenu\': true, \'is-active\': active, \'is-opened\': opened}"><div class="vue-submenu__title" ref="submenu-title" :style="[paddingStyle, titleStyle, { backgroundColor: backgroundColor }]"><slot name="title"></slot><i :class="[\'vue-submenu__icon-arrow\', submenuTitleIcon]"></i></div><template v-if="rootMenu.mode === \'horizontal\'"><ul class="vue-menu" v-show="opened"><slot></slot></ul></template><collapse-transition v-else><ul class="vue-menu" v-show="opened"><slot></slot></ul></collapse-transition></li>',
    render: function(h) {
      var active = this.active,
      opened = this.opened,
      paddingStyle = this.paddingStyle,
      rootMenu = this.rootMenu,
      mode = this.mode,
      disabled = this.disabled,
      $slots = this.$slots,
      isFirstLevel = this.isFirstLevel;

      var popupMenu = h(
        'transition',
        {},
        [h(
          'div',
          {
            ref: 'menu',
            directives: [{
              name: 'show',
              value: opened
            }],
            'class': ['vue-menu--' + mode]
          },
          [h(
            'ul',
            {
              attrs: {
                role: 'menu'
              },
              'class': ['vue-menu vue-menu--popup']
            },
            [$slots.default]
          )]
        )]
      );

      var inlineMenu = h('collapse-transition', [h(
        'ul',
        {
          attrs: {
            role: 'menu'
          },
          'class': 'vue-menu vue-menu--inline',
          directives: [{
            name: 'show',
            value: opened
          }]
        },
        [$slots.default]
      )]);


      var submenuTitleIcon = (
          rootMenu.mode === 'horizontal' && isFirstLevel ||
          rootMenu.mode === 'vertical' && !rootMenu.collapse
        ) ? 'vue-icon-arrow-down' : 'vue-icon-arrow-right';
      
      
      return h(
        'li',
        {
          'class': {
            'vue-submenu': true,
            'is-active': active,
            'is-opened': opened,
            'is-disabled': disabled
          },
          attrs: { role: 'menuitem',
            'aria-haspopup': 'true',
            'aria-expanded': opened
          },
          on: {
            'mouseenter': this.handleMouseenter,
            'mouseleave': this.handleMouseleave,
            'focus': this.handleMouseenter
          }
        },
        [h(
          'div',
          {
            'class': 'vue-submenu__title',
            ref: 'submenu-title',
            on: {
              'click': this.handleClick
            },
      
            style: [paddingStyle]
          },
          [$slots.title, h('i', { 'class': [submenuTitleIcon, 'vue-submenu__icon-arrow'] })]
        ), this.isMenuPopup ? popupMenu : inlineMenu]
      );
    },
    name: 'VueSubmenu',
    mixins: [VueUtil.component.menumixin, VueUtil.component.emitter],
    components: {
      CollapseTransition: VueUtil.component.collapseTransition
    },
    props: {
      index: {
        type: String,
        required: true
      },
      showTimeout: {
        type: Number,
        default: 300
      },
      hideTimeout: {
        type: Number,
        default: 300
      },
      disabled: Boolean
    },
    data: function() {
      return {
        timeout: null,
        items: {},
        submenus: {},
        mouseInChild: false
      };
    },
    computed: {
      opened: function() {
        return (this.rootMenu.openedMenus.indexOf(this.index) !== -1);
      },
      active: {
        cache: false,
        get: function() {
          var isActive = false;
          var submenus = this.submenus;
          var items = this.items;
          VueUtil.ownPropertyLoop(items, function(index) {
            if (items[index].active) {
              isActive = true;
            }
          });
          VueUtil.ownPropertyLoop(submenus, function(index) {
            if (submenus[index].active) {
              isActive = true;
            }
          });
          return isActive;
        }
      },
      mode: function() {
        return this.rootMenu.mode;
      },
      isMenuPopup: function() {
        return this.rootMenu.isMenuPopup;
      },
      isFirstLevel: function() {
        var isFirstLevel = true;
        var parent = this.$parent;
        while (parent && parent !== this.rootMenu) {
          if (['VueSubmenu', 'VueMenuItemGroup'].indexOf(parent.$options.name) > -1) {
            isFirstLevel = false;
            break;
          } else {
            parent = parent.$parent;
          }
        }
        return isFirstLevel;
      }
    },
    watch: {
      opened: function(val) {
        if (this.isMenuPopup) {
          this.$nextTick(function (_) {
            this.updatePopper();
          });
        }
      }
    },
    methods: {
      addItem: function(item) {
        this.items[item.index] = item;
      },
      removeItem: function(item) {
        delete this.items[item.index];
      },
      addSubmenu: function(item) {
        this.submenus[item.index] = item;
      },
      removeSubmenu: function(item) {
        delete this.submenus[item.index];
      },
      handleClick: function() {

        var rootMenu = this.rootMenu;
        var disabled = this.disabled;

        if (rootMenu.menuTrigger === 'hover' && rootMenu.mode === 'horizontal' || rootMenu.collapse && rootMenu.mode === 'vertical' || disabled) {
          return;
        }
        this.dispatch('VueMenu', 'submenu-click', this);
      },

      handleMouseenter: function () {
        var self = this;
    
        var rootMenu = this.rootMenu,
            disabled = this.disabled;

        if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical' || disabled) {
          return;
        }
        this.dispatch('VueSubmenu', 'mouse-enter-child');
        
        clearTimeout(this.timeout);
        this.timeout = setTimeout(function () {
          self.rootMenu.openMenu(self.index, self.indexPath);
        }, this.showTimeout);
      },
      handleMouseleave: function () {
        var self = this;
        var rootMenu = this.rootMenu;
    
        if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical') {
          return;
        }
        this.dispatch('VueSubmenu', 'mouse-leave-child');
        clearTimeout(this.timeout);
        this.timeout = setTimeout(function () {
          !self.mouseInChild && self.rootMenu.closeMenu(self.index);
        }, this.hideTimeout);
      },
      updatePopper: function () {
        var menu = VueUtil.closest(this.$el, '.vue-menu');
        var submenu = this.$el.querySelector('.vue-menu');
        var verticalMenu = submenu.parentNode;
        var hoverItem = verticalMenu.parentNode;

        if(!this.opened) {
          setTimeout(function() {
            submenu.style.height = '';
            submenu.style.overflow = '';
          }, 0);
          return;
        }
        
        if(this.rootMenu.collapse) {
          submenu.style.position = 'static';
        }

        verticalMenu.style.left = menu.offsetWidth + 5 + 'px';
        verticalMenu.style.top = hoverItem.offsetTop - VueUtil.closest(hoverItem, '.vue-menu').scrollTop + 'px';

        var rect = submenu.getBoundingClientRect();

        if (rect.bottom > window.innerHeight) {
          var over = rect.bottom - window.innerHeight;
          if (over > rect.top) {
            verticalMenu.style.top = verticalMenu.offsetTop - rect.top + 'px';
            submenu.style.height = window.innerHeight + 'px';
            submenu.style.overflow = 'auto';
          } else {
            verticalMenu.style.top = verticalMenu.offsetTop - over + 'px';
          }
        }
      }


      // mouseToggle: VueUtil.debounce(300, function(val) {
      //   if (val) {
      //     this.rootMenu.openMenu(this.index, this.indexPath);
      //   } else {
      //     this.rootMenu.closeMenu(this.index, this.indexPath);
      //   }
      // }),
      // mouseEnter: function() {
      //   this.mouseToggle(true);
      // },
      // mouseLeave: function() {
      //   this.mouseToggle(false);
      // },
      // bindEvents: function() {
      //   var triggerElm;
      //   if (this.rootMenu.mode === 'horizontal' && this.rootMenu.menuTrigger === 'hover') {
      //     triggerElm = this.$el;
      //     VueUtil.on(triggerElm, 'mouseenter', this.mouseEnter);
      //     VueUtil.on(triggerElm, 'mouseleave', this.mouseLeave);
      //   } else {
      //     triggerElm = this.$refs['submenu-title'];
      //     VueUtil.on(triggerElm, 'click', this.handleClick);
      //   }
      // },
      // unBindEvents: function() {
      //   var triggerElm;
      //   if (this.rootMenu.mode === 'horizontal' && this.rootMenu.menuTrigger === 'hover') {
      //     triggerElm = this.$el;
      //     VueUtil.off(triggerElm, 'mouseenter', this.mouseEnter);
      //     VueUtil.off(triggerElm, 'mouseleave', this.mouseLeave);
      //   } else {
      //     triggerElm = this.$refs['submenu-title'];
      //     VueUtil.off(triggerElm, 'click', this.handleClick);
      //   }
      // }
    },
    created: function() {
      this.parentMenu.addSubmenu(this);
      this.rootMenu.addSubmenu(this);
      var self = this;
      this.$on('mouse-enter-child', function() {
        self.mouseInChild = true;
        clearTimeout(self.timeout);
      });
      this.$on('mouse-leave-child', function() {
        self.mouseInChild = false;
        clearTimeout(self.timeout);
      });

    },
    beforeDestroy: function() {
      this.parentMenu.removeSubmenu(this);
      this.rootMenu.removeSubmenu(this);
      // this.unBindEvents();
    },
    mounted: function() {
      // this.bindEvents();
    }
  };
  Vue.component(VueSubMenu.name, VueSubMenu);
});



(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueSwitch = definition(context.Vue);
    delete context.VueSwitch;
  }
})(this, function(Vue) {
  'use strict';
  var VueSwitch = {
    template: '<label :tabindex="disabled ? -1 : tabindex" @keydown.space.stop.prevent="toggleCheck" :class="[\'vue-switch\', {\'is-disabled\': disabled, \'vue-switch--wide\': hasText}]">\
      <div class="vue-switch__mask" v-show="disabled"></div>\
      <input ref="check" class="vue-switch__input" type="checkbox" @change="handleChange" v-model="_value" :name="name" :disabled="disabled">\
      <span class="vue-switch__core" ref="core" :style="{\'width\': coreWidth + \'px\'}">\
        <span class="vue-switch__button" :style="buttonStyle"></span>\
      </span>\
      <transition name="label-fade"><div class="vue-switch__label vue-switch__label--left" v-show="_value" :style="{\'width\': coreWidth + \'px\'}">\
        <i :class="[onIconClass]" v-if="onIconClass"></i><span v-if="!onIconClass && onText">{{onText}}</span></div>\
      </transition>\
      <transition name="label-fade"><div class="vue-switch__label vue-switch__label--right" v-show="!_value" :style="{\'width\': coreWidth + \'px\'}">\
      <i :class="[offIconClass]" v-if="offIconClass"></i>\
      <span v-if="!offIconClass && offText">{{offText}}</span>\
      </div>\
      </transition>\
    </label>',
    name: 'VueSwitch',
    props: {
      value: {
        type: [Boolean, String, Number],
        default: true
      },
      onValue: {
        type: [Boolean, String, Number],
        default: true
      },
      offValue: {
        type: [Boolean, String, Number],
        default: false
      },
      disabled: Boolean,
      width: {
        type: Number,
        default: 0
      },
      onIconClass: {
        type: String,
        default: ''
      },
      offIconClass: {
        type: String,
        default: ''
      },
      onText: {
        type: String,
        default: 'ON'
      },
      offText: {
        type: String,
        default: 'OFF'
      },
      onColor: {
        type: String,
        default: ''
      },
      offColor: {
        type: String,
        default: ''
      },
      name: {
        type: String,
        default: ''
      },
      tabindex: {
        type: Number,
        default: 0
      }
    },
    data: function() {
      return {
        coreWidth: this.width,
        buttonStyle: {
          transform: ''
        }
      };
    },
    computed: {
      hasText: function() {
        return this.onText || this.offText;
      },
      _value: {
        get: function() {
          return this.value === this.onValue;
        },
        set: function(val) {
          this.$emit('input', val ? this.onValue : this.offValue);
        }
      }
    },
    watch: {
      value: function() {
        if (this.onColor || this.offColor) {
          this.setBackgroundColor();
        }
        this.handleButtonTransform();
      },
      width: function() {
          this.coreWidth = this.width;
          this.handleButtonTransform();
      }
    },
    methods: {
      handleChange: function(event) {
        this.$emit('change', event.currentTarget.checked ? this.onValue : this.offValue);
      },
      toggleCheck: function() {
        this.$refs.check.click();
      },
      handleButtonTransform: function() {
        this.buttonStyle.transform = this._value ? 'translate(' + (this.coreWidth - 20) + 'px, 2px)' : 'translate(2px, 2px)';
      },
      setBackgroundColor: function() {
        var newColor = this._value ? this.onColor : this.offColor;
        this.$refs.core.style.borderColor = newColor;
        this.$refs.core.style.backgroundColor = newColor;
      }
    },
    mounted: function() {
      if (this.width === 0) {
        this.coreWidth = this.hasText ? 58 : 46;
      }
      this.handleButtonTransform();
      if (this.onColor || this.offColor) {
        this.setBackgroundColor();
      }
    }
  };
  Vue.component(VueSwitch.name, VueSwitch);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueTabPane = definition(context.Vue, context.VueUtil);
    delete context.VueTabPane;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueTabPane = {
    template: '<div class="vue-tab-pane" v-show="noHide || active" :style="paneStyle" ><keep-alive><router-view v-if="router && active && $route.meta.keepAlive"></router-view></keep-alive><router-view v-if="router && active && !$route.meta.keepAlive"></router-view><slot v-if="!router"></slot></div>',
    name: 'VueTabPane',
    props: {
      label: String,
      labelContent: Function,
      name: String,
      closable: Boolean,
      disabled: Boolean
    },
    data: function() {
      return {
        index: null
      };
    },
    computed: {
      isClosable: function() {
        return this.closable || this.$parent.closable;
      },
      active: function() {
        return this.$parent.currentName === (this.name || this.index);
      },
      router: function() {
        return this.$parent.router;
      },
      noHide: function() {
        return this.$parent.noHide;
      },
      paneStyle: function() {
        if (this.noHide && !this.active) {
          return {
            position: 'absolute',
            top: '-100000px',
            visibility: 'hidden'
          };
        }

        return {};
      }
    },
    mounted: function() {
      this.$parent.addPanes(this);
    },
    destroyed: function() {
      this.$parent.removePanes(this);
    },
    watch: {
      label: function() {
        this.$parent.$forceUpdate();
      }
    }
  };
  Vue.component(VueTabPane.name, VueTabPane);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueTabs = definition(context.Vue, context.VueUtil);
    delete context.VueTabs;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueTabNav = {
    props: {
      panes: Array,
      currentName: String,
      editable: Boolean,
      onTabClick: {
        type: Function,
        default: function() {}
      },
      onTabRemove: {
        type: Function,
        default: function() {}
      },
      type: String,
      router: Boolean
    },
    data: function() {
      return {
        scrollable: false,
        navStyle: {
          transform: ''
        },
        isMobile:VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
        mScreenWidth: document.documentElement.clientWidth,
        lastClickIndex:-1,
        mIsHandelTabAdd:false
      };
    },
    methods: {
      routeToItem: function(item) {
        var route = item.name;
        this.$router && this.$router.push(route);
      },
      scrollLeft: function(index) {
        var tabsList      = this.$refs.tabs;
        var currentOffset = this.getCurrentScrollOffset();
        var newOffset     = 0;
        newOffset = tabsList[index+1] ? currentOffset - tabsList[index+1].offsetWidth : currentOffset - tabsList[index].offsetWidth;
        if(newOffset<0)
          newOffset = 0;
        this.setOffset(newOffset);
      }, 
      scrollRight: function(index) {
        var scrollWidth   = this.$refs.nav.scrollWidth;
        var navWidth      = this.$refs.nav.offsetWidth;
        var tabsList      = this.$refs.tabs;
        var currentOffset = this.getCurrentScrollOffset();

        var newOffset = 0;
        if(currentOffset == 0){
          newOffset = tabsList[index-1] ? tabsList[index-1].offsetWidth : tabsList[index].offsetWidth;
        }else{
          newOffset = currentOffset+tabsList[index].offsetWidth;
        }
        if(scrollWidth>navWidth && newOffset > (scrollWidth-navWidth))
          newOffset = scrollWidth - navWidth;
        if(navWidth<= this.mScreenWidth && scrollWidth <= navWidth)
          newOffset = this.mScreenWidth - navWidth;
        this.setOffset(newOffset);
      },
      scrollPrev: function() {
        var currentOffset = this.getCurrentScrollOffset();
        if (!currentOffset) return;
        var tabWidth = this.$refs.tabs[0].offsetWidth;
        var newOffset = currentOffset > tabWidth ? currentOffset - tabWidth : 0;
        this.setOffset(newOffset);
      },
      scrollNext: function() {
        var navWidth = this.$refs.nav.offsetWidth;
        var containerWidth = this.$refs.navScroll.offsetWidth;
        var currentOffset = this.getCurrentScrollOffset();
        if (navWidth - currentOffset <= containerWidth) return;
        var tabWidth = this.$refs.tabs[0].offsetWidth;
        var newOffset = navWidth - currentOffset > tabWidth ? currentOffset + tabWidth : (navWidth - tabWidth);
        this.setOffset(newOffset);
      },
      scrollToActiveTab: function() {
        if (!this.scrollable || this.isMobile) return;
        var nav = this.$refs.nav;
        var activeTab = this.$el.querySelector('.is-active');
        var navScroll = this.$refs.navScroll;
        var activeTabBounding = activeTab.getBoundingClientRect();
        var navScrollBounding = navScroll.getBoundingClientRect();
        var navBounding = nav.getBoundingClientRect();
        var currentOffset = this.getCurrentScrollOffset();
        var newOffset = currentOffset;
        if (activeTabBounding.left < navScrollBounding.left) {
          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
        }
        if (activeTabBounding.right > navScrollBounding.right) {
          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
        }
        if (navBounding.right < navScrollBounding.right) {
          newOffset = nav.offsetWidth - navScrollBounding.width;
        }
        this.setOffset(Math.max(newOffset, 0));
      },
      getCurrentScrollOffset: function() {
        var navStyle = this.navStyle;
        return navStyle.transform ? Number(navStyle.transform.match(/translateX\(-(\d+(\.\d+)*)px\)/)[1]) : 0;
      },
      setOffset: function(value) {
        this.navStyle.transform = 'translateX(-' + value + 'px)';
      },
      update: function() {
        if (this.$refs.nav && this.$refs.navScroll) {
          var navWidth = this.$refs.nav.offsetWidth;
          var containerWidth = this.$refs.navScroll.offsetWidth;
          var currentOffset = this.getCurrentScrollOffset();
          if (containerWidth < navWidth) {
            this.scrollable = this.scrollable || {};
            this.scrollable.prev = currentOffset;
            this.scrollable.next = currentOffset + containerWidth < navWidth;
            if (navWidth - currentOffset < containerWidth) {
              this.setOffset(navWidth - containerWidth);
            }
          } else {
            this.scrollable = false;
            if (currentOffset > 0) {
              this.setOffset(0);
            }
          }
        }
      },
      scrollYMouseWheel: function(event) {
        if (this.scrollable) {
          event.preventDefault();
          var wheelDelta = event.wheelDelta || -event.detail;
          if (wheelDelta < 0) {
            this.scrollNext();
          } else {
            this.scrollPrev();
          }
        }
      }
    },
    updated: function() {
      if(this.isMobile){
        this.mIsHandelTabAdd  = true;
        return;
      }
      this.$nextTick(this.update);
    },
    render: function(createElement) {
      var type = this.type;
      var panes = this.panes;
      var editable = this.editable;
      var onTabClick = this.onTabClick;
      var onTabRemove = this.onTabRemove;
      var navStyle = this.navStyle;
      var scrollable = this.scrollable;
      var scrollNext = this.scrollNext;
      var scrollPrev = this.scrollPrev;
      var router = this.router;
      var routeToItem = this.routeToItem;
      var self = this;
      var scrollBtn = scrollable ? [createElement('span', {
        'class': ['vue-tabs__nav-prev', scrollable.prev ? '' : 'is-disabled'],
        on: {
          'click': scrollPrev
        }
      }, [createElement('i', {
        'class': 'vue-icon-arrow-left'
      }, [])]), createElement('span', {
        'class': ['vue-tabs__nav-next', scrollable.next ? '' : 'is-disabled'],
        on: {
          'click': scrollNext     
        }
      }, [createElement('i', {
        'class': 'vue-icon-arrow-right'
      }, [])])] : null;
        var tabs = this._l(panes, function(pane, index) {
        var tabName = pane.name || pane.index || index;
        var closable = pane.isClosable || editable;
        pane.index = '' + index;
        var btnClose = closable ? createElement('span', {'class': 'vue-icon-close', on: {'click': function click(ev) {onTabRemove(pane, ev);}}}, []) : null;
        var tabLabelContent = pane.$slots.label || pane.label;
        return createElement('div', {
          key: index,
          'class': {
            'vue-tabs__item': true,
            'is-active': pane.active,
            'is-disabled': pane.disabled,
            'is-closable': closable
          },
          ref: 'tabs',
          refInFor: true,
          on: {
            'click': function click(ev) {
              router && routeToItem(pane);
              onTabClick(pane, tabName, ev);
              if(self.isMobile){
                var scrollWidth = self.$refs.nav.scrollWidth;
                if(scrollWidth<=self.mScreenWidth)
                  return;
                if(event.clientX > 3*self.mScreenWidth/5 && (self.lastClickIndex == -1 || self.lastClickIndex < index)){
                  //tab向右滑动
                  self.scrollRight(index); 
                  // scrollNext();
                }
                else if(event.clientX < 2*self.mScreenWidth/5 && (self.lastClickIndex == -1 || self.lastClickIndex > index)){
                  //向左滑动
                  self.scrollLeft(index);
                }
                self.lastClickIndex = index;
              }
            }
          }
        }, [tabLabelContent, btnClose]);
      });
      return createElement('div', {
        'class': ['vue-tabs__nav-wrap', scrollable ? 'is-scrollable' : '']
      }, [scrollBtn, createElement('div', {
        'class': ['vue-tabs__nav-scroll'],
        ref: 'navScroll'
      }, [createElement('div', {
        'class': 'vue-tabs__nav',
        ref: 'nav',
        style: navStyle
      }, [tabs])])]);
    },
    computed: {
      mouseWheel: function() {
        return VueUtil.isFirefox ? 'DOMMouseScroll' : 'mousewheel';
      }
    },
    mounted: function() {
      VueUtil.on(this.$refs.navScroll, this.mouseWheel, this.scrollYMouseWheel);
      VueUtil.addResizeListener(this.$el, this.update);
    },
    beforeDestroy: function() {
      VueUtil.off(this.$refs.navScroll, this.mouseWheel, this.scrollYMouseWheel);
      VueUtil.removeResizeListener(this.$el, this.update);
    }
  };
  var VueTabs = {
    name: 'VueTabs',
    components: {
      TabNav: VueTabNav
    },
    props: {
      type: String,
      closable: Boolean,
      addable: Boolean,
      value: {},
      editable: Boolean,
      tabBottom: Boolean,
      router: Boolean,
      noHide: {
        type: Boolean,
        default: false,
      }
    },
    data: function() {
      return {
        currentName: this.value,
        panes: [],
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
        mTouchStartX:0,
        mTouchEndX:0,
        mTouchStartY:0,
        mTouchEndY:0
      };
    },
    watch: {
      value: function(value) {
        this.setCurrentName(value);
      },
      currentName: function(value) {
        var self = this;
        if (self.$refs.nav) {
          self.$nextTick(function() {
            self.$refs.nav.scrollToActiveTab();
          });
        }
      }
    },
    methods: {
      handleTabClick: function(tab, tabName, event) {
        if (tab.disabled)
          return;
        this.setCurrentName(tabName);
        this.$emit('tab-click', tab, event);
      },
      handleTabRemove: function(pane, ev) {
        if (pane.disabled)
          return;
        ev.stopPropagation();
        this.$emit('edit', pane.name, 'remove');
        this.$emit('tab-remove', pane.name);
      },
      handleTabAdd: function() {
        this.$emit('edit', null, 'add');
        this.$emit('tab-add');
      },
      setCurrentName: function(value) {
        this.currentName = value;
        this.$emit('input', value);
      },
      addPanes: function(item) {
        var index = this.$slots.default.filter(function(slot) {
          return slot.data;
        }).indexOf(item.$vnode);
        this.panes.splice(index, 0, item);
        if(this.isMobile && this.$refs.nav && this.$refs.nav.mIsHandelTabAdd){
          var self = this;
          this.$nextTick(function() {
              self.$refs.nav.scrollRight(this.panes.length-1); //右滑
          });
        }
      },
      removePanes: function(item) {
        var panes = this.panes;
        var index = panes.indexOf(item);
        if (index !== -1) {
          panes.splice(index, 1);
        }
      },
      touchStart:function(event) {
        this.mTouchStartX = event.changedTouches[0].clientX;
        this.mTouchStartY = event.changedTouches[0].clientY;
      },
      touchEnd:function(event) {
        this.mTouchEndX = event.changedTouches[0].clientX;
        this.mTouchEndY = event.changedTouches[0].clientY;
        var moveRangeX = this.mTouchStartX - this.mTouchEndX;
        var moveRangeY = this.mTouchStartY - this.mTouchEndY;
        var activePane = null;
        var self = this;
        if(moveRangeX>100 && Math.abs(moveRangeY)<50){
          for(var i=0;i<this.panes.length;i++){
            var pane = this.panes[i];
            if(pane.active){
              activePane = this.panes[i+1];
              break;
            }
          }
        }else if(moveRangeX<-50 && Math.abs(moveRangeY)<50){
          for(var j=this.panes.length-1;j>=0;j--){
            var pane2 = this.panes[j];
            if(pane2.active){
              activePane = this.panes[j-1];
              break;
            }
          }
        }

        if(activePane){
          this.handleTabClick(activePane,activePane.name,event);
          if (self.$refs.nav) {
            self.$nextTick(function() {
              if(moveRangeX>0)
                self.$refs.nav.scrollRight(activePane.index); //右滑
              else
              self.$refs.nav.scrollLeft(activePane.index); //左滑
            });
          }
        }
      },
    },
    render: function(createElement) {
      var type = this.type;
      var handleTabClick = this.handleTabClick;
      var handleTabRemove = this.handleTabRemove;
      var handleTabAdd = this.handleTabAdd;
      var currentName = this.currentName;
      var panes = this.panes;
      var editable = this.editable;
      var addable = this.addable;
      var tabBottom = this.tabBottom;
      var router = this.router;
      var self = this;
      var newButton = editable || addable ? createElement('vue-button', {
        'class': 'vue-tabs__new-tab',
        attrs: {
          type: 'text',
          icon: 'vue-icon-plus'
        },
        on: {
          'click': handleTabAdd
        }
      }, []) : null;
      var navData = {
        props: {
          panes: panes,
          currentName: currentName,
          editable: editable,
          onTabClick: handleTabClick,
          onTabRemove: handleTabRemove,
          type: type,
          router: router
        },
        ref: 'nav'
      };
      var header = createElement('div', {
        'class': 'vue-tabs__header'
      }, [newButton, createElement('tab-nav', navData, [])]);
      var panels = createElement('div', {
        'class': 'vue-tabs__content',
        on: {
          'touchstart': self.touchStart,
          'touchend': self.touchEnd,
        }
      }, [this.$slots.default]);
      return createElement('div', {
        'class': {
          'vue-tabs': true,
          'vue-tabs--card': type === 'card',
          'vue-tabs--border-card': type === 'border-card',
          'header-bottom': tabBottom
        }
      }, [tabBottom ? [panels, header] : [header, panels]]);
    },
    created: function() {
      if (!this.currentName) {
        this.setCurrentName('0');
      }
    }
  };
  Vue.component(VueTabs.name, VueTabs);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueTag = definition(context.Vue);
    delete context.VueTag;
  }
})(this, function(Vue) {
  'use strict';
  var VueTag = {
    template: '<div :class="[\'vue-tag\', type ? \'vue-tag--\' + type : \'\', {\'is-hit\': hit}]" :style="{width: closable ? width+32+\'px\' : width+13+\'px\'}"><span :style="{width: width+\'px\', float: \'left\'}" ref="span"><slot></slot></span><i class="vue-tag__close vue-icon-close" v-if="closable" @click="handleClose"></i></div>',
    name: 'VueTag',
    props: {
      text: String,
      closable: Boolean,
      type: String,
      hit: Boolean,
      width: Number
    },
    methods: {
      handleClose: function(event) {
        this.$emit('close', event);
      }
    },
    mounted: function() {
      var el = this.$el;
      var spanNode = this.$refs.span;
      if (this.width && this.width < spanNode.scrollWidth) {
        el.setAttribute('title', el.innerText);
      }
    }
  };
  Vue.component(VueTag.name, VueTag);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueOption = definition(context.Vue, context.VueUtil);
    delete context.VueOption;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueOption = {
    template: '<li @mouseenter="hoverItem" @click.stop="selectOptionClick" v-show="visible" :class="[\'vue-select-dropdown__item\', {\'selected\': itemSelected, \'is-disabled\': disabled || groupDisabled || limitReached, \'hover\': itemHover}]"><slot><span>{{parent.getFormatedLabel(self)}}</span></slot></li>',
    name: 'VueOption',
    mixins: [VueUtil.component.emitter],
    props: {
      value: {
        required: true
      },
      label: [String, Number],
      selected: Boolean,
      created: Boolean,
      disabled: Boolean
    },
    data: function() {
      return {
        self: this,
        index: -1,
        groupDisabled: false,
        visible: true,
        hitState: false
      };
    },
    computed: {
      currentLabel: function() {
        return this.label || ((VueUtil.isString(this.value) || VueUtil.isNumber(this.value)) ? this.value : '');
      },
      currentValue: function() {
        return this.value || this.label || '';
      },
      parent: function() {
        var result = this.$parent;
        while (!result.isSelect) {
          result = result.$parent;
        }
        return result;
      },
      itemSelected: function() {
        if (!this.parent.multiple) {
          return this.value === this.parent.value;
        } else {
          return this.parent.value.indexOf(this.value) !== -1;
        }
      },
      itemHover: function() {
        return this.parent.hoverIndex === this.parent.options.indexOf(this);
      },
      limitReached: function() {
        if (this.parent.multiple) {
          return !this.itemSelected && this.parent.value.length >= this.parent.multipleLimit && this.parent.multipleLimit > 0;
        } else {
          return false;
        }
      }
    },
    watch: {
      currentLabel: function() {
        if (!this.created && !this.parent.remote && !this.parent.lazyload)
          this.dispatch('VueSelect', 'setSelected');
      },
      value: function() {
        if (!this.created && !this.parent.remote && !this.parent.lazyload)
          this.dispatch('VueSelect', 'setSelected');
      }
    },
    methods: {
      handleGroupDisabled: function(val) {
        this.groupDisabled = val;
      },
      hoverItem: function() {
        if (!this.disabled && !this.groupDisabled) {
          this.parent.hoverIndex = this.parent.options.indexOf(this);
        }
      },
      selectOptionClick: function() {
        if (this.disabled !== true && this.groupDisabled !== true) {
          this.dispatch('VueSelect', 'handleOptionClick', this);
        }
      },
      queryChange: function(query) {
        if (!this.parent.lazyload && VueUtil.isFunction(this.parent.filterMethod) && this.parent.data.length > 0) {
          this.visible = this.parent.filterMethod(query, this.parent.data[this.index], this.parent.getFormatedLabel(this));
        } else {
          var parsedQuery = String(query).replace(/(\^|\(|\)|\[|\]|\$|\*|\+|\.|\?|\\|\{|\}|\|)/g, '\\$1');
          this.visible = new RegExp(parsedQuery, 'i').test(this.parent.getFormatedLabel(this)) || this.created;
        }
        if (!this.visible) {
          this.parent.filteredOptionsCount--;
        }
      },
      resetIndex: function() {
        var self = this;
        self.$nextTick(function() {
          self.index = self.parent.options.indexOf(self);
        });
      }
    },
    created: function() {
      this.parent.options.push(this);
      this.parent.cachedOptions.push(this);
      this.parent.optionsCount++;
      this.parent.filteredOptionsCount++;
      this.index = this.parent.options.indexOf(this);
      this.$on('queryChange', this.queryChange);
      this.$on('handleGroupDisabled', this.handleGroupDisabled);
      this.$on('resetIndex', this.resetIndex);
    },
    beforeDestroy: function() {
      this.dispatch('VueSelect', 'onOptionDestroy', this);
    }
  };
  Vue.component(VueOption.name, VueOption);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueOptionGroup = definition(context.Vue, context.VueUtil);
    delete context.VueOptionGroup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueOptionGroup = {
    template: '<ul class="vue-select-group__wrap"><li class="vue-select-group__title" v-show="visible">{{label}}</li><li><ul class="vue-select-group"><slot></slot></ul></li></ul>',
    name: 'VueOptionGroup',
    mixins: [VueUtil.component.emitter],
    props: {
      label: String,
      disabled: Boolean
    },
    data: function() {
      return {
        visible: true
      };
    },
    watch: {
      disabled: function(val) {
        this.broadcast('VueOption', 'handleGroupDisabled', val);
      }
    },
    methods: {
      queryChange: function() {
        this.visible = this.$children && VueUtil.isArray(this.$children) && this.$children.some(function(option) {
          return option.visible === true;
        });
      }
    },
    created: function() {
      this.$on('queryChange', this.queryChange);
    },
    mounted: function() {
      if (this.disabled) {
        this.broadcast('VueOption', 'handleGroupDisabled', this.disabled);
      }
    }
  };
  Vue.component(VueOptionGroup.name, VueOptionGroup);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopper'], definition);
  } else {
    context.VueSelectDropdown = definition(context.Vue, context.VuePopper);
    delete context.VueSelectDropdown;
  }
})(this, function(Vue, VuePopper) {
  'use strict';
  var VueSelectDropdown = {
    template: '<div :class="[\'vue-select-dropdown\', {\'is-multiple\': $parent.multiple}, popperClass]"><slot></slot></div>',
    name: 'VueSelectDropdown',
    mixins: [VuePopper],
    props: {
      placement: {
        type: String,
        default: 'bottom-start',
      },
      autoWidth: {
        type: Boolean,
        default: true
      }
    },
    computed: {
      popperClass: function() {
        return this.$parent.popperClass;
      }
    },
    mounted: function() {
      this.referenceElm = this.$parent.$refs.reference.$el;
      this.$parent.popperElm = this.popperElm = this.$el;
      this.$on('updatePopper', this.updatePopper);
      this.$on('destroyPopper', this.destroyPopper);
    }
  };
  Vue.component(VueSelectDropdown.name, VueSelectDropdown);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueSelect = definition(context.Vue, context.VueUtil);
    delete context.VueSelect;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var formatedLabelCache = [];
  var getValueByPath = function(object, prop) {
    prop = prop || '';
    var paths = prop.split('.');
    var current = object;
    var result = null;
    VueUtil.loop(paths, function(path, i) {
      if (!current) return false;
      if (i === paths.length - 1) {
        result = current[path];
        return false;
      }
      current = current[path];
    });
    return result;
  };
  var VueSelect = {
    template: 
    '<div :class="[\'vue-select\', {\'filter-vue-select\': isMobile && visible && filterable}]" v-clickoutside="handleClose" v-scrolling="handleClose"> \
      <div :class="[\'vue-select__tags\', {\'no-reset-height\': !autoHeight}]" v-if="multiple" @click.stop="toggleMenu" \
        ref="tags" :style="{\'max-width\': inputWidth - 32 + \'px\'}"> \
        <transition-group @after-leave="resetInputHeight"> \
          <vue-tag v-for="(item, index) in selected" :key="getValueKey(item)" :closable="!disabled" hit :type="disabled ? \'\' : \'info\'" \
            @close="deleteTag($event, item)"><span class="vue-select__tags-text">{{getFormatedLabel(item)}}</span></vue-tag> \
        </transition-group>\
        <input type="text" :class="[\'vue-select__input\', {\'is-mini\': size===\'mini\'}]" @focus="visible == true" \
          :disabled="disabled" @keyup="managePlaceholder" @keydown="resetInputState" @keydown.down.prevent="navigateOptions(\'next\')" \
          @keydown.up.prevent="navigateOptions(\'prev\')" @keydown.enter.prevent="selectOption" @keydown.esc.prevent="visible = false" \
          @keydown.delete="deletePrevTag" v-model="query" v-if="filterable" :readonly="isMobile" :style="{width: multipleInputLength + \'px\', \'max-width\': inputWidth - 42 + \'px\'}" \
          ref="input" />\
      </div> \
      <vue-input ref="reference" v-model="selectedLabel" type="text" :text-align="textAlign" \
        :placeholder="placeholderLang" :autofocus="autofocus" :tabindex="tabindex" :name="name" :size="size" \
        :disabled="disabled" :readonly="isMobile || !filterable || multiple" :validate-event="false" @click="handleIconClick" \
        @mousedown.native="handleMouseDown" @keyup.native="debouncedOnInputChange" @input="keepMenu" @keydown.native.down.prevent="navigateOptions(\'next\')" \
        @keydown.native.up.prevent="navigateOptions(\'prev\')" @keydown.native.enter.prevent="selectOption" \
        @keydown.native.esc.prevent="visible = false" @keydown.native.tab="visible = false" @paste.native="debouncedOnInputChange" \
        @mouseenter.native="inputHovering = true" @mouseleave.native="inputHovering = false" :icon="iconClass"></vue-input> \
      <transition @after-leave="destroyPopper" @after-enter="handleMenuEnter"> \
        <vue-select-dropdown ref="popper" v-show="visible && emptyText !== false"  :append="append" > \
        <div :class="{\'vue-select-dropdown_main\':isMobile}">\
          <div @touchmove.prevent v-if="isMobile && visible && emptyText !== false" class="vue-aside__wrapper" @click="handleClose"></div> \
            <div :class="{\'vue-aside vue-aside-bottom\':isMobile && visible && emptyText !== false}">\
              <div class="tag_view" v-if="isMobile && visible && emptyText !== false && filterable && multiple && selected.length>0" @click.stop="toggleMenu">\
                <transition-group   @after-leave="resetInputHeight" > \
                  <vue-tag v-for="(item, index) in selected" :key="getValueKey(item)" :closable="!disabled" hit :type="disabled ? \'\' : \'info\'" \
                  @close="deleteTag($event, item)"><span class="vue-select__tags-text">{{getFormatedLabel(item)}}</span></vue-tag> \
                </transition-group>\
              </div>\
              <vue-input ref="filterInputRef" v-if="isMobile && visible && emptyText !== false && filterable" v-model="selectedLabel" type="text"\
              :placeholder="placeholderLang" @input="debouncedOnInputChange"\
              :icon="iconClass" @click="handleIconClick"></vue-input>\
              <div :class="{\'vue-select-dropdown_list_main\':isMobile && visible && emptyText !== false}">\
                <ul :class="[\'vue-select-dropdown__list\', {\'is-empty\': !allowCreate && filteredOptionsCount === 0}]" \
                  v-show="options.length > 0 && !loading"> \
                  <vue-option :value="query" created v-if="showNewOption"></vue-option> \
                  <vue-recycle-scroller \
                  ref="scroller" \
                  class="recycle-scroller" \
                  :items="lazyData" \
                  :item-size="itemSize" \
                  :key-field="valueMember" \
                  v-slot="ref" \
                  v-if="lazyload"> \
                    <slot :item="ref.item"></slot> \
                  </vue-recycle-scroller> \
                  <slot v-else></slot> \
                </ul> \
                <p class="vue-select-dropdown__empty" v-if="emptyText && !allowCreate">{{emptyText}}</p> \
              </div>\
          </div>\
          </div>\
        </vue-select-dropdown> \
      </transition> \
    </div>',
    mixins: [VueUtil.component.emitter],
    name: 'VueSelect',
    computed: {
      iconClass: function() {
        var criteria;
        var resultCss;
        if (this.multiple) {
          if (this.visible) {
            criteria = this.clearable && !this.disabled && this.inputHovering;
            resultCss = criteria && !this.multipleLimit && !this.lazyload ? 'vue-icon-success is-show-check' : (this.remote && this.filterable ? '' : 'vue-icon-arrow-up is-reverse');
            if(this.isMobile){
              criteria = this.clearable && !this.disabled;
              resultCss = criteria && !this.multipleLimit && !this.lazyload ? this.filterAllSelectedStatus ? 'vue-icon-success is-show-check is-all-select' : 'vue-icon-success is-show-check' : (this.remote && this.filterable ? '' : 'vue-icon-arrow-up is-reverse');
            }
            return resultCss;
          } else {
            criteria = this.clearable && !this.disabled && this.inputHovering && VueUtil.isDef(this.value) && this.value.length > 0;
            if(this.isMobile)
              criteria = this.clearable && !this.disabled && VueUtil.isDef(this.value) && this.value.length > 0;
            return criteria ? 'vue-icon-error is-show-close' : (this.remote && this.filterable ? '' : 'vue-icon-arrow-up');
          }
        } else {
          criteria = this.clearable && !this.disabled && this.inputHovering && VueUtil.isDef(this.value) && this.value !== '';
          resultCss = criteria ? 'vue-icon-error is-show-close' : (this.remote && this.filterable ? '' : 'vue-icon-arrow-up');
          if(this.isMobile){
            criteria = this.clearable && !this.disabled && VueUtil.isDef(this.value) && this.value !== '' && !this.visible;
            resultCss = criteria ? 'vue-icon-error is-show-close' : (this.remote || this.filterable) && this.visible ? '' : 'vue-icon-arrow-up';
          }
          return resultCss;
        }
      },
      emptyText: function() {
        if (this.loading) {
          return this.loadingText || this.$t('vue.select.loading');
        } else if (this.lazyload) {

          if (this.remote && this.query === '' && this.options.length === 0){
            if(this.isMobile && this.filterable && this.visible && this.selectedLabel.length>=0){
              return null;
            }
            return false;

          }
          if (this.filterable && this.data.length > 0 && this.lazyData.length === 0) {
            return this.noMatchText || this.$t('vue.select.noMatch');
          }
          if (this.data.length === 0) {
            return this.noDataText || this.$t('vue.select.noData');
          }
        } else {
          if (this.remote && this.query === '' && this.options.length === 0){
            if(this.isMobile && this.filterable && this.visible && this.selectedLabel.length>=0){
              return null;
            }
            return false;
          }
          if (this.filterable && this.options.length > 0 && this.filteredOptionsCount === 0) {
            return this.noMatchText || this.$t('vue.select.noMatch');
          }
          if (this.options.length === 0) {
            return this.noDataText || this.$t('vue.select.noData');
          }
        }
        return null;
      },
      showNewOption: function() {
        var self = this;
        var hasExistingOption = VueUtil.filter(self.options, function(option) {
          return !option.created;
        }).some(function(option) {
          return option.currentLabel === self.query;
        });
        return self.filterable && self.allowCreate && self.query !== '' && !hasExistingOption;
      },
      placeholderLang: function() {
        if (this.multiple) {
          if (VueUtil.isArray(this.value) && this.value.length > 0) {
            return '';
          } else if (this.query) {
            return '';
          } else {
            if (!this.currentPlaceholder) {
              return this.$t('vue.select.placeholder');
            }
            return this.currentPlaceholder;
          }
        }
        if (!this.placeholder)
          return this.$t('vue.select.placeholder');
        return this.placeholder;
      }
    },
    directives: {
      Clickoutside: VueUtil.component.clickoutside(),
      Scrolling: VueUtil.component.scrolling
    },
    props: {
      name: String,
      value: {required: true},
      size: String,
      disabled: Boolean,
      clearable: Boolean,
      filterable: Boolean,
      allowCreate: Boolean,
      loading: Boolean,
      popperClass: String,
      remote: Boolean,
      loadingText: String,
      noMatchText: String,
      noDataText: String,
      autofocus: Boolean,
      textAlign: String,
      tabindex: Number,
      remoteMethod: Function,
      filterMethod: Function,
      multiple: Boolean,
      multipleLimit: {
        type: Number,
        default: 0
      },
      placeholder: String,
      autoHeight: {
        type: Boolean,
        default: true
      },
      valueKey: {
        type: String,
        default: 'value'
      },
      lazyload: {
        type: Boolean,
        default: false
      },
      itemSize: {
        type: Number,
        default:36
      },
      displayMember: {
        type: String,
        default: 'label'
      },
      valueMember: {
        type: String,
        default: 'value'
      },
      data: {
        type: Array,
        default: function() {
          return [];
        }
      },
      labelFormatter: Function,
      appendToSelf: Boolean
    },
    data: function() {
      return {
        options: [],
        cachedOptions: [],
        createdLabel: null,
        createdSelected: false,
        selected: this.multiple ? [] : {},
        isSelect: true,
        multipleInputLength: 20,
        inputWidth: 0,
        cachedPlaceHolder: '',
        optionsCount: 0,
        filteredOptionsCount: 0,
        dropdownUl: null,
        visible: false,
        selectedLabel: '',
        hoverIndex: -1,
        query: '',
        bottomOverflowBeforeHidden: 0,
        topOverflowBeforeHidden: 0,
        optionsAllDisabled: false,
        inputHovering: false,
        currentPlaceholder: '',
        lazyData: [],
        append: null,
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
        filterAllSelectedStatus:false,
      };
    },
    watch: {
      data: {
        immediate: true,
        handler: function(val) {
          formatedLabelCache = [];
          this.lazyData = val;
        }
      },
      multiple: function(val) {
        var self = this;
        if (self.$refs.reference) {
          self.$refs.reference.setCurrentValue('');
        }
        if (val) {
          self.selected = [];
          self.$nextTick(function() {
            self.$emit('input', []);
          });
        } else {
          self.selected = {};
          self.$nextTick(function() {
            self.$emit('input', '');
          });
        }
      },
      value: function(val, oldVal) {
        var self = this;
        var valueItem;
        
        if (this.multiple) {
          this.resetInputHeight();
          if (val.length > 0 || (this.$refs.input && this.query !== '')) {
            this.currentPlaceholder = '';
          } else {
            this.currentPlaceholder = this.cachedPlaceHolder;
          }
          var valueMap = {};
          valueItem = [];
          if (val.length > 0) {
            
            if (this.lazyload) {
              for (var i = 0; i < this.data.length; i++) {
                var index = val.indexOf(this.data[i][self.valueMember]);
                if(index > -1) {
                  valueMap[index] = this.data[i];
                }
              }
            } else {
              for (var j = 0; j < this.options.length; j++) {
                var optionsIndex = val.indexOf(this.options[j].value);
                if(optionsIndex > -1) {
                  valueMap[optionsIndex] = this.data[j];
                }
              }
            }
          }
          
          for (var j = 0; j < Object.keys(valueMap).length; j++) {
            valueItem.push(valueMap[j]);
          }
        } else {
          if (this.lazyload) {
            valueItem = VueUtil.arrayFind(this.data, function(item) {
              return item[self.valueMember] === val;
            });
          } else {
            var optionIndex = VueUtil.arrayFindIndex(this.options, function(option) {
              return option.value == val;
            });
            valueItem = this.data[optionIndex];
          }
        }
        this.setSelected();
        this.$emit('change', val, valueItem, oldVal);
        this.dispatch('VueFormItem', 'vue.form.change', val);
      },
      query: function(val) {
        var self = this;
        self.$nextTick(function() {
          self.broadcast('VueSelectDropdown', 'updatePopper');
        });
        self.hoverIndex = -1;
        if (self.multiple && self.filterable) {
          self.resetInputHeight();
        }
        if (this.lazyload) {
          val = val || '';
          var parsedQuery = String(val).replace(/(\^|\(|\)|\[|\]|\$|\*|\+|\.|\?|\\|\{|\}|\|)/g, '\\$1');
          var reg = new RegExp(parsedQuery, 'i');
          this.filteredOptionsCount = this.data.length;
          var result = this.data.filter(function (option) {
            var currentLabel = option[self.displayMember] || ((VueUtil.isString(option[self.valueMember]) || VueUtil.isNumber(option[self.valueMember])) ? option[self.valueMember] : '');
            var formatedLabel = self.getFormatedLabel({
              currentLabel: currentLabel,
              value: option[self.valueMember]
            });

            var visible;
            if (VueUtil.isFunction(self.filterMethod)) {
              visible = self.filterMethod(val, option, formatedLabel);
            } else {
              visible = reg.test(formatedLabel);
            }

            if (!visible) {
              self.filteredOptionsCount--;
            }
            return visible;
          });

          this.lazyData = result;
          return;
        } else if (self.remote && VueUtil.isFunction(self.remoteMethod)) {
          self.hoverIndex = -1;
          self.remoteMethod(val);
          self.broadcast('VueOption', 'resetIndex');
        } else {
          self.filteredOptionsCount = self.optionsCount;
          self.broadcast('VueOption', 'queryChange', val);
          self.broadcast('VueOptionGroup', 'queryChange');
        }
      },
      selectedLabel: function(val){
      },
      visible: function(val) {
        var self = this;
        if(this.lazyload) {
          this.$refs.scroller.scrollToPosition(0);
        }
        if (!val) {
          self.$refs.reference.$refs.input.blur();
          self.handleIconHide();
          self.broadcast('VueSelectDropdown', 'destroyPopper');
          if (self.$refs.input) {
            self.$refs.input.blur();
          }
          self.query = '';
          self.selectedLabel = '';
          self.resetHoverIndex();
          self.$nextTick(function() {
            if (self.$refs.input && self.$refs.input.value === '' && self.selected.length === 0) {
              self.currentPlaceholder = self.cachedPlaceHolder;
            }
          });
          if (!self.multiple) {
            self.getOverflows();
            if (self.selected) {
              if (self.filterable && self.allowCreate && self.createdSelected && self.createdOption) {
                self.selectedLabel = self.createdLabel;
              } else {
                self.selectedLabel = self.getFormatedLabel(self.selected);
              }
              if (self.filterable)
                self.query = self.selectedLabel;
            }
          }
        } else {
          self.handleIconShow();
          self.broadcast('VueSelectDropdown', 'updatePopper');
          if (self.filterable) {
            self.query = self.selectedLabel;
            if (self.multiple) {
              if(self.$refs.input && !self.isMobile)
                self.$refs.input.focus();
            } else {
              if (!self.remote && !self.lazyload) {
                self.broadcast('VueOption', 'queryChange', '');
                self.broadcast('VueOptionGroup', 'queryChange');
              }
            }
            if(self.isMobile && self.remote){
              setTimeout(function(){
                self.$refs.filterInputRef.focus();
                self.$refs.reference.focus();
              },50);
            }
          }
        }
        
        self.$emit('visible-change', val);
      },
      options: function(val) {
        var self = this;
        self.optionsAllDisabled = val.length === VueUtil.filter(val, function(item) {
          return item.disabled === true;
        }).length;
        if (self.multiple) {
          self.resetInputHeight();
        }
        var inputs = self.$el.querySelectorAll('input');
        if ([].indexOf.call(inputs, document.activeElement) === -1) {
          self.setSelected();
        }
      },
      selected: function() {
        this.resetMultipeInput();
      },
      placeholder: function(val) {
        this.cachedPlaceHolder = val;
        this.managePlaceholder();
      }
    },
    methods: {
      focus: function() {
        this.$refs.reference && this.$nextTick(this.$refs.reference.focus);
      },
      handleIconHide: function() {
        var icon = this.$refs.reference.$refs.icon;
        if (icon) {
          VueUtil.removeClass(icon, 'is-reverse');
        }
      },
      handleIconShow: function() {
        var icon = this.$refs.reference.$refs.icon;
        if (icon && !VueUtil.hasClass(icon, 'vue-icon-error')) {
          VueUtil.addClass(icon, 'is-reverse');
        }
      },
      handleMenuEnter: function() {
        if (!this.dropdownUl) {
          this.dropdownUl = this.$refs.popper.$el.querySelector('.vue-select-dropdown__list');
          this.getOverflows();
        }
      },
      getOverflows: function() {
        if (this.dropdownUl && this.selected && this.selected.$el) {
          var selectedRect = this.selected.$el.getBoundingClientRect();
          var popperRect = this.$refs.popper.$el.getBoundingClientRect();
          this.bottomOverflowBeforeHidden = selectedRect.bottom - popperRect.bottom;
          this.topOverflowBeforeHidden = selectedRect.top - popperRect.top;
        }
      },
      getOption: function(value) {
        var option;
        var self = this;

        if (this.lazyload) {
          option = VueUtil.filter(this.data, function(option) {
            return option[self.valueMember] === value;
          })[0];
          if (option) {
            option = VueUtil.merge({}, option);
            option.value = option[this.valueMember];
            option.currentLabel = option[this.displayMember] || ((VueUtil.isString(option[this.valueMember]) || VueUtil.isNumber(option[this.valueMember])) ? option[this.valueMember] : '');
          }
        } else {
          option = VueUtil.filter(this.cachedOptions, function(option) {
            return option.value === value;
          })[0];
        }
        if (option)
          return option;
        var label = VueUtil.isString(value) || VueUtil.isNumber(value) ? value : '';
        var newOption = {
          value: value,
          currentLabel: label
        };
        return newOption;
      },
      setSelected: function() {
        var self = this;
        if (!self.multiple) {
          var option = self.getOption(self.value);
          if (option.created) {
            self.createdLabel = option.currentLabel;
            self.createdSelected = true;
          } else {
            self.createdSelected = false;
          }
          //移动端过滤输入框内容回退为空时，不做已选中值对它的重新赋值
          if(!(this.isMobile && this.visible && (this.remote || this.allowCreate)))
            self.selectedLabel = self.getFormatedLabel(option);

          self.selected = option;
          if (self.filterable)
            self.query = self.selectedLabel;
          return;
        }
        var result = [];
        VueUtil.loop(self.value, function(value) {
          result.push(self.getOption(value));
        });
        self.selected = result;
        self.$nextTick(function() {
          self.resetInputHeight();
        });
      },
      handleIconClick: function(event) {
        var value = [];
        if (this.iconClass.indexOf('vue-icon-error') !== -1) {
          this.deleteSelected(event);
        }else if(this.isMobile && this.iconClass.indexOf('vue-icon-success is-show-check is-all-select') !== -1){
          this.$emit('input', value);
          this.filterAllSelectedStatus = false;
        } else if (this.iconClass.indexOf('vue-icon-success is-show-check') !== -1) {
          VueUtil.loop(this.options, function(option) {
            if (!option.disabled) {
              value.push(option.value);
            }
          });
          this.$emit('input', value);
          this.filterAllSelectedStatus = true;
        }else {
          this.toggleMenu();
        }
      },
      handleMouseDown: function(event) {
        if (event.target.tagName !== 'INPUT')
          return;
        if (this.visible) {
          this.handleClose();
          this.focus();
          event.preventDefault();
        } else {
          this.toggleMenu();
        }
      },
      destroyPopper: function() {
        this.$refs.popper.destroyPopper();
      },
      handleClose: function() {
        this.visible = false;
      },
      deletePrevTag: function(e) {
        if (e.target.value.length <= 0) {
          var value = VueUtil.mergeArray([], this.value);
          value.pop();
          this.$emit('input', value);
        }
      },
      managePlaceholder: function() {
        if (this.currentPlaceholder !== '' && this.$refs.input) {
          this.currentPlaceholder = this.$refs.input.value ? '' : this.cachedPlaceHolder;
        }
      },
      resetInputState: function(e) {
        if (e.keyCode !== 8) {
          this.resetInputHeight();
        }
      },
      resetInputHeight: function() {
        var self = this;
        if (!this.autoHeight) return;
        self.$nextTick(function() {
          var sizeMap = {'large': 42, 'small': 30, 'mini': 22};
          var input = self.$refs.reference.$refs.input;
          var icon = self.$refs.reference.$refs.icon;
          input.style.height = '';
          if(icon) icon.style.lineHeight = '';

          var size = input.offsetHeight || 36;
          if(icon) icon.style.lineHeight = size + 'px';
          var newHeight = (parseInt(self.$refs.tags.children[0].offsetHeight / size, 10) + 1) * size;
          if (self.selected.length > 0 && self.multipleInputLength == self.inputWidth - 45) {
            newHeight += size;
          }

          newHeight !== size ? newHeight += 'px' : newHeight = '';
          input.style.height = newHeight;
          if(icon) icon.style.lineHeight = newHeight;
          if (self.visible && self.emptyText !== false) {
            self.broadcast('VueSelectDropdown', 'updatePopper');
          }
        });
      },
      resetHoverIndex: function() {
        var self = this;
        self.$nextTick(function() {
          if (!self.multiple) {
            self.hoverIndex = self.options.indexOf(self.selected);
          } else {
            if (self.selected.length > 0) {
              self.hoverIndex = Math.min.apply(null, VueUtil.map(self.selected, function(item) {
                return self.options.indexOf(item);
              }));
            } else {
              self.hoverIndex = -1;
            }
          }
        });
      },
      handleOptionSelect: function(option) {
        if (this.multiple) {
          var value = VueUtil.mergeArray([], this.value);
          var optionIndex = value.indexOf(option.value);
          if (optionIndex !== -1) {
            value.splice(optionIndex, 1);
          } else if (this.multipleLimit <= 0 || value.length < this.multipleLimit) {
            value.push(option.value);
          }
          this.$emit('input', value);
          if (option.created) {
            this.query = '';
          }
          if (this.filterable) {
            this.query = '';
            this.$refs.input.focus();
          } else {
            this.focus();
          }
        } else {
          this.$emit('input', option.value);
          this.visible = false;
          this.focus();
        }
      },
      toggleMenu: function() {
        if (this.filterable && this.query === '' && this.visible) {
          return;
        }
        if (!this.disabled) {
          this.visible = !this.visible;
        }
      },
      keepMenu: function() {
        if (!this.visible) {
          this.visible = true;
        }
      },
      navigateOptions: function(direction) {
        if (!this.visible) {
          this.visible = true;
          return;
        }
        if (this.options.length === 0 || this.filteredOptionsCount === 0)
          return;
        this.optionsAllDisabled = this.options.length === VueUtil.filter(this.options, function(item) {return item.disabled === true;}).length;
        if (!this.optionsAllDisabled) {
          if (direction === 'next') {
            if (this.lazyload) {
              this.getHoverIndexLazy(direction);
            } else {
              this.hoverIndex++;
              if (this.hoverIndex === this.options.length) {
                this.hoverIndex = 0;
              }
            }
            this.resetScrollTop();
            if (this.options[this.hoverIndex].disabled === true || this.options[this.hoverIndex].groupDisabled === true || !this.options[this.hoverIndex].visible) {
              this.navigateOptions('next');
            }
          }
          if (direction === 'prev') {
            if (this.lazyload) {
              this.getHoverIndexLazy(direction);
            } else {
              this.hoverIndex--;
              if (this.hoverIndex < 0) {
                this.hoverIndex = this.options.length - 1;
              }
            }
            this.resetScrollTop();
            if (this.options[this.hoverIndex].disabled === true || this.options[this.hoverIndex].groupDisabled === true || !this.options[this.hoverIndex].visible) {
              this.navigateOptions('prev');
            }
          }
        }
      },
      getHoverIndexLazy: function(direction) {
        var self = this;
        var currentLazyList = this.lazyData.slice(this.$refs.scroller.$_startIndex, this.$refs.scroller.$_endIndex);
        var hoverIndex = self.hoverIndex;
        var hoverValue;

        if(hoverIndex > -1) {
          var currentHoverValue = self.options[self.hoverIndex].value;
          //当前数据中处于第几个
          hoverIndex = VueUtil.findIndex(currentLazyList, function(option) {
            return option[self.valueMember] == currentHoverValue;
          });
        }

        if (direction == 'next') {
          hoverIndex++;
          if (hoverIndex == currentLazyList.length) {
            hoverIndex = currentLazyList.length -1;
          }
        } else if (direction == 'prev') {
          hoverIndex--;
          if (hoverIndex < 0) {
            hoverIndex = 0;
          }
        }
        hoverValue = currentLazyList[hoverIndex][self.valueMember];

        this.hoverIndex = VueUtil.findIndex(self.$refs.scroller.pool, function(pool) {
          return pool.position > -1 && pool.item[self.valueMember] == hoverValue;
        });
        
      },
      resetScrollTop: function() {
        var scrollPanel = this.lazyload ? this.$refs.scroller.$el : this.dropdownUl;

        var bottomOverflowDistance = this.options[this.hoverIndex].$el.getBoundingClientRect().bottom - this.$refs.popper.$el.getBoundingClientRect().bottom;
        var topOverflowDistance = this.options[this.hoverIndex].$el.getBoundingClientRect().top - this.$refs.popper.$el.getBoundingClientRect().top;
        if (bottomOverflowDistance > 0) {
          scrollPanel.scrollTop += bottomOverflowDistance;
        }
        if (topOverflowDistance < 0) {
          scrollPanel.scrollTop += topOverflowDistance;
        }
      },
      selectOption: function(event) {
        if (this.visible) {
          event.stopPropagation();
        } else {
          this.visible = true;
          return;
        }
        if (this.options[this.hoverIndex]) {
          this.handleOptionSelect(this.options[this.hoverIndex]);
        }
      },
      deleteSelected: function(event) {
        event && event.stopPropagation();
        if (this.multiple) {
          this.$emit('input', []);
        } else {
          this.$emit('input', '');
        }
        this.visible = false;
      },
      deleteTag: function(event, tag) {
        var index = this.selected.indexOf(tag);
        if (index !== -1 && !this.disabled) {
          var value = VueUtil.mergeArray([], this.value);
          value.splice(index, 1);
          this.$emit('input', value);
          this.$emit('remove-tag', tag);
        }
        event.stopPropagation();
      },
      onInputChange: function() {
        if (this.filterable) {
          this.query = this.selectedLabel;
        }
      },
      onOptionDestroy: function(option) {
        this.optionsCount--;
        this.filteredOptionsCount--;
        var index = this.options.indexOf(option);
        if (index !== -1) {
          this.options.splice(index, 1);
        }
        
        var self = this;
        VueUtil.throttle(100, function() {
          self.broadcast('VueOption', 'resetIndex');
        }).apply(self);
      },
      resetInputWidth: function() {
        var self = this;
        self.inputWidth = self.$refs.reference.$el.getBoundingClientRect().width;
        this.$nextTick(function() {
          setTimeout(function() {
            if(VueUtil.get(self, '$refs.reference.$el')) {
              self.inputWidth = self.$refs.reference.$el.getBoundingClientRect().width;
              self.resetMultipeInput();
            }
          }, 500);
        });
      },
      handleResize: function() {
        this.resetInputWidth();
        if (this.multiple) this.resetInputHeight();
      },
      debouncedOnInputChange: VueUtil.debounce(function() {
        this.onInputChange();
      }),
      getValueKey: function(item) {
        if (Object.prototype.toString.call(item.value).toLowerCase() !== '[object object]') {
          return item.value;
        } else {
          return getValueByPath(item.value, this.valueKey);
        }
      },
      getFormatedLabel: function(option) {
        if(!VueUtil.isFunction(this.labelFormatter)) {
          return option.currentLabel;
        }

        var keySpliter = '|';
        var key = option.currentLabel + keySpliter + option.value;
        var label = formatedLabelCache[key];
        if (label === undefined) {
          formatedLabelCache[key] = this.labelFormatter(option.currentLabel, option.value);
        }
        return formatedLabelCache[key];
      },

      resetMultipeInput: function() {
        var self = this;
        if(this.multiple && this.filterable) {
          self.multipleInputLength = 1;
          self.$nextTick(function() {
            setTimeout(function() {
              var totalLength = self.inputWidth;
              var inputReact = self.$refs.input.getBoundingClientRect();
              var totalTag = self.$refs.tags.querySelectorAll('.vue-tag');
              var sameLineTagCount = 0;
              for (var i = 0; i < self.selected.length; i++) {
                if(totalTag[i]) {
                  var tagReact = totalTag[i].getBoundingClientRect();
                  if(Math.abs(inputReact.top - tagReact.top) < 10) {
                    sameLineTagCount++;
                    totalLength -= (tagReact.width + 6); //6px是tag的margin-left
                  }
                }
              }
              self.multipleInputLength = totalLength - 45;

              if (sameLineTagCount === 0) {
                self.resetInputHeight();
              }
            }, 100);
          });
        }
      }
    },
    created: function() {
      this.cachedPlaceHolder = this.currentPlaceholder = this.placeholder;
      if (this.multiple && !VueUtil.isArray(this.value)) this.$emit('input', []);
      if (!this.multiple && VueUtil.isArray(this.value)) this.$emit('input', '');
      this.setSelected();
      this.$on('handleOptionClick', this.handleOptionSelect);
      this.$on('onOptionDestroy', this.onOptionDestroy);
      this.$on('setSelected', this.setSelected);
    },
    mounted: function() {
      this.appendToSelf && (this.append = this.$el);
      VueUtil.addResizeListener(this.$el, this.handleResize);
      if (this.remote && this.multiple) {
        this.resetInputHeight();
      }
      this.$nextTick(function() {
        this.setSelected();
        if (this.$refs.reference && this.$refs.reference.$el) {
          this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
        }
      });
    },
    beforeDestroy: function() {
      VueUtil.removeResizeListener(this.$el, this.handleResize);
    }
  };
  Vue.component(VueSelect.name, VueSelect);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueTree = definition(context.Vue, context.VueUtil);
    delete context.VueTree;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var NODE_KEY = '$treeNodeId';
  var getChildState = function(node) {
    var all = true;
    var none = true;
    var allWithoutDisable = true;
    VueUtil.loop(node, function(n) {
      if (n.checked !== true || n.indeterminate) {
        all = false;
        if (!n.disabled) {
          allWithoutDisable = false;
        }
      }
      if (n.checked !== false || n.indeterminate) {
        none = false;
      }
    });
    return {
      all: all,
      none: none,
      allWithoutDisable: allWithoutDisable,
      half: !all && !none
    };
  };
  var reInitChecked = function(node) {
    var childState = getChildState(node.childNodes);
    var all = childState.all;
    var none = childState.none;
    var half = childState.half;
    if (all) {
      node.checked = true;
      node.indeterminate = false;
    } else if (half) {
      node.checked = false;
      node.indeterminate = true;
    } else if (none) {
      node.checked = false;
      node.indeterminate = false;
    }
    var parent = node.parent;
    if (!parent || parent.level === 0) return;
    if (!node.store.checkStrictly) {
      reInitChecked(parent);
    }
  };
  var getPropertyFromData = function(node, prop) {
    var props = node.store.props;
    var data = node.data || {};
    var config = props[prop];
    if (VueUtil.isFunction(config)) {
      return config(data, node);
    }
    if (VueUtil.isString(config)) {
      return data[config];
    }
    if (!VueUtil.isDef(config)) {
      return '';
    }
  };
  var nodeIdSeed = 0;
  var Node = function(options) {
    var self = this;
    self.id = nodeIdSeed++;
    self.text = null;
    self.checked = false;
    self.indeterminate = false;
    self.data = null;
    self.expanded = false;
    self.parent = null;
    self.visible = true;
    VueUtil.ownPropertyLoop(options, function(name) {
      self[name] = options[name];
    });
    self.level = 0;
    self.loaded = false;
    self.childNodes = [];
    self.loading = false;
    self.label = self.getLabel();
    self.icon = self.getIcon();
    self.key = self.getKey();
    self.disabled = self.getDisabled();
    if (self.parent) {
      self.level = self.parent.level + 1;
    }
    var store = self.store;
    if (!store) throw 'store is required!';
    store.registerNode(self);
    var props = store.props;
    if (props && VueUtil.isDef(props.isLeaf)) {
      var isLeaf = getPropertyFromData(self, 'isLeaf');
      if (VueUtil.isBoolean(isLeaf)) {
        self.isLeafByUser = isLeaf;
      }
    }
    if (store.lazy !== true && self.data) {
      self.setData(self.data);
      if (store.defaultExpandAll) {
        self.expanded = true;
      }
    } else if (self.level > 0 && store.lazy && store.defaultExpandAll) {
      self.expand();
    }
    if (!self.data) return;
    var defaultExpandedKeys = store.defaultExpandedKeys;
    var key = store.key;
    if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(self.key) !== -1) {
      self.expand(null, store.autoExpandParent);
    }
    if (key && store.currentNodeKey && self.key === store.currentNodeKey) {
      store.currentNode = self;
    }
    if (store.lazy) {
      store._initDefaultCheckedNode(self);
    }
    self.updateLeafState();
  };
  Node.prototype.setData = function(data) {
    var self = this;
    if (!VueUtil.isArray(data)) {
      var markNodeData = function(node, data) {
        if (data[NODE_KEY]) return;
        Object.defineProperty(data, NODE_KEY, {
          value: node.id,
          enumerable: false,
          configurable: false,
          writable: false
        });
      };
      markNodeData(self, data);
    }
    self.data = data;
    self.childNodes = [];
    var children;
    if (self.level === 0 && self.data instanceof Array) {
      children = self.data;
    } else {
      children = getPropertyFromData(self, 'children') || [];
    }
    VueUtil.loop(children, function(child) {
      self.insertChild({
        data: child
      });
    });
  };
  Node.prototype.getLabel = function() {
    return getPropertyFromData(this, 'label');
  };
  Node.prototype.getIcon = function(node) {
    return getPropertyFromData(this, 'icon');
  };
  Node.prototype.getDisabled = function() {
    return getPropertyFromData(this, 'disabled');
  };
  Node.prototype.getKey = function() {
    var self = this;
    var nodeKey = self.store.key;
    if (self.data)
      return self.data[nodeKey];
    return null;
  };
  Node.prototype.insertChild = function(child, index) {
    if (!child) throw 'insertChild error: child is required.';
    var self = this;
    if (!(child instanceof Node)) {
      VueUtil.merge(child, {parent: self, store: self.store});
      child = new Node(child);
    }
    child.level = self.level + 1;
    if (!VueUtil.isDef(index) || index < 0) {
      self.childNodes.push(child);
    } else {
      self.childNodes.splice(index, 0, child);
    }
    self.updateLeafState();
  };
  Node.prototype.insertBefore = function(child, ref) {
    var self = this;
    var index;
    if (ref) {
      index = self.childNodes.indexOf(ref);
    }
    self.insertChild(child, index);
  };
  Node.prototype.insertAfter = function(child, ref) {
    var self = this;
    var index;
    if (ref) {
      index = self.childNodes.indexOf(ref);
      if (index !== -1)
        index += 1;
    }
    self.insertChild(child, index);
  };
  Node.prototype.removeChild = function(child) {
    var self = this;
    var index = self.childNodes.indexOf(child);
    if (index !== -1) {
      self.store && self.store.deregisterNode(child);
      child.parent = null;
      self.childNodes.splice(index, 1);
    }
    self.updateLeafState();
  };
  Node.prototype.removeChildByData = function(data) {
    var self = this;
    var targetNode = null;
    VueUtil.loop(self.childNodes, function(node) {
      if (node.data === data) {
        targetNode = node;
      }
    });
    if (targetNode) {
      self.removeChild(targetNode);
    }
  };
  Node.prototype.expand = function(callback, expandParent) {
    var self = this;
    var done = function() {
      if (expandParent) {
        var parent = self.parent;
        while (parent.level > 0) {
          parent.expanded = true;
          parent = parent.parent;
        }
      }
      self.expanded = true;
      if (callback)
        callback();
    };
    if (self.shouldLoadData()) {
      self.loadData(function(data) {
        if (VueUtil.isArray(data)) {
          var initLazyLoadChild = function(node) {
            if (node.checked) {
              var childNodes = node.childNodes;
              VueUtil.loop(childNodes, function(child) {
                if (!child.disabled) {
                  child.checked = true;
                }
              });
            }
            var parent = node.parent;
            if (!parent || parent.level === 0) return;
            reInitChecked(parent);
          };
          initLazyLoadChild(self);
          done();
        }
      });
    } else {
      done();
    }
  };
  Node.prototype.doCreateChildren = function(array, defaultProps) {
    var self = this;
    defaultProps = defaultProps || {};
    VueUtil.loop(array, function(item) {
      self.insertChild(VueUtil.merge({
        data: item
      }, defaultProps));
    });
  };
  Node.prototype.collapse = function() {
    this.expanded = false;
  };
  Node.prototype.shouldLoadData = function() {
    return this.store.lazy === true && this.store.load && !this.loaded;
  };
  Node.prototype.updateLeafState = function() {
    var self = this;
    if (self.store.lazy === true && self.loaded !== true && VueUtil.isDef(self.isLeafByUser)) {
      self.isLeaf = selfk.isLeafByUser;
      return;
    }
    var childNodes = self.childNodes;
    if (!self.store.lazy || (self.store.lazy === true && self.loaded === true)) {
      self.isLeaf = !childNodes || childNodes.length === 0;
      return;
    }
    self.isLeaf = false;
  };
  Node.prototype.setChecked = function(value, deep, recursion, passValue) {
    var self = this;
    self.indeterminate = value === 'half';
    self.checked = value === true;
    var selfChildState = getChildState(self);
    var all = selfChildState.all;
    var allWithoutDisable = selfChildState.allWithoutDisable;
    if (self.childNodes.length && !all && allWithoutDisable) {
      self.checked = false;
      value = false;
    }
    var handleDescendants = function(lazy) {
      if (deep && !lazy) {
        var childNodes = self.childNodes;
        VueUtil.loop(childNodes, function(child) {
          passValue = passValue || value !== false;
          var isCheck = child.disabled ? child.checked : passValue;
          child.setChecked(isCheck, deep, true, passValue);
        });
        var childState = getChildState(childNodes);
        var half = childState.half;
        var all = childState.all;
        if (!all) {
          self.checked = all;
          self.indeterminate = half;
        }
      }
    };
    if (!self.store.checkStrictly && self.shouldLoadData()) {
      self.loadData(function() {
        handleDescendants(true);
      }, {
          checked: value !== false
        });
    } else {
      handleDescendants();
    }
    var parent = self.parent;
    if (!parent || parent.level === 0) return;
    if (!self.store.checkStrictly && !recursion) {
      reInitChecked(parent);
    }
  };
  Node.prototype.getChildren = function() {
    var self = this;
    var data = self.data;
    if (!data) return null;
    var props = self.store.props;
    var children = 'children';
    if (props) {
      children = props.children || 'children';
    }
    if (!VueUtil.isDef(data[children])) {
      data[children] = null;
    }
    return data[children];
  };
  Node.prototype.updateChildren = function() {
    var self = this;
    var newData = self.getChildren() || [];
    var oldData = VueUtil.map(self.childNodes, function(node) {
      return node.data;
    });
    var newDataMap = {};
    var newNodes = [];
    VueUtil.loop(newData, function(item, index) {
      if (item[NODE_KEY]) {
        newDataMap[item[NODE_KEY]] = {
          index: index,
          data: item
        };
      } else {
        newNodes.push({
          index: index,
          data: item
        });
      }
    });
    VueUtil.loop(oldData, function(item) {
      if (!newDataMap[item[NODE_KEY]])
        self.removeChildByData(item);
    });
    VueUtil.loop(newNodes, function(args) {
      var index = args.index;
      var data = args.data;
      self.insertChild({
        data: data
      }, index);
    });
    self.updateLeafState();
  };
  Node.prototype.loadData = function(callback, defaultProps) {
    var self = this;
    defaultProps = defaultProps || {};
    if (self.store.lazy === true && self.store.load && !self.loaded && (!self.loading || Object.keys(defaultProps).length)) {
      self.loading = true;
      var resolve = function(children) {
        self.loaded = true;
        self.loading = false;
        self.childNodes = [];
        self.doCreateChildren(children, defaultProps);
        self.updateLeafState();
        if (callback) {
          callback.call(self, children);
        }
      };
      self.store.load(self, resolve);
    } else {
      if (callback) {
        callback.call(self);
      }
    }
  };
  var TreeStore = function(options) {
    var self = this;
    self.currentNode = null;
    self.currentNodeKey = null;
    VueUtil.ownPropertyLoop(options, function(option) {
      self[option] = options[option];
    });
    self.nodesMap = {};
    self.root = new Node({
      data: self.data,
      store: self
    });
    if (self.lazy && self.load) {
      var loadFn = self.load;
      loadFn(self.root, function(data) {
        self.root.doCreateChildren(data);
        self._initDefaultCheckedNodes();
      });
    } else {
      self._initDefaultCheckedNodes();
    }
  };
  TreeStore.prototype.filter = function(value) {
    var self = this;
    var filterNodeMethod = self.filterNodeMethod;
    var traverse = function(node) {
      var childNodes = node.root ? node.root.childNodes : node.childNodes;
      VueUtil.loop(childNodes, function(child) {
        child.visible = filterNodeMethod.call(child, value, child.data, child);
        traverse(child);
      });
      if (!node.visible && childNodes.length) {
        var allHidden = true;
        VueUtil.loop(childNodes, function(child) {
          if (child.visible)
            allHidden = false;
        });
        if (node.root) {
          node.root.visible = allHidden === false;
        } else {
          node.visible = allHidden === false;
        }
      }
      if (node.visible && !node.isLeaf)
        node.expand();
    };
    traverse(self);
  };
  TreeStore.prototype.setData = function(newVal) {
    var self = this;
    var instanceChanged = newVal !== self.root.data;
    self.root.setData(newVal);
    if (instanceChanged) {
      self._initDefaultCheckedNodes();
    }
  };
  TreeStore.prototype.getNode = function(data) {
    var getNodeKey = function(key, data) {
      if (!key)
        return data[NODE_KEY];
      return data[key];
    };
    var key = VueUtil.isObject(data) ? getNodeKey(this.key, data) : data;
    return this.nodesMap[key];
  };
  TreeStore.prototype.insertBefore = function(data, refData) {
    var self = this;
    var refNode = self.getNode(refData);
    refNode.parent.insertBefore({
      data: data
    }, refNode);
  };
  TreeStore.prototype.insertAfter = function(data, refData) {
    var self = this;
    var refNode = self.getNode(refData);
    refNode.parent.insertAfter({
      data: data
    }, refNode);
  };
  TreeStore.prototype.remove = function(data) {
    var self = this;
    var node = self.getNode(data);
    if (node && node.parent) {
      node.parent.removeChild(node);
    }
  };
  TreeStore.prototype.append = function(data, parentData) {
    var self = this;
    var parentNode = parentData ? self.getNode(parentData) : self.root;
    if (parentNode) {
      parentNode.insertChild({
        data: data
      });
    }
  };
  TreeStore.prototype._initDefaultCheckedNodes = function() {
    var self = this;
    var defaultCheckedKeys = self.defaultCheckedKeys || [];
    var nodesMap = self.nodesMap;
    VueUtil.loop(defaultCheckedKeys, function(checkedKey) {
      var node = nodesMap[checkedKey];
      if (node) {
        node.setChecked(true, !self.checkStrictly);
      }
    });
  };
  TreeStore.prototype._initDefaultCheckedNode = function(node) {
    var self = this;
    var defaultCheckedKeys = self.defaultCheckedKeys || [];
    var nodeKey = node.key || node.getKey();
    if (defaultCheckedKeys.indexOf(nodeKey) !== -1) {
      node.setChecked(true, !self.checkStrictly);
    }
  };
  TreeStore.prototype.setDefaultCheckedKey = function(newVal) {
    var self = this;
    if (newVal !== self.defaultCheckedKeys) {
      self.defaultCheckedKeys = newVal;
      self._initDefaultCheckedNodes();
    }
  };
  TreeStore.prototype.registerNode = function(node) {
    var self = this;
    var key = self.key;
    if (!key || !node || !node.data)
      return;
    var nodeKey = node.key || node.getKey();
    if (nodeKey)
      self.nodesMap[nodeKey] = node;
  };
  TreeStore.prototype.deregisterNode = function(node) {
    var self = this;
    var key = self.key;
    if (!key || !node || !node.data)
      return;
    var nodeKey = node.key || node.getKey();
    delete self.nodesMap[nodeKey];
  };
  TreeStore.prototype.getCheckedNodes = function() {
    var self = this;
    var leafOnly = arguments.length > 0 && VueUtil.isDef(arguments[0]) ? arguments[0] : false;
    var indeterminate = arguments.length > 1 && VueUtil.isDef(arguments[1]) ? arguments[1] : false;
    var visibleOnly = arguments.length > 2 && VueUtil.isDef(arguments[2]) ? arguments[2] : false;

    var checkedNodes = [];
    var traverse = function(node) {
      var childNodes = node.root ? node.root.childNodes : node.childNodes;
      VueUtil.loop(childNodes, function(child) {
        if(!visibleOnly || (visibleOnly && child.visible)) {
          if ((!leafOnly && (child.checked || (indeterminate && child.indeterminate)) ) || (leafOnly && child.isLeaf && child.checked)) {
            checkedNodes.push(child.data);
          }
        }
        traverse(child);
      });
    };
    traverse(self);
    return checkedNodes;
  };
  TreeStore.prototype.getCheckedKeys = function() {
    var self = this;
    var leafOnly = arguments.length > 0 && VueUtil.isDef(arguments[0]) ? arguments[0] : false;
    var indeterminate = arguments.length > 1 && VueUtil.isDef(arguments[1]) ? arguments[1] : false;
    var visibleOnly = arguments.length > 2 && VueUtil.isDef(arguments[2]) ? arguments[2] : false;

    var key = self.key;
    var allNodes = self._getAllNodes();
    var keys = [];
    VueUtil.loop(allNodes, function(node) {
      if(!visibleOnly || (visibleOnly && child.visible)) {
        if (!leafOnly || (leafOnly && node.isLeaf)) {
          if (node.checked || (indeterminate && node.indeterminate)) {
            keys.push((node.data || {})[key]);
          }
        }
      }
    });
    return keys;
  };
  TreeStore.prototype._getAllNodes = function() {
    var self = this;
    var allNodes = [];
    var nodesMap = self.nodesMap;
    VueUtil.ownPropertyLoop(nodesMap, function(nodeKey) {
      allNodes.push(nodesMap[nodeKey]);
    });
    return allNodes;
  };
  TreeStore.prototype._setCheckedKeys = function(key) {
    var self = this;
    var leafOnly = arguments.length > 1 && VueUtil.isDef(arguments[1]) ? arguments[1] : false;
    var checkedKeys = arguments[2];
    var allNodes = self._getAllNodes().sort(function(a, b) {return b.level - a.level;});
    var cache = {};
    var keys = Object.keys(checkedKeys);
    VueUtil.loop(allNodes, function(node) {
      node.setChecked(false, false);
    });
    VueUtil.loop(allNodes, function(node) {
      var nodeKey = node.data[key] + '';
      var checked = keys.indexOf(nodeKey) !== -1;
      if (!checked) {
        if (node.checked && !cache[nodeKey]) {
          node.setChecked(false, false);
        }
        return;
      }
      var parent = node.parent;
      while (parent && parent.level > 0) {
        cache[parent.data[key]] = true;
        parent = parent.parent;
      }
      if (node.isLeaf || self.checkStrictly) {
        node.setChecked(true, false);
        return;
      }
      node.setChecked(true, true);
      if (leafOnly) {
        node.setChecked(false, false);
        var traverse = function(node) {
          var childNodes = node.childNodes || [];
          VueUtil.loop(childNodes, function(child) {
            if (!child.isLeaf) {
              child.setChecked(false, false);
            }
            traverse(child);
          });
        };
        traverse(node);
      }
    });
  };
  TreeStore.prototype.setCheckedNodes = function(array) {
    var self = this;
    var leafOnly = arguments.length > 1 && VueUtil.isDef(arguments[1]) ? arguments[1] : false;
    var key = self.key;
    var checkedKeys = {};
    VueUtil.loop(array, function(item) {
      checkedKeys[(item || {})[key]] = true;
    });
    self._setCheckedKeys(key, leafOnly, checkedKeys);
  };
  TreeStore.prototype.setCheckedKeys = function(keys, leafonly) {
    var self = this;
    var leafOnly = arguments.length > 1 && VueUtil.isDef(arguments[1]) ? arguments[1] : false;
    self.defaultCheckedKeys = keys;
    var key = self.key;
    var checkedKeys = {};
    VueUtil.loop(keys, function(key) {
      checkedKeys[key] = true;
    });
    self._setCheckedKeys(key, leafOnly, checkedKeys);
  };
  TreeStore.prototype.setDefaultExpandedKeys = function(keys) {
    var self = this;
    keys = keys || [];
    self.defaultExpandedKeys = keys;
    VueUtil.loop(keys, function(key) {
      var node = self.getNode(key);
      if (node) node.expand(null, self.autoExpandParent);
    });
  };
  TreeStore.prototype.setChecked = function(data, checked, deep) {
    var self = this;
    var node = self.getNode(data);
    if (node) {
      node.setChecked(!!checked, deep);
    }
  };
  TreeStore.prototype.getCurrentNode = function() {
    return this.currentNode;
  };
  TreeStore.prototype.setCurrentNode = function(node) {
    this.currentNode = node;
  };
  TreeStore.prototype.setCurrentNodeKey = function(key) {
    var self = this;
    if (!key) {
      self.currentNode = null;
    } else {
      var node = self.getNode(key);
      if (node) {
        self.currentNode = node;
      }
    }
  };
  var VueTreeNode = {
    template: '<div @click.stop="handleClick" @dblclick.stop="handleDblclick" v-show="node.visible" :class="[\'vue-tree-node\', {\'is-expanded\': childNodeRendered && expanded,\'is-current\': tree.store.currentNode === node,\'is-hidden\': !node.visible}]"><div class="vue-tree-node__content" :style="{\'padding-left\': (node.level - 1) * tree.indent + \'px\'}"><span @click.stop="handleExpandIconClick" :class="[\'vue-tree-node__expand-icon\', {\'is-leaf\': node.isLeaf, expanded: !node.isLeaf && expanded}]"></span><vue-checkbox v-if="showCheckbox" v-model="node.checked" :indeterminate="node.indeterminate" :disabled="!!node.disabled" @change="handleCheckChange"></vue-checkbox><span v-if="node.loading" class="vue-tree-node__loading-icon vue-icon-loading"></span><node-content :node="node"></node-content></div><collapse-transition><div class="vue-tree-node__children" v-show="expanded"><vue-tree-node :render-content="renderContent" v-for="child in node.childNodes" :key="getNodeKey(child)" :node="child" @node-expand="handleChildNodeExpand"></vue-tree-node></div></collapse-transition></div>',
    name: 'VueTreeNode',
    mixins: [VueUtil.component.emitter],
    props: {
      node: {
        default: function() {
          return {};
        }
      },
      props: {},
      renderContent: Function
    },
    components: {
      CollapseTransition: VueUtil.component.collapseTransition,
      NodeContent: {
        props: {
          node: {
            required: true
          }
        },
        render: function(createElement) {
          var parent = this.$parent;
          var node = this.node;
          var data = node.data;
          var store = node.store;
          return (parent.renderContent ? parent.renderContent.call(parent._renderProxy, createElement, {
            _self: parent.tree.$vnode.context,
            node: node,
            data: data,
            store: store
          }) : createElement('span', {
            class: 'vue-tree-node__label'
          }, [this.node.label]));
        }
      }
    },
    data: function() {
      return {
        tree: null,
        expanded: false,
        childNodeRendered: false,
        showCheckbox: false,
        oldChecked: null,
        oldIndeterminate: null
      };
    },
    watch: {
      'node.indeterminate': function(val) {
        this.handleSelectChange(this.node.checked, val);
      },
      'node.checked': function(val) {
        this.handleSelectChange(val, this.node.indeterminate);
      },
      'node.expanded': function(val) {
        this.expanded = val;
        if (val) {
          this.childNodeRendered = true;
        }
      }
    },
    methods: {
      getNodeKey: function(node, index) {
        var nodeKey = this.tree.nodeKey;
        if (nodeKey && node) {
          return node.data[nodeKey];
        }
        return index;
      },
      handleSelectChange: function(checked, indeterminate) {
        if (this.oldChecked !== checked && this.oldIndeterminate !== indeterminate) {
          this.tree.$emit('check-change', this.node.data, checked, indeterminate, this.node, this);
        }
        this.oldChecked = checked;
        this.indeterminate = indeterminate;
      },
      handleClick: function() {
        var store = this.tree.store;
        store.setCurrentNode(this.node);
        this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);
        this.tree.currentNode = this;
        if (this.tree.expandOnClickNode) {
          this.handleExpandIconClick();
        }
        this.tree.$emit('node-click', this.node.data, this.node, this);
      },
      handleDblclick: function() {
        this.tree.$emit('node-dblclick', this.node.data, this.node, this);
      },
      handleExpandIconClick: function() {
        if (this.node.isLeaf)
          return;
        if (this.expanded) {
          this.tree.$emit('node-collapse', this.node.data, this.node, this);
          this.node.collapse();
        } else {
          this.node.expand();
          this.$emit('node-expand', this.node.data, this.node, this);
        }
      },
      handleCheckChange: function(ev) {
        this.node.setChecked(ev.target.checked, !this.tree.checkStrictly);
      },
      handleChildNodeExpand: function(nodeData, node, instance) {
        this.broadcast('VueTreeNode', 'tree-node-expand', node);
        this.tree.$emit('node-expand', nodeData, node, instance);
      }
    },
    created: function() {
      var self = this;
      var parent = self.$parent;
      if (parent.isTree) {
        self.tree = parent;
      } else {
        self.tree = parent.tree;
      }
      var tree = self.tree;
      if (!tree) {
        throw 'Can not find node\'s tree.';
      }
      var props = tree.props || {};
      var childrenKey = props['children'] || 'children';
      self.$watch('node.data.' + childrenKey, function() {
        self.node.updateChildren();
      });
      self.showCheckbox = tree.showCheckbox;
      if (self.node.expanded) {
        self.expanded = true;
        self.childNodeRendered = true;
      }
      if (self.tree.accordion) {
        self.$on('tree-node-expand', function(node) {
          if (self.node !== node) {
            self.node.collapse();
          }
        });
      }
    }
  };
  var VueTree = {
    template: 
    '<div :class="[\'vue-tree\', {\'vue-tree--highlight-current\': highlightCurrent}]"> \
      <vue-tree-node v-for="child in root.childNodes" :node="child" :props="props" :key="getNodeKey(child)" \
        :render-content="renderContent" @node-expand="handleNodeExpand"></vue-tree-node> \
      <div class="vue-tree__empty-block" v-if="!root.childNodes || root.childNodes.length === 0"><span class="vue-tree__empty-text">{{$t(\'vue.tree.emptyText\')}}</span></div> \
    </div>',
    name: 'VueTree',
    mixins: [VueUtil.component.emitter],
    components: {
      VueTreeNode: VueTreeNode
    },
    data: function() {
      return {
        store: null,
        root: null,
        currentNode: null
      };
    },
    props: {
      data: {
        type: Array
      },
      nodeKey: String,
      checkStrictly: Boolean,
      defaultExpandAll: Boolean,
      expandOnClickNode: {
        type: Boolean,
        default: true
      },
      autoExpandParent: {
        type: Boolean,
        default: true
      },
      defaultCheckedKeys: Array,
      defaultExpandedKeys: Array,
      renderContent: Function,
      showCheckbox: Boolean,
      props: {
        default: function() {
          return {
            children: 'children',
            label: 'label',
            icon: 'icon',
            disabled: 'disabled'
          };
        }
      },
      lazy: Boolean,
      highlightCurrent: Boolean,
      currentNodeKey: [String, Number],
      load: Function,
      filterNodeMethod: Function,
      accordion: Boolean,
      indent: {
        type: Number,
        default: 16
      }
    },
    computed: {
      children: {
        set: function(value) {
          this.data = value;
        },
        get: function() {
          return this.data;
        }
      }
    },
    watch: {
      defaultCheckedKeys: function(newVal) {
        this.store.defaultCheckedKeys = newVal;
        this.store.setDefaultCheckedKey(newVal);
      },
      defaultExpandedKeys: function(newVal) {
        this.store.defaultExpandedKeys = newVal;
        this.store.setDefaultExpandedKeys(newVal);
      },
      currentNodeKey: function(newVal) {
        this.store.setCurrentNodeKey(newVal);
        this.store.currentNodeKey = newVal;
      },
      data: function(newVal) {
        this.store.setData(newVal);
      }
    },
    methods: {
      filter: function(value) {
        if (!this.filterNodeMethod) throw 'filterNodeMethod is required when filter';
        this.store.filter(value);
      },
      getNodeKey: function(node, index) {
        var nodeKey = this.nodeKey;
        if (nodeKey && node) {
          return node.data[nodeKey];
        }
        return index;
      },
      getCurrentNode: function() {
        var currentNode = this.store.getCurrentNode();
        return currentNode ? currentNode.data : null;
      },
      getCurrentKey: function() {
        if (!this.nodeKey) return null;
        var currentNode = this.store.getCurrentNode();
        return currentNode ? currentNode.data[this.nodeKey] : null;
      },
      setCurrentNode: function(node) {
        if (!this.nodeKey) throw 'nodeKey is required in setCheckedNodes';
        if (!node) return this.store.setCurrentNodeKey(null);
        var key = node[this.nodeKey];
        return this.store.setCurrentNodeKey(key);
      },
      setCurrentKey: function(key) {
        if (!this.nodeKey) throw 'nodeKey is required in setCheckedNodes';
        return this.store.setCurrentNodeKey(key);
      },
      getCheckedNodes: function(leafOnly, indeterminate, visibleOnly) {
        return this.store.getCheckedNodes(leafOnly, indeterminate, visibleOnly);
      },
      getCheckedKeys: function(leafOnly, indeterminate, visibleOnly) {
        return this.store.getCheckedKeys(leafOnly, indeterminate, visibleOnly);
      },
      setCheckedNodes: function(nodes, leafOnly) {
        if (!this.nodeKey) throw 'nodeKey is required in setCheckedNodes';
        this.store.setCheckedNodes(nodes, leafOnly);
      },
      setCheckedKeys: function(keys, leafOnly) {
        if (!this.nodeKey) throw 'nodeKey is required in setCheckedNodes';
        this.store.setCheckedKeys(keys, leafOnly);
      },
      setChecked: function(data, checked, deep) {
        this.store.setChecked(data, checked, deep);
      },
      handleNodeExpand: function(nodeData, node, instance) {
        this.broadcast('VueTreeNode', 'tree-node-expand', node);
        this.$emit('node-expand', nodeData, node, instance);
      },
      expandAll: function() {
        this.store._getAllNodes().forEach(function(node) {
          node.expanded = true;
        });
      },

      collapseAll: function() {
        this.store._getAllNodes().forEach(function(node) {
          node.expanded = false;
        });
      }
    },
    created: function() {
      var self = this;
      self.isTree = true;
      self.store = new TreeStore({
        key: self.nodeKey,
        data: self.data,
        lazy: self.lazy,
        props: self.props,
        load: self.load,
        currentNodeKey: self.currentNodeKey,
        checkStrictly: self.checkStrictly,
        defaultCheckedKeys: self.defaultCheckedKeys,
        defaultExpandedKeys: self.defaultExpandedKeys,
        autoExpandParent: self.autoExpandParent,
        defaultExpandAll: self.defaultExpandAll,
        filterNodeMethod: self.filterNodeMethod
      });
      self.root = self.store.root;
    }
  };
  Vue.component(VueTree.name, VueTree);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCarousel = definition(context.Vue, context.VueUtil);
    delete context.VueCarousel;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCarousel = {
    template: '<div :class="[\'vue-carousel\', {\'vue-carousvue--card\': type === \'card\'}]" @mouseenter.stop="handleMouseEnter" @mouseleave.stop="handleMouseLeave" @touchstart.stop="handleTouchStart" @mousedown="handleMouseDrag"><div class="vue-carousel__container" :style="{height: height}"><transition name="carousel-arrow-left"><button type="button" v-if="arrow !== \'never\'" v-show="arrow === \'always\' || hover" @mouseenter="handleButtonEnter(\'left\')" @mouseleave="handleButtonLeave" @click.stop="throttledArrowClick(activeIndex - 1)" class="vue-carousel__arrow vue-carousel__arrow--left"><i class="vue-icon-arrow-left"></i></button></transition><transition name="carousel-arrow-right"><button type="button" v-if="arrow !== \'never\'" v-show="arrow === \'always\' || hover" @mouseenter="handleButtonEnter(\'right\')" @mouseleave="handleButtonLeave" @click.stop="throttledArrowClick(activeIndex + 1)" class="vue-carousel__arrow vue-carousel__arrow--right"><i class="vue-icon-arrow-right"></i></button></transition><slot></slot></div><ul v-if="indicatorPosition !== \'none\'" :class="[\'vue-carousel__indicators\', {\'vue-carousel__indicators--outside\': indicatorPosition === \'outside\' || type === \'card\'}]"><li v-for="(item, index) in items" :class="[\'vue-carousel__indicator\', {\'is-active\': index === activeIndex}]" @mouseenter="throttledIndicatorHover(index)" @click.stop="handleIndicatorClick(index)"><button type="button" class="vue-carousel__button"></button></li></ul></div>',
    name: 'VueCarousel',
    props: {
      initialIndex: {
        type: Number,
        default: 0
      },
      height: String,
      trigger: {
        type: String,
        default: 'hover'
      },
      autoplay: {
        type: Boolean,
        default: true
      },
      interval: {
        type: Number,
        default: 3000
      },
      indicatorPosition: String,
      indicator: {
        type: Boolean,
        default: true
      },
      arrow: {
        type: String,
        default: 'hover'
      },
      hoverStop: {
        type: Boolean,
        default: true
      },
      mousewhell: {
        type: Boolean,
        default: false
      },
      mousedrag: {
        type: Boolean,
        default: false
      },
      wrap: {
        type: Boolean,
        default: true
      },
      type: String
    },
    data: function() {
      return {
        items: [],
        activeIndex: -1,
        hover: false
      };
    },
    watch: {
      items: function(val) {
        if (val.length > 0)
          this.setActiveItem(0);
      },
      activeIndex: function(val, oldVal) {
        this.resetItemPosition();
        this.$emit('change', val, oldVal);
      }
    },
    methods: {
      handleMouseEnter: function() {
        this.hover = true;
        if (this.hoverStop) this.pauseTimer();
      },
      handleMouseLeave: function() {
        this.hover = false;
        if (this.hoverStop) this.startTimer();
      },
      handleMouseDrag: function(e) {
        if(!this.mousedrag) {
          return;
        }
        e.stopImmediatePropagation();
        this.mousedownX = e.clientX;
        this.mousemove = 0;
        VueUtil.on(document, 'mousemove', this.handleMousemove);
        VueUtil.on(document, 'mouseup', this.handleMouseup);
      },
      handleMousemove: function(e) {
        this.mousemove = this.mousedownX - e.clientX;
      },
      handleMouseup: function() {
        VueUtil.off(document, 'mousemove', this.handleMousemove);
        VueUtil.off(document, 'mouseup', this.handleMouseup);

        var mousemove = this.mousemove;
        if (mousemove > 10) {
          this.throttledArrowClick(this.activeIndex + 1);
        }
        if (mousemove < -10) {
          this.throttledArrowClick(this.activeIndex - 1);
        }
      },
      handleTouchStart: function(e) {
        e.stopImmediatePropagation();
        var tocuhPlace = this.tocuhPlace = {};
        var touches = e.touches[0];
        tocuhPlace.tocuhX = touches.pageX;
        VueUtil.on(document, 'touchmove', this.handleTouchMove);
        VueUtil.on(document, 'touchend', this.handleTouchEnd);
      },
      handleTouchMove: function(e) {
        var touches = e.touches[0];
        var tocuhPlace = this.tocuhPlace;
        tocuhPlace.touchMove = tocuhPlace.tocuhX - touches.pageX;
      },
      handleTouchEnd: function(e) {
        var tocuhPlace = this.tocuhPlace;
        if (tocuhPlace.touchMove > 10) {
          this.throttledArrowClick(this.activeIndex + 1);
        }
        if (tocuhPlace.touchMove < -10) {
          this.throttledArrowClick(this.activeIndex - 1);
        }
        VueUtil.off(document, 'touchmove',this.handleTouchMove);
        VueUtil.off(document, 'touchend', this.handleTouchEnd);
      },
      itemInStage: function(item, index) {
        var length = this.items.length;
        if (index === length - 1 && item.inStage && this.items[0].active || (item.inStage && this.items[index + 1] && this.items[index + 1].active)) {
          return 'left';
        } else if (index === 0 && item.inStage && this.items[length - 1].active || (item.inStage && this.items[index - 1] && this.items[index - 1].active)) {
          return 'right';
        }
        return false;
      },
      handleButtonEnter: function(arrow) {
        var self = this;
        VueUtil.loop(self.items, function(item, index) {
          if (arrow === self.itemInStage(item, index)) {
            item.hover = true;
          }
        });
      },
      handleButtonLeave: function() {
        var self = this;
        VueUtil.loop(self.items, function(item) {
          item.hover = false;
        });
      },
      updateItems: function() {
        this.items = VueUtil.filter(this.$children, function(child) {
          return child.$options.name === 'VueCarouselItem';
        });
      },
      resetItemPosition: function() {
        var self = this;
        VueUtil.loop(self.items, function(item, index) {
          item.translateItem(index, self.activeIndex);
        });
      },
      playSlides: function() {
        if (this.activeIndex < this.items.length - 1) {
          this.activeIndex++;
        } else {
          this.activeIndex = 0;
        }
      },
      pauseTimer: function() {
        clearInterval(this.timer);
      },
      startTimer: function() {
        if (this.interval <= 0 || !this.autoplay) return;
        this.timer = setInterval(this.playSlides, this.interval);
      },
      setActiveItem: function(index) {
        if (VueUtil.isString(index)) {
          var filteredItems = VueUtil.filter(this.items, function(item) {
            return item.name === index;
          });
          if (filteredItems.length > 0) {
            index = this.items.indexOf(filteredItems[0]);
          }
        }
        index = Number(index);
        if (isNaN(index) || index !== Math.floor(index)) {
          return;
        }
        var length = this.items.length;
        if (index < 0) {
          if (this.wrap) {
            this.activeIndex = length - 1;
          }
        } else if (index >= length) {
          if (this.wrap) {
            this.activeIndex = 0;
          }
        } else {
          this.activeIndex = index;
        }
      },
      prev: function() {
        this.setActiveItem(this.activeIndex - 1);
      },
      next: function() {
        this.setActiveItem(this.activeIndex + 1);
      },
      handleIndicatorClick: function(index) {
        this.activeIndex = index;
      },
      handleIndicatorHover: function(index) {
        if (this.trigger === 'hover' && index !== this.activeIndex) {
          this.activeIndex = index;
        }
      }
    },
    created: function() {
      var self = this;
      self.timer = null;
      self.throttledArrowClick = function(index) {
        self.setActiveItem(index);
      };
      self.throttledIndicatorHover = function(index) {
        self.handleIndicatorHover(index);
      };
    },
    mounted: function() {
      var self = this;
      self.updateItems();
      self.$nextTick(function() {
        VueUtil.addResizeListener(self.$el, self.resetItemPosition);
        if (self.initialIndex < self.items.length && self.initialIndex >= 0) {
          self.activeIndex = self.initialIndex;
        }
        self.startTimer();
      });
    },
    beforeDestroy: function() {
      this.pauseTimer();
      this.$el && VueUtil.removeResizeListener(this.$el, this.resetItemPosition);
    }
  };
  Vue.component(VueCarousel.name, VueCarousel);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueCarouselItem = definition(context.Vue);
    delete context.VueCarouselItem;
  }
})(this, function(Vue) {
  'use strict';
  function throttle(delay, noTrailing, callback, debounceMode) {
    var timeoutID;
    var cancelled = false;
    var lastExec = 0;

    function clearExistingTimeout() {
        if (timeoutID) {
            clearTimeout(timeoutID);
        }
    }

    function cancel() {
        clearExistingTimeout();
        cancelled = true;
    }

    if (typeof noTrailing !== 'boolean') {
        debounceMode = callback;
        callback = noTrailing;
        noTrailing = undefined;
    }

    function wrapper() {

        var self = this;
        var elapsed = Date.now() - lastExec;
        var args = arguments;

        if (cancelled) {
            return;
        }
        function exec() {
            lastExec = Date.now();
            callback.apply(self, args);
        }

        function clear() {
            timeoutID = undefined;
        }

        if (debounceMode && !timeoutID) {
            exec();
        }

        clearExistingTimeout();

        if (debounceMode === undefined && elapsed > delay) {
            exec();
        } else if (noTrailing !== true) {
            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
        }
    }

    wrapper.cancel = cancel;
    return wrapper;

}
  var VueCarouselItem = {
    template: '<div v-show="ready" :class="[\'vue-carousel__item\', {\'is-active\': active, \'vue-carousel__item--card\': $parent.type === \'card\', \'is-in-stage\': inStage, \'is-hover\': hover}]" \
              @click="handleItemClick" @mousewheel="handleMousewheel" :style=\'{msTransform: "translateX(" + translate + "px) scale(" + scale + ")", webkitTransform: "translateX(" + translate + "px) scale(" + scale + ")", transform: "translateX(" + translate + "px) scale(" + scale + ")"}\'>\
                <div v-if="$parent.type === \'card\'" v-show="!active" class="vue-carousel__mask"></div>\
                <slot></slot>\
              </div>',
    name: 'VueCarouselItem',
    props: {
      name: String
    },
    data: function() {
      return {
        hover: false,
        translate: 0,
        scale: 1,
        active: false,
        ready: false,
        inStage: false
      };
    },
    methods: {
      processIndex: function(index, activeIndex, length) {
        if (activeIndex === 0 && index === length - 1) {
          return -1;
        } else if (activeIndex === length - 1 && index === 0) {
          return length;
        } else if (index < activeIndex - 1 && activeIndex - index >= length / 2) {
          return length + 1;
        } else if (index > activeIndex + 1 && index - activeIndex >= length / 2) {
          return -2;
        }
        return index;
      },
      calculateTranslate: function(index, activeIndex, parentWidth) {
        if (this.inStage) {
          return parentWidth * ((2 - this.cardScale) * (index - activeIndex) + 1) / 4;
        } else if (index < activeIndex) {
          return -(1 + this.cardScale) * parentWidth / 4;
        } else {
          return (3 + this.cardScale) * parentWidth / 4;
        }
      },
      translateItem: function(index, activeIndex) {
        var parentWidth = this.$parent.$el.offsetWidth;
        var length = this.$parent.items.length;
        if (index !== activeIndex && length > 2) {
          index = this.processIndex(index, activeIndex, length);
        }
        if (this.$parent.type === 'card') {
          this.inStage = Math.round(Math.abs(index - activeIndex)) <= 1;
          this.active = index === activeIndex;
          this.translate = this.calculateTranslate(index, activeIndex, parentWidth);
          this.scale = this.active ? 1 : this.cardScale;
        } else {
          this.active = index === activeIndex;
          this.translate = parentWidth * (index - activeIndex);
        }
        this.ready = true;
      },
      handleItemClick: function() {
        var parent = this.$parent;
        if (parent && parent.type === 'card') {
          var index = parent.items.indexOf(this);
          parent.setActiveItem(index);
        }
      },
      handleMousewheel: throttle(500, true, function(e) {
        var parent = this.$parent;
        if (!parent.mousewhell) {
          return;
        }
        if (e.wheelDelta > 0) {
          parent.prev();
        } else {
          parent.next();
        }
      })
    },
    created: function() {
      this.$parent && this.$parent.updateItems();
      this.cardScale = 0.83;
    },
    destroyed: function() {
      this.$parent && this.$parent.updateItems();
    }
  };
  Vue.component(VueCarouselItem.name, VueCarouselItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueCard = definition(context.Vue);
    delete context.VueCard;
  }
})(this, function(Vue) {
  'use strict';
  var VueCard = {
    template: '<div  :class="[shadow ? \'is-\' + shadow + \'-shadow\' : \'is-hover-shadow\', \'vue-card\']"><div class="vue-card__header" v-if="$slots.header || header"><slot name="header">{{header}}</slot></div><div class="vue-card__body" :style="bodyStyle"><slot></slot></div></div>',
    name: 'VueCard',
    props: {
      header: {},
      bodyStyle: {},
      shadow: String
    }
  };
  Vue.component(VueCard.name, VueCard);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VuePopper'], definition);
  } else {
    context.VuePopover = definition(context.Vue, context.VueUtil, context.VuePopper);
    delete context.VuePopover;
  }
})(this, function(Vue, VueUtil, VuePopper) {
  'use strict';
  var VuePopover = {
    template: '<span><transition @after-leave="destroyPopper"><div :class="[\'vue-popover\', popperClass, {\'no-arrow\': !visibleArrow}]" ref="popper" v-show="!disabled && showPopper" :style="{width: popoverWidth + \'px\' \}"><div class="vue-popover__title" v-if="title" v-text="title"></div><slot>{{content}}</slot></div></transition><slot name="reference"></slot></span>',
    name: 'VuePopover',
    mixins: [VuePopper],
    props: {
      trigger: {
        type: String,
        default: 'click',
        validator: function(value) {
          return ['click', 'focus', 'hover', 'manual'].indexOf(value) !== -1;
        }
      },
      title: String,
      disabled: Boolean,
      content: String,
      reference: {},
      popperClass: String,
      width: [String, Number],
      visibleArrow: {
        type: Boolean,
        default: true
      }
    },
    data: function() {
      return {
        popoverWidth: null
      };
    },
    watch: {
      showPopper: function(newVal, oldVal) {
        if (newVal) {
          this.popoverWidth = this.width;
          if (!this.popoverWidth) {
            var reference = this.reference || this.$refs.reference;
            this.popoverWidth = parseInt(VueUtil.getStyle(reference, 'width'));
          }
          this.$emit('show');
        } else {
          this.$emit('hide');
        }
      }
    },
    methods: {
      bindEvents: function() {
        var self = this;
        var reference = self.reference || self.$refs.reference;
        var popper = self.popper || self.$refs.popper;
        if (!reference && self.$slots.reference && self.$slots.reference[0]) {
          reference = self.referenceElm = self.$slots.reference[0].elm;
        }
        if (self.trigger === 'click') {
          VueUtil.on(reference, 'click', self.doToggle);
          VueUtil.on(document, 'click', self.documentClick);
        } else if (self.trigger === 'hover') {
          VueUtil.on(reference, 'mouseenter', self.mouseEnter);
          VueUtil.on(popper, 'mouseenter', self.mouseEnter);
          VueUtil.on(reference, 'mouseleave', self.mouseLeave);
          VueUtil.on(popper, 'mouseleave', self.mouseLeave);
        } else if (self.trigger === 'focus') {
          var found = false;
          if ([].slice.call(reference.children).length) {
            VueUtil.loop(reference.childNodes, function(child) {
              if (child.nodeName === 'INPUT' || child.nodeName === 'TEXTAREA') {
                VueUtil.on(child, 'focus', self.doShow);
                VueUtil.on(child, 'blur', self.doClose);
                found = true;
                return false;
              }
            });
          }
          if (found) return;
          if (reference.nodeName === 'INPUT' || reference.nodeName === 'TEXTAREA') {
            VueUtil.on(reference, 'focus', self.doShow);
            VueUtil.on(reference, 'blur', self.doClose);
          } else {
            VueUtil.on(reference, 'mousedown', self.doShow);
            VueUtil.on(reference, 'mouseup', self.doClose);
          }
        }
      },
      unBindEvents: function() {
        var self = this;
        var reference = self.reference || self.$refs.reference;
        var popper = self.popper || self.$refs.popper;
        if (!reference && self.$slots.reference && self.$slots.reference[0]) {
          reference = self.referenceElm = self.$slots.reference[0].elm;
        }
        if (self.trigger === 'click') {
          VueUtil.off(reference, 'click', self.doToggle);
          VueUtil.off(document, 'click', self.documentClick);
        } else if (self.trigger === 'hover') {
          VueUtil.off(reference, 'mouseenter', self.mouseEnter);
          VueUtil.off(popper, 'mouseenter', self.mouseEnter);
          VueUtil.off(reference, 'mouseleave', self.mouseLeave);
          VueUtil.off(popper, 'mouseleave', self.mouseLeave);
        } else if (self.trigger === 'focus') {
          var found = false;
          if ([].slice.call(reference.children).length) {
            VueUtil.loop(reference.childNodes, function(child) {
              if (child.nodeName === 'INPUT' || child.nodeName === 'TEXTAREA') {
                VueUtil.off(child, 'focus', self.doShow);
                VueUtil.off(child, 'blur', self.doClose);
                found = true;
                return false;
              }
            });
          }
          if (found) return;
          if (reference.nodeName === 'INPUT' || reference.nodeName === 'TEXTAREA') {
            VueUtil.off(reference, 'focus', self.doShow);
            VueUtil.off(reference, 'blur', self.doClose);
          } else {
            VueUtil.off(reference, 'mousedown', self.doShow);
            VueUtil.off(reference, 'mouseup', self.doClose);
          }
        }
      },
      doToggle: function() {
        this.showPopper = !this.showPopper;
      },
      doShow: function() {
        this.showPopper = true;
      },
      doClose: function() {
        this.showPopper = false;
      },
      mouseToggle: VueUtil.debounce(30, function(showPopper) {
        this.showPopper = showPopper;
      }),
      mouseEnter: function() {
        this.mouseToggle(true);
      },
      mouseLeave: function() {
        this.mouseToggle(false);
      },
      documentClick: function(e) {
        var reference = this.reference || this.$refs.reference;
        var popper = this.popper || this.$refs.popper;
        if (!reference && this.$slots.reference && this.$slots.reference[0]) {
          reference = this.referenceElm = this.$slots.reference[0].elm;
        }
        if (!this.$el || !reference || this.$el.contains(e.target) || reference.contains(e.target) || !popper || popper.contains(e.target))
          return;
        this.showPopper = false;
      }
    },
    mounted: function() {
      this.bindEvents();
    },
    destroyed: function() {
      this.unBindEvents();
    }
  };
  var directive = function(el, binding, vnode) {
    vnode.context.$refs[binding.arg].$refs.reference = el;
  };
  Vue.directive('popover', directive);
  VuePopover.directive = directive;
  Vue.component(VuePopover.name, VuePopover);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopper', 'VueUtil'], definition);
  } else {
    context.VueCascader = definition(context.Vue, context.VuePopper, context.VueUtil);
    delete context.VueCascader;
  }
})(this, function(Vue, VuePopper, VueUtil) {
  'use strict';
  var getSibling = function (el, distance) {
    var parentNode = el.parentNode;
  
    if (parentNode) {
      var siblings = parentNode.querySelectorAll('.vue-cascader-menu__item:not(.is-disabled)');
      var index = Array.prototype.indexOf.call(siblings, el);
      return siblings[index + distance] || null;
    }
  
    return null;
  };
  
  var isLeaf = function(el) {
    return el.className.indexOf('vue-cascader-menu__item--extensible') === -1;
  };

  var VueCascaderMenu = {
    name: 'VueCascaderMenu',
    data: function() {
      return {
        inputWidth: 0,
        options: [],
        props: {},
        visible: false,
        activeValue: [],
        value: [],
        expandTrigger: 'click',
        changeOnSelect: false,
        popperClass: ''
      };
    },
    watch: {
      visible: function(value) {
        if (value) {
          this.activeValue = this.value;
        }
      },
      value: {
        immediate: true,
        handler: function(value) {
          this.activeValue = value;
        }
      }
    },
    computed: {
      activeOptions: {
        cache: false,
        get: function() {
          var self = this;
          var activeValue = self.activeValue;
          var configurableProps = ['label', 'value', 'children', 'disabled'];
          var formatOptions = function(options) {
            VueUtil.loop(options, function(option) {
              if (option.__IS__FLAT__OPTIONS) return;
              VueUtil.loop(configurableProps, function(prop) {
                var value = option[self.props[prop] || prop];
                if (value)
                  option[prop] = value;
              });
              if (VueUtil.isArray(option.children)) {
                formatOptions(option.children);
              }
            });
          };
          var loadActiveOptions = function(options, activeOptions) {
            options = options || [];
            activeOptions = activeOptions || [];
            var level = activeOptions.length;
            activeOptions[level] = options;
            var active = activeValue[level];
            if (active) {
              options = VueUtil.filter(options, function(option) {
                return option.value === active;
              })[0];
              if (options && options.children) {
                loadActiveOptions(options.children, activeOptions);
              }
            }
            return activeOptions;
          };
          formatOptions(self.options);
          return loadActiveOptions(self.options);
        }
      }
    },
    methods: {
      select: function(item, menuIndex) {
        if (item.__IS__FLAT__OPTIONS) {
          this.activeValue = item.value;
        } else if (menuIndex) {
          this.activeValue.splice(menuIndex, this.activeValue.length - 1, item.value);
        } else {
          this.activeValue = [item.value];
        }
        this.$emit('pick', this.activeValue);
      },
      handleMenuLeave: function() {
        this.$emit('menuLeave');
      },
      activeItem: function(item, menuIndex) {
        var len = this.activeOptions.length;
        this.activeValue.splice(menuIndex, len, item.value);
        this.activeOptions.splice(menuIndex + 1, len, item.children);
        if (this.changeOnSelect) {
          this.$emit('pick', this.activeValue, false);
        } else {
          this.$emit('activeItemChange', this.activeValue);
        }
      },
      focusNode: function (el) {
        if (!el) return;
        
        
        var focus = el.parentNode.parentNode.querySelectorAll('.is-focus');
        VueUtil.each(focus, function(node) {
          node.classList.remove('is-focus');
        });
    
        var rectElem = el.getBoundingClientRect(), rectContainer=el.parentNode.getBoundingClientRect();
        if (rectElem.bottom > rectContainer.bottom) el.scrollIntoView(false);
        if (rectElem.top < rectContainer.top) el.scrollIntoView();
    
        if(isLeaf(el)) {
          if(el.parentNode.querySelector('.is-active')) {
            this.activeValue.pop();
          }
          el.classList.add('is-focus');
        } else {
          el.click();
        }
      },
      handleNavigate: function(position) {

        if(this.options.length > 0 && this.options[0].__IS__FLAT__OPTIONS) {
          var target = this.$el.querySelector('.is-active,.is-focus');
          if (!target) {
            this.focusNode(this.$el.querySelector('.vue-cascader-menu__item'));
            return;
          }
          switch (position) {

            case 'up':
              var up = getSibling(target, -1);
              this.focusNode(up);
              break;
            case 'down':
              var down = getSibling(target, 1);
              this.focusNode(down);
              break;
            default:
              return;  
          }
          return;
        }

        if (this.activeValue.length == 0) {
          this.$el.querySelector('.vue-cascader-menu__item').click();
          return;
        }

        var target = this.$el.querySelectorAll('.is-active,.is-focus');
        target = target[target.length - 1];

        switch (position) {

          case 'up':
            var up = getSibling(target, -1);
            this.focusNode(up);
            break;
          case 'down':
            var down = getSibling(target, 1);
            this.focusNode(down);
            break;
          case 'left':
            var left = this.$el.querySelectorAll('.is-active,.is-focus');
            left = left[left.length -2];
            this.focusNode(left);
            break;
          case 'right':
            var lastMenu = this.$el.querySelectorAll('.vue-cascader-menu');
            lastMenu = lastMenu[lastMenu.length -1];
            var right = lastMenu.querySelector('.vue-cascader-menu__item:not(.is-disabled)');
            this.focusNode(right);
            break;
          default:
            return;  
        }
      },
      handleSelect: function() {
        var select = this.$el.querySelectorAll('.is-active,.is-focus');
        select = select[select.length -1];
        select && select.click();
      }
    },
    render: function(createElement) {
      var self = this;
      var activeValue = self.activeValue
        , activeOptions = self.activeOptions
        , visible = self.visible
        , expandTrigger = self.expandTrigger
        , popperClass = self.popperClass;
      var menus = self._l(activeOptions, function(menu, menuIndex) {
        var isFlat = false;
        var items = self._l(menu, function(item, itemIndex) {
          var events = {
            on: {}
          };
          if (item.__IS__FLAT__OPTIONS)
            isFlat = true;
          if (!item.disabled) {
            if (item.children) {
              var triggerEvent = {
                click: 'click',
                hover: 'mouseenter'
              }[expandTrigger];
              events.on[triggerEvent] = function() {
                self.activeItem(item, menuIndex);
              };
              if(expandTrigger == 'hover') {
                events.on.click = function(event) {
                  if(self.changeOnSelect && !event.x == 0 && !event.y == 0) {
                    self.select(item, menuIndex);
                  } else {
                    self.activeItem(item, menuIndex);
                  }
                };
              }
            } else {
              events.on.click = function() {
                self.select(item, menuIndex);
              };
            }
          }
          return createElement('li', {
            key: itemIndex,
            class: {
              'vue-cascader-menu__item': !0,
              'vue-cascader-menu__item--extensible': item.children,
              'is-active': item.value === activeValue[menuIndex],
              'is-disabled': item.disabled
            },
            on: events.on
          }, [item.label]);
        });
        var menuStyle = {};
        if (isFlat) {
          menuStyle.minWidth = self.inputWidth + 'px';
        }
        return createElement('ul', {
          key: menuIndex,
          class: {
            'vue-cascader-menu': true,
            'vue-cascader-menu--flexible': isFlat
          },
          style: menuStyle
        }, [items]);
      });
      return createElement('transition', {
        on: {
          'after-leave': self.handleMenuLeave
        }
      }, [createElement('div', {
        directives: [{
          name: 'show',
          value: visible
        }],
        class: ['vue-cascader-menus', popperClass]
      }, [menus])]);
    },
    created: function() {
      this.$on('navigate', this.handleNavigate);
      this.$on('select', this.handleSelect);
    }
  };
  var popperMixin = {
    props: {
      placement: {
        type: String,
        default: 'bottom-start'
      },
      offset: VuePopper.props.offset,
      popperOptions: VuePopper.props.options
    },
    methods: VuePopper.methods,
    data: VuePopper.data,
    beforeDestroy: VuePopper.beforeDestroy
  };
  var VueCascader = {
    template:'' +
'<span \
:class="[\'vue-cascader\', {\'is-opened\': menuVisible, \'is-disabled\': disabled},size ? \'vue-cascader--\' + size : \'\']" \
@click="handleClick" @mouseenter="inputHover = true" @mouseleave="inputHover = false" ref="reference" \
v-clickoutside="handleClickoutside" v-scrolling="handleClickoutside"> \
<vue-input :text-align="textAlign" ref="input" :autofocus="autofocus" :tabindex="tabindex" :readonly="!filterable" \
  :placeholder="currentLabels.length ? \'\' : placeholderLang" v-model="inputValue" @input="debouncedInputChange" \
  :validate-event="false" :size="size" :disabled="disabled" @keydown.native.down.prevent="navigateOptions(\'down\')" \
  @keydown.native.up.prevent="navigateOptions(\'up\')" @keydown.native.left.prevent="navigateOptions(\'left\')" \
  @keydown.native.right.prevent="navigateOptions(\'right\')" @keydown.native.enter.prevent="selectOption" \
  @keydown.native.esc.prevent="menuVisible = false" @keydown.native.tab="menuVisible = false"> \
  <template slot="icon"> \
    <i key="1" v-if="clearable && inputHover && currentLabels.length" \
      class="vue-input__icon vue-icon-error vue-cascader__clearIcon" @click="clearValue"> \
    </i> \
    <i key="2" v-else :class="[\'vue-input__icon vue-icon-arrow-up\', {\'is-reverse\': menuVisible}]"> \
    </i> \
  </template> \
</vue-input> \
<span class="vue-cascader__label" v-show="inputValue === \'\'"> \
  <template v-if="showAllLevels"> \
    <template v-for="(label, index) in currentLabels">{{label}}<span v-if="index < currentLabels.length - 1"> / \
      </span> \
    </template> \
  </template> \
  <template v-else>{{currentLabels[currentLabels.length - 1]}}</template> \
</span> \
</span>',
    name: 'VueCascader',
    directives: {
      Clickoutside: VueUtil.component.clickoutside(),
      Scrolling: VueUtil.component.scrolling
    },
    mixins: [popperMixin, VueUtil.component.emitter],
    props: {
      options: {
        type: Array,
        required: true
      },
      props: {
        type: Object,
        default: function() {
          return {
            children: 'children',
            label: 'label',
            value: 'value',
            disabled: 'disabled'
          };
        }
      },
      value: {
        type: Array,
        default: function() {
          return [];
        }
      },
      placeholder: String,
      disabled: Boolean,
      clearable: Boolean,
      changeOnSelect: Boolean,
      popperClass: String,
      expandTrigger: {
        type: String,
        default: 'click'
      },
      filterable: Boolean,
      size: String,
      autofocus: Boolean,
      textAlign: String,
      tabindex: Number,
      showAllLevels: {
        type: Boolean,
        default: true
      }
    },
    data: function() {
      return {
        currentValue: this.value,
        menu: null,
        menuVisible: false,
        inputHover: false,
        inputValue: '',
        flatOptions: null
      };
    },
    computed: {
      placeholderLang: function() {
        if (!this.placeholder)
          return this.$t('vue.cascader.placeholder');
        return this.placeholder;
      },
      labelKey: function() {
        return this.props.label || 'label';
      },
      valueKey: function() {
        return this.props.value || 'value';
      },
      childrenKey: function() {
        return this.props.children || 'children';
      },
      currentLabels: function() {
        var self = this;
        var options = self.options || [];
        var labels = [];
        VueUtil.loop(self.currentValue, function(value) {
          var targetOption = VueUtil.filter(options, function(option) {
            return option[self.valueKey] === value;
          })[0];
          if (targetOption) {
            labels.push(targetOption[self.labelKey]);
            options = targetOption[self.childrenKey];
          }
        });
        return labels;
      }
    },
    watch: {
      menuVisible: function(value) {
        value ? this.showMenu() : this.hideMenu();
      },
      value: function(value) {
        this.currentValue = value;
      },
      currentValue: function(value) {
        this.dispatch('VueFormItem', 'vue.form.change', [value]);
      },
      options: {
        deep: true,
        handler: function(value) {
          if (!this.menu) {
            this.initMenu();
          }
          this.flatOptions = this.flattenOptions(this.options);
          this.menu.options = value;
        }
      }
    },
    methods: {
      focus: function() {
        this.$refs.input.focus();
      },
      initMenu: function() {
        this.menu = new Vue(VueCascaderMenu).$mount();
        this.menu.options = this.options;
        this.menu.props = this.props;
        this.menu.expandTrigger = this.expandTrigger;
        this.menu.changeOnSelect = this.changeOnSelect;
        this.menu.popperClass = this.popperClass;
        this.popperElm = this.menu.$el;
        this.menu.$on('pick', this.handlePick);
        this.menu.$on('activeItemChange', this.handleActiveItemChange);
        this.menu.$on('menuLeave', this.destroyPopper);
      },
      showMenu: function() {
        var self = this;
        if (!self.menu) {
          self.initMenu();
        }
        self.menu.value = VueUtil.mergeArray([], self.currentValue);
        self.menu.visible = true;
        self.menu.options = self.options;
        self.$nextTick(function() {
          self.updatePopper();
          self.menu.inputWidth = self.$refs.input.$el.offsetWidth - 2;
        });
      },
      hideMenu: function() {
        this.inputValue = '';
        this.menu.visible = false;
      },
      handleActiveItemChange: function(value) {
        var self = this;
        self.$nextTick(function() {
          self.updatePopper();
        });
        self.$emit('active-item-change', value);
      },
      handlePick: function(value, close) {
        if (!VueUtil.isDef(close)) close = true;
        this.currentValue = value;
        this.$emit('input', value);
        this.$emit('change', value);
        if (close) {
          this.menuVisible = false;
        }
        this.$nextTick(this.focus);
      },
      handleInputChange: function(value) {
        var self = this;
        if (!self.menuVisible) {
          self.menuVisible = true;
        }
        var flatOptions = self.flatOptions;
        if (!value) {
          self.menu.options = self.options;
          return;
        }
        var filteredFlatOptions = VueUtil.filter(flatOptions, function(optionsStack) {
          return optionsStack.some(function(option) {
            return new RegExp(value, 'i').test(option[self.labelKey]);
          });
        });
        if (filteredFlatOptions.length > 0) {
          filteredFlatOptions = VueUtil.map(filteredFlatOptions, function(optionStack) {
            return {
              __IS__FLAT__OPTIONS: true,
              value:  VueUtil.map(optionStack, function(item) {
                return item[self.valueKey];
              }),
              label: self.renderFilteredOptionLabel(value, optionStack)
            };
          });
        } else {
          filteredFlatOptions = [{
            __IS__FLAT__OPTIONS: true,
            label: self.$t('vue.cascader.noMatch'),
            value: '',
            disabled: true
          }];
        }
        this.$nextTick(function() {
          self.menu.options = filteredFlatOptions;
        });
      },
      renderFilteredOptionLabel: function(inputValue, optionsStack) {
        var self = this;
        return  VueUtil.map(optionsStack, function(option, index) {
          var label = option[self.labelKey];
          var keywordIndex = label.toLowerCase().indexOf(inputValue.toLowerCase());
          var labelPart = label.slice(keywordIndex, inputValue.length + keywordIndex);
          var node = keywordIndex !== -1 ? self.highlightKeyword(label, labelPart) : label;
          return index === 0 ? node : [' / ', node];
        });
      },
      highlightKeyword: function(label, keyword) {
        var self = this;
        var h = self._c;
        return  VueUtil.map(label.split(keyword), function(node, index) {
          return index === 0 ? node : [h('span', {
            class: {
              'vue-cascader-menu__item__keyword': true
            }
          }, [self._v(keyword)]), node];
        });
      },
      flattenOptions: function(options, ancestor) {
        options = options || [];
        ancestor = ancestor || [];
        var self = this;
        var flatOptions = [];
        VueUtil.loop(options, function(option) {
          var optionsStack = ancestor.concat(option);
          if (!option[self.childrenKey]) {
            flatOptions.push(optionsStack);
          } else {
            if (self.changeOnSelect) {
              flatOptions.push(optionsStack);
            }
            flatOptions = flatOptions.concat(self.flattenOptions(option[self.childrenKey], optionsStack));
          }
        });
        return flatOptions;
      },
      clearValue: function(ev) {
        ev.stopPropagation();
        this.handlePick([], true);
      },
      handleClickoutside: function() {
        this.menuVisible = false;
      },
      handleClick: function() {
        if (this.disabled)
          return;
        if (this.filterable) {
          this.menuVisible = true;
          return;
        }
        this.menuVisible = !this.menuVisible;
      },
      debouncedInputChange: VueUtil.debounce(function(value) {
        this.handleInputChange(value);
      }),
      navigateOptions: function(position) {
        if(!this.menuVisible) {
          this.menuVisible = true;
          return;
        }
        this.menu.$emit('navigate', position);
      },
      selectOption: function(a) {
        if(!this.menuVisible) {
          this.menuVisible = true;
          return;
        }
        this.menu.$emit('select');
      }
    },
    mounted: function() {
      this.flatOptions = this.flattenOptions(this.options);
    },
    beforeDestroy: function() {
      if (this.menu) {
        this.menu.$destroy();
      }
    }
  };
  Vue.component(VueCascader.name, VueCascader);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueStep = definition(context.Vue, context.VueUtil);
    delete context.VueStep;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueStep = {
    template: '<div :style="[style, isLast ? \'\' : {marginRight: - $parent.stepOffset + \'px\'}]" :class="[\'vue-step\', \'is-\' + $parent.direction]"><div :class="[\'vue-step__head\', \'is-\' + currentStatus, {\'is-text\': !icon}]"><div :style="isLast ? \'\' : {marginRight: $parent.stepOffset + \'px\'}" :class="[\'vue-step__line\', \'is-\' + $parent.direction, {\'is-icon\': icon}]"><i class="vue-step__line-inner" :style="lineStyle"></i></div><span class="vue-step__icon"><slot v-if="currentStatus !== \'success\' && currentStatus !== \'error\'" name="icon"><i v-if="icon" :class="icon"></i><div v-else>{{index + 1}}</div></slot><i v-else :class="[\'vue-icon-\' + (currentStatus === \'success\' ? \'check\' : \'close\')]"></i></span></div><div class="vue-step__main" :style="{marginLeft: mainOffset}"><div ref="title" :class="[\'vue-step__title\', \'is-\' + currentStatus]"><slot name="title">{{title}}</slot></div><div :class="[\'vue-step__description\', \'is-\' + currentStatus]"><slot></slot></div></div></div>',
    name: 'VueStep',
    props: {
      title: String,
      icon: String,
      status: String
    },
    data: function() {
      return {
        index: -1,
        lineStyle: {},
        mainOffset: 0,
        internalStatus: ''
      };
    },
    beforeCreate: function() {
      this.$parent.steps.push(this);
    },
    computed: {
      currentStatus: function() {
        return this.status || this.internalStatus;
      },
      isLast: function() {
        var parent = this.$parent;
        return parent.steps[parent.steps.length - 1] === this;
      },
      style: function() {
        var parent = this.$parent;
        var isCenter = parent.center;
        var len = parent.steps.length;
        if (isCenter && this.isLast) {
          return {};
        }
        var space = (VueUtil.isNumber(parent.space) ? parent.space + 'px' : parent.space ? parent.space : 100 / (isCenter ? len - 1 : len) + '%');
        if (parent.direction === 'horizontal') {
          return {
            width: space
          };
        } else {
          if (!this.isLast) {
            return {
              height: space
            };
          }
        }
      }
    },
    methods: {
      updateStatus: function(val) {
        var prevChild = this.$parent.$children[this.index - 1];
        if (val > this.index) {
          this.internalStatus = this.$parent.finishStatus;
        } else if (val === this.index) {
          this.internalStatus = this.$parent.processStatus;
        } else {
          this.internalStatus = 'wait';
        }
        if (prevChild)
          prevChild.calcProgress(this.internalStatus);
      },
      calcProgress: function(status) {
        var step = 100;
        var style = {};
        style.transitionDelay = 150 * this.index + 'ms';
        if (status === this.$parent.processStatus) {
          step = 50;
        } else if (status === 'wait') {
          step = 0;
          style.transitionDelay = (-150 * this.index) + 'ms';
        }
        style.borderWidth = step ? '1px' : 0;
        this.$parent.direction === 'vertical' ? style.height = step + '%' : style.width = step + '%';
        this.lineStyle = style;
      }
    },
    mounted: function() {
      var self = this;
      var parent = self.$parent;
      if (parent.direction === 'horizontal') {
        if (parent.alignCenter) {
          self.mainOffset = -self.$refs.title.getBoundingClientRect().width / 2 + 16 + 'px';
        }
      }
      var unwatch = self.$watch('index', function(val) {
        self.$watch('$parent.active', self.updateStatus, {
          immediate: true
        });
        unwatch();
      });

      self.$watch('$parent.alignCenter', function(value) {
        if(value) {
            self.mainOffset = -self.$refs.title.getBoundingClientRect().width / 2 + 16 + 'px';
        } else {
            self.mainOffset = 0;
        }
      });
    }
  };
  Vue.component(VueStep.name, VueStep);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueSteps = definition(context.Vue, context.VueUtil);
    delete context.VueSteps;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueSteps = {
    template: '<div :class="[\'vue-steps\', \'is-\' + direction, center ? \'is-center\' : \'\']"><slot></slot></div>',
    name: 'VueSteps',
    props: {
      space: [Number, String],
      active: Number,
      direction: {
        type: String,
        default: 'horizontal'
      },
      alignCenter: Boolean,
      center: Boolean,
      finishStatus: {
        type: String,
        default: 'finish'
      },
      processStatus: {
        type: String,
        default: 'process'
      }
    },
    data: function() {
      return {
        steps: [],
        stepOffset: 0
      };
    },
    watch: {
      active: function(newVal, oldVal) {
        this.$emit('change', newVal, oldVal);
      },
      steps: function(steps) {
        var self = this;
        VueUtil.loop(steps, function(child, index) {
          child.index = index;
        });
        if (self.center) {
          var len = steps.length;
          self.$nextTick(function() {
            self.stepOffset = steps[len - 1].$el.getBoundingClientRect().width / (len - 1);
          });
        }
      }
    }
  };
  Vue.component(VueSteps.name, VueSteps);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueDropdown = definition(context.Vue, context.VueUtil);
    delete context.VueDropdown;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueDropdown = {
    template: '',
    name: 'VueDropdown',
    mixins: [VueUtil.component.emitter],
    directives: {
      Clickoutside: VueUtil.component.clickoutside()
    },
    props: {
      trigger: {
        type: String,
        default: 'hover'
      },
      menuAlign: {
        type: String,
        default: 'end'
      },
      type: String,
      size: String,
      splitButton: Boolean,
      hideOnClick: {
        type: Boolean,
        default: true
      }
    },
    data: function() {
      return {
        visible: false
      };
    },
    beforeDestroy: function() {
      this.unBindEvents();
    },
    mounted: function() {
      this.$on('menu-item-click', this.handleMenuItemClick);
      this.bindEvents();
    },
    watch: {
      visible: function(val) {
        this.broadcast('VueDropdownMenu', 'visible', val);
        this.$emit('visible-change', val);
      }
    },
    methods: {
      toggle: VueUtil.debounce(30, function(visible) {
        this.visible = visible;
      }),
      show: function() {
        this.toggle(true);
      },
      hide: function() {
        this.toggle(false);
      },
      handleClick: function() {
        this.visible = !this.visible;
      },
      bindEvents: function() {
        var trigger = this.trigger;
        var show = this.show;
        var hide = this.hide;
        var handleClick = this.handleClick;
        var splitButton = this.splitButton;
        var triggerElm = splitButton ? this.$refs.trigger.$el : this.$slots.default[0].elm;
        if (trigger === 'hover') {
          VueUtil.on(triggerElm, 'mouseenter', show);
          VueUtil.on(triggerElm, 'mouseleave', hide);
          var dropdownElm = this.$slots.dropdown[0].elm;
          VueUtil.on(dropdownElm, 'mouseenter', show);
          VueUtil.on(dropdownElm, 'mouseleave', hide);
        } else if (trigger === 'click') {
          VueUtil.on(triggerElm, 'click', handleClick);
        }
      },
      unBindEvents: function() {
        var trigger = this.trigger;
        var show = this.show;
        var hide = this.hide;
        var handleClick = this.handleClick;
        var splitButton = this.splitButton;
        var triggerElm = splitButton ? this.$refs.trigger.$el : this.$slots.default[0].elm;
        if (trigger === 'hover') {
          VueUtil.off(triggerElm, 'mouseenter', show);
          VueUtil.off(triggerElm, 'mouseleave', hide);
          var dropdownElm = this.$slots.dropdown[0].elm;
          VueUtil.off(dropdownElm, 'mouseenter', show);
          VueUtil.off(dropdownElm, 'mouseleave', hide);
        } else if (trigger === 'click') {
          VueUtil.off(triggerElm, 'click', handleClick);
        }
        
      },
      handleMenuItemClick: function(command, instance) {
        if (this.hideOnClick) {
          this.visible = false;
        }
        this.$emit('command', command, instance);
      }
    },
    render: function(createElement) {
      var self = this;
      var hide = self.hide
        , splitButton = self.splitButton
        , type = self.type
        , size = self.size;
      var handleClick = function() {
        self.$emit('click');
      };
      var triggerElm = !splitButton ? self.$slots.default : createElement('vue-button-group', null, [createElement('vue-button', {
        attrs: {
          type: type,
          size: size
        },
        nativeOn: {
          click: handleClick
        }
      }, [self.$slots.default]), createElement('vue-button', {
        ref: 'trigger',
        attrs: {
          type: type,
          size: size
        },
        class: 'vue-dropdown__caret-button'
      }, [createElement('i', {
        class: 'vue-dropdown__icon vue-icon-arrow-down'
      }, [])])]);
      return createElement('div', {
        class: 'vue-dropdown',
        directives: [{
          name: 'clickoutside',
          value: hide
        }]
      }, [triggerElm, self.$slots.dropdown]);
    }
  };
  Vue.component(VueDropdown.name, VueDropdown);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueDropdownItem = definition(context.Vue, context.VueUtil);
    delete context.VueDropdownItem;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueDropdownItem = {
    template: '<li :class="[\'vue-dropdown-menu__item\', {\'is-disabled\': disabled, \'vue-dropdown-menu__item--divided\': divided}]" @click="handleClick"><slot></slot></li>',
    name: 'VueDropdownItem',
    mixins: [VueUtil.component.emitter],
    props: {
      command: String,
      disabled: Boolean,
      divided: Boolean
    },
    methods: {
      handleClick: function(e) {
        this.dispatch('VueDropdown', 'menu-item-click', [this.command, this]);
      }
    }
  };
  Vue.component(VueDropdownItem.name, VueDropdownItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopper'], definition);
  } else {
    context.VueDropdownMenu = definition(context.Vue, context.VuePopper);
    delete context.VueDropdownMenu;
  }
})(this, function(Vue, VuePopper) {
  'use strict';
  var VueDropdownMenu = {
    template: '<transition @after-leave="destroyPopper"><div class="vue-dropdown-menu" v-show="showPopper"><ul class="vue-dropdown-menu__view"><slot></slot></ul></div></transition>',
    name: 'VueDropdownMenu',
    mixins: [VuePopper],
    created: function() {
      var self = this;
      self.$on('updatePopper', self.updatePopper);
      self.$on('visible', function(val) {
        self.showPopper = val;
      });
    },
    mounted: function() {
      this.$parent.popperElm = this.popperElm = this.$el;
      this.referenceElm = this.$parent.$el;
    },
    watch: {
      '$parent.menuAlign': {
        immediate: true,
        handler: function(val) {
          this.currentPlacement = 'bottom-' + val;
        }
      }
    }
  };
  Vue.component(VueDropdownMenu.name, VueDropdownMenu);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCollapse = definition(context.Vue, context.VueUtil);
    delete context.VueCollapse;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCollapse = {
    template: '<div class="vue-collapse"><slot></slot></div>',
    name: 'VueCollapse',
    props: {
      accordion: Boolean,
      value: {
        type: [Array, String, Number],
        default: function() {
          return [];
        }
      },
      expandOnClickHeader: {
        type: Boolean,
        default: true
      }
    },
    data: function() {
      return {
        activeNames: VueUtil.mergeArray([], this.value)
      };
    },
    watch: {
      value: function(value) {
        this.activeNames = VueUtil.mergeArray([], value);
      }
    },
    methods: {
      setActiveNames: function(activeNames) {
        activeNames = VueUtil.mergeArray([], activeNames);
        var value = this.accordion ? activeNames[0] : activeNames;
        this.activeNames = activeNames;
        this.$emit('input', value);
      },
      handleItemClick: function(item) {
        if (this.accordion) {
          this.setActiveNames(
            this.activeNames[0] &&
              this.activeNames[0] === item.name
              ? '' : item.name
          );
        } else {
          var activeNames = VueUtil.mergeArray([], this.activeNames);
          var index = activeNames.indexOf(item.name);
          if (index !== -1) {
            activeNames.splice(index, 1);
          } else {
            activeNames.push(item.name);
          }
          this.setActiveNames(activeNames);
        }
      }
    },
    created: function() {
      this.$on('item-click', this.handleItemClick);
    }
  };
  Vue.component(VueCollapse.name, VueCollapse);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCollapseItem = definition(context.Vue, context.VueUtil);
    delete context.VueCollapseItem;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCollapseItem = {
    template: '<div :class="[\'vue-collapse-item\', {\'is-active\': isActive}]"><div :class="[\'vue-collapse-item__header\', {\'header-expand\': headerExpand}]" @click="handleHeaderClick"><i class="vue-collapse-item__header__arrow vue-icon-arrow-right" @click="handleIconClick" v-show="expandOnClick"></i><slot name="title">{{title}}</slot></div><collapse-transition><div class="vue-collapse-item__wrap" v-show="isActive"><div class="vue-collapse-item__content"><slot></slot></div></div></collapse-transition></div>',
    name: 'VueCollapseItem',
    mixins: [VueUtil.component.emitter],
    components: {
      CollapseTransition: VueUtil.component.collapseTransition
    },
    data: function() {
      return {
        contentWrapStyle: {
          height: 'auto',
          display: 'block'
        },
        contentHeight: 0
      };
    },
    props: {
      title: String,
      expandOnClick: {
        type: Boolean,
        default: true
      },
      name: {
        type: [String, Number],
        default: function() {
          return this._uid;
        }
      }
    },
    computed: {
      isActive: function() {
        return this.$parent.activeNames.indexOf(this.name) !== -1;
      },
      headerExpand: function() {
        return this.$parent.expandOnClickHeader;
      }
    },
    methods: {
      handleIconClick: function() {
        if (!this.headerExpand && this.expandOnClick) {
          this.dispatch('VueCollapse', 'item-click', this);
        }
      },
      handleHeaderClick: function() {
        if (this.headerExpand && this.expandOnClick) {
          this.dispatch('VueCollapse', 'item-click', this);
        }
      },
      collapseAfterEnter: function() {
        this.$parent.$emit('change', this.$parent.activeNames);
      },
      collapseAfterLeave: function() {
        this.$parent.$emit('change', this.$parent.activeNames);
      }
    }
  };
  Vue.component(VueCollapseItem.name, VueCollapseItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueBadge = definition(context.Vue, context.VueUtil);
    delete context.VueBadge;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueBadge = {
    template: '<div class="vue-badge"><slot></slot><sup v-show="!hidden && ( content || isDot )" v-text="content" :class="[\'vue-badge__content\', {\'is-fixed\': $slots.default, \'is-dot\': isDot }]"></sup></div>',
    name: 'VueBadge',
    props: {
      value: {},
      max: Number,
      isDot: Boolean,
      hidden: Boolean
    },
    computed: {
      content: function() {
        if (this.isDot) return;
        var value = this.value;
        var max = this.max;
        if (VueUtil.isNumber(value) && VueUtil.isNumber(max)) {
          return max < value ? max + '+' : value;
        }
        return value;
      }
    }
  };
  Vue.component(VueBadge.name, VueBadge);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueBreadcrumb = definition(context.Vue);
    delete context.VueBreadcrumb;
  }
})(this, function(Vue) {
  'use strict';
  var VueBreadcrumb = {
    template: '<div class="vue-breadcrumb"><slot></slot></div>',
    name: 'VueBreadcrumb',
    props: {
      separator: {
        type: String,
        default: '/'
      }
    }
  };
  Vue.component(VueBreadcrumb.name, VueBreadcrumb);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueBreadcrumbItem = definition(context.Vue, context.VueUtil);
    delete context.VueBreadcrumbItem;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueBreadcrumbItem = {
    template: '<span class="vue-breadcrumb__item"><span class="vue-breadcrumb__item__inner" ref="link"><slot></slot></span><span class="vue-breadcrumb__separator">{{$parent.separator}}</span></span>',
    name: 'VueBreadcrumbItem',
    props: {
      to: {},
      replace: Boolean
    },
    methods: {
      linkToDo: function() {
        var to = this.to;
        if (to && this.$router) {
          this.replace ? this.$router.replace(to) : this.$router.push(to);
        } else {
          this.$emit('click');
        }
      }
    },
    mounted: function() {
      VueUtil.on(this.$refs.link, 'click', this.linkToDo);
    },
    beforeDestroy: function() {
      VueUtil.off(this.$refs.link, 'click', this.linkToDo);
    }
  };
  Vue.component(VueBreadcrumbItem.name, VueBreadcrumbItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VuePopper'], definition);
  } else {
    context.VuePicker = definition(context.Vue, context.VueUtil, context.VuePopper);
  }
})(this, function(Vue, VueUtil, VuePopper) {
  'use strict';
  var NewPopper = {
    props: {
      appendToBody: VuePopper.props.appendToBody,
      offset: VuePopper.props.offset,
      boundariesPadding: VuePopper.props.boundariesPadding,
      autoWidth:VuePopper.props.autoWidth
    },
    methods: VuePopper.methods,
    data: function() {return VueUtil.merge({ visibleArrow: false }, VuePopper.data);},
    beforeDestroy: VuePopper.beforeDestroy
  };
  var formatDate = VueUtil.formatDate,
      parseDate = VueUtil.parseDate,
      isDateObject = VueUtil.isDateObject,
      getWeekNumber = VueUtil.getWeekNumber;

  
  var DEFAULT_FORMATS = {
    date: 'yyyy-MM-dd',
    month: 'yyyy-MM',
    datetime: 'yyyy-MM-dd HH:mm:ss',
    time: 'HH:mm:ss',
    week: 'yyyywWW',
    timerange: 'HH:mm:ss',
    daterange: 'yyyy-MM-dd',
    monthrange: 'yyyy-MM',
    datetimerange: 'yyyy-MM-dd HH:mm:ss',
    year: 'yyyy'
  };
  var HAVE_TRIGGER_TYPES = [
    'date',
    'datetime',
    'time',
    'time-select',
    'week',
    'month',
    'year',
    'daterange',
    'monthrange',
    'timerange',
    'datetimerange',
    'dates'
  ];
  var DATE_FORMATTER = function(value, format) {
    if (format === 'timestamp') return value.getTime();
    return formatDate(value, format);
  };
  var DATE_PARSER = function(text, format) {
    if (format === 'timestamp') return new Date(Number(text));
    return parseDate(text, format);
  };
  var RANGE_FORMATTER = function(value, format) {
    if (Array.isArray(value) && value.length === 2) {
      var start = value[0];
      var end = value[1];

      if (start && end) {
        return [DATE_FORMATTER(start, format), DATE_FORMATTER(end, format)];
      }
    }
    return '';
  };
  var RANGE_PARSER = function(array, format, separator) {
    if (!Array.isArray(array)) {
      array = array.split(separator);
    }
    if (array.length === 2) {
      var range1 = array[0];
      var range2 = array[1];

      return [DATE_PARSER(range1, format), DATE_PARSER(range2, format)];
    }
    return [];
  };
  var TYPE_VALUE_RESOLVER_MAP = {
    default: {
      formatter: function (value) {
        if (!value) return '';
        return '' + value;
      },
      parser: function (text) {
        if (text === undefined || text === '') return null;
        return text;
      }
    },
    week: {
      formatter: function (value, format) {
        var week = getWeekNumber(value);
        var month = value.getMonth();
        var trueDate = new Date(value);
  
        if (week === 1 && month === 11) {
          trueDate.setHours(0, 0, 0, 0);
          trueDate.setDate(trueDate.getDate() + 3 - (trueDate.getDay() + 6) % 7);
        }
  
        var date = formatDate(trueDate, format);
        date = /WW/.test(date) ? date.replace(/WW/, week < 10 ? '0' + week : week) : date.replace(/W/, week);
        return date;
      },
      parser: function (text, format) {
        // parse as if a normal date
        return TYPE_VALUE_RESOLVER_MAP.date.parser(text, format);
      }
    },
    date: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    datetime: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    daterange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    monthrange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    datetimerange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    timerange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    time: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    month: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    year: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    number: {
      formatter: function (value) {
        if (!value) return '';
        return '' + value;
      },
      parser: function (text) {
        var result = Number(text);
  
        if (!isNaN(text)) {
          return result;
        } else {
          return null;
        }
      }
    },
    dates: {
      formatter: function (value, format) {
        return value.map(function (date) {
          return DATE_FORMATTER(date, format);
        });
      },
      parser: function (value, format) {
        return (typeof value === 'string' ? value.split(', ') : value).map(function (date) {
          return date instanceof Date ? date : DATE_PARSER(date, format);
        });
      }
    }
  };
  var PLACEMENT_MAP = {
    left: 'bottom-start',
    center: 'bottom',
    right: 'bottom-end'
  };

  var parseAsFormatAndType = function (value, customFormat, type) {
    var rangeSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '-';
    if (!value) return null;
    var parser = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP['default']).parser;
    var format = customFormat || DEFAULT_FORMATS[type];
    return parser(value, format, rangeSeparator);
  };
  
  var formatAsFormatAndType = function (value, customFormat, type) {
    if (!value) return null;
    var formatter = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP['default']).formatter;
    var format = customFormat || DEFAULT_FORMATS[type];
    return formatter(value, format);
  };
  /*
  * Considers:
  *   1. Date object
  *   2. date string
  *   3. array of 1 or 2
  */
  
  
  var valueEquals = function (a, b) {
    // considers Date object and string
    var dateEquals = function (a, b) {
      var aIsDate = a instanceof Date;
      var bIsDate = b instanceof Date;
  
      if (aIsDate && bIsDate) {
        return a.getTime() === b.getTime();
      }
  
      if (!aIsDate && !bIsDate) {
        return a === b;
      }
  
      return false;
    };
  
    var aIsArray = a instanceof Array;
    var bIsArray = b instanceof Array;
  
    if (aIsArray && bIsArray) {
      if (a.length !== b.length) {
        return false;
      }
  
      return a.every(function (item, index) {
        return dateEquals(item, b[index]);
      });
    }
  
    if (!aIsArray && !bIsArray) {
      return dateEquals(a, b);
    }
  
    return false;
  };
  
  var isString = function (val) {
    return typeof val === 'string' || val instanceof String;
  };
  
  var validator = function (val) {
    // either: String, Array of String, null / undefined
    return val === null || val === undefined || isString(val) || Array.isArray(val) && val.length === 2 && val.every(isString);
  };

  var VuePicker = {
    template: 
    '  <vue-input'+
    '    class="vue-date-editor"'+
    '    :class="\'vue-date-editor--\' + type"'+
    '    :readonly="isMobile || !editable || readonly || type === \'dates\' || type === \'week\'"'+
    '    :disabled="pickerDisabled"'+
    '    :size="pickerSize"'+
    '    :name="name"'+
    '    v-bind="firstInputId"'+
    '    v-if="!ranged"'+
    '    v-clickoutside="handleClose" v-scrolling="handleClose"'+
    '    :placeholder="placeholder"'+
    '    @focus="handleFocus"'+
    '    @keydown.native="handleKeydown"'+
    '    :value="displayValue"'+
    '    @input="function (value) {return userInput = value;}"'+
    '    @change="handleChange"'+
    '    @mouseenter.native="handleMouseEnter"'+
    '    @mouseleave.native="showClose = false"'+
    '    :validateEvent="false"'+
    '    :tabindex="tabindex"'+
    '    :icon="showClose ? \'\' + clearIcon : \'\'"'+
    '    :on-icon-click="handleClickIcon"'+
    '    ref="reference">'+
    '    <i slot="prefix"'+
    '      class="vue-input__icon"'+
    '      :class="triggerClass"'+
    '      @click="handleFocus">'+
    '    </i>'+
    // '    <i slot="suffix"'+
    // '      class="vue-input__icon"'+
    // '      @click="handleClickIcon"'+
    // '      :class="[showClose ? \'\' + clearIcon : \'\']"'+
    // '      v-if="haveTrigger">'+
    // '    </i>'+
    '  </vue-input>'+
    '  <div'+
    '    class="vue-date-editor vue-range-editor vue-input__inner"'+
    '    :class="['+
    '      \'vue-date-editor--\' + type,'+
    '      pickerSize ? \'vue-range-editor--\' + pickerSize  : \'\','+
    '      pickerDisabled ? \'is-disabled\' : \'\','+
    '      pickerVisible ? \'is-active\' : \'\','+
    '      isMobile ? \'user_un_operate\' : \'\''+
    '    ]"'+
    '    @click="handleRangeClick"'+
    '    @mouseenter="handleMouseEnter"'+
    '    @mouseleave="showClose = false"'+
    '    @keydown="handleKeydown"'+
    '    ref="reference"'+
    '    v-clickoutside="handleClose" v-scrolling="handleClose"'+
    '    v-else>'+
    '    <i :class="[\'vue-input__icon\', \'vue-range__icon\', triggerClass]"></i>'+
    '    <input'+
    '      autocompvare="off"'+
    '      :placeholder="startPlaceholder"'+
    '      :value="displayValue && displayValue[0]"'+
    '      :disabled="pickerDisabled"'+
    '      v-bind="firstInputId"'+
    '      :readonly="!editable || readonly || isMobile"'+
    '      :name="name && name[0]"'+
    '      @input="handleStartInput"'+
    '      @change="handleStartChange"'+
    '      @focus="handleFocus"'+
    '      ref="fromInput"'+
    '      :tabindex="tabindex"'+
    '      :class="[\'vue-range-input\',{\'user_un_operate\':isMobile}]">'+
    '    <slot name="range-separator">'+
    '      <span class="vue-range-separator">{{ rangeSeparator }}</span>'+
    '    </slot>'+
    '    <input'+
    '      autocompvare="off"'+
    '      :placeholder="endPlaceholder"'+
    '      :value="displayValue && displayValue[1]"'+
    '      :disabled="pickerDisabled"'+
    '      v-bind="secondInputId"'+
    '      :readonly="!editable || readonly || isMobile"'+
    '      :name="name && name[1]"'+
    '      @input="handleEndInput"'+
    '      @change="handleEndChange"'+
    '      @focus="handleFocus"'+
    '      :tabindex="tabindex"'+
    '      :class="[\'vue-range-input\',{\'user_un_operate\':isMobile}]">'+

    '    <i'+
    '      @click="handleClickIcon"'+
    '      v-if="haveTrigger"'+
    '      :class="[showClose ? \'\' + clearIcon : \'\']"'+
    '      class="vue-input__icon vue-range__close-icon">'+
    '    </i>'+
    '  </div>',
    mixins: [VueUtil.component.emitter, NewPopper],
    directives: {
      Clickoutside: VueUtil.component.clickoutside(function(vnode,mouseup,mousedown){//解决datepicker在移动端弹出框固定在下方的模式下，点击空白地方无法关闭弹出层的问题
        if (VueUtil.getSystemInfo().device != 'Mobile') {
          return;
        }
        var pel= vnode.context.popperElm.querySelector('.vue-picker-panel');
        if(mousedown.target.classList=='vue-aside__wrapper'){
          
          if(!pel){
            return true;
          }
          return !(pel.contains(mouseup.target)||pel.contains(mousedown.target));
        }else if(mousedown.target.classList=='vue-input__inner'){
          if(!vnode.context.popperElm){
            return false;
          }
          if(!pel){
            return false;
          }
          var pel2 =  vnode.context.popperElm.querySelector('.vue-date-picker__header') || vnode.context.popperElm.querySelector('.vue-date-picker__time-header') || vnode.context.popperElm.querySelector('.vue-date-range-picker__time-header');
          if(pel2)
            return false;
          return pel.contains(mouseup.target)||pel.contains(mousedown.target);
        }
        return false;
        
      }),
      Scrolling: VueUtil.component.scrolling
    },
    props: {
      size: String,
      format: String,
      valueFormat: String,
      readonly: Boolean,
      placeholder: String,
      startPlaceholder: String,
      endPlaceholder: String,
      prefixIcon: String,
      clearIcon: {
        type: String,
        default: 'vue-icon-close'
      },
      name: {
        default: '',
        validator: validator
      },
      disabled: Boolean,
      clearable: {
        type: Boolean,
        default: true
      },
      id: {
        default: '',
        validator: validator
      },
      popperClass: String,
      editable: {
        type: Boolean,
        default: true
      },
      align: {
        type: String,
        default: 'left'
      },
      value: {},
      defaultValue: {},
      defaultTime: {},
      rangeSeparator: {
        default: '-'
      },
      pickerOptions: {},
      unlinkPanels: Boolean,
      validateEvent: {
        type: Boolean,
        default: true
      },
      tabindex: Number,
    },
    data: function () {
      return {
        pickerVisible: false,
        showClose: false,
        userInput: null,
        valueOnOpen: null,
        // value when picker opens, used to determine whether to emit change
        unwatchPickerOptions: null,
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false
      };
    },
    watch: {
      pickerVisible: function (val) {
        if (this.readonly || this.pickerDisabled) return;
        if (val) {
          this.showPicker();
          this.valueOnOpen = Array.isArray(this.value) ?  this.value.slice() : this.value;
        } else {
          this.hidePicker();
          this.emitChange(this.value);
          this.userInput = null;
  
          if (this.validateEvent) {
            this.dispatch('VueFormItem', 'vue.form.blur');
          }
  
          this.$emit('blur', this);
          this.blur();
        }
       

      },
      parsedValue: {
        immediate: true,
        handler: function (val) {
          if (this.picker) {
            this.picker.value = val;
          }
        }
      },
      defaultValue: function (val) {
        // NOTE: should eventually move to jsx style picker + panel ?
        if (this.picker) {
          this.picker.defaultValue = val;
        }
      },
      value: function (val, oldVal) {
        if (!valueEquals(val, oldVal) && !this.pickerVisible && this.validateEvent) {
          this.dispatch('VueFormItem', 'vue.form.change', val);
        }
        if(this.isMobile &&val){
          this.showClose = true;        
        }else{
          this.showClose = false;
        }
        
      }
    },
    computed: {
      ranged: function () {
        return this.type.indexOf('range') > -1;
      },
      reference: function () {
        var reference = this.$refs.reference;
        return reference.$el || reference;
      },
      refInput: function () {
        if (this.reference) {
          return [].slice.call(this.reference.querySelectorAll('input'));
        }
  
        return [];
      },
      valueIsEmpty: function () {
        var val = this.value;
  
        if (Array.isArray(val)) {
          for (var i = 0, len = val.length; i < len; i++) {
            if (val[i]) {
              return false;
            }
          }
        } else {
          if (val) {
            return false;
          }
        }
  
        return true;
      },
      triggerClass: function () {
        return this.prefixIcon || (this.type.indexOf('time') !== -1 ? 'vue-icon-time' : 'vue-icon-date');
      },
      selectionMode: function () {
        if (this.type === 'week') {
          return 'week';
        } else if (this.type === 'month') {
          return 'month';
        } else if (this.type === 'year') {
          return 'year';
        } else if (this.type === 'dates') {
          return 'dates';
        }
  
        return 'day';
      },
      haveTrigger: function () {
        if (typeof this.showTrigger !== 'undefined') {
          return this.showTrigger;
        }
  
        return HAVE_TRIGGER_TYPES.indexOf(this.type) !== -1;
      },
      displayValue: function () {
        var formattedValue = formatAsFormatAndType(this.parsedValue, this.format, this.type, this.rangeSeparator);
  
        if (Array.isArray(this.userInput)) {
          return [this.userInput[0] || formattedValue && formattedValue[0] || '', this.userInput[1] || formattedValue && formattedValue[1] || ''];
        } else if (this.userInput !== null) {
          return this.userInput;
        } else if (formattedValue) {
          return this.type === 'dates' ? formattedValue.join(', ') : formattedValue;
        } else {
          return '';
        }
      },
      parsedValue: function () {
        if (!this.value) return this.value; // component value is not set
  
        if (this.type === 'time-select') return this.value; // time-select does not require parsing, this might change in next major version
  
        var valueIsDateObject = isDateObject(this.value) || Array.isArray(this.value) && this.value.every(isDateObject);
  
        if (valueIsDateObject) {
          return this.value;
        }
  
        if (this.valueFormat) {
          return parseAsFormatAndType(this.value, this.valueFormat, this.type, this.rangeSeparator) || this.value;
        } // NOTE: deal with common but incorrect usage, should remove in next major version
        // user might provide string / timestamp without value-format, coerce them into date (or array of date)
  
        return Array.isArray(this.value) ? this.value.map(function (val) {
          return new Date(val);
        }) : new Date(this.value);
      },
      _elFormItemSize: function _elFormItemSize() {
        return (this.elFormItem || {}).elFormItemSize;
      },
      pickerSize: function () {
        return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
      },
      pickerDisabled: function () {
        return this.disabled || (this.elForm || {}).disabled;
      },
      firstInputId: function () {
        var obj = {};
        var id;
  
        if (this.ranged) {
          id = this.id && this.id[0];
        } else {
          id = this.id;
        }
  
        if (id) obj.id = id;
        return obj;
      },
      secondInputId: function () {
        var obj = {};
        var id;
  
        if (this.ranged) {
          id = this.id && this.id[1];
        }
  
        if (id) obj.id = id;
        return obj;
      }
    },
    created: function () {
      // vue-popper
      this.popperOptions = {
        boundariesPadding: 0,
        gpuAcceleration: false
      };
      this.placement = PLACEMENT_MAP[this.align] || PLACEMENT_MAP.left;
      this.$on('fieldReset', this.handleFieldReset);
    },
    methods: {
      focus: function () {
        if (!this.ranged) {
          this.$refs.reference.focus();
        } else {
          this.handleFocus();
          var self = this;
          this.$nextTick(function() {
            self.$refs.fromInput && self.$refs.fromInput.focus();
          });
        }
      },
      blur: function () {
        this.refInput.forEach(function (input) {
          return input.blur();
        });
      },
      // {parse, formatTo} Value deals maps component value with internal Date
      parseValue: function (value) {
        var isParsed = isDateObject(value) || Array.isArray(value) && value.every(isDateObject);
  
        if (this.valueFormat && !isParsed) {
          return parseAsFormatAndType(value, this.valueFormat, this.type, this.rangeSeparator) || value;
        } else {
          return value;
        }
      },
      formatToValue: function (date) {
        var isFormattable = isDateObject(date) || Array.isArray(date) && date.every(isDateObject);
  
        if (this.valueFormat && isFormattable) {
          return formatAsFormatAndType(date, this.valueFormat, this.type, this.rangeSeparator);
        } else {
          return date;
        }
      },
      // {parse, formatTo} String deals with user input
      parseString: function (value) {
        var type = Array.isArray(value) ? this.type : this.type.replace('range', '');
        return parseAsFormatAndType(value, this.format, type);
      },
      formatToString: function (value) {
        var type = Array.isArray(value) ? this.type : this.type.replace('range', '');
        return formatAsFormatAndType(value, this.format, type);
      },
      handleMouseEnter: function () {
        if (this.readonly || this.pickerDisabled) return;
  
        if (!this.valueIsEmpty && this.clearable) {
          var self = this;
          setTimeout(function(){
            self.showClose = true;
          },10);
        }
      },
      handleChange: function () {
        if (this.userInput) {
          var value = this.parseString(this.displayValue);
  
          if (value) {
            this.picker.value = value;
  
            if (this.isValidValue(value)) {
              this.emitInput(value);
              this.userInput = null;
            }
          }
        }
  
        if (this.userInput === '') {
          this.emitInput(null);
          this.emitChange(null);
          this.userInput = null;
        }
      },
      handleStartInput: function (event) {
        if (this.userInput) {
          this.userInput = [event.target.value, this.userInput[1]];
        } else {
          this.userInput = [event.target.value, null];
        }
      },
      handleEndInput: function (event) {
        if (this.userInput) {
          this.userInput = [this.userInput[0], event.target.value];
        } else {
          this.userInput = [null, event.target.value];
        }
      },
      handleStartChange: function (callback) {
        var value = typeof callback === 'function' ? callback(this.userInput) : this.parseString(this.userInput && this.userInput[0]);
  
        if (value) {
          this.userInput = [this.formatToString(value), this.displayValue[1]];
          var newValue = [value, this.picker.value && this.picker.value[1]];
          this.picker.value = newValue;
  
          if (this.isValidValue(newValue)) {
            this.picker.rangeState && (this.picker.rangeState.selecting = false);
            this.emitInput(newValue);
            this.userInput = null;
          } else {
            this.picker.rangeState && (this.picker.rangeState.selecting = true);
          }
        }
      },
      handleEndChange: function (callback) {
        var value = typeof callback === 'function' ? callback(this.userInput) : this.parseString(this.userInput && this.userInput[1]);
  
        if (value) {
          this.userInput = [this.displayValue[0], this.formatToString(value)];
          var newValue = [this.picker.value && this.picker.value[0], value];
          this.picker.value = newValue;
  
          if (this.isValidValue(newValue)) {
            this.picker.rangeState && (this.picker.rangeState.selecting = false);
            this.emitInput(newValue);
            this.userInput = null;
          } else {
            this.picker.handleRangePick({minDate: value, maxDate: null});
            this.picker.rangeState && (this.picker.rangeState.selecting = true);
          }
        }
      },
      handleClickIcon: function (event) {
        if (this.readonly || this.pickerDisabled) return;
  
        if (this.showClose) {
          this.valueOnOpen = this.value;
          event.stopPropagation();
          this.emitInput(null);
          this.emitChange(null);
          this.showClose = false;
  
          if (this.picker && typeof this.picker.handleClear === 'function') {
            this.picker.handleClear();
          }
        } else {
          this.pickerVisible = !this.pickerVisible;
        }
      },
      handleClose: function () {
        if (!this.pickerVisible) return;
        this.pickerVisible = false;
  
        if (this.type === 'dates') {
          // restore to former value
          var oldValue = parseAsFormatAndType(this.valueOnOpen, this.valueFormat, this.type, this.rangeSeparator) || this.valueOnOpen;
          this.emitInput(oldValue);
        }
        

      },
      handleFieldReset: function (initialValue) {
        this.userInput = initialValue === '' ? null : initialValue;
      },
      handleFocus: function () {
        var type = this.type;
        if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {
          this.pickerVisible = true;
        }
  
        this.$emit('focus', this);
      },
      handleKeydown: function (event) {
        var self = this;
        var keyCode = event.keyCode; // ESC
        if (keyCode === 27) {
          this.pickerVisible = false;
          event.stopPropagation();
          return;
        } // Tab
  
  
        if (keyCode === 9) {
          if (!this.ranged) {
            this.handleChange();
            this.pickerVisible = this.picker.visible = false;
            this.blur();

            // grid内部无法捕获到tab事件
            if (!(this.$el && this.$el.parentNode.className.indexOf('vue-xtable-cell') > -1)) {
              event.stopPropagation();
            }
          } else if(!event.shiftKey) {
            // user may change focus between two input
            setTimeout(function () {
              if (self.refInput.indexOf(document.activeElement) === -1) {
                self.pickerVisible = false;
  
                self.blur();

                // grid内部无法捕获到tab事件
                if (!(this.$el && this.$el.parentNode.className.indexOf('vue-xtable-cell') > -1)) {
                  event.stopPropagation();
                }
              }
            }, 0);
          }
  
          return;
        } // Enter
  
  
        if (keyCode === 13) {
          if (this.userInput === '' || this.isValidValue(this.parseString(this.displayValue))) {
            this.handleChange();
            this.pickerVisible = this.picker.visible = false;
            this.blur();
          }
  
          event.stopPropagation();
          return;
        } // if user is typing, do not let picker handle key input
  
  
        if (this.userInput) {
          event.stopPropagation();
          return;
        } // delegate other keys to panel
  
  
        if (this.picker && this.picker.handleKeydown) {
          this.picker.handleKeydown(event);
        }
      },
      handleRangeClick: function () {
        var type = this.type;
  
        if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {
          this.pickerVisible = true;
        }
  
        this.$emit('focus', this);
      },
      hidePicker: function () {
        if (this.picker) {
          this.picker.resetView && this.picker.resetView();
          this.pickerVisible = this.picker.visible = false;
          this.destroyPopper();
        }
      },
      showPicker: function () {
        var self = this;
        if (this.$isServer) return;
  
        if (!this.picker) {
          this.mountPicker();
        }
  
        this.pickerVisible = this.picker.visible = true;
        this.updatePopper();
        this.picker.value = this.parsedValue;
        this.picker.resetView && this.picker.resetView();
        this.$nextTick(function () {
          self.picker.adjustSpinners && self.picker.adjustSpinners();
        });
      },
      mountPicker: function () {
        var self = this;
        
        if(Vue.i18n) this.panel.i18n = Vue.i18n;

        this.picker = new Vue(this.panel).$mount();
        this.picker.defaultValue = this.defaultValue;
        this.picker.defaultTime = this.defaultTime;
        this.picker.popperClass = this.popperClass;
        this.popperElm = this.picker.$el;
        this.picker.width = this.reference.getBoundingClientRect().width;
        this.picker.showTime = this.type === 'datetime' || this.type === 'datetimerange';
        this.picker.selectionMode = this.selectionMode;
        this.picker.unlinkPanels = this.unlinkPanels;
        this.picker.arrowControl = this.arrowControl || this.timeArrowControl || false;
        this.$watch('format', function (format) {
          self.picker.format = format;
        });
  
        var updateOptions = function () {
          var options = self.pickerOptions;
  
          if (options && options.selectableRange) {
            var ranges = options.selectableRange;
            var parser = TYPE_VALUE_RESOLVER_MAP.datetimerange.parser;
            var format = DEFAULT_FORMATS.timerange;
            ranges = Array.isArray(ranges) ? ranges : [ranges];
            self.picker.selectableRange = ranges.map(function (range) {
              return parser(range, format, self.rangeSeparator);
            });
          }
  
          for (var option in options) {
            if (options.hasOwnProperty(option) && // 忽略 time-picker 的该配置项
            option !== 'selectableRange') {
              self.picker[option] = options[option];
            }
          } // main format must prevail over undocumented pickerOptions.format
  
  
          if (self.format) {
            self.picker.format = self.format;
          }
        };
  
        updateOptions();
        this.unwatchPickerOptions = this.$watch('pickerOptions', function () {
          return updateOptions();
        }, {
          deep: true
        });
        this.$el.appendChild(this.picker.$el);
        this.picker.resetView && this.picker.resetView();
        this.picker.$on('dodestroy', this.doDestroy);      
        this.picker.$on('pick', function () {
          var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          self.userInput = null;
          self.pickerVisible = self.picker.visible = visible;
  
          self.emitInput(date);
  
          self.picker.resetView && self.picker.resetView();
        });
        this.picker.$on('select-range', function (start, end, pos) {
          if (self.refInput.length === 0) return;
  
          if (!pos || pos === 'min') {
            self.refInput[0].setSelectionRange(start, end);
  
            self.refInput[0].focus();
          } else if (pos === 'max') {
            self.refInput[1].setSelectionRange(start, end);
  
            self.refInput[1].focus();
          }
        });
      },
      unmountPicker: function () {
        if (this.picker) {
          this.picker.$destroy();
          this.picker.$off();
  
          if (typeof this.unwatchPickerOptions === 'function') {
            this.unwatchPickerOptions();
          }
  
          this.picker.$el.parentNode.removeChild(this.picker.$el);
        }
      },
      emitChange: function (val) {
        // determine user real change only
        if (!valueEquals(val, this.valueOnOpen)) {
          this.$emit('change', val);
          this.valueOnOpen = val;
  
          if (this.validateEvent) {
            this.dispatch('VueFormItem', 'vue.form.change', val);
          }
        }
      },
      emitInput: function (val) {
        var formatted = this.formatToValue(val);
        if (!valueEquals(this.value, formatted)) {
          this.$emit('input', formatted);
        }
      },
      isValidValue: function (value) {
        if (!this.picker) {
          this.mountPicker();
        }
  
        if (this.picker.isValidValue) {
          return value && this.picker.isValidValue(value);
        } else {
          return true;
        }
      }
    }
  };
  return VuePicker;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePicker'], definition);
  } else {
    context.VueTimeSelect = definition(context.Vue, context.VuePicker);
    delete context.VueTimeSelect;
  }
})(this, function(Vue, VuePicker) {
  'use strict';
  
  var parseTime = function (time) {
    var values = (time || '').split(':');
  
    if (values.length >= 2) {
      var hours = parseInt(values[0], 10);
      var minutes = parseInt(values[1], 10);
      return {
        hours: hours,
        minutes: minutes
      };
    }
    /* istanbul ignore next */
    return null;
  };
  
  var compareTime = function (time1, time2) {
    var value1 = parseTime(time1);
    var value2 = parseTime(time2);
    var minutes1 = value1.minutes + value1.hours * 60;
    var minutes2 = value2.minutes + value2.hours * 60;
  
    if (minutes1 === minutes2) {
      return 0;
    }
  
    return minutes1 > minutes2 ? 1 : -1;
  };
  
  var formatTime = function (time) {
    return (time.hours < 10 ? '0' + time.hours : time.hours) + ':' + (time.minutes < 10 ? '0' + time.minutes : time.minutes);
  };
  
  var nextTime = function (time, step) {
    var timeValue = parseTime(time);
    var stepValue = parseTime(step);
    var next = {
      hours: timeValue.hours,
      minutes: timeValue.minutes
    };
    next.minutes += stepValue.minutes;
    next.hours += stepValue.hours;
    next.hours += Math.floor(next.minutes / 60);
    next.minutes = next.minutes % 60;
    return formatTime(next);
  };
  
  function scrollIntoView(container, selected) {
    if (Vue.prototype.$isServer) return;
  
    if (!selected) {
      container.scrollTop = 0;
      return;
    }
  
    var offsetParents = [];
    var pointer = selected.offsetParent;
  
    while (pointer && container !== pointer && container.contains(pointer)) {
      offsetParents.push(pointer);
      pointer = pointer.offsetParent;
    }
  
    var top = selected.offsetTop + offsetParents.reduce(function (prev, curr) {
      return prev + curr.offsetTop;
    }, 0);
    var bottom = top + selected.offsetHeight;
    var viewRectTop = container.scrollTop;
    var viewRectBottom = viewRectTop + container.clientHeight;
  
    if (top < viewRectTop) {
      container.scrollTop = top;
    } else if (bottom > viewRectBottom) {
      container.scrollTop = bottom - container.clientHeight;
    }
  }

  var TimeSelect = {
    template: '  <transition name="vue-zoom-in-top" @before-enter="handleMenuEnter" @after-leave="$emit(\'destroyPopper\')">'+
    '    <div'+
    '      ref="popper"'+
    '      v-show="visible"'+
    '      :style="{ width: width + \'px\' }"'+
    '      :class="popperClass"'+
    '      class="vue-picker-panel time-select vue-popper">'+
    '      <vue-scrollbar noresize wrap-class="vue-picker-panel__content">'+
    '        <div class="time-select-item"'+
    '          v-for="item in items"'+
    '          :class="{ selected: value === item.value, disabled: item.disabled, default: item.value === defaultValue }"'+
    '          :disabled="item.disabled"'+
    '          :key="item.value"'+
    '          @click="handleClick(item)">{{ item.value }}</div>'+
    '      </vue-scrollbar>'+
    '    </div>'+
    '  </transition>',
    watch: {
      value: function (val) {
        var self = this;
  
        if (!val) return;
        this.$nextTick(function () {
          return self.scrollToOption();
        });
      }
    },
    methods: {
      handleClick: function (item) {
        if (!item.disabled) {
          this.$emit('pick', item.value);
        }
      },
      handleClear: function () {
        this.$emit('pick', null);
      },
      scrollToOption: function () {
        var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.selected';
        var menu = this.$refs.popper.querySelector('.vue-picker-panel__content');
        scrollIntoView(menu, menu.querySelector(selector));
      },
      handleMenuEnter: function () {
        var self = this;
  
        var selected = this.items.map(function (item) {
          return item.value;
        }).indexOf(this.value) !== -1;
        var hasDefault = this.items.map(function (item) {
          return item.value;
        }).indexOf(this.defaultValue) !== -1;
        var option = selected && '.selected' || hasDefault && '.default' || '.time-select-item:not(.disabled)';
        this.$nextTick(function () {
          return self.scrollToOption(option);
        });
      },
      scrollDown: function (step) {
        var items = this.items;
        var length = items.length;
        var total = items.length;
        var index = items.map(function (item) {
          return item.value;
        }).indexOf(this.value);
  
        while (total--) {
          index = (index + step + length) % length;
  
          if (!items[index].disabled) {
            this.$emit('pick', items[index].value, true);
            return;
          }
        }
      },
      isValidValue: function (date) {
        return this.items.filter(function (item) {
          return !item.disabled;
        }).map(function (item) {
          return item.value;
        }).indexOf(date) !== -1;
      },
      handleKeydown: function (event) {
        var keyCode = event.keyCode;
  
        if (keyCode === 38 || keyCode === 40) {
          var mapping = {
            40: 1,
            38: -1
          };
          var offset = mapping[keyCode.toString()];
          this.scrollDown(offset);
          event.stopPropagation();
          return;
        }
      }
    },
    data: function () {
      return {
        popperClass: '',
        start: '09:00',
        end: '18:00',
        step: '00:30',
        value: '',
        defaultValue: '',
        visible: false,
        minTime: '',
        maxTime: '',
        width: 0
      };
    },
    computed: {
      items: function () {
        var start = this.start;
        var end = this.end;
        var step = this.step;
        var result = [];
  
        if (start && end && step) {
          var current = start;
  
          while (compareTime(current, end) <= 0) {
            result.push({
              value: current,
              disabled: compareTime(current, this.minTime || '-1:-1') <= 0 || compareTime(current, this.maxTime || '100:100') >= 0
            });
            current = nextTime(current, step);
          }
        }
  
        return result;
      }
    }
  };
  var VueTimeSelect = {
    mixins: [VuePicker],
    name: 'VueTimeSelect',
    props: {
      type: {
        type: String,
        default: 'time-select'
      }
    },
    beforeCreate: function() {
      this.panel = TimeSelect;
    }
  };
  Vue.component(VueTimeSelect.name, VueTimeSelect);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePicker', 'VueUtil'], definition);
  } else {
    context.VueTimePicker = definition(context.Vue, context.VuePicker, context.VueUtil);
  }
})(this, function(Vue, VuePicker, VueUtil) {
  'use strict';

  var limitTimeRange = VueUtil.limitTimeRange,
    isDate = VueUtil.isDate,
    clearMilliseconds = VueUtil.clearMilliseconds,
    timeWithinRange = VueUtil.timeWithinRange,
    getRangeHours = VueUtil.getRangeHours,
    getRangeMinutes = VueUtil.getRangeMinutes,
    modifyTime = VueUtil.modifyTime,
    parseDate = VueUtil.parseDate,
    modifyDate = VueUtil.modifyDate;

  var MIN_TIME = parseDate('00:00:00', 'HH:mm:ss');
  var MAX_TIME = parseDate('23:59:59', 'HH:mm:ss');
  
  var minTimeOfDay = function (date) {
    return modifyDate(MIN_TIME, date.getFullYear(), date.getMonth(), date.getDate());
  };
  
  var maxTimeOfDay = function (date) {
    return modifyDate(MAX_TIME, date.getFullYear(), date.getMonth(), date.getDate());
  };
  
  var advanceTime = function (date, amount) {
    return new Date(Math.min(date.getTime() + amount, maxTimeOfDay(date).getTime()));
  };

  var TimeSpinner = {
    template: 
    '  <div class="vue-time-spinner" :class="{ \'has-seconds\': showSeconds }">'+
    '    <template v-if="!arrowControl">'+
    '      <vue-scrollbar'+
    '        @mouseenter.native="emitSelectRange(\'hours\')"'+
    '        @mousemove.native="adjustCurrentSpinner(\'hours\')"'+
    '        class="vue-time-spinner__wrapper"'+
    '        wrap-style="max-height: inherit;"'+
    '        view-class="vue-time-spinner__list"'+
    '        noresize'+
    '        tag="ul"'+
    '        ref="hours">'+
    '        <li'+
    '          @click="handleClick(\'hours\', { value: hour, disabled: disabled })"'+
    '          v-for="(disabled, hour) in hoursList"'+
    '          class="vue-time-spinner__item"'+
    '          :key="hour"'+
    '          :class="{ \'active\': hour === hours, \'disabled\': disabled }">{{ (\'0\' + (amPmMode ? (hour % 12 || 12) : hour )).slice(-2) }}{{ amPm(hour) }}</li>'+
    '      </vue-scrollbar>'+
    '      <vue-scrollbar'+
    '        @mouseenter.native="emitSelectRange(\'minutes\')"'+
    '        @mousemove.native="adjustCurrentSpinner(\'minutes\')"'+
    '        class="vue-time-spinner__wrapper"'+
    '        wrap-style="max-height: inherit;"'+
    '        view-class="vue-time-spinner__list"'+
    '        noresize'+
    '        tag="ul"'+
    '        ref="minutes">'+
    '        <li'+
    '          @click="handleClick(\'minutes\', { value: key, disabled: false })"'+
    '          v-for="(enabled, key) in minutesList"'+
    '          :key="key"'+
    '          class="vue-time-spinner__item"'+
    '          :class="{ \'active\': key === minutes, disabled: !enabled }">{{ (\'0\' + key).slice(-2) }}</li>'+
    '      </vue-scrollbar>'+
    '      <vue-scrollbar'+
    '        v-show="showSeconds"'+
    '        @mouseenter.native="emitSelectRange(\'seconds\')"'+
    '        @mousemove.native="adjustCurrentSpinner(\'seconds\')"'+
    '        class="vue-time-spinner__wrapper"'+
    '        wrap-style="max-height: inherit;"'+
    '        view-class="vue-time-spinner__list"'+
    '        noresize'+
    '        tag="ul"'+
    '        ref="seconds">'+
    '        <li'+
    '          @click="handleClick(\'seconds\', { value: key, disabled: false })"'+
    '          v-for="(second, key) in 60"'+
    '          class="vue-time-spinner__item"'+
    '          :class="{ \'active\': key === seconds }"'+
    '          :key="key">{{ (\'0\' + key).slice(-2) }}</li>'+
    '      </vue-scrollbar>'+
    '    </template>'+
    '    <template v-if="arrowControl">'+
    '      <div'+
    '        @mouseenter="emitSelectRange(\'hours\')"'+
    '        class="vue-time-spinner__wrapper is-arrow">'+
    '        <i v-repeat-click="decrease" class="vue-time-spinner__arrow vue-icon-arrow-up"></i>'+
    '        <i v-repeat-click="increase" class="vue-time-spinner__arrow vue-icon-arrow-down"></i>'+
    '        <ul class="vue-time-spinner__list" ref="hours">'+
    '          <li'+
    '            class="vue-time-spinner__item"'+
    '            :class="{ \'active\': hour === hours, \'disabled\': hoursList[hour] }"'+
    '            v-for="(hour, key) in arrowHourList"'+
    '            :key="key">{{ hour === undefined ? \'\' : (\'0\' + (amPmMode ? (hour % 12 || 12) : hour )).slice(-2) + amPm(hour) }}</li>'+
    '        </ul>'+
    '      </div>'+
    '      <div'+
    '        @mouseenter="emitSelectRange(\'minutes\')"'+
    '        class="vue-time-spinner__wrapper is-arrow">'+
    '        <i v-repeat-click="decrease" class="vue-time-spinner__arrow vue-icon-arrow-up"></i>'+
    '        <i v-repeat-click="increase" class="vue-time-spinner__arrow vue-icon-arrow-down"></i>'+
    '        <ul class="vue-time-spinner__list" ref="minutes">'+
    '          <li'+
    '            class="vue-time-spinner__item"'+
    '            :class="{ \'active\': minute === minutes }"'+
    '            v-for="(minute, key) in arrowMinuteList"'+
    '            :key="key">'+
    '            {{ minute === undefined ? \'\' : (\'0\' + minute).slice(-2) }}'+
    '          </li>'+
    '        </ul>'+
    '      </div>'+
    '      <div'+
    '        @mouseenter="emitSelectRange(\'seconds\')"'+
    '        class="vue-time-spinner__wrapper is-arrow"'+
    '        v-if="showSeconds">'+
    '        <i v-repeat-click="decrease" class="vue-time-spinner__arrow vue-icon-arrow-up"></i>'+
    '        <i v-repeat-click="increase" class="vue-time-spinner__arrow vue-icon-arrow-down"></i>'+
    '        <ul class="vue-time-spinner__list" ref="seconds">'+
    '          <li'+
    '            v-for="(second, key) in arrowSecondList"'+
    '            class="vue-time-spinner__item"'+
    '            :class="{ \'active\': second === seconds }"'+
    '            :key="key">'+
    '            {{ second === undefined ? \'\' : (\'0\' + second).slice(-2) }}'+
    '          </li>'+
    '        </ul>'+
    '      </div>'+
    '    </template>'+
   // '  </div>'+
    '  </div>',
    directives: {
      repeatClick: VueUtil.component.repeatClick
    },
    props: {
      date: {},
      defaultValue: {},
      // reserved for future use
      showSeconds: {
        type: Boolean,
        default: true
      },
      arrowControl: Boolean,
      amPmMode: {
        type: String,
        default: '' // 'a': am/pm; 'A': AM/PM
  
      }
    },
    computed: {
      hours: function () {
        return this.date.getHours();
      },
      minutes: function () {
        return this.date.getMinutes();
      },
      seconds: function () {
        return this.date.getSeconds();
      },
      hoursList: function () {
        return getRangeHours(this.selectableRange);
      },
      minutesList: function () {
        return getRangeMinutes(this.selectableRange, this.hours);
      },
      arrowHourList: function () {
        var hours = this.hours;
        return [hours > 0 ? hours - 1 : undefined, hours, hours < 23 ? hours + 1 : undefined];
      },
      arrowMinuteList: function () {
        var minutes = this.minutes;
        return [minutes > 0 ? minutes - 1 : undefined, minutes, minutes < 59 ? minutes + 1 : undefined];
      },
      arrowSecondList: function () {
        var seconds = this.seconds;
        return [seconds > 0 ? seconds - 1 : undefined, seconds, seconds < 59 ? seconds + 1 : undefined];
      }
    },
    data: function () {
      return {
        selectableRange: [],
        currentScrollbar: null,
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
      };
    },
    mounted: function () {
      var self = this;
  
      this.$nextTick(function () {
        !self.arrowControl && self.bindScrollEvent();
      });
    },
    methods: {
      
      increase: function () {
        this.scrollDown(1);
      },
      decrease: function () {
        this.scrollDown(-1);
      },
      modifyDateField: function (type, value) {
        switch (type) {
          case 'hours':
            this.$emit('change', modifyTime(this.date, value, this.minutes, this.seconds));
            break;
  
          case 'minutes':
            this.$emit('change', modifyTime(this.date, this.hours, value, this.seconds));
            break;
  
          case 'seconds':
            this.$emit('change', modifyTime(this.date, this.hours, this.minutes, value));
            break;
        }
      },
      handleClick: function (type, _ref) {
        var value = _ref.value,
            disabled = _ref.disabled;

        if (!disabled) {
          this.modifyDateField(type, value);
          this.emitSelectRange(type);
          this.adjustSpinner(type, value);
        }
      },
      emitSelectRange: function (type) {
        if (type === 'hours') {
          this.$emit('select-range', 0, 2);
        } else if (type === 'minutes') {
          this.$emit('select-range', 3, 5);
        } else if (type === 'seconds') {
          this.$emit('select-range', 6, 8);
        }
  
        this.currentScrollbar = type;
      },
      bindScrollEvent: function () {
        var self = this;
  
        var bindFuntion = function (type) {
          if(self.$refs[type]){
            self.$refs[type].wrap.onscroll = function (e) {
              self.handleScroll(type, e);
            };
          }
         
        };
  
        bindFuntion('hours');
        bindFuntion('minutes');
        bindFuntion('seconds');
      },
      handleScroll: function (type) {
        var value = Math.min(Math.floor((this.$refs[type].wrap.scrollTop - (this.scrollBarHeight(type) * 0.5 - 10) / this.typeItemHeight(type) + 3) / this.typeItemHeight(type)), type === 'hours' ? 23 : 59);
        this.modifyDateField(type, value);
      },
      // NOTE: used by datetime / date-range panel
      //       renamed from adjustScrollTop
      //       should try to refactory it
      adjustSpinners: function () {
        this.adjustSpinner('hours', this.hours);
        this.adjustSpinner('minutes', this.minutes);
        this.adjustSpinner('seconds', this.seconds);
      },
      adjustCurrentSpinner: function (type) {
        this.adjustSpinner(type, this[type]);
      },
      adjustSpinner: function (type, value) {
        if (this.arrowControl) return;
        var el = this.$refs[type].wrap;
  
        if (el) {
          el.scrollTop = Math.max(0, value * this.typeItemHeight(type));
        }
      },
      scrollDown: function (step) {
        if (!this.currentScrollbar) {
          this.emitSelectRange('hours');
        }
  
        var label = this.currentScrollbar;
        var hoursList = this.hoursList;
        var now = this[label];
  
        if (this.currentScrollbar === 'hours') {
          var total = Math.abs(step);
          step = step > 0 ? 1 : -1;
          var length = hoursList.length;
  
          while (length-- && total) {
            now = (now + step + hoursList.length) % hoursList.length;
  
            if (hoursList[now]) {
              continue;
            }
  
            total--;
          }
  
          if (hoursList[now]) return;
        } else {
          now = (now + step + 60) % 60;
        }
  
        this.modifyDateField(label, now);
        this.adjustSpinner(label, now);
      },
      amPm: function (hour) {
        var shouldShowAmPm = this.amPmMode.toLowerCase() === 'a';
        if (!shouldShowAmPm) return '';
        var isCapital = this.amPmMode === 'A';
        var content = hour < 12 ? ' am' : ' pm';
        if (isCapital) content = content.toUpperCase();
        return content;
      },
      typeItemHeight: function (type) {
        return this.$refs[type].$el.querySelector('li').offsetHeight;
      },
      scrollBarHeight: function (type) {
        return this.$refs[type].$el.offsetHeight;
      }
    }

  };
  var TimePanel = {
    template: '  <transition name="vue-zoom-in-top" @after-leave="$emit(\'destroyPopper\')">'+
    '     <div v-if="!isMobile && visible" '+
    '      v-show="visible"'+
    '      class="vue-time-panel vue-popper"'+
    '      :class="popperClass">'+
    '      <div class="vue-time-panel__content" :class="{ \'has-seconds\': showSeconds }">'+
    '        <time-spinner'+
    '          ref="spinner"'+
    '          @change="handleChange"'+
    '          :arrow-control="useArrow"'+
    '          :show-seconds="showSeconds"'+
    '          :am-pm-mode="amPmMode"'+
    '          @select-range="setSelectionRange"'+
    '          :date="date">'+
    '        </time-spinner>'+
    '      </div>'+
    '      <div class="vue-time-panel__footer">'+
    '        <button'+
    '          type="button"'+
    '          class="vue-time-panel__btn cancel"'+
    '          @click="handleCancel">{{ $t(\'vue.datepicker.cancel\') }}</button>'+
    '        <button'+
    '          type="button"'+
    '          class="vue-time-panel__btn"'+
    '          :class="{confirm: !disabled}"'+
    '          @click="handleConfirm()">{{ $t(\'vue.datepicker.confirm\') }}</button>'+
    '      </div>'+
    '    </div>'+




    '   <div v-else tabindex="-1" ref="timePanelDiv" style="width:100%;outline:none;" >'+

    '     <div v-if="isMobile && visible"  class="vue-aside__wrapper" ></div>'+
    '     <div'+
    '      v-show="visible"'+
    '      class="vue-time-panel vue-popper"'+
    '      :class="popperClass">'+
    '      <div class="vue-time-panel__content" :class="{ \'has-seconds\': showSeconds }">'+
    '        <time-spinner'+
    '          ref="spinner"'+
    '          @change="handleChange"'+
    '          :arrow-control="useArrow"'+
    '          :show-seconds="showSeconds"'+
    '          :am-pm-mode="amPmMode"'+
    '          @select-range="setSelectionRange"'+
    '          :date="date">'+
    '        </time-spinner>'+
    '      </div>'+
    '      <div class="vue-time-panel__footer">'+
    '        <button'+
    '          type="button"'+
    '          class="vue-time-panel__btn cancel"'+
    '          @click="handleCancel">{{ $t(\'vue.datepicker.cancel\') }}</button>'+
    '        <button'+
    '          type="button"'+
    '          class="vue-time-panel__btn"'+
    '          :class="{confirm: !disabled}"'+
    '          @click="handleConfirm()">{{ $t(\'vue.datepicker.confirm\') }}</button>'+
    '      </div>'+
    '    </div>'+
    

    '  </div> '+
    
    '  </transition>',

    components: {
      TimeSpinner: TimeSpinner
    },
    props: {
      visible: Boolean,
      timeArrowControl: Boolean
    },
    watch: {
      visible: function (val) {
        var self = this;
        
        if (val) {
          this.oldValue = this.value;
          this.$nextTick(function () {
           
             var rt = self.$refs.spinner.emitSelectRange('hours');

             if(self.$refs.timePanelDiv){
              self.$refs.timePanelDiv.focus();
             }
             return rt;
                        
          });
        } else {
          this.needInitAdjust = true;
        }
      },
      value: function (newVal) {
        var self = this;
  
        var date;
  
        if (newVal instanceof Date) {
          date = limitTimeRange(newVal, this.selectableRange, this.format);
        } else if (!newVal) {
          date = this.defaultValue ? new Date(this.defaultValue) : new Date();
        }
  
        this.date = date;
  
        if (this.visible && this.needInitAdjust) {
          this.$nextTick(function (_) {
            return self.adjustSpinners();
          });
          this.needInitAdjust = false;
        }
      },
      selectableRange: function (val) {
        this.$refs.spinner.selectableRange = val;
      },
      defaultValue: function (val) {
        if (!isDate(this.value)) {
          this.date = val ? new Date(val) : new Date();
        }
      }
    },
    data: function () {
      return {
        popperClass: '',
        format: 'HH:mm:ss',
        value: '',
        defaultValue: null,
        date: new Date(),
        oldValue: new Date(),
        selectableRange: [],
        selectionRange: [0, 2],
        disabled: false,
        arrowControl: false,
        needInitAdjust: true,
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
      };
    },
    computed: {
      showSeconds: function () {
        return (this.format || '').indexOf('ss') !== -1;
      },
      useArrow: function () {
        return this.arrowControl || this.timeArrowControl || false;
      },
      amPmMode: function () {
        if ((this.format || '').indexOf('A') !== -1) return 'A';
        if ((this.format || '').indexOf('a') !== -1) return 'a';
        return '';
      }
    },
    methods: {
      handleCancel: function () {
        this.$emit('pick', this.oldValue, false);
      },
      handleChange: function (date) {
        // this.visible avoids edge cases, when use scrolls during panel closing animation
        if (this.visible) {
          this.date = clearMilliseconds(date); // if date is out of range, do not emit
          if (this.isValidValue(this.date)) {
            this.$emit('pick', this.date, true);
          }
        }
      },
      setSelectionRange: function (start, end) {
        this.$emit('select-range', start, end);
        this.selectionRange = [start, end];
      },
      handleConfirm: function () {
        var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var first = arguments.length > 1 ? arguments[1] : undefined;
        if (first) return;
        var date = clearMilliseconds(limitTimeRange(this.date, this.selectableRange, this.format));
        this.$emit('pick', date, visible, first);
      },
      handleKeydown: function (event) {
        var keyCode = event.keyCode;
        var mapping = {
          38: -1,
          40: 1,
          37: -1,
          39: 1
        }; // Left or Right
  
        if (keyCode === 37 || keyCode === 39) {
          var step = mapping[keyCode];
          this.changeSelectionRange(step);
          event.preventDefault();
          return;
        } // Up or Down
  
  
        if (keyCode === 38 || keyCode === 40) {
          var _step = mapping[keyCode];
          this.$refs.spinner.scrollDown(_step);
          event.preventDefault();
          return;
        }
      },
      isValidValue: function (date) {
        return timeWithinRange(date, this.selectableRange, this.format);
      },
      adjustSpinners: function () {
        return this.$refs.spinner.adjustSpinners();
      },
      changeSelectionRange: function (step) {
        var list = [0, 3].concat(this.showSeconds ? [6] : []);
        var mapping = ['hours', 'minutes'].concat(this.showSeconds ? ['seconds'] : []);
        var index = list.indexOf(this.selectionRange[0]);
        var next = (index + step + list.length) % list.length;
        this.$refs.spinner.emitSelectRange(mapping[next]);
      }
    },
    mounted: function () {
      var self = this;
  
      this.$nextTick(function () {
        return self.handleConfirm(true, true);
      });
      this.$emit('mounted');
    }
  };
  var TimeRangePanel = {
    template: '  <transition'+
    '    name="vue-zoom-in-top"'+
    '    @after-leave="$emit(\'destroyPopper\')">'+
    '    <div :class="{\'user_un_operate\':isMobile}"><div v-if="isMobile && visible"  class="vue-aside__wrapper" ></div>'+
    '    <div'+
    '      v-show="visible"'+
    '      class="vue-time-range-picker vue-picker-panel vue-popper"'+
    '      :class="popperClass">'+
    '      <div class="vue-time-range-picker__content">'+
    '        <div class="vue-time-range-picker__cell">'+
    '          <div class="vue-time-range-picker__header">{{ $t(\'vue.datepicker.startTime\') }}</div>'+
    '          <div'+
    '            :class="{ \'has-seconds\': showSeconds, \'is-arrow\': arrowControl }"'+
    '            class="vue-time-range-picker__body vue-time-panel__content">'+
    '            <time-spinner'+
    '              ref="minSpinner"'+
    '              :show-seconds="showSeconds"'+
    '              :am-pm-mode="amPmMode"'+
    '              @change="handleMinChange"'+
    '              :arrow-control="arrowControl"'+
    '              @select-range="setMinSelectionRange"'+
    '              :date="minDate">'+
    '            </time-spinner>'+
    '          </div>'+
    '        </div>'+
    '        <div class="vue-time-range-picker__cell">'+
    '          <div class="vue-time-range-picker__header">{{ $t(\'vue.datepicker.endTime\') }}</div>'+
    '          <div'+
    '            :class="{ \'has-seconds\': showSeconds, \'is-arrow\': arrowControl }"'+
    '            class="vue-time-range-picker__body vue-time-panel__content">'+
    '            <time-spinner'+
    '              ref="maxSpinner"'+
    '              :show-seconds="showSeconds"'+
    '              :am-pm-mode="amPmMode"'+
    '              @change="handleMaxChange"'+
    '              :arrow-control="arrowControl"'+
    '              @select-range="setMaxSelectionRange"'+
    '              :date="maxDate">'+
    '            </time-spinner>'+
    '          </div>'+
    '        </div>'+
    '      </div>'+
    '      <div class="vue-time-panel__footer">'+
    '        <button'+
    '          type="button"'+
    '          class="vue-time-panel__btn cancel"'+
    '          @click="handleCancel()">{{ $t(\'vue.datepicker.cancel\') }}</button>'+
    '        <button'+
    '          type="button"'+
    '          :class="[\'vue-time-panel__btn\',btnDisabled ? \'disabled\': \'confirm\']"'+
    '          @click="handleConfirm()"'+
    '          :disabled="btnDisabled">{{ $t(\'vue.datepicker.confirm\') }}</button>'+
    '      </div>'+
    '      </div>'+
    '    </div>'+
    '  </transition>',
    components: {
      TimeSpinner: TimeSpinner
    },
  
    computed: {
      showSeconds: function () {
        return (this.format || '').indexOf('ss') !== -1;
      },
      offset: function () {
        return this.showSeconds ? 11 : 8;
      },
      spinner: function () {
        return this.selectionRange[0] < this.offset ? this.$refs.minSpinner : this.$refs.maxSpinner;
      },
      btnDisabled: function () {
        return this.minDate.getTime() > this.maxDate.getTime();
      },
      amPmMode: function () {
        if ((this.format || '').indexOf('A') !== -1) return 'A';
        if ((this.format || '').indexOf('a') !== -1) return 'a';
        return '';
      }
    },
    data: function () {
      return {
        popperClass: '',
        minDate: new Date(),
        maxDate: new Date(),
        value: [],
        oldValue: [new Date(), new Date()],
        defaultValue: null,
        format: 'HH:mm:ss',
        visible: false,
        selectionRange: [0, 2],
        arrowControl: false,
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
      };
    },
    watch: {
      value: function (_value) {
        if (Array.isArray(_value)) {
          this.minDate = new Date(_value[0]);
          this.maxDate = new Date(_value[1]);
        } else {
          if (Array.isArray(this.defaultValue)) {
            this.minDate = new Date(this.defaultValue[0]);
            this.maxDate = new Date(this.defaultValue[1]);
          } else if (this.defaultValue) {
            this.minDate = new Date(this.defaultValue);
            this.maxDate = advanceTime(new Date(this.defaultValue), 60 * 60 * 1000);
          } else {
            this.minDate = new Date();
            this.maxDate = advanceTime(new Date(), 60 * 60 * 1000);
          }
        }
      },
      visible: function (val) {
        var self = this;
  
        if (val) {
          this.oldValue = this.value;
          this.$nextTick(function () {
            return self.$refs.minSpinner.emitSelectRange('hours');
          });
        }
      }
    },
    methods: {
      handleClear: function () {
        this.$emit('pick', null);
      },
      handleCancel: function () {
        this.$emit('pick', this.oldValue);
      },
      handleMinChange: function (date) {
        this.minDate = clearMilliseconds(date);
        this.handleChange();
      },
      handleMaxChange: function (date) {
        this.maxDate = clearMilliseconds(date);
        this.handleChange();
      },
      handleChange: function () {
        if (this.isValidValue([this.minDate, this.maxDate])) {
          this.$refs.minSpinner.selectableRange = [[minTimeOfDay(this.minDate), this.maxDate]];
          this.$refs.maxSpinner.selectableRange = [[this.minDate, maxTimeOfDay(this.maxDate)]];
          this.$emit('pick', [this.minDate, this.maxDate], true);
        }
      },
      setMinSelectionRange: function (start, end) {
        this.$emit('select-range', start, end, 'min');
        this.selectionRange = [start, end];
      },
      setMaxSelectionRange: function (start, end) {
        this.$emit('select-range', start, end, 'max');
        this.selectionRange = [start + this.offset, end + this.offset];
      },
      handleConfirm: function () {
        var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var minSelectableRange = this.$refs.minSpinner.selectableRange;
        var maxSelectableRange = this.$refs.maxSpinner.selectableRange;
        this.minDate = limitTimeRange(this.minDate, minSelectableRange, this.format);
        this.maxDate = limitTimeRange(this.maxDate, maxSelectableRange, this.format);
        this.$emit('pick', [this.minDate, this.maxDate], visible);
      },
      adjustSpinners: function () {
        this.$refs.minSpinner.adjustSpinners();
        this.$refs.maxSpinner.adjustSpinners();
      },
      changeSelectionRange: function (step) {
        var list = this.showSeconds ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
        var mapping = ['hours', 'minutes'].concat(this.showSeconds ? ['seconds'] : []);
        var index = list.indexOf(this.selectionRange[0]);
        var next = (index + step + list.length) % list.length;
        var half = list.length / 2;
  
        if (next < half) {
          this.$refs.minSpinner.emitSelectRange(mapping[next]);
        } else {
          this.$refs.maxSpinner.emitSelectRange(mapping[next - half]);
        }
      },
      isValidValue: function (date) {
        return Array.isArray(date) && timeWithinRange(this.minDate, this.$refs.minSpinner.selectableRange) && timeWithinRange(this.maxDate, this.$refs.maxSpinner.selectableRange);
      },
      handleKeydown: function (event) {
        var keyCode = event.keyCode;
        var mapping = {
          38: -1,
          40: 1,
          37: -1,
          39: 1
        }; // Left or Right
  
        if (keyCode === 37 || keyCode === 39) {
          var step = mapping[keyCode];
          this.changeSelectionRange(step);
          event.preventDefault();
          return;
        } // Up or Down
  
  
        if (keyCode === 38 || keyCode === 40) {
          var _step = mapping[keyCode];
          this.spinner.scrollDown(_step);
          event.preventDefault();
          return;
        }
      }
    }
  };
  var VueTimePicker = {
    mixins: [VuePicker],
    name: 'VueTimePicker',
    props: {
      isRange: Boolean,
      arrowControl: Boolean
    },
    data: function () {
      return {
        type: ''
      };
    },
    watch: {
      isRange: function (_isRange) {
        if (this.picker) {
          this.unmountPicker();
          this.type = _isRange ? 'timerange' : 'time';
          this.panel = _isRange ? TimeRangePanel : TimePanel;
          this.mountPicker();
        } else {
          this.type = _isRange ? 'timerange' : 'time';
          this.panel = _isRange ? TimeRangePanel : TimePanel;
        }
      }
    },
    created: function () {
      this.type = this.isRange ? 'timerange' : 'time';
      this.panel = this.isRange ? TimeRangePanel : TimePanel;
    }
  };
  Vue.component(VueTimePicker.name, VueTimePicker);
  return TimePanel;
});

(function(context, definition) {
  'use strict';
  
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePicker', 'VueUtil', 'VueTimePicker'], definition);
  } else {
    context.VueDatePicker = definition(context.Vue, context.VuePicker, context.VueUtil, context.VueTimePicker);
    delete context.VueTimePicker;
  }
})(this, function(Vue, VuePicker, VueUtil, VueTimePicker) {
  'use strict';

  var _util = VueUtil,
  getFirstDayOfMonth = _util.getFirstDayOfMonth,
  getDayCountOfMonth = _util.getDayCountOfMonth,
  getWeekNumber = _util.getWeekNumber,
  getStartDateOfMonth = _util.getStartDateOfMonth,
  prevDate = _util.prevDate,
  nextDate = _util.nextDate,
  isDate = _util.isDate,
  clearTime = _util.clearTime,
  arrayFindIndex = _util.arrayFindIndex,
  arrayFind = _util.arrayFind,
  coerceTruthyValueToArray = _util.coerceTruthyValueToArray,
  getDayCountOfYear = _util.getDayCountOfYear,
  range = _util.range,
  hasClass = _util.hasClass,
  formatDate = _util.formatDate,
  parseDate = _util.parseDate,
  modifyDate = _util.modifyDate,
  modifyTime = _util.modifyTime,
  modifyWithTimeString = _util.modifyWithTimeString,
  clearMilliseconds = _util.clearMilliseconds,
  prevYear = _util.prevYear,
  nextYear = _util.nextYear,
  prevMonth = _util.prevMonth,
  nextMonth = _util.nextMonth,
  changeYearMonthAndClampDate = _util.changeYearMonthAndClampDate,
  extractDateFormat = _util.extractDateFormat,
  extractTimeFormat = _util.extractTimeFormat,
  timeWithinRange = _util.timeWithinRange;
    
  var datesInYear = function (year) {
    var numOfDays = getDayCountOfYear(year);
    var firstDay = new Date(year, 0, 1);
    return range(numOfDays).map(function (n) {
      return nextDate(firstDay, n);
    });
  };
  var datesInMonth = function (year, month) {
    var numOfDays = getDayCountOfMonth(year, month);
    var firstDay = new Date(year, month, 1);
    return range(numOfDays).map(function (n) {
      return nextDate(firstDay, n);
    });
  };

  var clearDate = function (date) {
    return new Date(date.getFullYear(), date.getMonth());
  };

  var getMonthTimestamp = function (time) {
    if (typeof time === 'number' || typeof time === 'string') {
      return clearDate(new Date(time)).getTime();
    } else if (time instanceof Date) {
      return clearDate(time).getTime();
    } else {
      return NaN;
    }
  };
  var WEEKS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  var getDateTimestamp = function (time) {
    if (typeof time === 'number' || typeof time === 'string') {
      return clearTime(new Date(time)).getTime();
    } else if (time instanceof Date) {
      return clearTime(time).getTime();
    } else {
      return NaN;
    }
  };
  var removeFromArray = function (arr, pred) {
    var idx = typeof pred === 'function' ? arrayFindIndex(arr, pred) : arr.indexOf(pred);
    return idx >= 0 ? [].concat(arr.slice(0, idx), arr.slice(idx + 1)) : arr;
  };

  var calcDefaultValue = function (defaultValue) {
    if (Array.isArray(defaultValue)) {
      return [new Date(defaultValue[0]), new Date(defaultValue[1])];
    } else if (defaultValue) {
      return [new Date(defaultValue), nextDate(new Date(defaultValue), 1)];
    } else {
      return [new Date(), nextDate(new Date(), 1)];
    }
  };
  var YearTable = {
    template: 
    '  <table @click="handleYearTableClick" class="vue-year-table">'+
    '    <tbody>'+
    '    <tr>'+
    '      <td class="available" :class="getCellStyle(startYear + 0)">'+
    '        <a class="cell">{{ startYear }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 1)">'+
    '        <a class="cell">{{ startYear + 1 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 2)">'+
    '        <a class="cell">{{ startYear + 2 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 3)">'+
    '        <a class="cell">{{ startYear + 3 }}</a>'+
    '      </td>'+
    '    </tr>'+
    '    <tr>'+
    '      <td class="available" :class="getCellStyle(startYear + 4)">'+
    '        <a class="cell">{{ startYear + 4 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 5)">'+
    '        <a class="cell">{{ startYear + 5 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 6)">'+
    '        <a class="cell">{{ startYear + 6 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 7)">'+
    '        <a class="cell">{{ startYear + 7 }}</a>'+
    '      </td>'+
    '    </tr>'+
    '    <tr>'+
    '      <td class="available" :class="getCellStyle(startYear + 8)">'+
    '        <a class="cell">{{ startYear + 8 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 9)">'+
    '        <a class="cell">{{ startYear + 9 }}</a>'+
    '      </td>'+
    '      <td></td>'+
    '      <td></td>'+
    '    </tr>'+
    '    </tbody>'+
    '  </table>',
    props: {
      disabledDate: {},
      value: {},
      defaultValue:  {
        validator: function(val) {
          return val === null || (val instanceof Date && isDate(val));
        }
      },
      date: {
        default: function() {
          return new Date();
        }
      }
    },
    computed: {
      startYear: function() {
        return Math.floor(this.date.getFullYear() / 10) * 10;
      }
    },
    methods: {
      getCellStyle: function (year) {
        var style = {};
        var today = new Date();
        style.disabled = typeof this.disabledDate === 'function' ? datesInYear(year).every(this.disabledDate) : false;
        style.current = arrayFindIndex(coerceTruthyValueToArray(this.value), function (date) {
          return date.getFullYear() === year;
        }) >= 0;
        style.today = today.getFullYear() === year;
        style.default = this.defaultValue && this.defaultValue.getFullYear() === year;
        return style;
      },
      handleYearTableClick: function (event) {
        var target = event.target;
  
        if (target.tagName === 'A') {
          if (hasClass(target.parentNode, 'disabled')) return;
          var year = target.textContent || target.innerText;
          this.$emit('pick', Number(year));
        }
      }
    }
  };
  var MonthTable = {
    template: 
    '  <table @click="handleMonthTableClick" @mousemove="handleMouseMove" class="vue-month-table">'+
    '    <tbody>'+
    '    <tr v-for="(row, key) in rows" :key="key">'+
    '      <td :class="getCellStyle(cell)" v-for="(cell, key) in row" :key="key">'+
    '        <div>'+
    '          <a class="cell">{{ $t(\'vue.datepicker.months.\' + months[cell.text]) }}</a>'+
    '        </div>'+
    '      </td>'+
    '    </tr>'+
    '    </tbody>'+
    '  </table>',
    props: {
      disabledDate: {},
      value: {},
      selectionMode: {
        default: 'month'
      },
      minDate: {},
      maxDate: {},
      defaultValue: {
        validator: function (val) {
          return val === null || isDate(val) || Array.isArray(val) && val.every(isDate);
        }
      },
      date: {
        default: function() {
          return new Date();
        }
      },
      rangeState: {
        default: function () {
          return {
            endDate: null,
            selecting: false
          };
        }
      }
    },
    watch: {
      'rangeState.endDate': function (newVal) {
        this.markRange(this.minDate, newVal);
      },
      minDate: function (newVal, oldVal) {
        if (getMonthTimestamp(newVal) !== getMonthTimestamp(oldVal)) {
          this.markRange(this.minDate, this.maxDate);
        }
      },
      maxDate: function (newVal, oldVal) {
        if (getMonthTimestamp(newVal) !== getMonthTimestamp(oldVal)) {
          this.markRange(this.minDate, this.maxDate);
        }
      }
    },
    data: function () {
      return {
        months: ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'],
        tableRows: [[], [], []],
        lastRow: null,
        lastColumn: null
      };
    },
    methods: {
      cellMatchesDate: function (cell, date) {
        var value = new Date(date);
        return this.date.getFullYear() === value.getFullYear() && Number(cell.text) === value.getMonth();
      },
      getCellStyle: function (cell) {
        var self = this;
  
        var style = {};
        var year = this.date.getFullYear();
        var today = new Date();
        var month = cell.text;
        var defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];
        style.disabled = typeof this.disabledDate === 'function' ? datesInMonth(year, month).every(this.disabledDate) : false;
        style.current = arrayFindIndex(coerceTruthyValueToArray(this.value), function (date) {
          return date.getFullYear() === year && date.getMonth() === month;
        }) >= 0;
        style.today = today.getFullYear() === year && today.getMonth() === month;
        style.default = defaultValue.some(function (date) {
          return self.cellMatchesDate(cell, date);
        });
  
        if (cell.inRange) {
          style['in-range'] = true;
  
          if (cell.start) {
            style['start-date'] = true;
          }
  
          if (cell.end) {
            style['end-date'] = true;
          }
        }
  
        return style;
      },
      getMonthOfCell: function (month) {
        var year = this.date.getFullYear();
        return new Date(year, month, 1);
      },
      markRange: function (minDate, maxDate) {
        minDate = getMonthTimestamp(minDate);
        maxDate = getMonthTimestamp(maxDate) || minDate;
        var _ref = [Math.min(minDate, maxDate), Math.max(minDate, maxDate)];
        minDate = _ref[0];
        maxDate = _ref[1];
        var rows = this.rows;
  
        for (var i = 0, k = rows.length; i < k; i++) {
          var row = rows[i];
  
          for (var j = 0, l = row.length; j < l; j++) {
            var cell = row[j];
            var index = i * 4 + j;
            var time = new Date(this.date.getFullYear(), index).getTime();
            cell.inRange = minDate && time >= minDate && time <= maxDate;
            cell.start = minDate && time === minDate;
            cell.end = maxDate && time === maxDate;
          }
        }
      },
      handleMouseMove: function (event) {
        if (!this.rangeState.selecting) return;
        var target = event.target;
  
        if (target.tagName === 'A') {
          target = target.parentNode.parentNode;
        }
  
        if (target.tagName === 'DIV') {
          target = target.parentNode;
        }
  
        if (target.tagName !== 'TD') return;
        var row = target.parentNode.rowIndex;
        var column = target.cellIndex; // can not select disabled date
  
        if (this.rows[row][column].disabled) return; // only update rangeState when mouse moves to a new cell
        // this avoids frequent Date object creation and improves performance
  
        if (row !== this.lastRow || column !== this.lastColumn) {
          this.lastRow = row;
          this.lastColumn = column;
          this.$emit('changerange', {
            minDate: this.minDate,
            maxDate: this.maxDate,
            rangeState: {
              selecting: true,
              endDate: this.getMonthOfCell(row * 4 + column)
            }
          });
        }
      },
      handleMonthTableClick: function (event) {
        var target = event.target;
  
        if (target.tagName === 'A') {
          target = target.parentNode.parentNode;
        }
  
        if (target.tagName === 'DIV') {
          target = target.parentNode;
        }
  
        if (target.tagName !== 'TD') return;
        if (hasClass(target, 'disabled')) return;
        var column = target.cellIndex;
        var row = target.parentNode.rowIndex;
        var month = row * 4 + column;
        var newDate = this.getMonthOfCell(month);
  
        if (this.selectionMode === 'range') {
          if (!this.rangeState.selecting) {
            this.$emit('pick', {
              minDate: newDate,
              maxDate: null
            });
            this.rangeState.selecting = true;
          } else {
            if (newDate >= this.minDate) {
              this.$emit('pick', {
                minDate: this.minDate,
                maxDate: newDate
              });
            } else {
              this.$emit('pick', {
                minDate: newDate,
                maxDate: this.minDate
              });
            }
  
            this.rangeState.selecting = false;
          }
        } else {
          this.$emit('pick', month);
        }
      }
    },
    computed: {
      rows: function () {
        var self = this;
  
        var rows = this.tableRows;
        var disabledDate = this.disabledDate;
        var selectedDate = [];
        var now = getMonthTimestamp(new Date());
  
        for (var i = 0; i < 3; i++) {
          var row = rows[i];
  
          var _loop = function _loop(j) {
            var cell = row[j];
  
            if (!cell) {
              cell = {
                row: i,
                column: j,
                type: 'normal',
                inRange: false,
                start: false,
                end: false
              };
            }
  
            cell.type = 'normal';
            var index = i * 4 + j;
            var time = new Date(self.date.getFullYear(), index).getTime();
            cell.inRange = time >= getMonthTimestamp(self.minDate) && time <= getMonthTimestamp(self.maxDate);
            cell.start = self.minDate && time === getMonthTimestamp(self.minDate);
            cell.end = self.maxDate && time === getMonthTimestamp(self.maxDate);
            var isToday = time === now;
  
            if (isToday) {
              cell.type = 'today';
            }
  
            cell.text = index;
            var cellDate = new Date(time);
            cell.disabled = typeof disabledDate === 'function' && disabledDate(cellDate);
            cell.selected = arrayFind(selectedDate, function (date) {
              return date.getTime() === cellDate.getTime();
            });
  
            self.$set(row, j, cell);
          };
  
          for (var j = 0; j < 4; j++) {
            _loop(j);
          }
        }
  
        return rows;
      }
    }
  };
  var DateTable = {
    template: 
    '  <table'+
    '    cellspacing="0"'+
    '    cellpadding="0"'+
    '    class="vue-date-table"'+
    '    @click="handleClick"'+
    '    @mousemove="handleMouseMove"'+
    '    :class="{ \'is-week-mode\': selectionMode === \'week\' }">'+
    '    <tbody>'+
    '    <tr>'+
    '      <th v-if="showWeekNumber">{{ $t(\'vue.datepicker.week\') }}</th>'+
    '      <th v-for="(week, key) in WEEKS" :key="key">{{ $t(\'vue.datepicker.weeks.\' + week) }}</th>'+
    '    </tr>'+
    '    <tr'+
    '      class="vue-date-table__row"'+
    '      v-for="(row, key) in rows"'+
    '      :class="{ current: isWeekActive(row[1]) }"'+
    '      :key="key">'+
    '      <td'+
    '        v-for="(cell, key) in row"'+
    '        :class="getCellClasses(cell)"'+
    '        :key="key">'+
    '        <div>'+
    '          <span>'+
    '            {{ cell.text }}'+
    '          </span>'+
    '        </div>'+
    '      </td>'+
    '    </tr>'+
    '    </tbody>'+
    '  </table>',
    props: {
      firstDayOfWeek: {
        default: 7,
        type: Number,
        validator: function (val) {
          return val >= 1 && val <= 7;
        }
      },
      events: Array,
      dateClass: Array,
      value: {},
      defaultValue: {
        validator: function (val) {
          // either: null, valid Date object, Array of valid Date objects
          return val === null || isDate(val) || Array.isArray(val) && val.every(isDate);
        }
      },
      date: {},
      selectionMode: {
        default: 'day'
      },
      showWeekNumber: {
        type: Boolean,
        default: false
      },
      disabledDate: {},
      minDate: {},
      maxDate: {},
      rangeState: {
        default: function _default() {
          return {
            endDate: null,
            selecting: false
          };
        }
      }
    },
    computed: {
      offsetDay: function () {
        var week = this.firstDayOfWeek; // 周日为界限，左右偏移的天数，3217654 例如周一就是 -1，目的是调整前两行日期的位置
    
        return week > 3 ? 7 - week : -week;
      },
      WEEKS: function (_WEEKS) {
        function WEEKS() {
          return _WEEKS.apply(this, arguments);
        }
    
        WEEKS.toString = function () {
          return _WEEKS.toString();
        };
    
        return WEEKS;
      }(function () {
        var week = this.firstDayOfWeek;
        return WEEKS.concat(WEEKS).slice(week, week + 7);
      }),
      year: function () {
        return this.date.getFullYear();
      },
      month: function () {
        return this.date.getMonth();
      },
      startDate: function () {
        return getStartDateOfMonth(this.year, this.month);
      },
      rows: function () {
        var self = this;
    
        // TODO: refactory rows / getCellClasses
        var date = new Date(this.year, this.month, 1);
        var day = getFirstDayOfMonth(date); // day of first day
    
        var dateCountOfMonth = getDayCountOfMonth(date.getFullYear(), date.getMonth());
        var dateCountOfLastMonth = getDayCountOfMonth(date.getFullYear(), date.getMonth() === 0 ? 11 : date.getMonth() - 1);
        day = day === 0 ? 7 : day;
        var offset = this.offsetDay;
        var rows = this.tableRows;
        var count = 1;
        var startDate = this.startDate;
        var disabledDate = this.disabledDate;
        var selectedDate = this.selectionMode === 'dates' ? coerceTruthyValueToArray(this.value) : [];
        var now = getDateTimestamp(new Date());
    
        for (var i = 0; i < 6; i++) {
          var row = rows[i];
    
          if (this.showWeekNumber) {
            if (!row[0]) {
              row[0] = {
                type: 'week',
                text: getWeekNumber(nextDate(startDate, i * 7 + 1))
              };
            }
          }
    
          var _loop = function _loop(j) {
            var cell = row[self.showWeekNumber ? j + 1 : j];
    
            if (!cell) {
              cell = {
                row: i,
                column: j,
                type: 'normal',
                inRange: false,
                start: false,
                end: false
              };
            }
    
            cell.type = 'normal';
            var index = i * 7 + j;
            var time = nextDate(startDate, index - offset).getTime();
            cell.inRange = time >= getDateTimestamp(self.minDate) && time <= getDateTimestamp(self.maxDate);
            cell.start = self.minDate && time === getDateTimestamp(self.minDate);
            cell.end = self.maxDate && time === getDateTimestamp(self.maxDate);
            var isToday = time === now;
    
            if (isToday) {
              cell.type = 'today';
            }
    
            if (i >= 0 && i <= 1) {
              var numberOfDaysFromPreviousMonth = day + offset < 0 ? 7 + day + offset : day + offset;
    
              if (j + i * 7 >= numberOfDaysFromPreviousMonth) {
                cell.text = count++;
              } else {
                cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - j % 7) + 1 + i * 7;
                cell.type = 'prev-month';
              }
            } else {
              if (count <= dateCountOfMonth) {
                cell.text = count++;
              } else {
                cell.text = count++ - dateCountOfMonth;
                cell.type = 'next-month';
              }
            }
    
            var cellDate = new Date(time);
            cell.disabled = typeof disabledDate === 'function' && disabledDate(cellDate);
            cell.selected = arrayFind(selectedDate, function (date) {
              return VueUtil.formatDate(date, 'yyyyMMdd') === VueUtil.formatDate(cellDate, 'yyyyMMdd');
            });
    
            cell.event = false;
            cell.dateClass = '';

            if (cell.type === 'today' || cell.type === 'normal') {
              if (self.events && self.events.length > 0) {
                VueUtil.loop(self.events, function(event) {
                  var st = VueUtil.parseDate(event.start).getTime();
                  var ed = VueUtil.parseDate(event.end ? event.end : st).getTime();
                  if (time >= st && time <= ed) {
                    cell.event = true;
                  }
                });
              }
            }

            if (self.dateClass && self.dateClass.length > 0) {
              VueUtil.loop(self.dateClass, function(dateClass) {
                var st;
                var ed;
                if(dateClass.date) {
                  st = VueUtil.parseDate(dateClass.date).getTime();
                  ed = st;
                } else {
                  st = VueUtil.parseDate(dateClass.start).getTime();
                  ed = VueUtil.parseDate(dateClass.end ? dateClass.end : st).getTime();
                }

                if (time >= st && time <= ed) {
                  cell.dateClass += (dateClass.customClass + ' ');
                }
              });
            }
            self.$set(row, self.showWeekNumber ? j + 1 : j, cell);
          };
    
          for (var j = 0; j < 7; j++) {
            _loop(j);
          }
    
          if (this.selectionMode === 'week') {
            var start = this.showWeekNumber ? 1 : 0;
            var end = this.showWeekNumber ? 7 : 6;
            var isWeekActive = this.isWeekActive(row[start + 1]);
            row[start].inRange = isWeekActive;
            row[start].start = isWeekActive;
            row[end].inRange = isWeekActive;
            row[end].end = isWeekActive;
          }
        }
        return rows;
      }
    },
    watch: {
      'rangeState.endDate': function (newVal) {
        this.markRange(this.minDate, newVal);
      },

      minDate: function (newVal, oldVal) {
        if (getDateTimestamp(newVal) !== getDateTimestamp(oldVal)) {
          this.markRange(this.minDate, this.maxDate);
        }
      },

      maxDate: function (newVal, oldVal) {
        if (getDateTimestamp(newVal) !== getDateTimestamp(oldVal)) {
          this.markRange(this.minDate, this.maxDate);
        }
      }
    },
    data: function() {
      return {
        tableRows: [ [], [], [], [], [], [] ],
        lastRow: null,
        lastColumn: null,
        lastClick: null,
      };
    },
    methods: {
      cellMatchesDate: function (cell, date) {
        var value = new Date(date);
        return this.year === value.getFullYear() && this.month === value.getMonth() && Number(cell.text) === value.getDate();
      },
      getCellClasses: function (cell) {
        var selectionMode = this.selectionMode;
        var defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];
        var classes = [];

        if ((cell.type === 'normal' || cell.type === 'today') && !cell.disabled) {
          classes.push('available');
    
          if (cell.type === 'today') {
            classes.push('today');
          }
        } else {
          classes.push(cell.type);
        }
    
        var self = this;
    
        if (cell.type === 'normal' && defaultValue.some(function (date) {
          return self.cellMatchesDate(cell, date);
        })) {
          classes.push('default');
        }

        if (selectionMode === 'day' && (cell.type === 'normal' || cell.type === 'today') && this.cellMatchesDate(cell, this.value)) {
          classes.push('current');
        }
    
        if (cell.inRange && (cell.type === 'normal' || cell.type === 'today' || this.selectionMode === 'week')) {
          classes.push('in-range');
    
          if (cell.start) {
            classes.push('start-date');
          }
    
          if (cell.end) {
            classes.push('end-date');
          }
        }
    
        if (cell.disabled) {
          classes.push('disabled');
        }

        if (cell.selected) {
          classes.push('selected');
        }
        if (cell.event) {
          classes.push('event-date');
        }

        if (cell.dateClass) {
          classes.push(cell.dateClass.trim());
        }
        return classes.join(' ');
      },
      getDateOfCell: function (row, column) {
        var offsetFromStart = row * 7 + (column - (this.showWeekNumber ? 1 : 0)) - this.offsetDay;
        return nextDate(this.startDate, offsetFromStart);
      },
      isWeekActive: function (cell) {
        if (this.selectionMode !== 'week') return false;
        var newDate = new Date(this.year, this.month, 1);
        var year = newDate.getFullYear();
        var month = newDate.getMonth();
    
        if (cell.type === 'prev-month') {
          newDate.setMonth(month === 0 ? 11 : month - 1);
          newDate.setFullYear(month === 0 ? year - 1 : year);
        }
    
        if (cell.type === 'next-month') {
          newDate.setMonth(month === 11 ? 0 : month + 1);
          newDate.setFullYear(month === 11 ? year + 1 : year);
        }
    
        newDate.setDate(parseInt(cell.text, 10));
    
        if (isDate(this.value)) {
          var dayOffset = (this.value.getDay() - this.firstDayOfWeek + 7) % 7 - 1;
          var weekDate = prevDate(this.value, dayOffset);
          return weekDate.getTime() === newDate.getTime();
        }
    
        return false;
      },
      markRange: function (minDate, maxDate) {
        minDate = getDateTimestamp(minDate);
        maxDate = getDateTimestamp(maxDate) || minDate;
        var _ref = [Math.min(minDate, maxDate), Math.max(minDate, maxDate)];
        minDate = _ref[0];
        maxDate = _ref[1];
        var startDate = this.startDate;
        var rows = this.rows;
    
        for (var i = 0, k = rows.length; i < k; i++) {
          var row = rows[i];
    
          for (var j = 0, l = row.length; j < l; j++) {
            if (this.showWeekNumber && j === 0) continue;
            var cell = row[j];
            var index = i * 7 + j + (this.showWeekNumber ? -1 : 0);
            var time = nextDate(startDate, index - this.offsetDay).getTime();
            cell.inRange = minDate && time >= minDate && time <= maxDate;
            cell.start = minDate && time === minDate;
            cell.end = maxDate && time === maxDate;
          }
        }
      },
      handleMouseMove: function (event) {
        
        if (!this.rangeState.selecting) return;
        var target = event.target;
    
        if (target.tagName === 'SPAN') {
          target = target.parentNode.parentNode;
        }
    
        if (target.tagName === 'DIV') {
          target = target.parentNode;
        }
    
        if (target.tagName !== 'TD') return;
        var row = target.parentNode.rowIndex - 1;
        var column = target.cellIndex; // can not select disabled date
    
        if (this.rows[row][column].disabled) return; // only update rangeState when mouse moves to a new cell
        // this avoids frequent Date object creation and improves performance
    
        if (row !== this.lastRow || column !== this.lastColumn) {
          this.lastRow = row;
          this.lastColumn = column;
          this.$emit('changerange', {
            minDate: this.minDate,
            maxDate: this.maxDate,
            rangeState: {
              selecting: true,
              endDate: this.getDateOfCell(row, column)
            }
          });
        }
      },
      handleClick: function (event) {
        var target = event.target;
        var self = this;
        if (target.tagName === 'SPAN') {
          target = target.parentNode.parentNode;
        }
    
        if (target.tagName === 'DIV') {
          target = target.parentNode;
        }
    
        if (target.tagName !== 'TD') return;
        var row = target.parentNode.rowIndex - 1;
        var column = this.selectionMode === 'week' ? 1 : target.cellIndex;
        var cell = this.rows[row][column];
        if (cell.disabled || cell.type === 'week') return;
        var newDate = this.getDateOfCell(row, column);
        this.lastClick = {date: newDate, jsEvent: event};
        if (this.selectionMode === 'range') {

          if (!this.rangeState.selecting) {
            this.$emit('pick', {
              minDate: newDate,
              maxDate: null
            });
            this.rangeState.selecting = true;
          } else {
            if (newDate >= this.minDate) {
              this.$emit('pick', {
                minDate: this.minDate,
                maxDate: newDate
              });
            } else {
              this.$emit('pick', {
                minDate: newDate,
                maxDate: this.minDate
              });
            }
            setTimeout(function() {
              self.rangeState.selecting = false;
            }, 100);
           
          }
        } else if (this.selectionMode === 'day') {
          this.$emit('pick', newDate);
        } else if (this.selectionMode === 'week') {
          var weekNumber = getWeekNumber(newDate);
          var value = newDate.getFullYear() + 'w' + weekNumber;
          this.$emit('pick', {
            year: newDate.getFullYear(),
            week: weekNumber,
            value: value,
            date: newDate
          });
        } else if (this.selectionMode === 'dates') {
          var _value = this.value || [];
    
          var newValue = cell.selected ? removeFromArray(_value, function (date) {
            return date.getTime() === newDate.getTime();
          }) : [].concat(_value, [newDate]);
          this.$emit('pick', newValue);
        }
      }
    }
  };

  var DatePanel = {
    template: 
    '  <transition name="vue-zoom-in-top" @after-enter="handleEnter" @after-leave="handleLeave">'+
    '    <div tabindex="-1" style="outline:none;" ref="datePanelDiv"><div class="vue-aside__wrapper" v-if="isMobile"></div>'+
    '    <div'+
    '      v-show="visible"'+
    '      class="vue-picker-panel vue-date-picker vue-popper"'+
    '      :class="[{'+
    '        \'has-sidebar\': $slots.sidebar || shortcuts,'+
    '        \'has-time\': showTime'+
    '      }, popperClass]">'+
    '      <div class="vue-picker-panel__body-wrapper" style="position:relative">'+
    '        <slot name="sidebar" class="vue-picker-panel__sidebar" ></slot>'+
    '        <div class="vue-picker-panel__sidebar"   v-if="shortcuts">'+
    '          <button'+
    '            type="button"'+
    '            class="vue-picker-panel__shortcut"'+
    '            v-for="(shortcut, key) in shortcuts"'+
    '            :key="key"'+
    '            @click="handleShortcutClick(shortcut)">{{ shortcut.text }}</button>'+
    '        </div>'+
    '        <div class="vue-picker-panel__body">'+
    '          <div class="vue-date-picker__time-header" v-if="showTime">'+
    '            <span class="vue-date-picker__editor-wrap">'+
    '              <vue-input'+
    '                :placeholder="$t(\'vue.datepicker.selectDate\')"'+
    '                :value="visibleDate"'+
    '                size="small"'+
    '                @input="function (val) { return userInputDate = val;}"'+
    '                @change="handleVisibleDateChange" />'+
    '            </span>'+
    '            <span class="vue-date-picker__editor-wrap" v-clickoutside="handleTimePickClose" v-scrolling="handleTimePickClose">'+
    '              <vue-input'+
    '                ref="input"'+
    '                @focus="timePickerVisible = true"'+
    '                :placeholder="$t(\'vue.datepicker.selectTime\')"'+
    '                :value="visibleTime"'+
    '                size="small"'+
    '                @input="function (val) { return userInputTime = val;}"'+
    '               :readonly="isMobile"'+
    '                @change="handleVisibleTimeChange" />'+
    '              <time-picker'+
    '                ref="timepicker"'+
    '                :time-arrow-control="arrowControl"'+
    '                @pick="handleTimePick"'+
    '                :visible="timePickerVisible"'+
    '                @mounted="proxyTimePickerDataProperties">'+
    '              </time-picker>'+
    '            </span>'+
    '          </div>'+
    '          <div style="padding:6px;12px;margin:0;"'+
    '            class="vue-date-picker__header"'+
    '            :class="{ \'vue-date-picker__header--bordered\': currentView === \'year\' || currentView === \'month\' }"'+
    '            v-show="currentView !== \'time\'">'+
    '            <button'+
    '              type="button"'+
    '              @click="prevYear"'+
    '              class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-d-arrow-left">'+
    '            </button>'+
    '            <button'+
    '              type="button"'+
    '              @click="prevMonth"'+
    '              v-show="currentView === \'date\'"'+
    '              class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-arrow-left">'+
    '            </button>'+
    '            <span'+
    '              @click="showYearPicker"'+
    '              role="button"'+
    '              class="vue-date-picker__header-label">{{ yearLabel }}</span>'+
    '            <span'+
    '              @click="showMonthPicker"'+
    '              v-show="currentView === \'date\'"'+
    '              role="button"'+
    '              class="vue-date-picker__header-label"'+
    '              :class="{ active: currentView === \'month\' }">{{$t(\'vue.datepicker.month\' + (month + 1))}}</span>'+
    '            <button'+
    '              type="button"'+
    '              @click="nextYear"'+
    '              class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-d-arrow-right">'+
    '            </button>'+
    '            <button'+
    '              type="button"'+
    '              @click="nextMonth"'+
    '              v-show="currentView === \'date\'"'+
    '              class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-arrow-right">'+
    '            </button>'+
    '          </div>'+
    '          <div class="vue-picker-panel__content">'+
    '            <date-table'+
    '              v-show="currentView === \'date\'"'+
    '              @pick="handleDatePick"'+
    '              :selection-mode="selectionMode"'+
    '              :first-day-of-week="firstDayOfWeek"'+
    '              :value="value"'+
    '              :default-value="defaultValue ? new Date(defaultValue) : null"'+
    '              :date="date"'+
    '              :disabled-date="disabledDate">'+
    '            </date-table>'+
    '            <year-table'+
    '              v-show="currentView === \'year\'"'+
    '              @pick="handleYearPick"'+
    '              :value="value"'+
    '              :default-value="defaultValue ? new Date(defaultValue) : null"'+
    '              :date="date"'+
    '              :disabled-date="disabledDate">'+
    '            </year-table>'+
    '            <month-table'+
    '              v-show="currentView === \'month\'"'+
    '              @pick="handleMonthPick"'+
    '              :value="value"'+
    '              :default-value="defaultValue ? new Date(defaultValue) : null"'+
    '              :date="date"'+
    '              :disabled-date="disabledDate">'+
    '            </month-table>'+
    '          </div>'+
    '        </div>'+
    '      </div>'+
    '      <div'+
    '        class="vue-picker-panel__footer"'+
    '        v-show="footerVisible && currentView === \'date\'">'+
    '        <vue-button'+
    '          size="mini"'+
    '          type="text"'+
    '          class="vue-picker-panel__link-btn"'+
    '          @click="changeToNow"'+
    '          v-show="selectionMode !== \'dates\'">'+
    '          {{ $t(\'vue.datepicker.now\') }}'+
    '        </vue-button>'+
    '        <vue-button'+
    '          plain'+
    '          size="mini"'+
    '          class="vue-picker-panel__link-btn"'+
    '          @click="confirm">'+
    '          {{ $t(\'vue.datepicker.confirm\') }}'+
    '        </vue-button>'+
    '      </div>'+
    '    </div>'+
    '</div>'+
    '  </transition>',
    directives: {
      Clickoutside: VueUtil.component.clickoutside(),
      Scrolling: VueUtil.component.scrolling
    },
    watch: {
      date: function(val, oldVal) {
        if(val.getFullYear() !== oldVal.getFullYear() || val.getMonth() !== oldVal.getMonth()) {
          this.$emit('view-month-change', val);
        }
      },
      visible: function (val) {
        var self = this;
        
        if(val){
          this.$nextTick(function () {
            // self.$refs.datePanelDiv.focus();
          });
        }
        
      },
      showTime: function (val) {
        var self = this;
  
        /* istanbul ignore if */
        if (!val) return;
        this.$nextTick(function (_) {
          var inputElm = self.$refs.input.$el;
  
          if (inputElm) {
            self.pickerWidth = inputElm.getBoundingClientRect().width + 10;
          }
        });
      },
      value: function (val) {
        if (this.selectionMode === 'dates' && this.value) return;
  
        if (isDate(val)) {
          this.date = new Date(val);
        } else {
          this.date = this.getDefaultValue();
        }
      },
      defaultValue: function (val) {
        if (!isDate(this.value)) {
          this.date = val ? new Date(val) : new Date();
        }
      },
      timePickerVisible: function (val) {
        var self = this;
  
        if (val) this.$nextTick(function () {
          return self.$refs.timepicker.adjustSpinners();
        });
      },
      selectionMode: function (newVal) {
        if (newVal === 'month') {
          /* istanbul ignore next */
          if (this.currentView !== 'year' || this.currentView !== 'month') {
            this.currentView = 'month';
          }
        } else if (newVal === 'dates') {
          this.currentView = 'date';
        }
      }
    },
    methods: {
      proxyTimePickerDataProperties: function () {
        var self = this;
  
        var format = function (timeFormat) {
          self.$refs.timepicker.format = timeFormat;
        };
  
        var value = function (_value) {
          self.$refs.timepicker.value = _value;
        };
  
        var date = function (_date) {
          self.$refs.timepicker.date = _date;
        };
  
        var selectableRange = function (_selectableRange) {
          self.$refs.timepicker.selectableRange = _selectableRange;
        };
  
        this.$watch('value', value);
        this.$watch('date', date);
        this.$watch('selectableRange', selectableRange);
        format(this.timeFormat);
        value(this.value);
        date(this.date);
        selectableRange(this.selectableRange);
      },
      handleClear: function () {
        this.date = this.getDefaultValue();
        this.$emit('pick', null);
      },
      emit: function (value) {
        var self = this;
  
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
  
        if (!value) {
          this.$emit.apply(this, ['pick', value].concat(args));
        } else if (Array.isArray(value)) {
          var dates = value.map(function (date) {
            return self.showTime ? clearMilliseconds(date) : clearTime(date);
          });
          this.$emit.apply(this, ['pick', dates].concat(args));
        } else {
          this.$emit.apply(this, ['pick', this.showTime ? clearMilliseconds(value) : clearTime(value)].concat(args));
        }
  
        this.userInputDate = null;
        this.userInputTime = null;
      },
      resetDate: function() {
        this.date = new Date(this.date);
      },
      showMonthPicker: function () {
        this.currentView = 'month';
      },
      showYearPicker: function () {
        this.currentView = 'year';
      },
      // XXX: 没用到
      // handleLabelClick() {
      //   if (this.currentView === 'date') {
      //     this.showMonthPicker();
      //   } else if (this.currentView === 'month') {
      //     this.showYearPicker();
      //   }
      // },
      prevMonth: function (_prevMonth) {
        function prevMonth() {
          return _prevMonth.apply(this, arguments);
        }
  
        prevMonth.toString = function () {
          return _prevMonth.toString();
        };
  
        return prevMonth;
      }(function () {
        this.date = prevMonth(this.date);
      }),
      nextMonth: function (_nextMonth) {
        function nextMonth() {
          return _nextMonth.apply(this, arguments);
        }
  
        nextMonth.toString = function () {
          return _nextMonth.toString();
        };
  
        return nextMonth;
      }(function () {
        this.date = nextMonth(this.date);
      }),
      prevYear: function (_prevYear) {
        function prevYear() {
          return _prevYear.apply(this, arguments);
        }
  
        prevYear.toString = function () {
          return _prevYear.toString();
        };
  
        return prevYear;
      }(function () {
        if (this.currentView === 'year') {
          this.date = prevYear(this.date, 10);
        } else {
          this.date = prevYear(this.date);
        }
      }),
      nextYear: function (_nextYear) {
        function nextYear() {
          return _nextYear.apply(this, arguments);
        }
  
        nextYear.toString = function () {
          return _nextYear.toString();
        };
  
        return nextYear;
      }(function () {
        if (this.currentView === 'year') {
          this.date = nextYear(this.date, 10);
        } else {
          this.date = nextYear(this.date);
        }
      }),
      handleShortcutClick: function (shortcut) {
        if (shortcut.onClick) {
          shortcut.onClick(this);
        }
      },
      handleTimePick: function (value, visible, first) {
        if (isDate(value)) {
          var newDate = this.value ? modifyTime(this.value, value.getHours(), value.getMinutes(), value.getSeconds()) : modifyWithTimeString(this.getDefaultValue(), this.defaultTime);
          this.date = newDate;
          this.emit(this.date, true);
        } else {
          this.emit(value, true);
        }
  
        if (!first) {
          this.timePickerVisible = visible;
        }
      },
      handleTimePickClose: function () {
        this.timePickerVisible = false;
      },
      handleMonthPick: function (month) {
        if (this.selectionMode === 'month') {
          this.date = modifyDate(this.date, this.year, month, 1);
          this.emit(this.date);
        } else {
          this.date = changeYearMonthAndClampDate(this.date, this.year, month); // TODO: should emit intermediate value ??
          // this.emit(this.date);
  
          this.currentView = 'date';
        }
      },
      handleDatePick: function (value) {
        if (this.selectionMode === 'day') {
          var newDate = this.value ? modifyDate(this.value, value.getFullYear(), value.getMonth(), value.getDate()) : modifyWithTimeString(value, this.defaultTime); // change default time while out of selectableRange
  
          if (!this.checkDateWithinRange(newDate)) {
            newDate = modifyDate(this.selectableRange[0][0], value.getFullYear(), value.getMonth(), value.getDate());
          }
  
          this.date = newDate;
          this.emit(this.date, this.showTime);
        } else if (this.selectionMode === 'week') {
          this.emit(value.date);
        } else if (this.selectionMode === 'dates') {
          this.emit(value, true); // set false to keep panel open
        }
      },
      handleYearPick: function (year) {
        if (this.selectionMode === 'year') {
          this.date = modifyDate(this.date, year, 0, 1);
          this.emit(this.date);
        } else {
          this.date = changeYearMonthAndClampDate(this.date, year, this.month); // TODO: should emit intermediate value ??
          // this.emit(this.date, true);
  
          this.currentView = 'month';
        }
      },
      changeToNow: function () {
        // NOTE: not a permanent solution
        //       consider disable "now" button in the future
        if ((!this.disabledDate || !this.disabledDate(new Date())) && this.checkDateWithinRange(new Date())) {
          this.date = new Date();
          this.emit(this.date);
        }
      },
      confirm: function () {
        if (this.selectionMode === 'dates') {
          this.emit(this.value);
        } else {
          // value were emitted in handle{Date,Time}Pick, nothing to update here
          // deal with the scenario where: user opens the picker, then confirm without doing anything
          var value = this.value ? this.value : modifyWithTimeString(this.getDefaultValue(), this.defaultTime);
          this.date = new Date(value); // refresh date
  
          this.emit(value);
        }
      },
      resetView: function () {
        if (this.selectionMode === 'month') {
          this.currentView = 'month';
        } else if (this.selectionMode === 'year') {
          this.currentView = 'year';
        } else {
          this.currentView = 'date';
        }
      },
      handleEnter: function () {
        document.body.addEventListener('keydown', this.handleKeydown);
      },
      handleLeave: function () {
        this.$emit('destroyPopper');
        document.body.removeEventListener('keydown', this.handleKeydown);
      },
      handleKeydown: function (event) {
        var keyCode = event.keyCode;
        var list = [38, 40, 37, 39];
  
        if (this.visible && !this.timePickerVisible) {
          if (list.indexOf(keyCode) !== -1) {
            this.handleKeyControl(keyCode);
            event.stopPropagation();
            event.preventDefault();
          }
  
          if (keyCode === 13 && this.userInputDate === null && this.userInputTime === null) {
            // Enter
            this.emit(this.date, false);
          }
        }
      },
      handleKeyControl: function (keyCode) {
        var mapping = {
          'year': {
            38: -4,
            40: 4,
            37: -1,
            39: 1,
            offset: function (date, step) {
              return date.setFullYear(date.getFullYear() + step);
            }
          },
          'month': {
            38: -4,
            40: 4,
            37: -1,
            39: 1,
            offset: function (date, step) {
              return date.setMonth(date.getMonth() + step);
            }
          },
          'week': {
            38: -1,
            40: 1,
            37: -1,
            39: 1,
            offset: function (date, step) {
              return date.setDate(date.getDate() + step * 7);
            }
          },
          'day': {
            38: -7,
            40: 7,
            37: -1,
            39: 1,
            offset: function (date, step) {
              return date.setDate(date.getDate() + step);
            }
          }
        };
        var mode = this.selectionMode;
        var year = 3.1536e10;
        var now = this.date.getTime();
        var newDate = new Date(this.date.getTime());
  
        while (Math.abs(now - newDate.getTime()) <= year) {
          var map = mapping[mode];
          map.offset(newDate, map[keyCode]);
  
          if (typeof this.disabledDate === 'function' && this.disabledDate(newDate)) {
            continue;
          }
  
          this.date = newDate;
          this.$emit('pick', newDate, true);
          break;
        }
      },
      handleVisibleTimeChange: function (value) {
        var time = parseDate(value, this.timeFormat);
  
        if (time && this.checkDateWithinRange(time)) {
          this.date = modifyDate(time, this.year, this.month, this.monthDate);
          this.userInputTime = null;
          this.$refs.timepicker.value = this.date;
          this.timePickerVisible = false;
          this.emit(this.date, true);
        }
      },
      handleVisibleDateChange: function (value) {
        var date = parseDate(value, this.dateFormat);
  
        if (date) {
          if (typeof this.disabledDate === 'function' && this.disabledDate(date)) {
            return;
          }
  
          this.date = modifyTime(date, this.date.getHours(), this.date.getMinutes(), this.date.getSeconds());
          this.userInputDate = null;
          this.resetView();
          this.emit(this.date, true);
        }
      },
      isValidValue: function (value) {
        return value && !isNaN(value) && (typeof this.disabledDate === 'function' ? !this.disabledDate(value) : true) && this.checkDateWithinRange(value);
      },
      getDefaultValue: function () {
        // if default-value is set, return it
        // otherwise, return now (the moment this method gets called)
        return this.defaultValue ? new Date(this.defaultValue) : new Date();
      },
      checkDateWithinRange: function (date) {
        return this.selectableRange.length > 0 ? timeWithinRange(date, this.selectableRange, this.format || 'HH:mm:ss') : true;
      }
    },
    components: {
      TimePicker: VueTimePicker,
      YearTable: YearTable,
      MonthTable: MonthTable,
      DateTable: DateTable
    },
    data: function () {
      return {
        popperClass: '',
        date: new Date(),
        value: null,
        defaultValue: null,
        // use getDefaultValue() for time computation
        defaultTime: null,
        showTime: false,
        selectionMode: 'day',
        shortcuts: '',
        visible: false,
        currentView: 'date',
        disabledDate: '',
        selectableRange: [],
        firstDayOfWeek: 7,
        showWeekNumber: false,
        timePickerVisible: false,
        format: '',
        arrowControl: false,
        userInputDate: null,
        userInputTime: null,
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
      };
    },
    computed: {
      year: function () {
        return this.date.getFullYear();
      },
      month: function () {
        return this.date.getMonth();
      },
      week: function () {
        return getWeekNumber(this.date);
      },
      monthDate: function () {
        return this.date.getDate();
      },
      footerVisible: function () {
        return this.showTime || this.selectionMode === 'dates';
      },
      visibleTime: function () {
        if (this.userInputTime !== null) {
          return this.userInputTime;
        } else {
          return formatDate(this.value || this.defaultValue, this.timeFormat);
        }
      },
      visibleDate: function () {
        if (this.userInputDate !== null) {
          return this.userInputDate;
        } else {
          return formatDate(this.value || this.defaultValue, this.dateFormat);
        }
      },
      yearLabel: function () {
        var yearTranslation = this.$t('vue.datepicker.year');
  
        if (this.currentView === 'year') {
          var startYear = Math.floor(this.year / 10) * 10;
  
          if (yearTranslation) {
            return startYear + ' ' + yearTranslation + ' - ' + (startYear + 9) + ' ' + yearTranslation;
          }
  
          return startYear + ' - ' + (startYear + 9);
        }
  
        return this.year + ' ' + yearTranslation;
      },
      timeFormat: function () {
        if (this.format) {
          return extractTimeFormat(this.format);
        } else {
          return 'HH:mm:ss';
        }
      },
      dateFormat: function () {
        if (this.format) {
          return extractDateFormat(this.format);
        } else {
          return 'yyyy-MM-dd';
        }
      }
    }
  };
  var DateRangePanel = {
    template: 
    '  <transition name="vue-zoom-in-top" @after-leave="$emit(\'destroyPopper\')">'+
    '    <div><div class="vue-aside__wrapper" v-if="isMobile"></div>'+
    '    <div'+
    '      v-show="visible"'+
    '      class="vue-picker-panel vue-date-range-picker vue-popper"'+
    '      :class="[{'+
    '        \'has-sidebar\': $slots.sidebar || shortcuts,'+
    '        \'has-time\': showTime'+
    '      }, popperClass]">'+
    '      <div class="vue-picker-panel__body-wrapper" style="position:relative">'+
    '        <slot name="sidebar" class="vue-picker-panel__sidebar"></slot>'+
    '        <div class="vue-picker-panel__sidebar" v-if="shortcuts">'+
    '          <button'+
    '            type="button"'+
    '            class="vue-picker-panel__shortcut"'+
    '            v-for="(shortcut, key) in shortcuts"'+
    '            :key="key"'+
    '            @click="handleShortcutClick(shortcut)">{{shortcut.text}}</button>'+
    '        </div>'+
    '        <div class="vue-picker-panel__body">'+
    '          <div class="vue-date-range-picker__time-header" v-if="showTime">'+
    '            <span class="vue-date-range-picker__editors-wrap">'+
    '              <span class="vue-date-range-picker__time-picker-wrap">'+
    '                <vue-input'+
    '                  size="small"'+
    '                  :disabled="rangeState.selecting"'+
    '                  ref="minInput"'+
    '                  :placeholder="$t(\'vue.datepicker.startDate\')"'+
    '                  class="vue-date-range-picker__editor"'+
    '                  :readonly="isMobile"'+
    '                  :value="minVisibleDate"'+
    '                  @input="function (val) {return handleDateInput(val, \'min\');}"'+
    '                  @change="function (val) {return handleDateChange(val, \'min\');}" />'+
    '              </span>'+
    '              <span class="vue-date-range-picker__time-picker-wrap" v-clickoutside="handleMinTimeClose" v-scrolling="handleMinTimeClose">'+
    '                <vue-input'+
    '                  size="small"'+
    '                  class="vue-date-range-picker__editor"'+
    '                  :disabled="rangeState.selecting"'+
    '                  :placeholder="$t(\'vue.datepicker.startTime\')"'+
    '                  :value="minVisibleTime"'+
    '                  :readonly="isMobile"'+
    '                  @focus="minTimePickerVisible = true"'+
    '                  @input="function (val) {return handleTimeInput(val, \'min\');}"'+
    '                  @change="function (val) {return handleTimeChange(val, \'min\');}" />'+
    '                <time-picker'+
    '                  ref="minTimePicker"'+
    '                  @pick="handleMinTimePick"'+
    '                  :time-arrow-control="arrowControl"'+
    '                  :visible="minTimePickerVisible"'+
    '                  @mounted="$refs.minTimePicker.format=timeFormat">'+
    '                </time-picker>'+
    '              </span>'+
    '            </span>'+
    
                //移动端时分行显示
    '            <span v-if="!isMobile" class="vue-icon-arrow-right"></span>'+
    '            <span v-if="!isMobile" class="vue-date-range-picker__editors-wrap is-right">'+
    '              <span class="vue-date-range-picker__time-picker-wrap">'+
    '                <vue-input'+
    '                  size="small"'+
    '                  class="vue-date-range-picker__editor"'+
    '                  :disabled="rangeState.selecting"'+
    '                  :placeholder="$t(\'vue.datepicker.endDate\')"'+
    '                  :value="maxVisibleDate"'+
    '                  :readonly="!minDate || isMobile"'+
    '                  @input="function (val) {return handleDateInput(val, \'max\');}"'+
    '                  @change="function (val) {return handleDateChange(val, \'max\');}" />'+
    '              </span>'+
    '              <span class="vue-date-range-picker__time-picker-wrap" v-clickoutside="handleMaxTimeClose" v-scrolling="handleMaxTimeClose">'+
    '                <vue-input'+
    '                  size="small"'+
    '                  class="vue-date-range-picker__editor"'+
    '                  :disabled="rangeState.selecting"'+
    '                  :placeholder="$t(\'vue.datepicker.endTime\')"'+
    '                  :value="maxVisibleTime"'+
    '                  :readonly="!minDate || isMobile"'+
    '                  @focus="minDate && (maxTimePickerVisible = true)"'+
    '                  @input="function (val) {return handleTimeInput(val, \'max\');}"'+
    '                  @change="function (val) {return handleTimeChange(val, \'max\');}" />'+
    '                <time-picker'+
    '                  ref="maxTimePicker"'+
    '                  @pick="handleMaxTimePick"'+
    '                  :time-arrow-control="arrowControl"'+
    '                  :visible="maxTimePickerVisible"'+
    '                  @mounted="$refs.maxTimePicker.format=timeFormat">'+
    '                </time-picker>'+
    '              </span>'+
    '            </span>'+

    '          </div>'+
    '          <div class="vue-picker-panel__content vue-date-range-picker__content is-left">'+
    '            <div class="vue-date-range-picker__header">'+
    '              <button'+
    '                type="button"'+
    '                @click="leftPrevYear"'+
    '                class="vue-picker-panel__icon-btn vue-icon-d-arrow-left"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="leftPrevMonth"'+
    '                class="vue-picker-panel__icon-btn vue-icon-arrow-left"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="leftNextYear"'+
    '                v-if="unlinkPanels"'+
    '                :disabled="!enableYearArrow"'+
    '                :class="{ \'is-disabled\': !enableYearArrow }"'+
    '                class="vue-picker-panel__icon-btn vue-icon-d-arrow-right"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="leftNextMonth"'+
    '                v-if="unlinkPanels"'+
    '                :disabled="!enableMonthArrow"'+
    '                :class="{ \'is-disabled\': !enableMonthArrow }"'+
    '                class="vue-picker-panel__icon-btn vue-icon-arrow-right"></button>'+
    '              <div>{{ leftLabel }}</div>'+
    '            </div>'+
    '            <date-table'+
    '              selection-mode="range"'+
    '              :date="leftDate"'+
    '              :default-value="defaultValue"'+
    '              :min-date="minDate"'+
    '              :max-date="maxDate"'+
    '              :range-state="rangeState"'+
    '              :disabled-date="disabledDate"'+
    '              @changerange="handleChangeRange"'+
    '              :first-day-of-week="firstDayOfWeek"'+
    '              @pick="handleRangePick">'+
    '            </date-table>'+
    '          </div>'+

              //移动端时分行显示
 //   '          <div class="vue-date-range-picker__time-header" style="text-align: center;" v-if="showTime&&isMobile">'+
 //   '            <span class="vue-icon-arrow-right"></span>'+
//  '          </div>'+
    '          <div class="vue-date-range-picker__time-header" v-if="showTime && isMobile">'+
    '            <span  class="vue-date-range-picker__editors-wrap is-right">'+
    '              <span class="vue-date-range-picker__time-picker-wrap">'+
    '                <vue-input'+
    '                  size="small"'+
    '                  class="vue-date-range-picker__editor"'+
    '                  :disabled="rangeState.selecting"'+
    '                  :placeholder="$t(\'vue.datepicker.endDate\')"'+
    '                  :value="maxVisibleDate"'+
    '                  :readonly="!minDate || isMobile"'+
    '                  @input="function (val) {return handleDateInput(val, \'max\');}"'+
    '                  @change="function (val) {return handleDateChange(val, \'max\');}" />'+
    '              </span>'+
    '              <span class="vue-date-range-picker__time-picker-wrap" v-clickoutside="handleMaxTimeClose" v-scrolling="handleMaxTimeClose">>'+
    '                <vue-input'+
    '                  size="small"'+
    '                  class="vue-date-range-picker__editor"'+
    '                  :disabled="rangeState.selecting"'+
    '                  :placeholder="$t(\'vue.datepicker.endTime\')"'+
    '                  :value="maxVisibleTime"'+
    '                  :readonly="!minDate || isMobile"'+
    '                  @focus="minDate && (maxTimePickerVisible = true)"'+
    '                  @input="function (val) {return handleTimeInput(val, \'max\');}"'+
    '                  @change="function (val) {return handleTimeChange(val, \'max\');}" />'+
    '                <time-picker'+
    '                  ref="maxTimePicker"'+
    '                  @pick="handleMaxTimePick"'+
    '                  :time-arrow-control="arrowControl"'+
    '                  :visible="maxTimePickerVisible"'+
    '                  @mounted="$refs.maxTimePicker.format=timeFormat">'+
    '                </time-picker>'+
    '              </span>'+
    '            </span>'+
    '          </div>'+

    '          <div class="vue-picker-panel__content vue-date-range-picker__content is-right">'+
    '            <div class="vue-date-range-picker__header">'+
    '              <button'+
    '                type="button"'+
    '                @click="rightPrevYear"'+
    '                v-if="unlinkPanels"'+
    '                :disabled="!enableYearArrow"'+
    '                :class="{ \'is-disabled\': !enableYearArrow }"'+
    '                class="vue-picker-panel__icon-btn vue-icon-d-arrow-left"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="rightPrevMonth"'+
    '                v-if="unlinkPanels"'+
    '                :disabled="!enableMonthArrow"'+
    '                :class="{ \'is-disabled\': !enableMonthArrow }"'+
    '                class="vue-picker-panel__icon-btn vue-icon-arrow-left"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="rightNextYear"'+
    '                class="vue-picker-panel__icon-btn vue-icon-d-arrow-right"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="rightNextMonth"'+
    '                class="vue-picker-panel__icon-btn vue-icon-arrow-right"></button>'+
    '              <div>{{ rightLabel }}</div>'+
    '            </div>'+
    '            <date-table'+
    '              selection-mode="range"'+
    '              :date="rightDate"'+
    '              :default-value="defaultValue"'+
    '              :min-date="minDate"'+
    '              :max-date="maxDate"'+
    '              :range-state="rangeState"'+
    '              :disabled-date="disabledDate"'+
    '              @changerange="handleChangeRange"'+
    '              :first-day-of-week="firstDayOfWeek"'+
    '              @pick="handleRangePick">'+
    '            </date-table>'+
    '          </div>'+
    '        </div>'+
    '      </div>'+
    '      <div class="vue-picker-panel__footer" v-if="showTime">'+
    '        <vue-button'+
    '          size="mini"'+
    '          type="text"'+
    '          class="vue-picker-panel__link-btn"'+
    '          @click="handleClear">'+
    '          {{ $t(\'vue.datepicker.clear\') }}'+
    '        </vue-button>'+
    '        <vue-button'+
    '          plain'+
    '          size="mini"'+
    '          class="vue-picker-panel__link-btn"'+
    '          :disabled="btnDisabled"'+
    '          @click="handleConfirm(false)">'+
    '          {{ $t(\'vue.datepicker.confirm\') }}'+
    '        </vue-button>'+
    '      </div>'+
    '    </div>'+
    '   </div>'+
    '  </transition>',
    components: {
      TimePicker: VueTimePicker,
      DateTable: DateTable
    },
    directives: {
      Clickoutside: VueUtil.component.clickoutside(),
      Scrolling: VueUtil.component.scrolling
    },
    computed: {
      btnDisabled: function () {
        return !(this.minDate && this.maxDate && !this.selecting && this.isValidValue([this.minDate, this.maxDate]));
      },
      leftLabel: function () {
        return this.leftDate.getFullYear() + ' ' + this.$t('vue.datepicker.year') + ' ' + this.$t('vue.datepicker.month'.concat(this.leftDate.getMonth() + 1));
      },
      rightLabel: function () {
        return this.rightDate.getFullYear() + ' ' + this.$t('vue.datepicker.year') + ' ' + this.$t('vue.datepicker.month'.concat(this.rightDate.getMonth() + 1));
      },
      leftYear: function () {
        return this.leftDate.getFullYear();
      },
      leftMonth: function () {
        return this.leftDate.getMonth();
      },
      leftMonthDate: function () {
        return this.leftDate.getDate();
      },
      rightYear: function () {
        return this.rightDate.getFullYear();
      },
      rightMonth: function () {
        return this.rightDate.getMonth();
      },
      rightMonthDate: function () {
        return this.rightDate.getDate();
      },
      minVisibleDate: function () {
        if (this.dateUserInput.min !== null) return this.dateUserInput.min;
        if (this.minDate) return formatDate(this.minDate, this.dateFormat);
        return '';
      },
      maxVisibleDate: function () {
        if (this.dateUserInput.max !== null) return this.dateUserInput.max;
        if (this.maxDate || this.minDate) return formatDate(this.maxDate || this.minDate, this.dateFormat);
        return '';
      },
      minVisibleTime: function () {
        if (this.timeUserInput.min !== null) return this.timeUserInput.min;
        if (this.minDate) return formatDate(this.minDate, this.timeFormat);
        return '';
      },
      maxVisibleTime: function () {
        if (this.timeUserInput.max !== null) return this.timeUserInput.max;
        if (this.maxDate || this.minDate){
          var tmpDate = this.maxDate ? this.maxDate : new Date(this.minDate);
          if(!this.maxDate && this.minDate)
            tmpDate.setHours(23,59,59);
          return formatDate(tmpDate, this.timeFormat);
        }
        return '';
      },
      timeFormat: function () {
        if (this.format) {
          return extractTimeFormat(this.format);
        } else {
          return 'HH:mm:ss';
        }
      },
      dateFormat: function () {
        if (this.format) {
          return extractDateFormat(this.format);
        } else {
          return 'yyyy-MM-dd';
        }
      },
      enableMonthArrow: function () {
        var nextMonth = (this.leftMonth + 1) % 12;
        var yearOffset = this.leftMonth + 1 >= 12 ? 1 : 0;
        return this.unlinkPanels && new Date(this.leftYear + yearOffset, nextMonth) < new Date(this.rightYear, this.rightMonth);
      },
      enableYearArrow: function () {
        return this.unlinkPanels && this.rightYear * 12 + this.rightMonth - (this.leftYear * 12 + this.leftMonth + 1) >= 12;
      }
    },
    data: function () {
      return {
        popperClass: '',
        value: [],
        defaultValue: null,
        defaultTime: null,
        minDate: '',
        maxDate: '',
        leftDate: new Date(),
        rightDate: nextMonth(new Date()),
        rangeState: {
          endDate: null,
          selecting: false,
          row: null,
          column: null
        },
        showTime: false,
        shortcuts: '',
        visible: '',
        disabledDate: '',
        firstDayOfWeek: 7,
        minTimePickerVisible: false,
        maxTimePickerVisible: false,
        format: '',
        arrowControl: false,
        unlinkPanels: false,
        dateUserInput: {
          min: null,
          max: null
        },
        timeUserInput: {
          min: null,
          max: null
        },
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
      };
    },
    watch: {
      visible: function (val) {
        var self = this;
        if(val){
         
          this.$nextTick(function () {
            if(self.$refs.minInput){
              self.$refs.minInput.focus();
            }
          
          });
        }
        
      },
      minDate: function (val) {
        var self = this;
        this.dateUserInput.min = null;
        this.timeUserInput.min = null;
        this.$nextTick(function () {
          if (self.$refs.maxTimePicker && self.maxDate && self.maxDate < self.minDate) {
            var format = 'HH:mm:ss';
            self.$refs.maxTimePicker.selectableRange = [[parseDate(formatDate(self.minDate, format), format), parseDate('23:59:59', format)]];
          }
        });
  
        if (val && this.$refs.minTimePicker) {
          this.$refs.minTimePicker.date = val;
          this.$refs.minTimePicker.value = val;
        }
      },
      maxDate: function (val) {
        this.dateUserInput.max = null;
        this.timeUserInput.max = null;
  
        if (val && this.$refs.maxTimePicker) {
          this.$refs.maxTimePicker.date = val;
          this.$refs.maxTimePicker.value = val;
        }
      },
      minTimePickerVisible: function (val) {
        var self = this;
         
        if (val) {
          this.$nextTick(function () {
            self.$refs.minTimePicker.date = self.minDate;
            self.$refs.minTimePicker.value = self.minDate;
  
            self.$refs.minTimePicker.adjustSpinners();
          });
        }
      },
      maxTimePickerVisible: function (val) {
        var self = this;
        if (val) {
          this.$nextTick(function () {
            self.$refs.maxTimePicker.date = self.maxDate;
            self.$refs.maxTimePicker.value = self.maxDate;
  
            self.$refs.maxTimePicker.adjustSpinners();
          });
        }
      },
      value: function (newVal) {
        if (!newVal) {
          this.minDate = null;
          this.maxDate = null;
        } else if (Array.isArray(newVal)) {
          this.minDate = isDate(newVal[0]) ? new Date(newVal[0]) : null;
          this.maxDate = isDate(newVal[1]) ? new Date(newVal[1]) : null;
          if (this.minDate) {
            this.leftDate = this.minDate;
  
            var minDateYear;
            var minDateMonth;
            var maxDateYear;
            var maxDateMonth;

            if (this.unlinkPanels && this.maxDate) {
              minDateYear = this.minDate.getFullYear();
              minDateMonth = this.minDate.getMonth();
              maxDateYear = this.maxDate.getFullYear();
              maxDateMonth = this.maxDate.getMonth();
              this.rightDate = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? nextMonth(this.maxDate) : this.maxDate;
            } else {
              this.rightDate = nextMonth(this.leftDate);
            }
          } else if (this.maxDate) {
            this.rightDate = this.maxDate;
  
            if (this.unlinkPanels && this.minDate) {
              minDateYear = this.minDate.getFullYear();
              minDateMonth = this.minDate.getMonth();
              maxDateYear = this.maxDate.getFullYear();
              maxDateMonth = this.maxDate.getMonth();
              this.leftDate = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? prevMonth(this.minDate) : this.minDate;
            } else {
              this.leftDate = prevMonth(this.rightDate);
            }
          } else {
            this.leftDate = calcDefaultValue(this.defaultValue)[0];
            this.rightDate = nextMonth(this.leftDate);
          }
        }
      },

      defaultValue: function (val) {
        if (!Array.isArray(this.value)) {
          var _calcDefaultValue = calcDefaultValue(val),
              left = _calcDefaultValue[0],
              right = _calcDefaultValue[1];
  
          this.leftDate = left;
          this.rightDate = val && val[1] && this.unlinkPanels ? right : nextMonth(this.leftDate);
        }
      }
    },
    methods: {
      handleClear: function () {
        this.minDate = null;
        this.maxDate = null;
        this.leftDate = calcDefaultValue(this.defaultValue)[0];
        this.rightDate = nextMonth(this.leftDate);
        this.$emit('pick', null);
      },
      handleChangeRange: function (val) {
        this.minDate = val.minDate;
        this.maxDate = val.maxDate;
        this.rangeState = val.rangeState;
      },
      handleDateInput: function (value, type) {
        this.dateUserInput[type] = value;
        if (value.length !== this.dateFormat.length) return;
        var parsedValue = parseDate(value, this.dateFormat);
  
        if (parsedValue) {
          if (typeof this.disabledDate === 'function' && this.disabledDate(new Date(parsedValue))) {
            return;
          }
  
          if (type === 'min') {
            this.minDate = modifyDate(this.minDate || new Date(), parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
            this.leftDate = new Date(parsedValue);
  
            if (!this.unlinkPanels) {
              this.rightDate = nextMonth(this.leftDate);
            }
          } else {
            this.maxDate = modifyDate(this.maxDate || new Date(), parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
            this.rightDate = new Date(parsedValue);
  
            if (!this.unlinkPanels) {
              this.leftDate = prevMonth(parsedValue);
            }
          }
        }
      },
      handleDateChange: function (value, type) {
        var parsedValue = parseDate(value, this.dateFormat);
        if (parsedValue) {
          if (type === 'min') {
            this.minDate = modifyDate(this.minDate, parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
  
            if (this.minDate > this.maxDate) {
              this.maxDate = this.minDate;
            }
          } else {
            this.maxDate = modifyDate(this.maxDate, parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
  
            if (this.maxDate < this.minDate) {
              this.minDate = this.maxDate;
            }
          }
        }
      },
      handleTimeInput: function (value, type) {
        var self = this;
        this.timeUserInput[type] = value;
        if (value.length !== this.timeFormat.length) return;
        var parsedValue = parseDate(value, this.timeFormat);
  
        if (parsedValue) {
          if (type === 'min') {
            this.minDate = modifyTime(this.minDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
            this.$nextTick(function (_) {
              return self.$refs.minTimePicker.adjustSpinners();
            });
          } else {
            this.maxDate = modifyTime(this.maxDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
            this.$nextTick(function (_) {
              return self.$refs.maxTimePicker.adjustSpinners();
            });
          }
        }
      },
      handleTimeChange: function (value, type) {
        var parsedValue = parseDate(value, this.timeFormat);
  
        if (parsedValue) {
          if (type === 'min') {
            this.minDate = modifyTime(this.minDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
  
            if (this.minDate > this.maxDate) {
              this.maxDate = this.minDate;
            }
  
            this.$refs.minTimePicker.value = this.minDate;
            this.minTimePickerVisible = false;
          } else {
            this.maxDate = modifyTime(this.maxDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
  
            if (this.maxDate < this.minDate) {
              this.minDate = this.maxDate;
            }
  
            this.$refs.maxTimePicker.value = this.minDate;
            this.maxTimePickerVisible = false;
          }
        }
      },
      handleRangePick: function (val) {
        var self = this;
        var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var defaultTime = this.defaultTime || [];
        var minDate = modifyWithTimeString(val.minDate, defaultTime[0]);
        var maxDate = modifyWithTimeString(val.maxDate, defaultTime[1]);
        if (this.maxDate === maxDate && this.minDate === minDate) {
          return;
        }
  
        this.onPick && this.onPick(val);
  
        if(maxDate){
          maxDate.setHours(23,59,59);
        }
        self.maxDate = maxDate;
        self.minDate = minDate;
        if (!close || this.showTime) return;
        this.handleConfirm();
      },
      handleShortcutClick: function (shortcut) {
        if (shortcut.onClick) {
          shortcut.onClick(this);
        }
      },
      handleMinTimePick: function (value, visible, first) {
        this.minDate = this.minDate || new Date();
  
        if (value) {
          this.minDate = modifyTime(this.minDate, value.getHours(), value.getMinutes(), value.getSeconds());
        }
  
        if (!first) {
          this.minTimePickerVisible = visible;
        }
  
        if (!this.maxDate || this.maxDate && this.maxDate.getTime() < this.minDate.getTime()) {
          this.maxDate = new Date(this.minDate);
        }
      },
      handleMinTimeClose: function () {
        this.minTimePickerVisible = false;
      },
      handleMaxTimePick: function (value, visible, first) {

        if (this.maxDate && value) {
          this.maxDate = modifyTime(this.maxDate, value.getHours(), value.getMinutes(), value.getSeconds());
        }
  
        if (!first) {
          this.maxTimePickerVisible = visible;
        }
  
        if (this.maxDate && this.minDate && this.minDate.getTime() > this.maxDate.getTime()) {
          this.minDate = new Date(this.maxDate);
        }
      },
      handleMaxTimeClose: function () {
        this.maxTimePickerVisible = false;
      },
      // leftPrev*, rightNext* need to take care of `unlinkPanels`
      leftPrevYear: function () {
        this.leftDate = prevYear(this.leftDate);
  
        if (!this.unlinkPanels) {
          this.rightDate = nextMonth(this.leftDate);
        }
      },
      leftPrevMonth: function () {
        this.leftDate = prevMonth(this.leftDate);
  
        if (!this.unlinkPanels) {
          this.rightDate = nextMonth(this.leftDate);
        }
      },
      rightNextYear: function () {
        if (!this.unlinkPanels) {
          this.leftDate = nextYear(this.leftDate);
          this.rightDate = nextMonth(this.leftDate);
        } else {
          this.rightDate = nextYear(this.rightDate);
        }
      },
      rightNextMonth: function () {
        if (!this.unlinkPanels) {
          this.leftDate = nextMonth(this.leftDate);
          this.rightDate = nextMonth(this.leftDate);
        } else {
          this.rightDate = nextMonth(this.rightDate);
        }
      },
      // leftNext*, rightPrev* are called when `unlinkPanels` is true
      leftNextYear: function () {
        this.leftDate = nextYear(this.leftDate);
      },
      leftNextMonth: function () {
        this.leftDate = nextMonth(this.leftDate);
      },
      rightPrevYear: function () {
        this.rightDate = prevYear(this.rightDate);
      },
      rightPrevMonth: function () {
        this.rightDate = prevMonth(this.rightDate);
      },
      handleConfirm: function () {
        var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  
        if (this.isValidValue([this.minDate, this.maxDate])) {
          this.$emit('pick', [this.minDate, this.maxDate], visible);
        }
      },
      isValidValue: function (value) {
        return Array.isArray(value) && value && value[0] && value[1] && isDate(value[0]) && isDate(value[1]) && value[0].getTime() <= value[1].getTime() && (typeof this.disabledDate === 'function' ? !this.disabledDate(value[0]) && !this.disabledDate(value[1]) : true);
      },
      resetView: function () {
        // NOTE: this is a hack to reset {min, max}Date on picker open.
        // TODO: correct way of doing so is to refactor {min, max}Date to be dependent on value and internal selection state
        //       an alternative would be resetView whenever picker becomes visible, should also investigate date-panel's resetView
        this.minDate = this.value && isDate(this.value[0]) ? new Date(this.value[0]) : null;
        this.maxDate = this.value && isDate(this.value[0]) ? new Date(this.value[1]) : null;
      }
    }
  };

  var MonthRangePanel = {
    template: ' <transition name="vue-zoom-in-top" @after-leave="$emit(\'destroyPopper\')"> '
    + '   <div '
    + '     v-show="visible" '
    + '     class="vue-picker-panel vue-date-range-picker vue-popper" '
    + '     :class="[{ '
    + '       \'has-sidebar\': $slots.sidebar || shortcuts '
    + '     }, popperClass]"> '
    + '     <div class="vue-picker-panel__body-wrapper"> ' //style="position:relative"
    + '       <slot name="sidebar" class="vue-picker-panel__sidebar"></slot> ' 
    + '       <div class="vue-picker-panel__sidebar" v-if="shortcuts"> '
    + '         <button '
    + '           type="button" '
    + '           class="vue-picker-panel__shortcut" '
    + '           v-for="(shortcut, key) in shortcuts" '
    + '           :key="key" '
    + '           @click="handleShortcutClick(shortcut)">{{shortcut.text}}</button> '
    + '       </div> '
    + '       <div class="vue-picker-panel__body"> '
    + '         <div class="vue-picker-panel__content vue-date-range-picker__content is-left"> '
    + '           <div class="vue-date-range-picker__header"> '
    + '             <button '
    + '               type="button" '
    + '               @click="leftPrevYear" '
    + '               class="vue-picker-panel__icon-btn vue-icon-d-arrow-left"></button> '
    + '             <button '
    + '               type="button" '
    + '               v-if="unlinkPanels" '
    + '               @click="leftNextYear" '
    + '               :disabled="!enableYearArrow" '
    + '               :class="{ \'is-disabled\': !enableYearArrow }" '
    + '               class="vue-picker-panel__icon-btn vue-icon-d-arrow-right"></button> '
    + '             <div>{{ leftLabel }}</div> '
    + '           </div> '
    + '           <month-table '
    + '             selection-mode="range" '
    + '             :date="leftDate" '
    + '             :default-value="defaultValue" '
    + '             :min-date="minDate" '
    + '             :max-date="maxDate" '
    + '             :range-state="rangeState" '
    + '             :disabled-date="disabledDate" '
    + '             @changerange="handleChangeRange" '
    + '             @pick="handleRangePick"> '
    + '           </month-table> '
    + '         </div> '
    + '         <div class="vue-picker-panel__content vue-date-range-picker__content is-right"> '
    + '           <div class="vue-date-range-picker__header"> '
    + '             <button '
    + '               type="button" '
    + '               v-if="unlinkPanels" '
    + '               @click="rightPrevYear" '
    + '               :disabled="!enableYearArrow" '
    + '               :class="{ \'is-disabled\': !enableYearArrow }" '
    + '               class="vue-picker-panel__icon-btn vue-icon-d-arrow-left"></button> '
    + '             <button '
    + '               type="button" '
    + '               @click="rightNextYear" '
    + '               class="vue-picker-panel__icon-btn vue-icon-d-arrow-right"></button> '
    + '             <div>{{ rightLabel }}</div> '
    + '           </div> '
    + '           <month-table '
    + '             selection-mode="range" '
    + '             :date="rightDate" '
    + '             :default-value="defaultValue" '
    + '             :min-date="minDate" '
    + '             :max-date="maxDate" '
    + '             :range-state="rangeState" '
    + '             :disabled-date="disabledDate" '
    + '             @changerange="handleChangeRange" '
    + '             @pick="handleRangePick"> '
    + '           </month-table> '
    + '         </div> '
    + '       </div> '
    + '     </div> '
    + '   </div> '
    + ' </transition> ',
    components: {
      MonthTable:MonthTable
    },
    directives: {
      Clickoutside: VueUtil.component.clickoutside()
    },
    computed: {
      btnDisabled: function () {
        return !(this.minDate && this.maxDate && !this.selecting && this.isValidValue([this.minDate, this.maxDate]));
      },

      leftLabel: function () {
        return this.leftDate.getFullYear() + ' ' + this.$t('vue.datepicker.year');
      },

      rightLabel: function () {
        return this.rightDate.getFullYear() + ' ' + this.$t('vue.datepicker.year');
      },

      leftYear: function () {
        return this.leftDate.getFullYear();
      },

      rightYear: function () {
        return this.rightDate.getFullYear() === this.leftDate.getFullYear() ? this.leftDate.getFullYear() + 1 : this.rightDate.getFullYear();
      },

      enableYearArrow: function () {
        return this.unlinkPanels && this.rightYear > this.leftYear + 1;
      }
    },
    data: function () {
      return {
        popperClass: '',
        value: [],
        defaultValue: null,
        defaultTime: null,
        minDate: '',
        maxDate: '',
        leftDate: new Date(),
        rightDate: nextYear(new Date()),
        rangeState: {
          endDate: null,
          selecting: false,
          row: null,
          column: null
        },
        shortcuts: '',
        visible: '',
        disabledDate: '',
        format: '',
        arrowControl: false,
        unlinkPanels: false
      };
    },

    watch: {
      value: function(newVal) {
        if (!newVal) {
          this.minDate = null;
          this.maxDate = null;
        } else if (Array.isArray(newVal)) {
          this.minDate = isDate(newVal[0]) ? new Date(newVal[0]) : null;
          this.maxDate = isDate(newVal[1]) ? new Date(newVal[1]) : null;
          if (this.minDate) {
            this.leftDate = this.minDate;
            if (this.unlinkPanels && this.maxDate) {
              var minDateYear = this.minDate.getFullYear();
              var maxDateYear = this.maxDate.getFullYear();
              this.rightDate = minDateYear === maxDateYear
                ? nextYear(this.maxDate)
                : this.maxDate;
            } else {
              this.rightDate = nextYear(this.leftDate);
            }
          } else {
            this.leftDate = calcDefaultValue(this.defaultValue)[0];
            this.rightDate = nextYear(this.leftDate);
          }
        }
      },

      defaultValue: function(val) {
        if (!Array.isArray(this.value)) {
          var defaultVal = calcDefaultValue(val);
          var left= defaultVal[0];
          var right = defaultVal[1];
          this.leftDate = left;
          this.rightDate = val && val[1] && left.getFullYear() !== right.getFullYear() && this.unlinkPanels
            ? right
            : nextYear(this.leftDate);
        }
      }
    },
    methods: {
      handleClear: function () {
        this.minDate = null;
        this.maxDate = null;
        this.leftDate = calcDefaultValue(this.defaultValue)[0];
        this.rightDate = nextYear(this.leftDate);
        this.$emit('pick', null);
      },
      handleChangeRange: function (val) {
        this.minDate = val.minDate;
        this.maxDate = val.maxDate;
        this.rangeState = val.rangeState;
      },
      handleRangePick: function (val) {
        var self = this;
  
        var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var defaultTime = this.defaultTime || [];
        var minDate = modifyWithTimeString(val.minDate, defaultTime[0]);
        var maxDate = modifyWithTimeString(val.maxDate, defaultTime[1]);
  
        if (this.maxDate === maxDate && this.minDate === minDate) {
          return;
        }
  
        this.onPick && this.onPick(val);
        this.maxDate = maxDate;
        this.minDate = minDate;
  
        setTimeout(function () {
          self.maxDate = maxDate;
          self.minDate = minDate;
        }, 10);
        if (!close) return;
        this.handleConfirm();
      },
      handleShortcutClick: function (shortcut) {
        if (shortcut.onClick) {
          shortcut.onClick(this);
        }
      },
      // leftPrev*, rightNext* need to take care of `unlinkPanels`
      leftPrevYear: function leftPrevYear() {
        this.leftDate = prevYear(this.leftDate);
  
        if (!this.unlinkPanels) {
          this.rightDate = prevYear(this.rightDate);
        }
      },
      rightNextYear: function () {
        if (!this.unlinkPanels) {
          this.leftDate = nextYear(this.leftDate);
        }
  
        this.rightDate = nextYear(this.rightDate);
      },
      // leftNext*, rightPrev* are called when `unlinkPanels` is true
      leftNextYear: function () {
        this.leftDate = nextYear(this.leftDate);
      },
      rightPrevYear: function () {
        this.rightDate = prevYear(this.rightDate);
      },
      handleConfirm: function () {
        var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  
        if (this.isValidValue([this.minDate, this.maxDate])) {
          this.$emit('pick', [this.minDate, this.maxDate], visible);
        }
      },
      isValidValue: function (value) {
        return Array.isArray(value) && value && value[0] && value[1] && isDate(value[0]) && isDate(value[1]) && value[0].getTime() <= value[1].getTime() && (typeof this.disabledDate === 'function' ? !this.disabledDate(value[0]) && !this.disabledDate(value[1]) : true);
      },
      resetView: function () {
        // NOTE: this is a hack to reset {min, max}Date on picker open.
        // TODO: correct way of doing so is to refactor {min, max}Date to be dependent on value and internal selection state
        //       an alternative would be resetView whenever picker becomes visible, should also investigate date-panel's resetView
        this.minDate = this.value && isDate(this.value[0]) ? new Date(this.value[0]) : null;
        this.maxDate = this.value && isDate(this.value[0]) ? new Date(this.value[1]) : null;
      }
    },
  };

  var getPanel = function (type) {
    
    if (type === 'daterange' || type === 'datetimerange') {
      return DateRangePanel;
    } else if (type === 'monthrange') {
      return MonthRangePanel;
    }
  
    return DatePanel;
  };
  var VueDatePicker = {
    mixins: [VuePicker],
    name: 'VueDatePicker',
    props: {
      type: {
        type: String,
        default: 'date'
      },
      timeArrowControl: Boolean,
      appendToSelf: Boolean
    },
    watch: {
      type: function (_type) {
        if (this.picker) {
          this.unmountPicker();
          this.panel = getPanel(_type);
          this.mountPicker();
        } else {
          this.panel = getPanel(_type);
        }
      }
    },
    created: function () {
      this.panel = getPanel(this.type);
    },
    mounted: function () {
      this.appendToSelf && (this.append = this.$el);
    }
  };
  Vue.component(VueDatePicker.name, VueDatePicker);
  return function() {
    return {
      DatePanel: DatePanel,
      YearTable: YearTable,
      MonthTable: MonthTable
    };
  };
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VuePopup'], definition);
  } else {
    context.VueMessageBox = definition(context.Vue, context.VueUtil, context.VuePopup);
    delete context.VueMessageBox;
  }
})(this, function(Vue, VueUtil, VuePopup) {
  'use strict';
  var VueMessageBox = {
    template: '<div><div class="vue-message-box__wrapper" v-show="visible"></div><transition name="msgbox-fade" @after-leave="doDestroy"><div :class="[\'vue-message-box\', customClass]" v-show="visible"><div class="vue-message-box__header" v-if="title !== null"><div class="vue-message-box__title">{{title || $t(\'vue.messagebox.title\')}}</div></div><div class="vue-message-box__content" v-if="message !== \'\'"><div :class="[\'vue-message-box__status\', typeClass]"></div><div class="vue-message-box__message" :style="{\'margin-left\': typeClass ? \'50px\' : \'0\'}"><slot><p>{{message}}</p></slot></div></div><div class="vue-message-box__btns"><vue-button :loading="cancelButtonLoading" :class="[cancelButtonClasses]" v-if="showCancelButton" @click.native="handleAction(\'cancel\')">{{cancelButtonText || $t(\'vue.messagebox.cancel\')}}</vue-button><vue-button :loading="confirmButtonLoading" ref="confirm" :class="[confirmButtonClasses]" @click.native="handleAction(\'confirm\')">{{confirmButtonText || $t(\'vue.messagebox.confirm\')}}</vue-button></div></div></transition></div>',
    mixins: [VuePopup],
    computed: {
      typeClass: function() {
        var typeMap = {
          success: 'success',
          info: 'information',
          warning: 'warning',
          error: 'error'
        };
        return this.type && typeMap[this.type.toLowerCase()] ? 'vue-icon-' + typeMap[this.type.toLowerCase()] : '';
      },
      confirmButtonClasses: function() {
        return 'vue-button--primary ' + this.confirmButtonClass;
      },
      cancelButtonClasses: function() {
        return this.cancelButtonClass;
      }
    },
    methods: {
      getSafeClose: function() {
        var self = this;
        var currentId = self.uid;
        return function() {
          self.$nextTick(function() {
            if (currentId === self.uid) self.doClose();
          });
        };
      },
      doClose: function() {
        var self = this;
        if (!self.visible) return;
        self.visible = false;
        self.opened = false;
        if (self.action) self.callback(self.action, self);

        this.$nextTick(function() {
          self.$destroy();
          setTimeout(function() {
            if(self.$el) {
              document.body.removeChild(self.$el);
            }
          }, 200);
        });
      },
      handleAction: function(action) {
        this.action = action;
        if (VueUtil.isFunction(this.beforeClose)) {
          this.close = this.getSafeClose();
          this.beforeClose(action, this, this.close);
        } else {
          this.doClose();
        }
      },
      doDestroy: function() {
        this.$destroy();
      }
    },
    watch: {
      visible: function(val) {
        var self = this;
        if (val) {
          self.uid++;
          self.$nextTick(function() {
            self.$refs.confirm.$el.focus();
          });
        }
      }
    },
    data: function() {
      return {
        uid: 1,
        title: null,
        message: '',
        type: '',
        customClass: '',
        showCancelButton: false,
        action: '',
        confirmButtonText: '',
        cancelButtonText: '',
        confirmButtonLoading: false,
        cancelButtonLoading: false,
        confirmButtonClass: '',
        cancelButtonClass: '',
        callback: null,
        beforeClose: null
      };
    }
  };
  var MessageBoxConstructor = Vue.extend(VueMessageBox);
  var currentMsg, instance;
  var msgQueue = [];
  var defaultCallback = function(action) {
    if (currentMsg) {
      if (action === 'confirm') {
        currentMsg.resolve(action);
      }
      if (action === 'cancel') {
        currentMsg.reject(action);
      }
    }
  };
  var initInstance = function() {
    instance = new MessageBoxConstructor({
      el: document.createElement('div')
    });
    instance.callback = defaultCallback;
  };
  var showNextMsg = function() {
    initInstance();
    instance.action = '';
    if (!instance.visible) {
      if (msgQueue.length > 0) {
        currentMsg = msgQueue.shift();
        var options = currentMsg.options;
        VueUtil.ownPropertyLoop(options, function(prop) {
          instance[prop] = options[prop];
        });
        if (!VueUtil.isDef(options.callback)) {
          instance.callback = defaultCallback;
        }
        var oldCb = instance.callback;
        instance.callback = function(action, instance) {
          oldCb(action, instance);
          showNextMsg();
        };
        if (VueUtil.isVNode(instance.message)) {
          instance.$slots.default = [instance.message];
          instance.message = null;
        }
        document.body.appendChild(instance.$el);
        Vue.nextTick(function() {
          instance.visible = true;
        });
      }
    }
  };
  var MessageBox = function(options) {
    var callback;
    if (options.callback) {
      callback = options.callback;
    }
    return new Promise(function(resolve, reject) {
      msgQueue.push({
        options: VueUtil.merge({}, options, {closeOnPressEscape: false}),
        callback: callback,
        resolve: resolve,
        reject: reject
      });
      showNextMsg();
    });
  };
  var messageBoxAlert = function(options) {
    return new MessageBox(VueUtil.merge({}, options, {showCancelButton: false}));
  };
  var messageBoxConfirm = function(options) {
    return new MessageBox(VueUtil.merge({}, options, {showCancelButton: true}));
  };
  Vue.prototype.$alert = messageBoxAlert;
  Vue.prototype.$confirm = messageBoxConfirm;
  Vue.alert = messageBoxAlert;
  Vue.confirm = messageBoxConfirm;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueNotification = definition(context.Vue, context.VueUtil);
    delete context.VueNotification;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueNotification = {
    template: '<transition :name="isLeft ? \'notify-left\' : isTop ? \'notify-top\' : isBottom ? \'notify-bottom\' : isCenter? \'notify-center\' : \'notify-right\'" @after-leave="doDestroy"><div :class="[\'vue-notification\', {\'vue-notification-translateX\':centerX, \'vue-notification-translateY\':centerY, \'vue-notification-center\':centerX&&centerY},customClass]" v-show="visible" :style="{top: top ? top + \'px\' : \'auto\', bottom: bottom ? bottom + \'px\' : \'auto\', left: left ? left + \'px\' : \'auto\', right: right ? right + \'px\' : \'auto\'}"><i :class="[\'vue-notification__icon\', typeClass, iconClass]" v-if="type || iconClass"></i><div :class="[\'vue-notification__group\', {\'content_margin\':centerX&&centerY&&(type || iconClass)}]"><h2 class="vue-notification__title" v-text="title" v-if="showTitle"></h2><div class="vue-notification__content" v-if="showMessage" :style="{\'margin-top\':showTitle?\'10px\':\'\'}"><slot>{{message}}</slot></div><div class="vue-notification__closeBtn vue-icon-close" @click="close" v-if="duration===0 || showClose"></div></div></div></transition>',
    data: function() {
      return {
        visible: false,
        title: '',
        message: '',
        duration: 3000,
        type: '',
        customClass: '',
        iconClass: '',
        onClose: null,
        closed: false,
        top: null,
        bottom: null,
        left: null,
        right: null,
        centerX: false,
        centerY: false,
        position: VueUtil.getSystemInfo().device == 'Mobile'? 'center-center':'top-right',
        isLeft: false,
        isTop: false,
        isBottom: false,
        isCenter: false,
        showClose: false
      };
    },
    computed: {
      showTitle: function() {
        if (VueUtil.trim(this.title) === '') {
          return false;
        }
        return true;
      },
      showMessage: function() {
        if (VueUtil.trim(this.message) === '' && !this.$slots.default) {
          return false;
        }
        return true;
      },
      typeClass: function() {
        var typeMap = {
          success: 'success',
          info: 'information',
          warning: 'warning',
          error: 'error'
        };
        return this.type && typeMap[this.type.toLowerCase()] ? 'vue-icon-' + typeMap[this.type.toLowerCase()] : '';
      }
    },
    methods: {
      close: function() {
        this.closed = true;
        if (VueUtil.isFunction(this.onClose)) {
          this.onClose();
        }
      },
      doDestroy: function() {
        this.$destroy();
      }
    },
    mounted: function() {
      if (this.duration > 0) {
        VueUtil.debounce(this.duration, function() {
          !this.closed && this.close();
        }).call(this);
      }
    }
  };
  var NotificationConstructor = Vue.extend(VueNotification);
  var instances = [];
  var leftTopInstances = [];
  var leftBottomInstances = [];
  var rightTopInstances = [];
  var rightBottomInstances = [];
  var centerTopInstances = [];
  var centerBottomInstances = [];
  var insertIns = function(insertInstances, instance, position) {
    var distHeight = 8;
    instance[position] = distHeight;
    if (!VueUtil.config.notifyStack) {
      VueUtil.loop(insertInstances, function(insertInstance) {
        distHeight += insertInstance.dom.offsetHeight + 8;
      });
      instance[position] = distHeight;
    }
    insertInstances.push(instance);
  };
  var removeIns = function(removeInstances, instance, position) {
    var removedHeight = instance.dom.offsetHeight + 8;
    var removeIndex = removeInstances.indexOf(instance);
    removeInstances.splice(removeIndex, 1);
    if (!VueUtil.config.notifyStack) {
      VueUtil.loop(removeInstances, function(removeInstance, index) {
        if (index < removeIndex) return;
        removeInstance.dom.style[position] = parseInt(removeInstance.dom.style[position], 10) - removedHeight + 'px';
      });
    }
  };
  var getinsPos = function(instance) {
    var instancePosition = instance.position.split('-');
    var positionX = instancePosition[1];
    var positionY = instancePosition[0];
    var insPos = {};
    insPos.isLeft = (positionX.indexOf('left') !== -1);
    insPos.isCenterX = (positionX.indexOf('center') !== -1);
    insPos.isRight = (positionX.indexOf('right') !== -1);
    insPos.isTop = (positionY.indexOf('top') !== -1);
    insPos.isCenterY = (positionY.indexOf('center') !== -1);
    insPos.isBottom = (positionY.indexOf('bottom') !== -1);
    return insPos;
  };
  var Notification = function(options) {
    options = options || {};
    var userOnClose = options.onClose;
    var id = 'notification-' + VueUtil.createUuid();
    options.onClose = function() {
      Notification.close(id, userOnClose);
    };
    var instance = new NotificationConstructor({
      data: options
    });
    if (VueUtil.isVNode(options.message)) {
      instance.$slots.default = [options.message];
      options.message = '';
    }
    instance.id = id;
    instance.vm = instance.$mount();
    instance.dom = instance.vm.$el;
    instance.dom.style.zIndex = VueUtil.nextZIndex();
    var insPos = getinsPos(instance);
    if ((!insPos.isLeft && !insPos.isCenterX && !insPos.isRight) || (!insPos.isTop && !insPos.isCenterY && !insPos.isBottom)) {
      instance.$destroy();
      return;
    }
    instance.isLeft = false;
    instance.isBottom = false;
    instance.top = false;
    instance.isCenter = false;
    if (insPos.isCenterY) {
      instance.centerY = true;
    }
    if (insPos.isLeft) {
      instance.left = 8;
      instance.isLeft = true;
    }
    if (insPos.isCenterX) {
      instance.centerX = true;
      instance.isCenter = true;
      insPos.isBottom && (instance.isBottom = true);
      insPos.isTop && (instance.isTop = true);
    }
    if (insPos.isRight) {
      instance.right = 8;
    }
    if (insPos.isBottom) {
      var position = 'bottom';
      insPos.isLeft && insertIns(leftBottomInstances, instance, position);
      insPos.isCenterX && insertIns(centerBottomInstances, instance, position);
      insPos.isRight && insertIns(rightBottomInstances, instance, position);
    }
    if (insPos.isTop) {
      var position = 'top';
      insPos.isLeft && insertIns(leftTopInstances, instance, position);
      insPos.isCenterX && insertIns(centerTopInstances, instance, position);
      insPos.isRight && insertIns(rightTopInstances, instance, position);
    }
    instance.dom.style.display = '';
    instance.dom.style.opacity = 0;
    instances.push(instance);
    document.body.appendChild(instance.vm.$el);
    Vue.nextTick(function() {
      instance.vm.visible = true;
      instance.dom.style.opacity = 1;
    });
  };
  VueUtil.loop(['success', 'warning', 'info', 'error'], function(type) {
    Notification[type] = function(options) {
      options.type = type;
      Notification(options);
    };
  });
  Notification.close = function(id, userOnClose) {
    VueUtil.loop(instances, function(instance, i) {
      if (id === instance.id) {
        if (VueUtil.isFunction(userOnClose)) {
          userOnClose(instance);
        }
        var insPos = getinsPos(instance);
        if (insPos.isBottom) {
          var position = 'bottom';
          insPos.isLeft && removeIns(leftBottomInstances, instance, position);
          insPos.isCenterX && removeIns(centerBottomInstances, instance, position);
          insPos.isRight && removeIns(rightBottomInstances, instance, position);
        }
        if (insPos.isTop) {
          var position = 'top';
          insPos.isLeft && removeIns(leftTopInstances, instance, position);
          insPos.isCenterX && removeIns(centerTopInstances, instance, position);
          insPos.isRight && removeIns(rightTopInstances, instance, position);
        }
        instance.vm.visible = false;
        instances.splice(i, 1);
        return false;
      }
    });
  };
  Vue.prototype.$notify = Notification;
  Vue.notify = Notification;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VuePagination = definition(context.Vue, context.VueUtil);
    delete context.VuePagination;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VuePager = {
    template: '<ul @click="onPagerClick" class="vue-pager"><li :class="{active: currentPage === 1}" v-if="pageCount > 0" class="number">1</li><li :class="[\'vue-icon more btn-quickprev\', quickprevIconClass]" v-if="showPrevMore" @mouseenter="quickprevIconClass = \'vue-icon-d-arrow-left\'" @mouseleave="quickprevIconClass = \'vue-icon-more\'"></li><li v-for="pager in pagers" :class="[\'number\', {active: currentPage === pager}]">{{pager}}</li><li :class="[\'vue-icon more btn-quicknext\', quicknextIconClass]" v-if="showNextMore" @mouseenter="quicknextIconClass = \'vue-icon-d-arrow-right\'" @mouseleave="quicknextIconClass = \'vue-icon-more\'"></li><li :class="[\'number\', {active: currentPage === pageCount}]" v-if="pageCount > 1">{{pageCount}}</li></ul>',
    name: 'VuePager',
    props: {
      currentPage: Number,
      pageCount: Number
    },
    watch: {
      showPrevMore: function(val) {
        if (!val) this.quickprevIconClass = 'vue-icon-more';
      },
      showNextMore: function(val) {
        if (!val) this.quicknextIconClass = 'vue-icon-more';
      }
    },
    methods: {
      onPagerClick: function(event) {
        var target = event.target;
        if (target.tagName === 'UL') {
          return;
        }
        var newPage = Number(event.target.textContent);
        var pageCount = this.pageCount;
        var currentPage = this.currentPage;
        if (target.className.indexOf('more') !== -1) {
          if (target.className.indexOf('quickprev') !== -1) {
            newPage = currentPage - 5;
          } else if (target.className.indexOf('quicknext') !== -1) {
            newPage = currentPage + 5;
          }
        }
        if (!isNaN(newPage)) {
          if (newPage < 1) {
            newPage = 1;
          }
          if (newPage > pageCount) {
            newPage = pageCount;
          }
        }
        if (newPage !== currentPage) {
          this.$emit('change', newPage);
        }
      }
    },
    computed: {
      pagers: function() {
        var pagerCount = 7;
        var currentPage = Number(this.currentPage);
        var pageCount = Number(this.pageCount);
        var showPrevMore = false;
        var showNextMore = false;
        if (pageCount > pagerCount) {
          if (currentPage > pagerCount - 2) {
            showPrevMore = true;
          }
          if (currentPage < pageCount - 2) {
            showNextMore = true;
          }
        }
        var array = [];
        if (showPrevMore && !showNextMore) {
          var startPage = pageCount - (pagerCount - 2);
          for (var i = startPage; i < pageCount; i++) {
            array.push(i);
          }
        } else if (!showPrevMore && showNextMore) {
          for (var i = 2; i < pagerCount; i++) {
            array.push(i);
          }
        } else if (showPrevMore && showNextMore) {
          var offset = Math.floor(pagerCount / 2) - 1;
          for (var i = currentPage - offset; i <= currentPage + offset; i++) {
            array.push(i);
          }
        } else {
          for (var i = 2; i < pageCount; i++) {
            array.push(i);
          }
        }
        this.showPrevMore = showPrevMore;
        this.showNextMore = showNextMore;
        return array;
      }
    },
    data: function() {
      return {
        current: null,
        showPrevMore: false,
        showNextMore: false,
        quicknextIconClass: 'vue-icon-more',
        quickprevIconClass: 'vue-icon-more'
      };
    }
  };
  var VuePagination = {
    name: 'VuePagination',
    props: {
      pageSize: {
        type: Number,
        default: 10
      },
      small: Boolean,
      total: Number,
      pageCount: Number,
      currentPage: {
        type: Number,
        default: 1
      },
      layout: {
        default: 'prev, pager, next, jumper, ->, total'
      },
      pageSizes: {
        type: Array,
        default: function() {
          return [10, 20, 30, 40, 50, 100];
        }
      }
    },
    data: function() {
      return {
        internalCurrentPage: 1,
        internalPageSize: 0
      };
    },
    render: function(createElement) {
      var self = this;
      var template = createElement('div', {class: 'vue-pagination'}, []);
      var layout = self.layout || '';
      if (!layout) return;
      var TEMPLATE_MAP = {
        prev: createElement('prev', null, []),
        jumper: createElement('jumper', null, []),
        pager: createElement('pager', {attrs: {currentPage: self.internalCurrentPage, pageCount: self.internalPageCount}, on: {change: self.handleCurrentChange}}, []),
        next: createElement('next', null, []),
        sizes: createElement('sizes', {attrs: {pageSizes: self.pageSizes}}, []),
        slot: createElement('my-slot', null, []),
        total: createElement('total', null, [])
      };
      var components = VueUtil.map(layout.split(','), function(item) {return item.trim();});
      var rightWrapper = createElement('div', {class: 'vue-pagination__rightwrapper'}, []);
      var haveRightWrapper = false;
      if (self.small) {
        template.data.class += ' vue-pagination--small';
      }
      VueUtil.loop(components, function(compo) {
        if (compo === '->') {
          haveRightWrapper = true;
          return;
        }
        if (!haveRightWrapper) {
          template.children.push(TEMPLATE_MAP[compo]);
        } else {
          rightWrapper.children.push(TEMPLATE_MAP[compo]);
        }
      });
      if (haveRightWrapper) {
        template.children.push(rightWrapper);
      }
      return template;
    },
    components: {
      MySlot: {
        render: function(createElement) {
          return this.$parent.$slots.default ? this.$parent.$slots.default[0] : '';
        }
      },
      Prev: {
        render: function(createElement) {
          return createElement('button', {attrs: {type: 'button'}, class: ['btn-prev', {disabled: this.$parent.internalCurrentPage <= 1}], on: {click: this.$parent.prev}}, [createElement('i', {class: 'vue-icon vue-icon-arrow-left'}, [])]);
        }
      },
      Next: {
        render: function(createElement) {
          return createElement('button', {attrs: {type: 'button'}, class: ['btn-next', {disabled: this.$parent.internalCurrentPage === this.$parent.internalPageCount || 0 === this.$parent.internalPageCount}], on: {click: this.$parent.next}}, [createElement('i', {class: 'vue-icon vue-icon-arrow-right'}, [])]);
        }
      },
      Sizes: {
        props: {
          pageSizes: Array
        },
        watch: {
          pageSizes: {
            immediate: true,
            handler: function(value) {
              if (VueUtil.isArray(value)) {
                this.$parent.internalPageSize = value.indexOf(this.$parent.pageSize) !== -1 ? this.$parent.pageSize : this.pageSizes[0];
              }
            }
          }
        },
        render: function(createElement) {
          var self = this;
          return createElement('span', {class: 'vue-pagination__sizes'}, [createElement('vue-select', {attrs: {value: this.$parent.internalPageSize}, on: {input: this.handleChange}}, [VueUtil.map(this.pageSizes, function(item) {return createElement('vue-option', {attrs: {value: item, label: item + ' ' + self.$t('vue.pagination.pagesize')}}, []);})])]);
        },
        methods: {
          handleChange: function(val) {
            if (val !== this.$parent.internalPageSize) {
              this.$parent.internalPageSize = val = parseInt(val, 10);
              this.$parent.$emit('size-change', val);
            }
          }
        }
      },
      Jumper: {
        data: function() {
          return {
            oldValue: null
          };
        },
        methods: {
          handleFocus: function(event) {
            this.oldValue = event.target.value;
          },
          handleChange: function(event) {
            this.$parent.internalCurrentPage = this.$parent.getValidCurrentPage(event.target.value);
            this.oldValue = null;
          }
        },
        render: function(createElement) {
          return createElement('span', {class: 'vue-pagination__jump'}, [this.$t('vue.pagination.goto'), createElement('input', {class: 'vue-pagination__editor', attrs: {type: 'number', min: 1, max: this.$parent.internalPageCount, number: !0}, domProps: {value: this.$parent.internalCurrentPage}, on: {change: this.handleChange, focus: this.handleFocus}, style: {width: '30px'}}, []), this.$t('vue.pagination.pageClassifier')]);
        }
      },
      Total: {
        render: function(createElement) {
          return VueUtil.isNumber(this.$parent.total) ? createElement('span', {class: 'vue-pagination__total'}, [this.$t('vue.pagination.total', {total: this.$parent.total})]) : '';
        }
      },
      Pager: VuePager
    },
    methods: {
      handleCurrentChange: function(val) {
        this.internalCurrentPage = this.getValidCurrentPage(val);
      },
      prev: function() {
        var newVal = this.internalCurrentPage - 1;
        this.internalCurrentPage = this.getValidCurrentPage(newVal);
      },
      next: function() {
        var newVal = this.internalCurrentPage + 1;
        this.internalCurrentPage = this.getValidCurrentPage(newVal);
      },
      getValidCurrentPage: function(value) {
        value = parseInt(value, 10);
        var havePageCount = VueUtil.isNumber(this.internalPageCount);
        var resetValue;
        if (!havePageCount) {
          if (isNaN(value) || value < 1) resetValue = 1;
        } else {
          if (value < 1) {
            resetValue = 1;
          } else if (value > this.internalPageCount) {
            resetValue = this.internalPageCount;
          }
        }
        if (!VueUtil.isDef(resetValue) && isNaN(value)) {
          resetValue = 1;
        } else if (resetValue === 0) {
          resetValue = 1;
        }
        return !VueUtil.isDef(resetValue) ? value : resetValue;
      }
    },
    computed: {
      internalPageCount: function() {
        if (VueUtil.isNumber(this.total)) {
          return Math.ceil(this.total / this.internalPageSize);
        } else if (VueUtil.isNumber(this.pageCount)) {
          return this.pageCount;
        }
        return null;
      }
    },
    watch: {
      currentPage: {
        immediate: true,
        handler: function(val) {
          this.internalCurrentPage = val;
        }
      },
      pageSize: {
        immediate: true,
        handler: function(val) {
          this.internalPageSize = val;
        }
      },
      internalCurrentPage: function(newVal, oldVal) {
        var self = this;
        newVal = parseInt(newVal, 10);
        if (isNaN(newVal)) {
          newVal = oldVal || 1;
        } else {
          newVal = self.getValidCurrentPage(newVal);
        }
        if (VueUtil.isDef(newVal)) {
          self.$nextTick(function() {
            self.internalCurrentPage = newVal;
            if (oldVal !== newVal) {
              self.$emit('current-change', self.internalCurrentPage);
            }
          });
        } else {
          self.$emit('current-change', self.internalCurrentPage);
        }
      },
      internalPageCount: function(newVal) {
        var oldPage = this.internalCurrentPage;
        if (newVal > 0 && oldPage === 0) {
          this.internalCurrentPage = 1;
        } else if (oldPage > newVal) {
          this.internalCurrentPage = newVal === 0 ? 1 : newVal;
        }
      }
    }
  };
  Vue.component(VuePagination.name, VuePagination);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueProgress = definition(context.Vue);
    delete context.VueProgress;
  }
})(this, function(Vue) {
  'use strict';
  var VueProgress = {
    template: '<div :class="[\'vue-progress\', \'vue-progress--\' + type, status ? \'is-\' + status : \'\',{\'vue-progress--without-text\': !showText,\'vue-progress--text-inside\': textInside,}]"><div class="vue-progress-bar" v-if="type === \'line\'"><div class="vue-progress-bar__outer" :style="{height: strokeWidth + \'px\'}"><div class="vue-progress-bar__inner" :style="barStyle"><div class="vue-progress-bar__innerText" v-if="showText && textInside">{{percentage}}%</div></div></div></div><div class="vue-progress-circle" :style="{height: width + \'px\', width: width + \'px\'}" v-else><svg viewBox="0 0 100 100"><path class="vue-progress-circle__track" :d="trackPath" stroke="#e5e9f2" :stroke-width="relativeStrokeWidth" fill="none"></path><path class="vue-progress-circle__path" :d="trackPath" stroke-linecap="round" :stroke="stroke" :stroke-width="relativeStrokeWidth" fill="none" :style="circlePathStyle"></path></svg></div><div class="vue-progress__text" v-if="showText && !textInside" :style="{fontSize: progressTextSize + \'px\'}"><template v-if="!status">{{percentage}}%</template><i v-else :class="iconClass"></i></div></div>',
    name: 'VueProgress',
    props: {
      type: {
        type: String,
        default: 'line',
        validator: function(val) {return ['line', 'circle'].indexOf(val) !== -1;}
      },
      percentage: {
        type: Number,
        default: 0,
        validator: function(val) {return val >= 0 && val <= 100;}
      },
      status: {
        type: String
      },
      strokeWidth: {
        type: Number,
        default: 6
      },
      textInside: Boolean,
      width: {
        type: Number,
        default: 126
      },
      showText: {
        type: Boolean,
        default: true
      }
    },
    computed: {
      barStyle: function() {
        var style = {};
        style.width = this.percentage + '%';
        return style;
      },
      relativeStrokeWidth: function() {
        return (this.strokeWidth / this.width * 100).toFixed(1);
      },
      trackPath: function() {
        var radius = parseInt(50 - parseFloat(this.relativeStrokeWidth) / 2, 10);
        return 'M 50 50 m 0 -' + radius + ' a ' + radius + ' ' + radius + ' 0 1 1 0 ' + 2 * radius + ' a ' + radius + ' ' + radius + ' 0 1 1 0 -' + 2 * radius;
      },
      perimeter: function() {
        var radius = 50 - parseFloat(this.relativeStrokeWidth) / 2;
        return 2 * Math.PI * radius;
      },
      circlePathStyle: function() {
        var perimeter = this.perimeter;
        return {
          strokeDasharray: perimeter + 'px,' + perimeter + 'px',
          strokeDashoffset: (1 - this.percentage / 100) * perimeter + 'px',
          transition: 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease'
        };
      },
      stroke: function() {
        var ret;
        switch (this.status) {
          case 'success':
            ret = '#67c23a';
            break;
          case 'exception':
            ret = '#fb5555';
            break;
          default:
            ret = '#409eff';
        }
        return ret;
      },
      iconClass: function() {
        if (this.type === 'line') {
          return this.status === 'success' ? 'vue-icon-success' : 'vue-icon-error';
        } else {
          return this.status === 'success' ? 'vue-icon-check' : 'vue-icon-close';
        }
      },
      progressTextSize: function() {
        return this.type === 'line' ? 12 + this.strokeWidth * 0.4 : this.width * 0.25 + 6;
      }
    }
  };
  Vue.component(VueProgress.name, VueProgress);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueSlider = definition(context.Vue, context.VueUtil);
    delete context.VueSlider;
  }
})(this, function(Vue, VueUtil, VueTooltip) {
  'use strict';
  var VueSliderButton = {
    template: '<div @mouseenter="handleMouseEnter" @mouseleave="handleMouseLeave" @mousedown="onButtonDown" @touchstart="onButtonDown" :class="[\'vue-slider__button-wrapper\', {\'hover\': hovering, \'dragging\': dragging}]" :style="wrapperStyle" ref="button"><vue-tooltip placement="top" ref="tooltip" :disabled="!showTooltip"><span slot="content">{{formatValue}}</span><div :class="[\'vue-slider__button\', {\'hover\': hovering, \'dragging\': dragging}]"></div></vue-tooltip></div>',
    name: 'VueSliderButton',
    props: {
      value: {
        type: Number,
        default: 0
      },
      vertical: Boolean
    },
    data: function() {
      return {
        hovering: false,
        dragging: false,
        startX: 0,
        currentX: 0,
        startY: 0,
        currentY: 0,
        startPosition: 0,
        newPosition: null,
        oldValue: this.value
      };
    },
    computed: {
      disabled: function() {
        return this.$parent.disabled;
      },
      max: function() {
        return this.$parent.max;
      },
      min: function() {
        return this.$parent.min;
      },
      step: function() {
        return this.$parent.step;
      },
      showTooltip: function() {
        return this.$parent.showTooltip;
      },
      precision: function() {
        return this.$parent.precision;
      },
      currentPosition: function() {
        return (this.value - this.min) / (this.max - this.min) * 100 + '%';
      },
      enableFormat: function() {
        return this.$parent.formatTooltip instanceof Function;
      },
      formatValue: function() {
        return this.enableFormat && this.$parent.formatTooltip(this.value) || this.value;
      },
      wrapperStyle: function() {
        return this.vertical ? {bottom: this.currentPosition} : {left: this.currentPosition};
      }
    },
    watch: {
      dragging: function(val) {
        this.$parent.dragging = val;
      }
    },
    methods: {
      displayTooltip: function() {
        this.$refs.tooltip && (this.$refs.tooltip.showPopper = true);
      },
      hideTooltip: function() {
        this.$refs.tooltip && (this.$refs.tooltip.showPopper = false);
      },
      handleMouseEnter: function() {
        this.hovering = true;
        this.displayTooltip();
      },
      handleMouseLeave: function() {
        this.hovering = false;
        this.hideTooltip();
      },
      onButtonDown: function(event) {
        if (this.disabled) return;
        event.preventDefault();
        this.displayTooltip();
        this.onDragStart(event);
        VueUtil.addTouchMove(document, this.onDragging);
        VueUtil.addTouchEnd(document, this.onDragEnd);
        VueUtil.on(document, 'contextmenu', this.onDragEnd);
      },
      onDragStart: function(event) {
        this.dragging = true;
        if (this.vertical) {
          this.startY = event.clientY || event.touches[0].clientY;
        } else {
          this.startX = event.clientX || event.touches[0].clientX;
        }
        this.startPosition = parseFloat(this.currentPosition);
      },
      onDragging: function(event) {
        if (this.dragging) {
          this.displayTooltip();
          var diff = 0;
          var sliderSize = 1;
          var parentObj = this.$parent;
          if (parentObj.$refs.slider) {
            sliderSize = parentObj.$refs.slider['client' + (parentObj.vertical ? 'Height' : 'Width')];
          }
          if (this.vertical) {
            this.currentY = event.clientY || event.touches[0].clientY;
            diff = (this.startY - this.currentY) / sliderSize * 100;
          } else {
            this.currentX = event.clientX || event.touches[0].clientX;
            diff = (this.currentX - this.startX) / sliderSize * 100;
          }
          this.newPosition = this.startPosition + diff;
          this.setPosition(this.newPosition);
        }
      },
      onDragEnd: function() {
        if (this.dragging) {
          VueUtil.debounce(function() {
            this.dragging = false;
            this.hideTooltip();
            this.setPosition(this.newPosition);
          }).call(this);
          VueUtil.removeTouchMove(document, this.onDragging);
          VueUtil.removeTouchEnd(document, this.onDragEnd);
          VueUtil.off(document, 'contextmenu', this.onDragEnd);
        }
      },
      setPosition: function(newPosition) {
        if (newPosition === null) return;
        if (newPosition < 0) {
          newPosition = 0;
        } else if (newPosition > 100) {
          newPosition = 100;
        }
        var lengthPerStep = 100 / ((this.max - this.min) / this.step);
        var steps = Math.round(newPosition / lengthPerStep);
        var value = steps * lengthPerStep * (this.max - this.min) * 0.01 + this.min;
        value = parseFloat(value.toFixed(this.precision));
        this.$emit('input', value);
        this.$refs.tooltip && this.$refs.tooltip.updatePopper();
        if (!this.dragging && this.value !== this.oldValue) {
          this.oldValue = this.value;
        }
      }
    }
  };
  var VueSlider = {
    template: '<div class="vue-slider" :class="{\'is-vertical\': vertical}"><div :class="[\'vue-slider__runway\', {\'disabled\': disabled}]" :style="runwayStyle" @click="onSliderClick" ref="slider"><div class="vue-slider__bar" :style="barStyle"></div><slider-button :vertical="vertical" v-model="firstValue" ref="button1"></slider-button><slider-button :vertical="vertical" v-model="secondValue" ref="button2" v-if="range"></slider-button><div class="vue-slider__stop" v-for="item in stops" :style="vertical ? {\'bottom\': item + \'%\'} : {\'left\': item + \'%\'}" v-if="showStops"></div></div></div>',
    name: 'VueSlider',
    mixins: [VueUtil.component.emitter],
    props: {
      min: {
        type: Number,
        default: 0
      },
      max: {
        type: Number,
        default: 100
      },
      step: {
        type: Number,
        default: 1
      },
      value: {
        type: [Number, Array],
        default: 0
      },
      showStops: Boolean,
      showTooltip: {
        type: Boolean,
        default: true
      },
      formatTooltip: Function,
      disabled: Boolean,
      range: Boolean,
      vertical: Boolean,
      height: {
        type: Number,
        default: 200
      }
    },
    components: {
      SliderButton: VueSliderButton
    },
    data: function() {
      return {
        firstValue: null,
        secondValue: null,
        oldValue: null,
        dragging: false
      };
    },
    watch: {
      value: function(val, oldVal) {
        if (this.dragging ||
          VueUtil.isArray(val) &&
          VueUtil.isArray(oldVal) &&
          val.every(function(item, index) {return item === oldVal[index];})) {
          return;
        }
        this.setValues();
      },
      dragging: function(val) {
        if (!val) {
          this.setValues();
        }
      },
      firstValue: function(val) {
        if (this.range) {
          this.$emit('input', [this.minValue, this.maxValue]);
        } else {
          this.$emit('input', val);
        }
      },
      secondValue: function() {
        if (this.range) {
          this.$emit('input', [this.minValue, this.maxValue]);
        }
      },
      min: function() {
        this.setValues();
      },
      max: function() {
        this.setValues();
      }
    },
    methods: {
      valueChanged: function() {
        var self = this;
        if (self.range) {
          return ![self.minValue, self.maxValue]
            .every(function(item, index) {return item === self.oldValue[index];});
        } else {
          return self.value !== self.oldValue;
        }
      },
      setValues: function() {
        var val = this.value;
        if (this.range && VueUtil.isArray(val)) {
          if (val[1] < this.min) {
            this.$emit('input', [this.min, this.min]);
          } else if (val[0] > this.max) {
            this.$emit('input', [this.max, this.max]);
          } else if (val[0] < this.min) {
            this.$emit('input', [this.min, val[1]]);
          } else if (val[1] > this.max) {
            this.$emit('input', [val[0], this.max]);
          } else {
            this.firstValue = val[0];
            this.secondValue = val[1];
            if (this.valueChanged()) {
              this.$emit('change', [this.minValue, this.maxValue]);
              this.dispatch('VueFormItem', 'vue.form.change', [this.minValue, this.maxValue]);
              this.oldValue = VueUtil.mergeArray([], val);
            }
          }
        } else if (!this.range && VueUtil.isNumber(val)) {
          if (val < this.min) {
            this.$emit('input', this.min);
          } else if (val > this.max) {
            this.$emit('input', this.max);
          } else {
            this.firstValue = val;
            if (this.valueChanged()) {
              this.$emit('change', val);
              this.dispatch('VueFormItem', 'vue.form.change', val);
              this.oldValue = val;
            }
          }
        }
      },
      setPosition: function(percent) {
        var targetValue = this.min + percent * (this.max - this.min) / 100;
        if (!this.range) {
          this.$refs.button1.setPosition(percent);
          return;
        }
        var button;
        if (Math.abs(this.minValue - targetValue) < Math.abs(this.maxValue - targetValue)) {
          button = this.firstValue < this.secondValue ? 'button1' : 'button2';
        } else {
          button = this.firstValue > this.secondValue ? 'button1' : 'button2';
        }
        this.$refs[button].setPosition(percent);
      },
      onSliderClick: function(event) {
        if (this.disabled || this.dragging) return;
        var sliderSize = 1;
        if (this.$refs.slider) {
          sliderSize = this.$refs.slider['client' + (this.vertical ? 'Height' : 'Width')];
        }
        if (this.vertical) {
          var sliderOffsetBottom = this.$refs.slider.getBoundingClientRect().bottom;
          this.setPosition((sliderOffsetBottom - (event.clientY || event.touches[0].clientY)) / sliderSize * 100);
        } else {
          var sliderOffsetLeft = this.$refs.slider.getBoundingClientRect().left;
          this.setPosition(((event.clientX || event.touches[0].clientX) - sliderOffsetLeft) / sliderSize * 100);
        }
      }
    },
    computed: {
      stops: function() {
        var self = this;
        var stopCount = (self.max - self.min) / self.step;
        var stepWidth = 100 * self.step / (self.max - self.min);
        var result = [];
        for (var i = 1; i < stopCount; i++) {
          result.push(i * stepWidth);
        }
        if (self.range) {
          return VueUtil.filter(result, function(step) {
            return step < 100 * (self.minValue - self.min) / (self.max - self.min) ||
              step > 100 * (self.maxValue - self.min) / (self.max - self.min);
          });
        } else {
          return VueUtil.filter(result, function(step) {return step > 100 * (self.firstValue - self.min) / (self.max - self.min);});
        }
      },
      minValue: function() {
        return Math.min(this.firstValue, this.secondValue);
      },
      maxValue: function() {
        return Math.max(this.firstValue, this.secondValue);
      },
      barSize: function() {
        return this.range ? 100 * (this.maxValue - this.minValue) / (this.max - this.min) + '%' : 100 * (this.firstValue - this.min) / (this.max - this.min) + '%';
      },
      barStart: function() {
        return this.range ? 100 * (this.minValue - this.min) / (this.max - this.min) + '%' : '0%';
      },
      precision: function() {
        var precisions = VueUtil.map([this.min, this.max, this.step], function(item) {
          var decimal = ('' + item).split('.')[1];
          return decimal ? decimal.length : 0;
        });
        return Math.max.apply(null, precisions);
      },
      runwayStyle: function() {
        return this.vertical ? {height: this.height + 'px'} : {};
      },
      barStyle: function() {
        return this.vertical ? {height: this.barSize, bottom: this.barStart} : {width: this.barSize, left: this.barStart};
      }
    },
    mounted: function() {
      if (this.range) {
        if (VueUtil.isArray(this.value)) {
          this.firstValue = Math.max(this.min, this.value[0]);
          this.secondValue = Math.min(this.max, this.value[1]);
        } else {
          this.firstValue = this.min;
          this.secondValue = this.max;
        }
        this.oldValue = [this.firstValue, this.secondValue];
      } else {
        if (!VueUtil.isNumber(this.value)) {
          this.firstValue = this.min;
        } else {
          this.firstValue = Math.min(this.max, Math.max(this.min, this.value));
        }
        this.oldValue = this.firstValue;
      }
    }
  };
  Vue.component(VueSlider.name, VueSlider);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueRate = definition(context.Vue, context.VueUtil);
    delete context.VueRate;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueRate = {
    template: '<div class="vue-rate"><span v-for="item in max" class="vue-rate__item" @mousemove="setCurrentValue(item, $event)" @mouseleave="resetCurrentValue" @click="selectValue(item)" :style="{cursor: disabled ? \'auto\' : \'pointer\'}"><i :class="[\'vue-rate__icon\', classes[item - 1], {\'hover\': hoverIndex === item}]" :style="getIconStyle(item)"><i v-if="showDecimalIcon(item)" :class="[\'vue-rate__decimal\', decimalIconClass]" :style="decimalStyle"></i></i></span><span v-if="showText" class="vue-rate__text" :style="{color: textColor}">{{text}}</span></div>',
    name: 'VueRate',
    data: function() {
      return {
        classMap: {},
        colorMap: {},
        pointerAtLeftHalf: false,
        currentValue: this.value,
        hoverIndex: -1
      };
    },
    props: {
      value: {
        type: Number,
        default: 0
      },
      lowThreshold: {
        type: Number,
        default: 2
      },
      highThreshold: {
        type: Number,
        default: 4
      },
      max: {
        type: Number,
        default: 5
      },
      colors: {
        type: Array,
        default: function() {
          return ['#F7BA2A', '#F7BA2A', '#F7BA2A'];
        }
      },
      voidColor: {
        type: String,
        default: '#C6D1DE'
      },
      disabledVoidColor: {
        type: String,
        default: '#EFF2F7'
      },
      iconClasses: {
        type: Array,
        default: function() {
          return ['vue-icon-star-on', 'vue-icon-star-on', 'vue-icon-star-on'];
        }
      },
      voidIconClass: {
        type: String,
        default: 'vue-icon-star-off'
      },
      disabledVoidIconClass: {
        type: String,
        default: 'vue-icon-star-on'
      },
      disabled: Boolean,
      allowHalf: Boolean,
      showText: Boolean,
      textColor: {
        type: String,
        default: '1f2d3d'
      },
      texts: {
        type: Array,
        default: function() {
          return [];
        }
      },
      textTemplate: {
        type: String,
        default: '{value}'
      }
    },
    computed: {
      text: function() {
        var result = '';
        if (this.disabled) {
          result = this.textTemplate.replace(/\{\s*value\s*\}/, this.value);
        } else {
          result = this.texts[Math.ceil(this.currentValue) - 1];
        }
        return result;
      },
      decimalStyle: function() {
        var width = '';
        if (this.disabled) {
          width = (this.valueDecimal < 50 ? 0 : 50) + '%';
        }
        if (this.allowHalf) {
          width = '50%';
        }
        return {
          color: this.activeColor,
          width: width
        };
      },
      valueDecimal: function() {
        return this.value * 100 - Math.floor(this.value) * 100;
      },
      decimalIconClass: function() {
        return this.getValueFromMap(this.value, this.classMap);
      },
      voidClass: function() {
        return this.disabled ? this.classMap.disabledVoidClass : this.classMap.voidClass;
      },
      activeClass: function() {
        return this.getValueFromMap(this.currentValue, this.classMap);
      },
      activeColor: function() {
        return this.getValueFromMap(this.currentValue, this.colorMap);
      },
      classes: function() {
        var result = [];
        var i = 0;
        var threshold = this.currentValue;
        if (this.allowHalf && this.currentValue !== Math.floor(this.currentValue)) {
          threshold--;
        }
        for (; i < threshold; i++) {
          result.push(this.activeClass);
        }
        for (; i < this.max; i++) {
          result.push(this.voidClass);
        }
        return result;
      }
    },
    watch: {
      value: function(val) {
        this.$emit('change', val);
        this.currentValue = val;
      },
      colors: function(val) {
        this.colorMap.lowColor = val[0];
        this.colorMap.mediumColor = val[1];
        this.colorMap.highColor = val[2];
      },
      voidColor: function(val) {
        this.colorMap.voidColor = val;
      },
      disabledVoidColor: function(val) {
        this.colorMap.disabledVoidColor = val;
      },
      iconClasses: function(val) {
        this.classMap.lowClass = val[0];
        this.classMap.mediumClass = val[1];
        this.classMap.highClass = val[2];
      },
      voidClass: function(val) {
        this.classMap.voidClass = val;
      },
      disabledVoidClass: function(val) {
        this.classMap.disabledVoidClass = val;
      }
    },
    methods: {
      getValueFromMap: function(value, map) {
        var result = '';
        if (value <= this.lowThreshold) {
          result = map.lowColor || map.lowClass;
        } else if (value >= this.highThreshold) {
          result = map.highColor || map.highClass;
        } else {
          result = map.mediumColor || map.mediumClass;
        }
        return result;
      },
      showDecimalIcon: function(item) {
        var showWhenDisabled = this.disabled && this.valueDecimal > 0 && item - 1 < this.value && item > this.value;
        var showWhenAllowHalf = this.allowHalf && this.pointerAtLeftHalf && ((item - 0.5).toFixed(1) === this.currentValue.toFixed(1));
        return showWhenDisabled || showWhenAllowHalf;
      },
      getIconStyle: function(item) {
        var voidColor = this.disabled ? this.colorMap.disabledVoidColor : this.colorMap.voidColor;
        return {
          color: item <= this.currentValue ? this.activeColor : voidColor
        };
      },
      selectValue: function(value) {
        if (this.disabled) {
          return;
        }
        if (this.allowHalf && this.pointerAtLeftHalf) {
          this.$emit('input', this.currentValue);
        } else {
          this.$emit('input', value);
        }
      },
      setCurrentValue: function(value, event) {
        if (this.disabled) {
          return;
        }
        if (this.allowHalf) {
          var target = event.target;
          if (VueUtil.hasClass(target, 'vue-rate__item')) {
            target = target.querySelector('.vue-rate__icon');
          }
          if (VueUtil.hasClass(target, 'vue-rate__decimal')) {
            target = target.parentNode;
          }
          this.pointerAtLeftHalf = event.offsetX * 2 <= target.clientWidth;
          this.currentValue = this.pointerAtLeftHalf ? value - 0.5 : value;
        } else {
          this.currentValue = value;
        }
        this.hoverIndex = value;
      },
      resetCurrentValue: function() {
        if (this.disabled) {
          return;
        }
        if (this.allowHalf) {
          this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
        }
        this.currentValue = this.value;
        this.hoverIndex = -1;
      }
    },
    created: function() {
      if (!this.value) {
        this.$emit('input', 0);
      }
      this.classMap = {
        lowClass: this.iconClasses[0],
        mediumClass: this.iconClasses[1],
        highClass: this.iconClasses[2],
        voidClass: this.voidIconClass,
        disabledVoidClass: this.disabledVoidIconClass
      };
      this.colorMap = {
        lowColor: this.colors[0],
        mediumColor: this.colors[1],
        highColor: this.colors[2],
        voidColor: this.voidColor,
        disabledVoidColor: this.disabledVoidColor
      };
    }
  };
  Vue.component(VueRate.name, VueRate);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VueResource'], definition);
  } else {
    context.VueUpload = definition(context.Vue, context.VueUtil);
    delete context.VueUpload;
  }
})(this, function(Vue, VueUtil) {
  'use strict';

  function handleDragOutside(e) {
    e = e || event;
    e.preventDefault();
  }

  function noop() {}
  var UploadDragger = {
    template: '<div :class="[\'vue-upload-dragger\', {\'is-dragover\': dragover}]" @drop.prevent="onDrop" @dragover.prevent="onDragover" @dragleave.prevent="dragover = false"><slot></slot></div>',
    name: 'VueUploadDrag',
    props: {
      disabled: Boolean
    },
    data: function() {
      return {
        dragover: false
      };
    },
    methods: {
      onDragover: function() {
        if (!this.disabled) {
          this.dragover = true;
        }
      },
      onDrop: function(e) {
        if (!this.disabled) {
          this.dragover = false;
          this.$emit('file', e.dataTransfer.files);
        }
      }
    }
  };
  var UploadList = {
    template: '<transition-group tag="ul" :class="[\'vue-upload-list\', \'vue-upload-list--\' + listType, {\'is-disabled\': disabled}]" name="vue-list">\
                <li v-for="(file, index) in files" :class="[\'vue-upload-list__item\', \'is-\' + file.status]" :key="file.uid">\
                  <img class="vue-upload-list__item-thumbnail" v-if="!isMobile && file.status !== \'uploading\' && [\'picture-card\', \'picture\'].indexOf(listType) !== -1"\
                   :src="file.url" :alt="file.name"/>\
                  <a v-if="!isMobile" class="vue-upload-list__item-name" @click="handleClick(file, index, files)">\
                   <i class="vue-icon-document"></i>{{file.name}}</a>\
                  <label v-if="!isMobile" class="vue-upload-list__item-status-label">\
                    <i :class="{\'vue-icon-upload-success\': true, \'vue-icon-success\': listType === \'text\', \'vue-icon-check\': [\'picture-card\', \'picture\'].indexOf(listType) !== -1}"></i>\
                  </label>\
                  <i class="vue-icon-close" v-if="!isMobile && !disabled" @click="$emit(\'remove\', file)"></i>\
                  <vue-progress v-if="!isMobile && file.status === \'uploading\'" :type="listType === \'picture-card\' ? \'circle\' : \'line\'" :stroke-width="listType === \'picture-card\' ? 6 : 2" \
                  :percentage="parsePercentage(file.percentage)"></vue-progress>\
                  <span class="vue-upload-list__item-actions" v-if="!isMobile && listType === \'picture-card\'">\
                    <span class="vue-upload-list__item-preview" v-if="handlePreview && listType === \'picture-card\'" @click="handlePreview(file,index,files)">\
                      <i class="vue-icon-view"></i>\
                    </span>\
                    <span v-if="!disabled" class="vue-upload-list__item-delete" @click="$emit(\'remove\', file)"><i class="vue-icon-delete2"></i></span>\
                  </span>\
                  <div v-if="isMobile" style="position:relative;overflow:hidden;width:100%;height:100%;">\
                    <img class="vue-upload-list__item-thumbnail" v-if="file.status !== \'uploading\' && [\'picture-card\', \'picture\'].indexOf(listType) !== -1" \
                        :src="file.url" :alt="listType === \'picture-card\'?file.name:\'load failed\'" @click="handlePreview(file,index,files)" />\
                    <a class="vue-upload-list__item-name" @click="handleClick(file,index,files)"><i class="vue-icon-document"></i>{{file.name}}</a>\
                    <label class="vue-upload-list__item-status-label">\
                      <i :class="{\'vue-icon-upload-success\': true, \'vue-icon-success\': listType === \'text\', \'vue-icon-check\': [\'picture-card\', \'picture\'].indexOf(listType) !== -1}"></i>\
                    </label>\
                    <vue-progress v-if="file.status === \'uploading\'" :type="listType === \'picture-card\' ? \'circle\' : \'line\'" \
                    :stroke-width="listType === \'picture-card\' ? 6 : 2" :percentage="parsePercentage(file.percentage)"></vue-progress>\
                  </div>\
                  <i v-if="isMobile && !disabled" class="vue-icon-error" @click="$emit(\'remove\', file)"></i>\
                </li></transition-group>',
    props: {
      files: {
        type: Array,
        default: function() {
          return [];
        }
      },
      disabled: Boolean,
      handlePreview: Function,
      listType: String
    },
    data: function() {
      return {
        isMobile: VueUtil.getSystemInfo().device == 'Mobile'  && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
      };
    },
    methods: {
      parsePercentage: function(val) {
        return parseInt(val, 10);
      },
      handleClick: function(file,index,files) {
        this.handlePreview && this.handlePreview(file,index,files);
      },
    }
  };
  var Upload = {
    inject: ['uploader'],
    components: {
      UploadDragger: UploadDragger
    },
    props: {
      type: String,
      action: {
        type: String,
        default: location.href
      },
      name: {
        type: String,
        default: 'file'
      },
      data: Object,
      headers: Object,
      withCredentials: Boolean,
      multiple: Boolean,
      max: Number,
      accept: String,
      onStart: Function,
      onProgress: Function,
      onSuccess: Function,
      onError: Function,
      beforeUpload: Function,
      drag: Boolean,
      onPreview: {
        type: Function,
        default: function() {}
      },
      onRemove: {
        type: Function,
        default: function() {}
      },
      fileList: Array,
      autoUpload: Boolean,
      listType: String,
      httpRequest: {
        type: Function,
        default: function(option) {
          if (!VueUtil.isDef(this.$http)) return;
          var httpOption = {};
          httpOption.headers = option.headers;
          httpOption.progress = function progress(e) {
            if (e.total > 0) {
              e.percent = e.loaded / e.total * 100;
            }
            option.onProgress(e);
          };
          if (option.withCredentials) {
            httpOption.emulateJSON = true;
          }
          var formData = new FormData();
          if (option.data) {
            VueUtil.ownPropertyLoop(option.data, function(key) {
              formData.append(key, option.data[key]);
            });
          }
          formData.append(option.filename, option.file);
          this.$http.post(option.action, formData, httpOption).then(function(reqponse) {
            option.onSuccess(reqponse);
          }, function(reqponse) {
            option.onError(reqponse);
          });
        }
      },
      disabled: Boolean,
      clickable: {
        type: Boolean,
        default: true,
      },
      tabindex: {
        type: Number,
        default: 0,
      }
    },
    data: function() {
      return {
        mouseover: false,
        reqs: {}
      };
    },
    methods: {
      isImage: function(str) {
        return str.indexOf('image') !== -1;
      },
      handleChange: function(ev) {
        var files = ev.target.files;
        if (!files) return;

        if (this.max > 0 && this.multiple) {
          files = [].slice.call(files, 0, this.max - this.fileList.length);
        }
        this.uploadFiles(files);
      },
      uploadFiles: function(files) {
        var self = this;
        var postFiles = [].slice.call(files);
        if (!self.multiple) {
          postFiles = postFiles.slice(0, 1);
        }
        if (postFiles.length === 0) return;
        VueUtil.loop(postFiles, function(rawFile) {
          self.onStart(rawFile);
          if (self.autoUpload) self.upload(rawFile);
        });
      },
      upload: function(rawFile) {
        var self = this;
        self.$refs.input.value = null;
        if (!self.beforeUpload) {
          return self.post(rawFile);
        }
        var before = self.beforeUpload(rawFile);
        if (before && before.then) {
          before.then(function(processedFile) {
            if (VueUtil.isFile(processedFile)) {
              self.post(processedFile);
            } else {
              self.post(rawFile);
            }
          }, function() {
            self.onRemove(rawFile, true);
          });
        } else if (before !== false) {
          self.post(rawFile);
        } else {
          self.onRemove(rawFile, true);
        }
      },
      abort: function(rawFile) {
        var reqs = this.reqs;
        if (rawFile) {
          var uid = rawFile;
          if (rawFile.uid) uid = rawFile.uid;
          if (reqs[uid]) {
            reqs[uid].abort();
          }
        } else {
          VueUtil.ownPropertyLoop(reqs, function(uid) {
            if (reqs[uid]) reqs[uid].abort();
            delete reqs[uid];
          });
        }
      },
      post: function(rawFile) {
        var self = this;
        var uid = rawFile.uid;
        var options = {
          headers: self.headers,
          withCredentials: self.withCredentials,
          file: rawFile,
          data: self.data,
          filename: self.name,
          action: self.action,
          onProgress: function onProgress(e) {
            self.onProgress(e, rawFile);
          },
          onSuccess: function onSuccess(res) {
            self.onSuccess(res, rawFile);
            delete self.reqs[uid];
          },
          onError: function onError(err) {
            self.onError(err, rawFile);
            delete self.reqs[uid];
          }
        };
        var req = self.httpRequest(options);
        self.reqs[uid] = req;
        if (req && req.then) {
          req.then(options.onSuccess, options.onError);
        }
      },
      handleClick: function() {
        if (!this.disabled && this.clickable) {
          this.$refs.input.value = null;
          this.$refs.input.click();
        }
      }
    },
    render: function(createElement) {
      var handleClick = this.handleClick;
      var drag = this.drag;
      var handleChange = this.handleChange;
      var multiple = this.multiple;
      var accept = this.accept;
      var listType = this.listType;
      var uploadFiles = this.uploadFiles;
      var disabled = this.disabled;
      var data = {
        class: {
          'vue-upload': true,
          'is-disabled': disabled,
          'clickable': this.clickable
        },
        on: {
          click: handleClick,
          keydown: function($event) {
            if (!$event.type.indexOf('key') && Vue.prototype._k($event.keyCode, 'space', 32, $event.key, [' ', 'Spacebar']))
                return null;
            $event.stopPropagation();
            $event.preventDefault();
            return handleClick($event);
        }
        },
        attrs: {
          'tabindex': (this.disabled || (this.listType !== 'picture-card' && !drag)) ? -1 : this.tabindex
        }
      };
      data.class['vue-upload--' + listType] = true;
      return createElement('div', data, [drag ? createElement('upload-dragger', {attrs: {disabled: disabled}, on: {'file': uploadFiles}}, [this.$slots.default]) : this.$slots.default, createElement('input', {class: 'vue-upload__input', attrs: {type: 'file', name: name, multiple: multiple, accept: accept}, ref: 'input', on: {'change': handleChange}}, [])]);
    }
  };
  var IframeUpload = {
    components: {
      UploadDragger: UploadDragger
    },
    props: {
      type: String,
      data: {},
      action: {
        type: String,
        default: location.href
      },
      name: {
        type: String,
        default: 'file'
      },
      withCredentials: Boolean,
      accept: String,
      onStart: Function,
      onProgress: Function,
      onSuccess: Function,
      onError: Function,
      beforeUpload: Function,
      onPreview: {
        type: Function,
        default: function() {}
      },
      onRemove: {
        type: Function,
        default: function() {}
      },
      drag: Boolean,
      listType: String,
      disabled: Boolean,
      clickable: {
        type: Boolean,
        default: true
      }
    },
    data: function() {
      return {
        mouseover: false,
        domain: '',
        file: null,
        submitting: false
      };
    },
    methods: {
      isImage: function(str) {
        return str.indexOf('image') !== -1;
      },
      handleClick: function() {
        if (!this.disabled && clickable) {
          this.$refs.input.click();
        }
      },
      handleChange: function(ev) {
        var file = ev.target.value;
        if (file) {
          this.uploadFiles(file);
        }
      },
      uploadFiles: function(file) {
        if (this.submitting) return;
        this.submitting = true;
        this.file = file;
        this.onStart(file);
        var formNode = this.getFormNode();
        var dataSpan = this.getFormDataNode();
        var data = this.data;
        if (VueUtil.isFunction(data)) {
          data = data(file);
        }
        var inputs = [];
        VueUtil.ownPropertyLoop(data, function(key) {
          inputs.push('<input name="' + key + '" value="' + data[key] + '"/>');
        });
        dataSpan.innerHTML = inputs.join('');
        formNode.submit();
        dataSpan.innerHTML = '';
      },
      getFormNode: function() {
        return this.$refs.form;
      },
      getFormDataNode: function() {
        return this.$refs.data;
      },
      messageHandle: function(event) {
        if (!this.file) return;
        var targetOrigin = new URL(this.action).origin;
        if (event.origin !== targetOrigin) return;
        var response = event.data;
        if (response.result === 'success') {
          this.onSuccess(response, this.file);
        } else if (response.result === 'failed') {
          this.onError(response, this.file);
        }
        this.submitting = false;
        this.file = null;
      }
    },
    created: function() {
      this.frameName = 'frame-' + Date.now();
    },
    mounted: function() {
      var self = this;
      VueUtil.on(document, 'message', this.messageHandle);
    },
    beforeDestroy: function() {
      VueUtil.off(document, 'message', this.messageHandle);
    },
    render: function(createElement) {
      var drag = this.drag;
      var uploadFiles = this.uploadFiles;
      var listType = this.listType;
      var frameName = this.frameName;
      var disabled = this.disabled;
      var oClass = {'vue-upload': true};
      oClass['vue-upload--' + listType] = true;
      return createElement('div', {'class': oClass, on: {'click': this.handleClick}, nativeOn: {'drop': this.onDrop, 'dragover': this.handleDragover, 'dragleave': this.handleDragleave}}, [createElement('iframe', {on: {'load': this.onload}, ref: 'iframe', attrs: {name: frameName}}, []), createElement('form', {ref: 'form', attrs: {action: this.action, target: frameName, enctype: 'multipart/form-data', method: 'POST'}}, [createElement('input', {'class': 'vue-upload__input', attrs: {type: 'file', name: 'file', accept: this.accept}, ref: 'input', on: {'change': this.handleChange}}, []), createElement('input', {attrs: {type: 'hidden', name: 'documentDomain', value: document.domain}}, []), createElement('span', {ref: 'data'}, [])]), drag ? createElement('upload-dragger', {on: {'file': uploadFiles}, attrs: {disabled: disabled}}, [this.$slots.default]) : this.$slots.default]);
    }
  };
  var migrating = {
    mounted: function() {
      if (!this.$vnode) return;
    },
    methods: {
      getMigratingConfig: function() {
        return {
          props: {},
          events: {}
        };
      }
    }
  };
  var VueUpload = {
    name: 'VueUpload',
    mixins: [migrating],
    components: {
      UploadList: UploadList,
      Upload: Upload,
      IframeUpload: IframeUpload
    },
    provide: {
      uploader: null
    },
    props: {
      action: {
        type: String,
        default: location.href
      },
      headers: {
        type: Object,
        default: function() {
          return {};
        }
      },
      data: Object,
      multiple: Boolean,
      max: {
        type: Number,
        default: 0
      },
      name: {
        type: String,
        default: 'file'
      },
      drag: Boolean,
      dragger: Boolean,
      withCredentials: Boolean,
      showFileList: {
        type: Boolean,
        default: true
      },
      accept: String,
      type: {
        type: String,
        default: 'select'
      },
      beforeUpload: Function,
      beforeRemove: Function,
      onRemove: {
        type: Function,
        default: function() {}
      },
      onChange: {
        type: Function,
        default: function() {}
      },
      onPreview: {
        type: Function
      },
      onSuccess: {
        type: Function,
        default: function() {}
      },
      onProgress: {
        type: Function,
        default: function() {}
      },
      onError: {
        type: Function,
        default: function() {}
      },
      fileList: {
        type: Array,
        default: function() {
          return [];
        }
      },
      autoUpload: {
        type: Boolean,
        default: true
      },
      listType: {
        type: String,
        default: 'text'
      },
      httpRequest: Function,
      disabled: Boolean,
      clickable: {
        type: Boolean,
        default: true
      }
    },
    data: function() {
      return {
        uploadFiles: [],
        dragOver: false,
        draging: false,
        tempIndex: 1
      };
    },
    watch: {
      fileList: {
        immediate: true,
        handler: function(fileList) {
          var self = this;
          self.uploadFiles = VueUtil.map(fileList, function(item) {
            item.uid = item.uid || (Date.now() + self.tempIndex++);
            item.status = self.autoUpload ? 'success' : 'ready';
            return item;
          });
        }
      },
      disabled: function(val) {
        VueUtil.loop(this.$el.querySelectorAll('button'), function(buttonNote) {
          if (val) {
            VueUtil.addClass(buttonNote, 'is-disabled');
          } else {
            VueUtil.removeClass(buttonNote, 'is-disabled');
          }
        });
      }
    },
    methods: {
      handleStart: function(rawFile) {
        rawFile.uid = Date.now() + this.tempIndex++;
        var file = {
          status: 'ready',
          name: rawFile.name,
          size: rawFile.size,
          percentage: 0,
          uid: rawFile.uid,
          raw: rawFile
        };
        try {
          file.url = URL.createObjectURL(rawFile);
        } catch (e) {
          throw e;
        }
        this.uploadFiles.push(file);
        this.onChange(file, this.uploadFiles);
      },
      handleProgress: function(ev, rawFile) {
        var file = this.getFile(rawFile);
        this.onProgress(ev, file, this.uploadFiles);
        file.status = 'uploading';
        file.percentage = ev.percent || 0;
      },
      handleSuccess: function(res, rawFile) {
        var file = this.getFile(rawFile);
        if (file) {
          file.status = 'success';
          file.response = res;
          this.onSuccess(res, file, this.uploadFiles);
          this.onChange(file, this.uploadFiles);
        }
      },
      handleError: function(err, rawFile) {
        var file = this.getFile(rawFile);
        var fileList = this.uploadFiles;
        file.status = 'fail';
        fileList.splice(fileList.indexOf(file), 1);
        this.onError(err, file, this.uploadFiles);
        this.onChange(file, this.uploadFiles);
      },
      handleRemove: function(file, raw) {
        if (raw) {
          file = this.getFile(raw);
        }

        var self = this;
        function doRemove() {
          self.abort(file);
          var fileList = self.uploadFiles;
          fileList.splice(fileList.indexOf(file), 1);
          self.onRemove(file, fileList);
        }

        if (!this.beforeRemove) {
          doRemove();
        } else if (typeof this.beforeRemove === 'function') {
          var before = this.beforeRemove(file, this.uploadFiles);
          if (before && before.then) {
            before.then(function() {
              doRemove();
            }, noop);
          } else if (before !== false) {
            doRemove();
          }
        }
      },
      getFile: function(rawFile) {
        var fileList = this.uploadFiles;
        var target;
        fileList.every(function(item) {
          target = rawFile.uid === item.uid ? item : null;
          return !target;
        });
        return target;
      },
      abort: function(file) {
        this.$refs['upload-inner'].abort(file);
      },
      clearFiles: function() {
        this.uploadFiles = [];
      },
      submit: function() {
        var self = this;
        VueUtil.loop(VueUtil.filter(self.uploadFiles, function(file) {
          return file.status === 'ready';
        }), function(file) {
          self.$refs['upload-inner'].upload(file.raw);
        });
      },
      getMigratingConfig: function() {
        return {
          props: {
            'default-file-list': 'default-file-list is renamed to file-list.',
            'show-upload-list': 'show-file-list is renamed to show-file-list.',
            'thumbnail-mode': 'thumbnail-mode has been deprecated.'
          }
        };
      }
    },
    render: function(createElement) {
      var uploadList;
      if (this.showFileList) {
        uploadList = createElement('UploadList', {attrs: {disabled: this.disabled, listType: this.listType, files: this.uploadFiles, handlePreview: this.onPreview}, on: {'remove': this.handleRemove}}, []);
      }
      var uploadData = {
        directives: [{
          name: 'show',
          value: this.max == 0 || this.max > this.uploadFiles.length
        }],
        props: {
          type: this.type,
          drag: this.drag,
          action: this.action,
          multiple: this.multiple,
          max: this.max,
          'before-upload': this.beforeUpload,
          'with-credentials': this.withCredentials,
          headers: this.headers,
          name: this.name,
          data: this.data,
          accept: this.accept,
          fileList: this.uploadFiles,
          autoUpload: this.autoUpload,
          listType: this.listType,
          disabled: this.disabled,
          clickable: this.clickable,
          'on-start': this.handleStart,
          'on-progress': this.handleProgress,
          'on-success': this.handleSuccess,
          'on-error': this.handleError,
          'on-preview': this.onPreview,
          'on-remove': this.handleRemove,
          'http-request': this.httpRequest
        },
        ref: 'upload-inner'
      };
      var trigger = this.$slots.trigger || this.$slots.default;
      var uploadComponent = (VueUtil.isDef(FormData)) ? createElement('upload', uploadData, [trigger]) : createElement('iframeUpload', uploadData, [trigger]);
      return createElement('div', null, ['picture-card' === this.listType ? uploadList : '', this.$slots.trigger ? [uploadComponent, this.$slots.default] : uploadComponent, this.$slots.tip, 'picture-card' !== this.listType ? uploadList : '']);
    },
    mounted: function () {
      VueUtil.on(window, 'dragover', handleDragOutside, false);
      VueUtil.on(window, 'drop', handleDragOutside, false);
    },
    beforeDestroy: function() {
      VueUtil.off(window, 'dragover', handleDragOutside);
      VueUtil.off(window, 'drop', handleDragOutside);
    }
  };
  Vue.component(VueUpload.name, VueUpload);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueLoadingBar = definition(context.Vue, context.VueUtil);
    delete context.VueLoadingBar;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var loadingBar = null;
  var intervaler = null;
  var newInstance = function() {
    var loadingBar = document.createElement('div');
    loadingBar.className = 'vue-loading-bar';
    loadingBar.style.display = 'none';
    var innerDiv = document.createElement('div');
    VueUtil.addClass(innerDiv, 'vue-loading-bar-inner');
    VueUtil.addClass(innerDiv, 'vue-loading-bar-inner-color-primary');
    loadingBar.appendChild(innerDiv);
    document.body.appendChild(loadingBar);
    return {
      show: function(options) {
        if (loadingBar.style.display === 'none') {
          loadingBar.style.display = '';
          loadingBar.style.zIndex = VueUtil.nextZIndex();
        }
        if (options.error) {
          VueUtil.addClass(innerDiv, 'vue-loading-bar-inner-color-error');
        } else {
          VueUtil.removeClass(innerDiv, 'vue-loading-bar-inner-color-error');
        }
        if (VueUtil.isDef(options.percent)) {
          innerDiv.style.width = options.percent + '%';
        }
      },
      hide: function() {
        loadingBar.style.display = 'none';
      },
      isShow: function() {
        return (loadingBar.style.display !== 'none');
      }
    };
  };
  var initLoadingBar = function() {
    if (!VueUtil.isDef(loadingBar)) loadingBar = newInstance();
  };
  var hideInstance = VueUtil.debounce(500, function(fn) {
    if (VueUtil.isFunction(fn)) fn();
    loadingBar.hide();
  });
  var VueLoadingBar = {
    start: function(fn) {
      initLoadingBar();
      if (loadingBar.isShow()) return;
      var percent = 0;
      loadingBar.show({percent: percent});
      intervaler = setInterval(function() {
        percent += 6;
        if (percent > 95) {
          clearInterval(intervaler);
          percent = 96;
        }
        loadingBar.show({percent: percent});
      }, 250);
      if (VueUtil.isFunction(fn)) fn();
    },
    update: function(percent, fn) {
      initLoadingBar();
      clearInterval(intervaler);
      loadingBar.show({percent: percent});
      if (VueUtil.isFunction(fn)) fn();
    },
    finish: VueUtil.debounce(function(fn) {
      initLoadingBar();
      clearInterval(intervaler);
      loadingBar.show({percent: 100});
      hideInstance(fn);
    }),
    error: VueUtil.debounce(function(fn) {
      initLoadingBar();
      clearInterval(intervaler);
      loadingBar.show({percent: 100, error: true});
      hideInstance(fn);
    })
  };
  Vue.loadingBar = VueLoadingBar;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueNote = definition(context.Vue);
    delete context.VueNote;
  }
})(this, function(Vue) {
  'use strict';
  var VueNote = {
    template: '<div :class="[\'vue-note\', typeClass, typeBox]"><div class="vue-note__content"><span class="vue-note__title is-bold" v-if="title">{{title}}</span><div class="vue-note__description"><slot></slot></div></div></div>',
    name: 'VueNote',
    props: {
      title: {
        type: String,
        default: ''
      },
      type: {
        type: String,
        default: 'info'
      },
      plain: Boolean
    },
    computed: {
      typeClass: function() {
        return 'vue-note--' + this.type;
      },
      typeBox: function() {
        if (this.plain) {
          return 'vue-note--plain';
        }
      }
    }
  };
  Vue.component(VueNote.name, VueNote);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueList = definition(context.Vue, context.VueUtil);
    delete context.VueList;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueList = {
    name: 'VueList',
    data: function() {
      return {
        defaultSlotLen: 0,
        activedIndex: null,
        keyList: [],
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
      };
    },
    props: {
      height: {
        type: Number,
        default: 200
      },
      onScroll: Function,
      defaultActivedIndex: {
        type: Number,
        default: 0
      },
      defaultSelected: {
        type: Boolean,
        default: true
      },
      scrollbar: Boolean
    },
    methods: {
      updateKeyList: function() {
        if(Array.isArray(this.$slots.default)) {
          this.keyList = this.$slots.default.map(function(item) {
            return item.key;
          });
        }
      },
      setItemIndex: function(item) {
        if(this.$slots.default.length != this.keyList.length) {
          this.updateKeyList();
        }
        item.index = this.keyList.indexOf(item.$vnode.key);
      },
      handleItemClick: function(itemObj) {
        this.activedIndex = itemObj.index;
      },
      handleScroll: function(e, scrollTop, isTop, isBottom) {
        if (!VueUtil.isDef(scrollTop)) {
          scrollTop = this.$el.scrollTop;
          isTop = (scrollTop === 0);
          isBottom = (scrollTop === this.$el.scrollHeight - this.$el.clientHeight);
        }
        this.updateZone(scrollTop);
        this.$emit('scroll', e, scrollTop, isTop, isBottom);
      },
      updateZone: function(offset) {
        var delta = this.delta;
        if (!VueUtil.isDef(delta)) return;
        if (delta.total <= delta.keeps) return;
        offset = offset || 0;
        var overs = Math.floor(offset / delta.size);
        overs < 0 && (overs = 0);
        var start = overs;
        var end = overs + delta.keeps;
        if (overs + delta.keeps >= delta.total) {
          end = delta.total;
          start = delta.total - delta.keeps;
        }
        delta.end = end;
        delta.start = start;
        this.$forceUpdate();
      },
      filter: function(slots) {
        var delta = this.delta;
        if (delta.keeps === 0 || slots.length <= delta.keeps) {
          delta.marginTop = 0;
          delta.marginBottom = 0;
          return slots;
        }
        delta.total = slots.length;
        delta.marginTop = delta.size * delta.start;
        delta.marginBottom = delta.size * (delta.total - delta.keeps - delta.start);
        var result = [];
        for (var i = delta.start, j = delta.end; i < j; i++) {
          result.push(slots[i]);
        }
        return result;
      },
      createDelta: function(slots) {
        var delta = this.delta = Object.create(null);
        delta.start = 0;
        delta.total = 0;
        delta.marginTop = 0;
        delta.marginBottom = 0;
        delta.size = this.isMobile?13:20;
        delta.remain = Math.floor(this.height * 1 / delta.size);
        delta.end = delta.remain;
        delta.keeps = delta.remain;
        if (slots.length <= delta.remain) {
          delta.end = slots.length;
          delta.keeps = slots.length;
        }
      }
    },
    render: function(createElement) {
      var slots = this.$slots.default;
      if (!VueUtil.isArray(slots)) return null;
      if (!VueUtil.isDef(this.delta) || this.defaultSlotLen !== slots.length) {
        this.createDelta(slots);
        this.defaultSlotLen = slots.length;
      }
      var delta = this.delta;
      var showList = this.filter(slots);
      var style = {
        'margin-top': delta.marginTop + 'px',
        'margin-bottom':  delta.marginBottom + 'px'
      };
      if (VueUtil.isChrome) {
        style = {
          'padding-top': delta.marginTop + 'px',
          'padding-bottom':  delta.marginBottom + 'px'
        };
      }
      var list = null;
      if (this.scrollbar) {
        list = createElement('div', {
          'class': ['vue-list'],
          'style': {
            'height': this.isMobile? '100%' : this.height * 1 + 'px'
          }
        }, [createElement('vue-scrollbar', {
            props: {
              height: this.isMobile? '100%' :this.height * 1
            },
            'on': {
              'scrollY': this.handleScroll
            },
            ref: 'scrollbar'
          }, [createElement('div', {
            'style': style
          }, showList)])
        ]);
      } else {
        list = createElement('div', {
          'class': ['vue-list'],
          'style': {
            'height':  this.isMobile? '100%' : this.height * 1 + 'px',
            'overflow': 'auto'
          },
          'on': {
            'scroll': this.handleScroll
          }
        }, [createElement('div', {
            'style': {
              'margin-top': delta.marginTop + 'px',
              'margin-bottom': delta.marginBottom + 'px',
              'height':this.isMobile? '100%' : this.height * 1 + 'px', 
            }
          }, showList)
        ]);
      }
      return list;
    },
    created: function() {
      this.updateKeyList();
    },
    mounted: function() {
      var self = this;
      self.$on('item-click', self.handleItemClick);
      if (self.defaultSelected && self.$slots.default) {
        self.$nextTick(function() {
          var defaultSlot = self.$slots.default[self.defaultActivedIndex];
          defaultSlot && defaultSlot.componentInstance && defaultSlot.componentInstance.handleClick();
        });
      }
    }
  };
  Vue.component(VueList.name, VueList);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueListItem = definition(context.Vue, context.VueUtil);
    delete context.VueListItem;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueListItem = {
    template: '<div :class="[\'vue-list-item\', {\'is-active\': isActive}]" @click="handleClick"><slot></slot></div>',
    name: 'VueListItem',
    mixins: [VueUtil.component.emitter],
    data: function() {
      return {
        index: null
      };
    },
    methods: {
      handleClick: function() {
        this.dispatch('VueList', 'item-click', this);
        this.$emit('select', this);
      }
    },
    computed: {
      list: function() {
        var parent = this.$parent;
        while (parent.$options.name !== 'VueList') {
          parent = parent.$parent;
        }
        return parent;
      },
      isActive: function() {
        return this.list.activedIndex === this.index;
      }
    },
    mounted: function() {
      this.list.setItemIndex(this);
    }
  };
  Vue.component(VueListItem.name, VueListItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueDivider = definition(context.Vue);
    delete context.VueDivider;
  }
})(this, function(Vue) {
  'use strict';
  var VueDivider = {
    template: '<div class="vue-divider"><legend class="vue-divider__content" v-if="$slots.default"><slot></slot></legend></div>',
    name: 'VueDivider'
  };
  Vue.component(VueDivider.name, VueDivider);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VuePopper'], definition);
  } else {
    context.VueColorPicker = definition(context.Vue, context.VueUtil, context.VuePopper);
    delete context.VueColorPicker;
  }
})(this, function(Vue, VueUtil, VuePopper) {
  'use strict';
  var bound01 = function(value, max) {
    var isOnePointZero = function(n) {
      return VueUtil.isString(n) && n.indexOf('.') !== -1 && parseFloat(n) === 1;
    };
    var isPercentage = function(n) {
      return VueUtil.isString(n) && n.indexOf('%') !== -1;
    };
    if (isOnePointZero(value)) value = '100%';
    var processPercent = isPercentage(value);
    value = Math.min(max, Math.max(0, parseFloat(value)));
    if (processPercent) {
      value = parseInt(value * max, 10) / 100;
    }
    if ((Math.abs(value - max) < 0.000001)) {
      return 1;
    }
    return (value % max) / parseFloat(max);
  };
  var rgb2hsv = function(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h,
      s;
    var v = max;
    var d = max - min;
    s = max === 0 ? 0 : d / max;
    if (max === min) {
      h = 0;
    } else {
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }
    return {
      h: h * 360,
      s: s * 100,
      v: v * 100
    };
  };
  var hsv2rgb = function(h, s, v) {
    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    var i = Math.floor(h);
    var f = h - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    var mod = i % 6;
    var r = [v, q, p, p, t, v][mod];
    var g = [t, v, v, q, p, p][mod];
    var b = [p, p, t, v, v, q][mod];
    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  };
  var Color = function(options) {
    var self = this;
    self._hue = 0;
    self._saturation = 100;
    self._value = 100;
    self._alpha = 100;
    self.enableAlpha = false;
    self.format = 'hex';
    self.value = '';
    options = options || {};
    VueUtil.ownPropertyLoop(options, function(option) {
      self[option] = options[option];
    });
    self.doOnChange();
  };
  Color.prototype.set = function(prop, value) {
    var self = this;
    if (arguments.length === 1 && VueUtil.isObject(prop)) {
      VueUtil.ownPropertyLoop(prop, function(p) {
        self.set(p, prop[p]);
      });
      return;
    }
    self['_' + prop] = value;
    self.doOnChange();
  };
  Color.prototype.get = function(prop) {
    return this['_' + prop];
  };
  Color.prototype.toRgb = function() {
    return hsv2rgb(this._hue, this._saturation, this._value);
  };
  Color.prototype.fromString = function(value) {
    var self = this;
    if (!value) {
      this._hue = 0;
      this._saturation = 100;
      this._value = 100;
      this.doOnChange();
      return;
    }
    var fromHSV = function(h, s, v) {
      self._hue = h;
      self._saturation = s;
      self._value = v;
      self.doOnChange();
    };
    if (value.indexOf('hsl') !== -1) {
      var parts = VueUtil.map(VueUtil.filter(value.replace(/hsla|hsl|\(|\)/gm, '').split(/\s|,/g), function(val) {return val !== '';}), function(val, index) {return index > 2 ? parseFloat(val) : parseInt(val, 10);});
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      }
      if (parts.length >= 3) {
        var hsl2hsv = function(hue, sat, light) {
          sat = sat / 100;
          light = light / 100;
          var smin = sat;
          var lmin = Math.max(light, 0.01);
          var sv;
          var v;
          light *= 2;
          sat *= (light <= 1) ? light : 2 - light;
          smin *= lmin <= 1 ? lmin : 2 - lmin;
          v = (light + sat) / 2;
          sv = light === 0 ? (2 * smin) / (lmin + smin) : (2 * sat) / (light + sat);
          return {
            h: hue,
            s: sv * 100,
            v: v * 100
          };
        };
        var _hsl2hsv = hsl2hsv(parts[0], parts[1], parts[2]);
        var h = _hsl2hsv.h;
        var s = _hsl2hsv.s;
        var v = _hsl2hsv.v;
        fromHSV(h, s, v);
      }
    } else if (value.indexOf('hsv') !== -1) {
      var parts = VueUtil.map(VueUtil.filter(value.replace(/hsva|hsv|\(|\)/gm, '').split(/\s|,/g), function(val) {return val !== '';}), function(val, index) {return index > 2 ? parseFloat(val) : parseInt(val, 10);});
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      }
      if (parts.length >= 3) {
        fromHSV(parts[0], parts[1], parts[2]);
      }
    } else if (value.indexOf('rgb') !== -1) {
      var parts = VueUtil.map(VueUtil.filter(value.replace(/rgba|rgb|\(|\)/gm, '').split(/\s|,/g), function(val) {return val !== '';}), function(val, index) {return index > 2 ? parseFloat(val) : parseInt(val, 10);});
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      }
      if (parts.length >= 3) {
        var _rgb2hsv = rgb2hsv(parts[0], parts[1], parts[2]);
        var h = _rgb2hsv.h;
        var s = _rgb2hsv.s;
        var v = _rgb2hsv.v;
        fromHSV(h, s, v);
      }
    } else if (value.indexOf('#') !== -1) {
      var hex = value.replace('#', '').trim();
      var r, g, b;
      var parseHexChannel = function(hex) {
        var HEX_INT_MAP = {A: 10, B: 11, C: 12, D: 13, E: 14, F: 15};
        if (hex.length === 2) {
          return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
        }
        return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
      };
      if (hex.length === 3) {
        r = parseHexChannel(hex[0] + hex[0]);
        g = parseHexChannel(hex[1] + hex[1]);
        b = parseHexChannel(hex[2] + hex[2]);
      } else if (hex.length === 6) {
        r = parseHexChannel(hex.substring(0, 2));
        g = parseHexChannel(hex.substring(2, 4));
        b = parseHexChannel(hex.substring(4));
      }
      var _rgb2hsv = rgb2hsv(r, g, b);
      var h = _rgb2hsv.h;
      var s = _rgb2hsv.s;
      var v = _rgb2hsv.v;
      fromHSV(h, s, v);
    }
  };
  Color.prototype.doOnChange = function() {
    var _hue = this._hue;
    var _saturation = this._saturation;
    var _value = this._value;
    var _alpha = this._alpha;
    var format = this.format;
    var hsv2hsl = function(hue, sat, val) {
      return [hue, (sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue)) || 0, hue / 2];
    };
    if (this.enableAlpha) {
      switch (format) {
        case 'hsl':
          var hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = 'hsla(' + _hue + ', ' + Math.round(hsl[1] * 100) + '%, ' + Math.round(hsl[2] * 100) + '%, ' + _alpha / 100 + ')';
          break;
        case 'hsv':
          this.value = 'hsva(' + _hue + ', ' + Math.round(_saturation) + '%, ' + Math.round(_value) + '%, ' + _alpha / 100 + ')';
          break;
        default:
          var _hsv2rgb = hsv2rgb(_hue, _saturation, _value);
          var r = _hsv2rgb.r;
          var g = _hsv2rgb.g;
          var b = _hsv2rgb.b;
          this.value = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + _alpha / 100 + ')';
      }
    } else {
      switch (format) {
        case 'hsl':
          var hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = 'hsl(' + _hue + ', ' + Math.round(_hsl[1] * 100) + '%, ' + Math.round(_hsl[2] * 100) + '%)';
          break;
        case 'hsv':
          this.value = 'hsv(' + _hue + ', ' + Math.round(_saturation) + '%, ' + Math.round(_value) + '%)';
          break;
        case 'rgb':
          var _hsv2rgb2 = hsv2rgb(_hue, _saturation, _value);
          var r = _hsv2rgb2.r;
          var g = _hsv2rgb2.g;
          var b = _hsv2rgb2.b;
          this.value = 'rgb(' + r + ', ' + g + ', ' + b + ')';
          break;
        default:
          var toHex = function(ref) {
            var r = ref.r;
            var g = ref.g;
            var b = ref.b;
            var INT_HEX_MAP = {10: 'A', 11: 'B', 12: 'C', 13: 'D', 14: 'E', 15: 'F'};
            var hexOne = function(value) {
              value = Math.min(Math.round(value), 255);
              var high = Math.floor(value / 16);
              var low = value % 16;
              return '' + (INT_HEX_MAP[high] || high) + (INT_HEX_MAP[low] || low);
            };
            if (isNaN(r) || isNaN(g) || isNaN(b)) return '';
            return '#' + hexOne(r) + hexOne(g) + hexOne(b);
          };
          this.value = toHex(hsv2rgb(_hue, _saturation, _value));
      }
    }
  };
  var draggable = function(element, options) {
    var isDragging = false;
    var moveFn = function(event) {
      if (options.drag) {
        options.drag(event);
      }
    };
    var upFn = function(event) {
      if (options.end) {
        options.end(event);
      }
      VueUtil.removeTouchMove(document, moveFn);
      VueUtil.removeTouchEnd(document, upFn);
      document.onselectstart = null;
      document.ondragstart = null;
      isDragging = false;
    };
    var downFn = function(event) {
      if (isDragging) return;
      if (options.start) {
        options.start(event);
      }
      VueUtil.addTouchMove(document, moveFn);
      VueUtil.addTouchEnd(document, upFn);
      document.onselectstart = function() {return false;};
      document.ondragstart = function() {return false;};
      isDragging = true;
    };
    VueUtil.addTouchStart(element, downFn);
  };
  var SvPanel = {
    template: '<div class="vue-color-svpanel" :style="{backgroundColor: background}"><div class="vue-color-svpanel__white"></div><div class="vue-color-svpanel__black"></div><div class="vue-color-svpanel__cursor" :style="{top: cursorTop + \'px\', left: cursorLeft + \'px\'}"><div></div></div></div>',
    props: {
      color: {
        required: true,
      }
    },
    computed: {
      colorValue: function() {
        var hue = this.color.get('hue');
        var value = this.color.get('value');
        return {hue: hue, value: value};
      }
    },
    watch: {
      colorValue: function() {
        this.update();
      }
    },
    methods: {
      update: function() {
        var saturation = this.color.get('saturation');
        var value = this.color.get('value');
        var el = this.$el;
        var boundingClientRect = el.getBoundingClientRect();
        var width = boundingClientRect.width;
        var height = boundingClientRect.height;
        if (!height) height = width * 3 / 4;
        this.cursorLeft = saturation * width / 100;
        this.cursorTop = (100 - value) * height / 100;
        this.background = 'hsl(' + this.color.get('hue') + ', 100%, 50%)';
      },
      handleDrag: function(event) {
        if (!VueUtil.isDef(event.clientX) && event.touches.length === 0) return;
        var el = this.$el;
        var rect = el.getBoundingClientRect();
        var left = (event.clientX || event.touches[0].clientX) - rect.left;
        var top = (event.clientY || event.touches[0].clientY) - rect.top;
        left = Math.max(0, left);
        left = Math.min(left, rect.width);
        top = Math.max(0, top);
        top = Math.min(top, rect.height);
        this.cursorLeft = left;
        this.cursorTop = top;
        this.color.set({
          saturation: left / rect.width * 100,
          value: 100 - top / rect.height * 100
        });
      }
    },
    mounted: function() {
      var self = this;
      draggable(self.$el, {
        start: function(event) {
          self.handleDrag(event);
        },
        drag: function(event) {
          self.handleDrag(event);
        },
        end: function(event) {
          self.handleDrag(event);
        }
      });
      self.update();
    },
    data: function() {
      return {
        cursorTop: 0,
        cursorLeft: 0,
        background: 'hsl(0, 100%, 50%)'
      };
    }
  };
  var HueSlider = {
    template: '<div :class="[\'vue-color-hue-slider\', {\'is-vertical\': vertical}]"><div class="vue-color-hue-slider__bar" @click="handleClick" ref="bar"></div><div class="vue-color-hue-slider__thumb" :style="{left: thumbLeft + \'px\', top: thumbTop + \'px\'}" ref="thumb"></div></div>',
    props: {
      color: {
        required: true
      },
      vertical: Boolean
    },
    data: function() {
      return {
        thumbLeft: 0,
        thumbTop: 0
      };
    },
    computed: {
      hueValue: function() {
        var hue = this.color.get('hue');
        return hue;
      }
    },
    watch: {
      hueValue: function() {
        this.update();
      }
    },
    methods: {
      handleClick: function(event) {
        var thumb = this.$refs.thumb;
        var target = event.target;
        if (target !== thumb) {
          this.handleDrag(event);
        }
      },
      handleDrag: function(event) {
        if (!VueUtil.isDef(event.clientX) && event.touches.length === 0) return;
        var rect = this.$el.getBoundingClientRect();
        var thumb = this.$refs.thumb;
        var hue;
        if (!this.vertical) {
          var thumbWidth = thumb.offsetWidth;
          var left = (event.clientX || event.touches[0].clientX) - rect.left;
          left = Math.min(left, rect.width - thumbWidth / 2);
          left = Math.max(thumbWidth / 2, left);
          hue = Math.round((left - thumbWidth / 2) / (rect.width - thumbWidth) * 360);
        } else {
          var thumbHeight = thumb.offsetHeight;
          var top = (event.clientY || event.touches[0].clientY) - rect.top;
          top = Math.min(top, rect.height - thumbHeight / 2);
          top = Math.max(thumbHeight / 2, top);
          hue = Math.round((top - thumbHeight / 2) / (rect.height - thumbHeight) * 360);
        }
        this.color.set('hue', hue);
      },
      getThumbLeft: function() {
        if (this.vertical) return 0;
        var el = this.$el;
        var hue = this.color.get('hue');
        if (!el) return 0;
        var thumb = this.$refs.thumb;
        return Math.round(hue * (el.offsetWidth - thumb.offsetWidth / 2) / 360);
      },
      getThumbTop: function() {
        if (!this.vertical) return 0;
        var el = this.$el;
        var hue = this.color.get('hue');
        if (!el) return 0;
        var thumb = this.$refs.thumb;
        return Math.round(hue * (el.offsetHeight - thumb.offsetHeight / 2) / 360);
      },
      update: function() {
        this.thumbLeft = this.getThumbLeft();
        this.thumbTop = this.getThumbTop();
      }
    },
    mounted: function() {
      var self = this;
      var _$refs = self.$refs;
      var bar = _$refs.bar;
      var thumb = _$refs.thumb;
      var dragConfig = {
        start: function(event) {
          self.handleDrag(event);
        },
        drag: function(event) {
          self.handleDrag(event);
        },
        end: function(event) {
          self.handleDrag(event);
        }
      };
      draggable(bar, dragConfig);
      draggable(thumb, dragConfig);
      self.update();
    }
  };
  var AlphaSlider = {
    template: '<div :class="[\'vue-color-alpha-slider\', {\'is-vertical\': vertical}]"><div class="vue-color-alpha-slider__bar" @click="handleClick" ref="bar" :style="{background: background}"></div><div class="vue-color-alpha-slider__thumb" ref="thumb" :style="{left: thumbLeft + \'px\', top: thumbTop + \'px\'}"></div></div>',
    props: {
      color: {
        required: true
      },
      vertical: Boolean
    },
    watch: {
      'color._alpha': function() {
        this.update();
      },
      'color.value': function() {
        this.update();
      }
    },
    methods: {
      handleClick: function(event) {
        var thumb = this.$refs.thumb;
        var target = event.target;
        if (target !== thumb) {
          this.handleDrag(event);
        }
      },
      handleDrag: function(event) {
        if (!VueUtil.isDef(event.clientX) && event.touches.length === 0) return;
        var rect = this.$el.getBoundingClientRect();
        var thumb = this.$refs.thumb;
        if (!this.vertical) {
          var thumbWidth = thumb.offsetWidth;
          var left = (event.clientX || event.touches[0].clientX) - rect.left;
          left = Math.max(thumbWidth / 2, left);
          left = Math.min(left, rect.width - thumbWidth / 2);
          this.color.set('alpha', Math.round((left - thumbWidth / 2) / (rect.width - thumbWidth) * 100));
        } else {
          var thumbHeight = thumb.offsetHeight;
          var top = (event.clientY || event.touches[0].clientY) - rect.top;
          top = Math.max(thumbHeight / 2, top);
          top = Math.min(top, rect.height - thumbHeight / 2);
          this.color.set('alpha', Math.round((top - thumbHeight / 2) / (rect.height - thumbHeight) * 100));
        }
      },
      getThumbLeft: function() {
        if (this.vertical) return 0;
        var el = this.$el;
        var alpha = this.color._alpha;
        if (!el) return 0;
        var thumb = this.$refs.thumb;
        return Math.round(alpha * (el.offsetWidth - thumb.offsetWidth / 2) / 100);
      },
      getThumbTop: function() {
        if (!this.vertical) return 0;
        var el = this.$el;
        var alpha = this.color._alpha;
        if (!el) return 0;
        var thumb = this.$refs.thumb;
        return Math.round(alpha * (el.offsetHeight - thumb.offsetHeight / 2) / 100);
      },
      getBackground: function() {
        if (this.color && this.color.value) {
          var colorToRgb = this.color.toRgb();
          var r = colorToRgb.r;
          var g = colorToRgb.g;
          var b = colorToRgb.b;
          return 'linear-gradient(to right, rgba(' + r + ', ' + g + ', ' + b + ', 0) 0%, rgba(' + r + ', ' + g + ', ' + b + ', 1) 100%)';
        }
        return null;
      },
      update: function() {
        this.thumbLeft = this.getThumbLeft();
        this.thumbTop = this.getThumbTop();
        this.background = this.getBackground();
      }
    },
    data: function() {
      return {
        thumbLeft: 0,
        thumbTop: 0,
        background: null
      };
    },
    mounted: function() {
      var self = this;
      var _$refs = self.$refs;
      var bar = _$refs.bar;
      var thumb = _$refs.thumb;
      var dragConfig = {
        start: function(event) {
          self.handleDrag(event);
        },
        drag: function(event) {
          self.handleDrag(event);
        },
        end: function(event) {
          self.handleDrag(event);
        }
      };
      draggable(bar, dragConfig);
      draggable(thumb, dragConfig);
      self.update();
    }
  };
  var PickerDropdown = {
    template: '<transition @after-leave="destroyPopper">\
                <div class="vue-color-dropdown" v-show="showPopper">\
                  <div class="vue-color-dropdown__main-wrapper">\
                    <hue-slider ref="hue" :color="color" vertical style="float: right;"></hue-slider>\
                    <sv-panel ref="sl" :color="color"></sv-panel>\
                  </div>\
                  <alpha-slider v-if="showAlpha" ref="alpha" :color="color"></alpha-slider>\
                  <div class="vue-color-dropdown__btns">\
                    <vue-row type="flex" justify="space-between">\
                      <vue-col :span="14"><vue-input size="small" class="vue-color-dropdown__value" v-model="currentColor" @blur="formatColor"></vue-input></vue-col>\
                      <vue-col :span="10">\
                        <vue-button type="text" @click="$emit(\'clear\')">{{$t(\'vue.colorpicker.clear\')}}</vue-button>\
                        <vue-button @click="confirmValue">{{$t(\'vue.colorpicker.confirm\')}}</vue-button>\
                      </vue-col></vue-row></div></div></transition>',
    mixins: [VuePopper],
    components: {
      SvPanel: SvPanel,
      HueSlider: HueSlider,
      AlphaSlider: AlphaSlider
    },
    props: {
      color: {
        required: true
      },
      showAlpha: Boolean
    },
    data: function() {
      return {
        currentColor: null
      };
    },
    methods: {
      confirmValue: function() {
        this.$emit('pick');
      },
      formatColor: function() {
        this.$parent.color.fromString(this.currentColor);
      }
    },
    mounted: function() {
      this.$parent.popperElm = this.popperElm = this.$el;
      this.referenceElm = this.$parent.$el;
    },
    watch: {
      '$parent.color.value': function(val) {
        this.currentColor = val;
      },
      showPopper: function(val) {
        var self = this;
        if (val === true) {
          self.$nextTick(function() {
            var _$refs = self.$refs;
            var sl = _$refs.sl;
            var hue = _$refs.hue;
            var alpha = _$refs.alpha;
            sl && sl.update();
            hue && hue.update();
            alpha && alpha.update();
          });
        }
      }
    }
  };
  var VueColorPicker = {
    template: '<div class="vue-color-picker" :class="[disabled ? \'is-disabled\' : \'\']" v-clickoutside="hide" v-scrolling="hide"> \
                <div class="vue-color-picker__mask" v-if="disabled"></div> \
                <div class="vue-color-picker__trigger" @click="handleTrigger"> \
                  <slot>\
                  <span :class="[\'vue-color-picker__color\', {\'is-alpha\': showAlpha}]">\
                    <span class="vue-color-picker__color-inner" :style="{backgroundColor: displayedColor}"></span> \
                    <span class="vue-color-picker__empty vue-icon-close" v-if="!value && !showPanelColor"></span> \
                  </span> \
                  <span class="vue-color-picker__icon vue-icon-arrow-down"></span>\
                  </slot>\
                </div> \
                <picker-dropdown ref="dropdown" \
                  class="vue-color-picker__panel" v-model="showPicker" @pick="confirmValue" @clear="clearValue" :color="color" \
                  :show-alpha="showAlpha">\
                </picker-dropdown> \
                <div @touchmove.prevent v-if="isMobile && showPicker" class="color_dropdown_mask_view" @click="showPicker=false"></div> \
              </div>',
    name: 'VueColorPicker',
    props: {
      value: String,
      showAlpha: Boolean,
      colorFormat: String,
      disabled: Boolean
    },
    directives: {
      Clickoutside: VueUtil.component.clickoutside(),
      Scrolling: VueUtil.component.scrolling
    },
    computed: {
      displayedColor: function() {
        if (!this.value && !this.showPanelColor) {
          return 'transparent';
        } else {
          var colorToRgb = this.color.toRgb();
          var r = colorToRgb.r;
          var g = colorToRgb.g;
          var b = colorToRgb.b;
          return this.showAlpha ? 'rgba(' + r + ', ' + g + ', ' + b + ', ' + this.color.get('alpha') / 100 + ')' : 'rgb(' + r + ', ' + g + ', ' + b + ')';
        }
      }
    },
    watch: {
      value: function(val) {
        if (!val) {
          this.showPanelColor = false;
        } else if (val !== this.color.value) {
          this.color.fromString(val);
        }
      },
      color: {
        deep: true,
        handler: function() {
          this.showPanelColor = true;
        }
      },
      disabled: function(val) {
        if(val === true) {
          this.showPicker = false;
        }
      }
    },
    methods: {
      handleTrigger: function() {
        if (this.disabled) return;
        this.showPicker = !this.showPicker;
      },
      confirmValue: function(value) {
        this.$emit('input', this.color.value);
        this.$emit('change', this.color.value);
        this.showPicker = false;
      },
      clearValue: function() {
        this.$emit('input', null);
        this.$emit('change', null);
        this.showPanelColor = false;
        this.showPicker = false;
        this.resetColor();
      },
      hide: function() {
        this.showPicker = false;
        this.resetColor();
      },
      resetColor: function() {
        var self = this;
        self.$nextTick(function() {
          if (self.value) {
            self.color.fromString(self.value);
          } else {
            self.showPanelColor = false;
          }
        });
      }
    },
    mounted: function() {
      var value = this.value;
      if (value) {
        this.color.fromString(value);
      }
      this.popperElm = this.$refs.dropdown.$el;
    },
    data: function() {
      var color = new Color({
        enableAlpha: this.showAlpha,
        format: this.colorFormat
      });
      return {
        color: color,
        showPicker: false,
        showPanelColor: false,
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
      };
    },
    components: {
      PickerDropdown: PickerDropdown
    }
  };
  Vue.component(VueColorPicker.name, VueColorPicker);
});

(function(context, definition) {
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VueDatePicker'], definition);
  } else {
    context.VueCalendar = definition(context.Vue, context.VueUtil, context.VueDatePicker);
    delete context.VueCalendar;
    delete context.VueDatePicker;
    delete context.VuePicker;
  }
})(this, function(Vue, VueUtil, VueDatePicker) {
  'use strict';
  var EventCard = {
    props: {
      date: Date,
      firstDay: Number,
      event: Object
    },
    data: function() {
      return {
        defaultWidth: 0
      };
    },
    render: function(createElement) {
      if (this.defaultWidth === 0) return;
      var self = this;
      var event = self.event;
      var start = VueUtil.parseDate(event.start);
      var end = VueUtil.parseDate(event.end);
      var showTitile = (self.date.getDay() === self.firstDay || VueUtil.formatDate(start) === VueUtil.formatDate(self.date));
      var eventItem = createElement('div', {class: ['vue-full-calendar__event-item', 'is-opacity']}, []);
      if (showTitile) {
        var dateCount = Math.floor((end.getTime() - self.date.getTime()) / 86400000) + 1;
        var lastDayCount = 7 - self.date.getDay();
        var defaultWidth = self.defaultWidth;
        var isEnd = false;
        if (lastDayCount >= dateCount) {
          defaultWidth = defaultWidth * dateCount;
          isEnd = true;
        } else {
          defaultWidth = defaultWidth * lastDayCount;
        }
        if (isEnd) defaultWidth = defaultWidth - 4;
        var eventClass = [];
        var customClass = event.customClass;
        if (VueUtil.isDef(customClass)) {
          VueUtil.mergeArray(eventClass, customClass);
        }
        if (VueUtil.formatDate(start) === VueUtil.formatDate(self.date)) {
          eventClass.push('is-start');
          defaultWidth = defaultWidth - 4;
        }
        eventClass = eventClass.join(' ');
        var mouseenterItem = function(eventCards, event) {
          VueUtil.loop(eventCards, function(card) {
            if (card.event.cellIndex === event.cellIndex
              && VueUtil.formatDate(event.start) === VueUtil.formatDate(card.event.start)
              && VueUtil.formatDate(event.end) === VueUtil.formatDate(card.event.end)) {
              card.$refs.eventItem && card.$refs.eventItem.classList.add('hover');
            }
          });
        };
        var mouseleaveItem = function(eventCards, event) {
          VueUtil.loop(eventCards, function(card) {
            if (card.event.cellIndex === event.cellIndex
              && VueUtil.formatDate(event.start) === VueUtil.formatDate(card.event.start)
              && VueUtil.formatDate(event.end) === VueUtil.formatDate(card.event.end)) {
              card.$refs.eventItem && card.$refs.eventItem.classList.remove('hover');
            }
          });
        };
        var eventCards = self.$parent.$refs.eventCard;
        eventItem = createElement('div', null, [createElement('div', {
          domProps: {innerHTML: event.title},
          class: ['vue-full-calendar__event-item', eventClass, {'is-opacity': !event.isShow}],
          style: {'position': 'absolute', 'width': defaultWidth + 'px'},
          ref: 'eventItem',
          attrs: {title: event.tooltip || event.title},
          on: {
            click: function(e) {
              self.$emit('click', event, e);
            },
            mouseenter: function(e) {mouseenterItem(eventCards, event);},
            mouseleave: function(e) {mouseleaveItem(eventCards, event);}
          },
        }), createElement('div', {class: ['vue-full-calendar__event-item', 'is-opacity']}, [])]);
      }
      return eventItem;
    }
  };
  var FcHeader = {
    template: '<div class="vue-full-calendar-header"><div class="vue-full-calendar-header__left"><slot name="fcLeftHeader"></slot></div><div class="vue-full-calendar-header__center"><button type="button" @click="changeMonth(-1 , \'year\')" class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-d-arrow-left"></button><button type="button" @click="changeMonth(-1, \'month\')" class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-arrow-left"></button><vue-popover trigger="click"><year-table @pick="handleYearPick" :year="currentMonth.getFullYear()"></year-table><span slot="reference" class="vue-date-picker__header-label">{{yearLabel}}</span></vue-popover><vue-popover trigger="click"><month-table @pick="handleMonthPick" :month="currentMonth.getMonth()"></month-table><span slot="reference" :class="[\'vue-date-picker__header-label\']">{{monthLabel}}</span></vue-popover><button type="button" @click="changeMonth(1 , \'year\')" class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-d-arrow-right"></button><button type="button" @click="changeMonth(1 , \'month\')" class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-arrow-right"></button></div><div class="vue-full-calendar-header__right"><slot name="fcRightHeader"></slot><span class="thisMonth" @click="changeToNow" v-if="!$slots.fcRightHeader">{{$t(\'vue.datepicker.thisMonth\')}}</span></div></div>',
    props: {
      currentMonth: Date,
      firstDay: Number
    },
    components: {
      YearTable: VueDatePicker().YearTable,
      MonthTable: VueDatePicker().MonthTable
    },
    computed: {
      monthLabel: function() {
        var month = this.currentMonth.getMonth() + 1;
        return this.$t('vue.datepicker.month' + month);
      },
      yearLabel: function() {
        var year = this.currentMonth.getFullYear();
        if (!year) return '';
        var yearTranslation = this.$t('vue.datepicker.year');
        return year + ' ' + yearTranslation;
      }
    },
    methods: {
      handleYearPick: function(year) {
        var result = new Date();
        this.currentMonth.setFullYear(year);
        result.setTime(this.currentMonth.getTime());
        this.$emit('change', result);
      },
      handleMonthPick: function(month) {
        var result = new Date();
        this.currentMonth.setMonth(month);
        result.setTime(this.currentMonth.getTime());
        this.$emit('change', result);
      },
      changeMonth: function(num, type) {
        var newMonth = VueUtil.addDate(this.currentMonth, num, type);
        this.$emit('change', newMonth);
      },
      changeToNow: function() {
        this.$emit('change', new Date);
      }
    }
  };
  var FullCalendar = {
    template: '<div class="vue-full-calendar" :style="compStyle">                                                                                                    \
                <fc-header :current-month="currentMonth" :first-day="firstDay" @change="emitChangeMonth">                                                            \
                  <slot slot="fcLeftHeader" name="fcHeaderLeft"></slot>                                                                                              \
                  <slot slot="fcRightHeader" name="fcHeaderRight"></slot>                                                                                            \
                </fc-header>                                                                                                                                         \
                <div class="vue-full-calendar-body">                                                                                                                 \
                  <div v-if="weekLabel" class="vue-full-calendar__weeks">                                                                                            \
                    <div class="vue-full-calendar__week" v-for="(week, weekIndex) in WEEKS" :key="weekIndex">{{$t(weekLabel[week])}}</div></div>                     \
                  <div v-else class="vue-full-calendar__weeks">                                                                                                      \
                    <div class="vue-full-calendar__week" v-for="(week, weekIndex) in WEEKS" :key="weekIndex">{{$t(\'vue.datepicker.weeks.\'+week)}}</div></div>      \
                  <div class="vue-full-calendar__dates">                                                                                                             \
                    <div class="vue-full-calendar__dates-events">                                                                                                    \
                      <div class="vue-full-calendar__events-week" v-for="(week,weekIndex) in currentDates" :key="weekIndex">                                         \
                        <div v-for="(day, dayIndex) in week" :style="eventDayStyle" :key="dayIndex"                                                                  \
                    :class="[\'vue-full-calendar__events-day\', {\'today\': day.isToday}, day.dayClass]" ref="eventsDay">                                            \
                          <div :class="[\'day-number\']" @mouseenter="mouseenterDay" @mouseleave="mouseleaveDay"                                                     \
                    @click="dayclick(day.date, $event)">{{day.monthDay}}</div>                                                                                       \
                          <div class="vue-full-calendar__event-box">                                                                                                 \
                            <event-card ref="eventCard" :event="event" :date="day.date" :firstDay="firstDay"                                                         \
                      v-for="(event, eventIndex) in day.events" :key="eventIndex" v-show="event.cellIndex <= eventLimit"                                             \
                      @click="eventclick"></event-card>                                                                                                              \
                            <vue-popover trigger="click" v-if="day.events.length > eventLimit && showMore">                                                          \
                              <div class="vue-full-calendar__more-events">                                                                                           \
                                <ul class="events-list">                                                                                                             \
                                  <li v-for="(event, eventIndex) in selectDay.showEvents" :key="eventIndex"                                                          \
                        :class="[\'vue-full-calendar__event-item\', event.customClass]" @click="eventclick(event, $event)"                                           \
                        @mouseenter="mouseenterEvent(event, $event)" @mouseleave="mouseleaveEvent(event, $event)"                                                    \
                        :title="event.title">{{event.title}}</li></ul>                                                                                               \
                              </div>                                                                                                                                 \
                              <div slot="reference" class="more-link" @click="moreclick(day, $event)">+ {{day.moreCount}}</div></vue-popover>                        \
                            <div v-if="day.events.length > eventLimit && !showMore" class="more-link" @click="moreclick(day, $event)">+{{day.moreCount}}</div></div> \
                        </div>                                                                                                                                       \
                      </div>                                                                                                                                         \
                    </div>                                                                                                                                           \
                  </div>                                                                                                                                             \
                </div>                                                                                                                                               \
              </div>',
    props: {
      events: Array,
      eventLimit: Number,
      showMore: Boolean,
      dateClass: Array,
      weekClass: Array,
      weekLabel: Object,
      disabledDates: Function
    },
    components: {
      EventCard: EventCard,
      FcHeader: FcHeader
    },
    mounted: function() {
      this.emitChangeMonth(this.currentMonth);
      VueUtil.addResizeListener(this.$el, this.changeEventCardWidth);
    },
    beforeDestroy: function() {
      this.$el && VueUtil.removeResizeListener(this.$el, this.changeEventCardWidth);
    },
    data: function() {
      return {
        currentMonth: new Date,
        firstDay: 0,
        selectDay: {}
      };
    },
    computed: {
      currentDates: function() {
        return this.getCalendar();
      },
      WEEKS: function() {
        var WEEKS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
        var week = this.firstDay;
        return VueUtil.mergeArray(WEEKS, WEEKS).slice(week, week + 7);
      },
      eventDayStyle: function() {
        var style = {};
        var height = (this.eventLimit + 2) * 20;
        style.height = height + 'px';
        return style;
      },
      compStyle: function() {
        var style = {};
        var width = (this.eventLimit + 2) * 20 * 7 + 43;
        var height = (this.eventLimit + 2) * 20 * 7 + 63 - this.eventLimit * 20;
        style.width = width + 'px';
        style.height = height + 'px';
        return style;
      }
    },
    watch: {
      events: function(val) {
        this.$nextTick(this.changeEventCardWidth);
      }
    },
    methods: {
      changeEventCardWidth: function() {
        var eventCard = this.$refs.eventCard;
        var defaultWidth = parseFloat(VueUtil.getStyle(this.$refs.eventsDay[0], 'width'));
        if (VueUtil.isArray(eventCard)) {
          VueUtil.loop(eventCard, function(card) {
            card.defaultWidth = defaultWidth;
          });
        } else if(VueUtil.isDef(eventCard)) {
          eventCard.defaultWidth = defaultWidth;
        }
      },
      getStartDateOfMonth: function(year, month) {
        var result = new Date(year, month, 1);
        var day = result.getDay();
        if (day === 0) day = 7;
        result.setTime(result.getTime() - 86400000 * day);
        return result;
      },
      emitChangeMonth: function(firstDayOfMonth) {
        this.currentMonth = firstDayOfMonth;
        var start = this.getStartDateOfMonth(firstDayOfMonth.getFullYear(), firstDayOfMonth.getMonth());
        var end = VueUtil.addDate(start, 6, 'week');
        this.$nextTick(this.changeEventCardWidth);
        this.$emit('changemonth', start, end, firstDayOfMonth);
      },
      getCalendar: function() {
        var monthViewStartDate = this.getStartDateOfMonth(this.currentMonth.getFullYear(), this.currentMonth.getMonth());
        var calendar = [];
        var dateClassAry = this.dateClass;
        var weekClassAry = this.weekClass;
        for (var perWeek = 0; perWeek < 6; perWeek++) {
          var week = [];
          for (var perDay = 0; perDay < 7; perDay++) {
            var dayClass = [];
            if (VueUtil.isFunction(this.disabledDates)) {
              if (this.disabledDates(monthViewStartDate)) {
                VueUtil.mergeArray(dayClass, 'disabled');
              }
            }

            VueUtil.loop(dateClassAry, function(dateClass) {
              var time = monthViewStartDate.getTime();
              var st;
              var ed;
              if(dateClass.date) {
                st = VueUtil.parseDate(dateClass.date).getTime();
                ed = st;
              } else {
                st = VueUtil.parseDate(dateClass.start).getTime();
                ed = VueUtil.parseDate(dateClass.end ? dateClass.end : st).getTime();
              }

              if (time >= st && time <= ed) {
                VueUtil.mergeArray(dayClass, dateClass.customClass);
              }
            });
            VueUtil.loop(weekClassAry, function(weekClass) {
              if (weekClass.week === perDay) {
                VueUtil.mergeArray(dayClass, weekClass.customClass);
              }
            });
            week.push({
              monthDay: monthViewStartDate.getDate(),
              isToday: (VueUtil.formatDate(monthViewStartDate) === VueUtil.formatDate(new Date)),
              weekDay: perDay,
              date: monthViewStartDate,
              events: this.slotEvents(monthViewStartDate),
              dayClass: dayClass
            });
            monthViewStartDate = VueUtil.addDate(monthViewStartDate, 1);
          }
          var self = this;
          VueUtil.loop(week, function(day) {
            day.showEvents = VueUtil.filter(day.events, function(event) {
              return event.isShow === true;
            });
            day.moreCount = 0;
            VueUtil.loop(day.showEvents, function(event) {
              if (event.cellIndex > self.eventLimit) {
                day.moreCount++;
              }
            });
          });
          calendar.push(week);
        }
        return calendar;
      },
      slotEvents: function(date) {
        var cellIndexArr = [];
        var events = VueUtil.mergeArray([], this.events);
        var thisDayEvents = VueUtil.filter(events, function(day) {
          var st = VueUtil.parseDate(day.start).getTime();
          var ed = VueUtil.parseDate(day.end ? day.end : st).getTime();
          var de = VueUtil.parseDate(date).getTime();
          return (de >= st && de <= ed);
        });
        for (var i = 0; i < thisDayEvents.length; i++) {
          thisDayEvents[i].cellIndex = thisDayEvents[i].cellIndex || (i + 1);
          thisDayEvents[i].isShow = true;
          if (thisDayEvents[i].cellIndex === i + 1 || i > this.eventLimit) continue;
          var formatDate = VueUtil.formatDate(date);
          thisDayEvents.splice(i, 0, {
            cellIndex: i + 1,
            start: formatDate,
            end: formatDate,
            isShow: false
          });
        }
        thisDayEvents.sort(function(a, b) {
          if (!a.cellIndex) return 1;
          if (!b.cellIndex) return -1;
          return a.cellIndex - b.cellIndex;
        });
        return thisDayEvents;
      },
      findEventsByDate: function(date, events) {
        var findEvents = [];
        VueUtil.loop(events, function(event) {
          var st = VueUtil.parseDate(event.start).getTime();
          var ed = VueUtil.parseDate(event.end ? event.end : st).getTime();
          var de = VueUtil.parseDate(date).getTime();
          if (de >= st && de <= ed) {
            findEvents.push(event);
          }
        });
        return findEvents;
      },
      mouseenterDay: function(e) {
        e.target.parentElement.classList.add('hover');
      },
      mouseleaveDay: function(e) {
        e.target.parentElement.classList.remove('hover');
      },
      mouseenterEvent: function(event, e) {
        VueUtil.loop(this.$refs.eventCard, function(card) {
          if (card.event.cellIndex === event.cellIndex
            && VueUtil.formatDate(event.start) === VueUtil.formatDate(card.event.start)
            && VueUtil.formatDate(event.end) === VueUtil.formatDate(card.event.end)) {
            card.$refs.eventItem && card.$refs.eventItem.classList.add('hover');
          }
        });
        e.target.classList.add('hover');
      },
      mouseleaveEvent: function(event, e) {
        VueUtil.loop(this.$refs.eventCard, function(card) {
          if (card.event.cellIndex === event.cellIndex
            && VueUtil.formatDate(event.start) === VueUtil.formatDate(card.event.start)
            && VueUtil.formatDate(event.end) === VueUtil.formatDate(card.event.end)) {
            card.$refs.eventItem && card.$refs.eventItem.classList.remove('hover');
          }
        });
        e.target.classList.remove('hover');
      },
      moreclick: function(day, jsEvent) {
        this.selectDay = day;
        var dateEvents = this.findEventsByDate(day.date, this.events);
        this.$emit('moreclick', day.date, dateEvents, jsEvent);
      },
      dayclick: function(date, jsEvent) {
        var dateEvents = this.findEventsByDate(date, this.events);
        this.$emit('dayclick', date, dateEvents, jsEvent);
      },
      eventclick: function(event, jsEvent) {
        if (!event.isShow) return;
        jsEvent.stopPropagation();
        this.$emit('eventclick', event, jsEvent);
      }
    }
  };
  var DefaultCalendar = {
    template:'<div                                                                                                                     '+
    'class="vue-picker-panel vue-date-picker vue-popper"                                                                      '+
    ':class="[{                                                                                                               '+
    '  \'has-sidebar\': $slots.sidebar || shortcuts,                                                                          '+
    '  \'has-time\': showTime ,                                                                                                '+
    '  \'fix-month\': fixMonth                                                                                                 '+
    '}, popperClass]">                                                                                                        '+
    '<div class="vue-picker-panel__body-wrapper">                                                                             '+
    '  <div class="vue-picker-panel__body">                                                                                   '+
    '    <div                                                                                                                 '+
    '      class="vue-date-picker__header"                                                                                    '+
    '      :class="{ \'vue-date-picker__header--bordered\': currentView === \'year\' || currentView === \'month\' }"          '+
    '      v-show="currentView !== \'time\'">                                                                                 '+
    '      <button  v-if="!fixMonth"                                                                                          '+
    '        type="button"                                                                                                    '+
    '        @click="prevYear"                                                                                                '+
    '        class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-d-arrow-left">                              '+
    '      </button>                                                                                                          '+
    '      <button   v-if="!fixMonth"                                                                                         '+
    '        type="button"                                                                                                    '+
    '        @click="prevMonth"                                                                                               '+
    '        v-show="currentView === \'date\'"                                                                                '+
    '        class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-arrow-left">                                '+
    '      </button>                                                                                                          '+
    '      <span     v-if="!fixMonth"                                                                                           '+
    '        @click="showYearPicker"                                                                                          '+
    '        role="button"                                                                                                    '+
    '        class="vue-date-picker__header-label">{{ yearLabel }}</span>                                                     '+
    '      <span     v-if="!fixMonth"                                                                                        '+
    '        @click="showMonthPicker"                                                                                         '+
    '        v-show="currentView === \'date\'"                                                                                '+
    '        role="button"                                                                                                    '+
    '        class="vue-date-picker__header-label"                                                                            '+
    '        :class="{ active: currentView === \'month\' }">{{$t(\'vue.datepicker.month\' + (month + 1))}}</span>             '+
    
    '      <span   v-if="fixMonth"                                                                                            '+
    '        role="button"                                                                                                    '+
    '        >{{ yearLabel }}</span>                                                     '+
    '      <span    v-if="fixMonth"                                                                                           '+
    '        v-show="currentView === \'date\'"                                                                                '+
    '        role="button"                                                                                                    '+
    '                                                                                    '+
    '        :class="{ active: currentView === \'month\' }">{{$t(\'vue.datepicker.month\' + (month + 1))}}</span>             '+

    '      <button    v-if="!fixMonth"                                                                                         '+
    '        type="button"                                                                                                    '+
    '        @click="nextYear"                                                                                                '+
    '        class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-d-arrow-right">                             '+
    '      </button>                                                                                                          '+
    '      <button      v-if="!fixMonth"                                                                                          '+
    '        type="button"                                                                                                    '+
    '        @click="nextMonth"                                                                                               '+
    '        v-show="currentView === \'date\'"                                                                                '+
    '        class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-arrow-right">                               '+
    '      </button>                                                                                                          '+
    '    </div>                                                                                                               '+
    '    <div class="vue-picker-panel__content">                                                                              '+
    '      <date-table                                                                                                        '+
    '        v-show="currentView === \'date\'"                                                                                '+
    '        @pick="handleDatePick"                                                                                           '+
    '        :selection-mode="selectionMode"                                                                                  '+
    '        :events="events"                                                                                                 '+
    '        :date-class="dateClass"                                                                                                 '+
    '        :first-day-of-week="firstDayOfWeek"                                                                              '+
    '        :value="value"                                                                                                   '+
    '        :default-value="defaultValue ? new Date(defaultValue) : null"                                                    '+
    '        :date="date"                                                                                                     '+
    '        ref="dateTable"                                                                                                  '+
    '        :disabled-date="disabledDate">                                                                                   '+
    '      </date-table>                                                                                                      '+
    '      <year-table                                                                                                        '+
    '        v-show="currentView === \'year\'"                                                                                '+
    '        @pick="handleYearPick"                                                                                           '+
    '        :value="value"                                                                                                   '+
    '        :default-value="defaultValue ? new Date(defaultValue) : null"                                                    '+
    '        :date="date"                                                                                                     '+
    '        :disabled-date="disabledDate">                                                                                   '+
    '      </year-table>                                                                                                      '+
    '      <month-table                                                                                                       '+
    '        v-show="currentView === \'month\'"                                                                               '+
    '        @pick="handleMonthPick"                                                                                          '+
    '        :value="value"                                                                                                   '+
    '        :default-value="defaultValue ? new Date(defaultValue) : null"                                                    '+
    '        :date="date"                                                                                                     '+
    '        :disabled-date="disabledDate">                                                                                   '+
    '      </month-table>                                                                                                     '+
    '    </div>                                                                                                               '+
    '  </div>                                                                                                                 '+
    '</div>                                                                                                                   '+
    '<div v-show="selectionMode !== \'dates\'"                                                                                  '+
    '  class="vue-picker-panel__footer">                                                                                      '+
    '  <vue-button                                                                                                            '+
    '    size="mini"                                                                                                          '+
    '    type="text"                                                                                                          '+
    '    class="vue-picker-panel__link-btn"                                                                                   '+
    '    @click="changeToNow" >                                                                                '+
    '    {{ nowLabel }}                                                                                                       '+
    '  </vue-button>                                                                                                          '+
    '</div>                                                                                                                   '+
    '</div>                                                                                                                   ',
    mixins: [VueDatePicker().DatePanel],
    data: function() {
      return {
        date: new Date(),
        currentView: 'date',
        width: 0,
      };
    },
    props: {
      type: {
        default: 'date',
        type: String
      },
      fixMonth: Boolean,
      events: Array,
      dateClass: Array,
      disabledDates: Function
    },
    computed: {
      yearLabel: function() {
        var year = this.year;
        if (!year)
          return '';
        var yearTranslation = this.$t('vue.datepicker.year');
        if (this.currentView === 'year') {
          var startYear = Math.floor(year / 10) * 10;
          if (yearTranslation) {
            return startYear + ' ' + yearTranslation + ' - ' + (startYear + 9) + ' ' + yearTranslation;
          }
          return startYear + ' - ' + (startYear + 9);
        }
        return this.year + ' ' + yearTranslation;
      },
      monthLabel: function() {
        return this.$t('vue.datepicker.month' + (this.month + 1));
      },
      nowLabel: function() {
        return this.$t('vue.datepicker.today');
      }
    },
    mounted: function() {
      if (this.type === 'week') {
        this.selectionMode =  'week';
      } else if (this.type === 'month') {
        this.selectionMode = 'month';
      } else if (this.type === 'year') {
        this.selectionMode = 'year';
      } else if (this.type === 'dates') {
        this.selectionMode = 'dates';
      } else {
        this.selectionMode = 'day';
      }

      if (this.date && !this.year) {
        this.year = this.date.getFullYear();
        this.month = this.date.getMonth();
      }
      this.disabledDate = this.disabledDates;
    },
    created: function() {
      this.$on('pick', function(date) {
        var findEventsByDate = function(date, events) {
          if (events && events.length > 0) {
            var findEvents = [];
            VueUtil.loop(events, function(event) {
              var st = VueUtil.parseDate(event.start).getTime();
              var ed = VueUtil.parseDate(event.end ? event.end : st).getTime();
              var de = VueUtil.parseDate(date).getTime();
              if (de >= st && de <= ed) {
                findEvents.push(event);
              }
            });
            return findEvents;
          }
        };
        //this.value = date;
        var dateEvents;
        if (this.selectionMode == 'day') {
          dateEvents = findEventsByDate(date, this.events);
        }
        var clickDate = this.$refs.dateTable.lastClick;
        if (clickDate) {
          this.$emit('dayclick', date, dateEvents, clickDate.jsEvent, clickDate.date);
        }
      });
    }
  };
  var VueCalendar = {
    template: '<full-calendar v-if="full" ref="fullCalendar" :date-class="dateClass" :disabled-dates="disabledDate" @changemonth="changeMonth" :week-class="weekClass" :week-label="weekLabel" :events="events" :event-limit="eventLimit" :show-more="showMore" @dayclick="dayclick" @eventclick="eventclick" @moreclick="moreclick"><slot name="headerLeft" slot="fcHeaderLeft"></slot><slot name="headerRight" slot="fcHeaderRight"></slot></full-calendar><calendar v-else :events="events" :type="type" :fixMonth="fixMonth" :date-class="dateClass" :disabled-dates="disabledDate" @dayclick="dayclick" @view-month-change="viewMonthChange" ref="calendar"></calendar>',
    name: 'VueCalendar',
    components: {
      calendar: DefaultCalendar,
      FullCalendar: FullCalendar
    },
    props: {
      events: {
        type: Array,
        default: function() {
          return [];
        }
      },
      eventLimit: {
        type: Number,
        default: 2
      },
      showMore: {
        type: Boolean,
        default: true
      },
      dateClass: {
        type: Array,
        default: function() {
          return [];
        }
      },
      weekClass: {
        type: Array,
        default: function() {
          return [];
        }
      },
      weekLabel: {
        type: Object,
        default: function() {
          return null;
        }
      },
      type: {
        default: 'date',
        type: String
      },
      full: Boolean,
      value: '',
      fixMonth: Boolean,
      disabledDate: Function
    },
    model: {
      event: 'dayclick'
    },
    methods: {
      toDate: function(date) {
        if (this.$refs.fullCalendar && this.$refs.fullCalendar.emitChangeMonth) {
          this.$refs.fullCalendar.emitChangeMonth(date);
        } else {
          this.$refs.calendar.date = new Date(date);
        }

      },
      changeToNow: function () {
        if (this.$refs.fullCalendar && this.$refs.fullCalendar.emitChangeMonth) {
          this.$refs.fullCalendar.emitChangeMonth(new Date);
        } else {
          this.$refs.calendar.changeToNow();
        }
      },
      dayclick: function(day, events, jsEvent, currentDay) {
        this.$emit('dayclick', day, events, jsEvent, currentDay);
      },
      viewMonthChange: function(date, events, jsEvent) {
        this.$emit('view-month-change', date, events, jsEvent);
      },
      changeMonth: function(start, end, firstDayOfMonth) {
        this.$emit('change-month', start, end, firstDayOfMonth);
      },
      eventclick: function(event, jsEvent) {
        this.$emit('eventclick', event, jsEvent);
      },
      moreclick: function(day, events, jsEvent) {
        this.$emit('moreclick', day, events, jsEvent);
      },
    },
    watch: {
      value: function(val) {
        if(!this.full) {
          this.$refs.calendar.value = val;
        }
      }
    },
    mounted: function() {
      if(!this.full) {
        this.$refs.calendar.value = this.value;
        this.$refs.calendar.$emit('pick', this.value);
        if(this.value instanceof Array && this.value.length > 0) {
          this.$refs.calendar.date = this.value[0];
        }
      }
    }
  };
  Vue.component(VueCalendar.name, VueCalendar);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VuePin = definition(context.Vue, context.VueUtil);
    delete context.VuePin;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VuePin = {
    template: '<div class="vue-pin" :class="pinClass"><div :style="styles"><slot></slot></div></div>',
    name: 'VuePin',
    props: {
      offsetTop: {
        type: Number,
        default: 0
      },
      offsetBottom: {
        type: Number
      },
      fixed: Boolean
    },
    data: function() {
      return {
        pin: false,
        styles: {}
      };
    },
    computed: {
      offsetType: function() {
        var type = 'top';
        if (this.offsetBottom >= 0) {
          type = 'bottom';
        }
        return type;
      },
      pinClass: function() {
        return {
          'vue-pin-pined': this.pin,
        };
      }
    },
    mounted: function() {
      var self = this;
      self.$nextTick(function() {
        if (self.fixed) {
          self.pin = true;
          var elOffset = self.getOffset(self.$el);
          if (self.offsetType == 'bottom') {
            self.styles = {
              bottom: self.offsetBottom + 'px',
              left: elOffset.left + 'px',
              width: self.$el.offsetWidth + 'px',
              position: 'fixed',
              zIndex: VueUtil.nextZIndex()
            };
          } else {
            self.styles = {
              top: self.offsetTop + 'px',
              left: elOffset.left + 'px',
              width: self.$el.offsetWidth + 'px',
              position: 'fixed',
              zIndex: VueUtil.nextZIndex()
            };
          }
        } else {
          self.scrollParent = VueUtil.component.getScrollParent(self.$el);
          VueUtil.on(self.scrollParent, 'scroll', self.handleScroll);
          VueUtil.addResizeListener(self.handleScroll);
        }
      });
    },
    beforeDestroy: function() {
      if (!this.fixed) {
        VueUtil.off(this.scrollParent, 'scroll', this.handleScroll);
        VueUtil.removeResizeListener(this.handleScroll);
      }
    },
    methods: {
      getScroll: function(top) {
        var ret = null;
        if (VueUtil.isDef(top)) {
          ret = pageYOffset;
          if (!VueUtil.isNumber(ret)) ret = document.documentElement.scrollTop;
        } else {
          ret = pageXOffset;
          if (!VueUtil.isNumber(ret)) ret = document.documentElement.scrollLeft;
        }
        return ret;
      },
      getOffset: function(element) {
        var rect = element.getBoundingClientRect();
        var scrollTop = this.getScroll(true);
        var scrollLeft = this.getScroll();
        var clientTop = document.body.clientTop || 0;
        var clientLeft = document.body.clientLeft || 0;
        return {
          top: rect.top + scrollTop - clientTop,
          left: rect.left + scrollLeft - clientLeft
        };
      },
      handleScroll: function() {
        var pin = this.pin;
        var scrollTop = this.getScroll(true);
        var elOffset = this.getOffset(this.$el);
        var windowHeight = innerHeight;
        var elHeight = this.$el.getElementsByTagName('div')[0].offsetHeight;
        if ((elOffset.top - this.offsetTop) < scrollTop && this.offsetType == 'top' && !pin) {
          this.pin = true;
          this.styles = {
            top: this.offsetTop + 'px',
            left: elOffset.left + 'px',
            width: this.$el.offsetWidth + 'px',
            position: 'fixed',
            zIndex: VueUtil.nextZIndex()
          };
          this.$emit('change', true);
        } else if ((elOffset.top - this.offsetTop) > scrollTop && this.offsetType == 'top' && pin) {
          this.pin = false;
          this.styles = null;
          this.$emit('change', false);
        }
        if ((elOffset.top + this.offsetBottom + elHeight) > (scrollTop + windowHeight) && this.offsetType == 'bottom' && !pin) {
          this.pin = true;
          this.styles = {
            bottom: this.offsetBottom + 'px',
            left: elOffset.left + 'px',
            width: this.$el.offsetWidth + 'px',
            position: 'fixed',
            zIndex: VueUtil.nextZIndex()
          };
          this.$emit('change', true);
        } else if ((elOffset.top + this.offsetBottom + elHeight) < (scrollTop + windowHeight) && this.offsetType == 'bottom' && pin) {
          this.pin = false;
          this.styles = null;
          this.$emit('change', false);
        }
      }
    }
  };
  Vue.component(VuePin.name, VuePin);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueDraggable = definition(context.Vue, context.VueUtil);
    delete context.VueDraggable;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var directive = function() {
    var Bind = function(object, fun, args) {
      return function() {
        return fun.apply(object, args || []);
      };
    };
    var BindAsEventListener = function(object, fun) {
      var args = [].slice.call(arguments).slice(2);
      return function(e) {
        return fun.apply(object, VueUtil.mergeArray([e || event], args));
      };
    };
    var Class = function(properties) {
      var _class = function() {
        return (arguments[0] !== null && VueUtil.isFunction(this.initialize)) ? this.initialize.apply(this, arguments) : this;
      };
      _class.prototype = properties;
      return _class;
    };
    var dragEl = new Class({
      initialize: function(el, cancelObj, resizeObj, offsetLeft, offsetTop, moveOut) {
        this._dragobj = el;
        this._body = cancelObj;
        this._resize = resizeObj;
        this._x = 0;
        this._y = 0;
        this._fM = BindAsEventListener(this, this.Move);
        this._fS = Bind(this, this.Stop);
        this._isdrag = null;
        this._Css = null;
        this.offsetLeft = offsetLeft;
        this.offsetTop = offsetTop;
        this.moveOut = moveOut;
        this.Minwidth = parseInt(VueUtil.getStyle(el, 'minWidth'));
        this.Minheight = parseInt(VueUtil.getStyle(el, 'minHeight'));
        VueUtil.addTouchStart(this._dragobj, BindAsEventListener(this, this.Start, true));
        VueUtil.addTouchStart(this._resize, BindAsEventListener(this, this.Start, false));
      },
      isCancel: function(el) {
        if (this._body.indexOf(el) !== -1) return true;
        if (this._dragobj === el) return false;
        return this.isCancel(el.parentElement);
      },
      Cancelbubble: function(e) {
        VueUtil.isBoolean(e.cancelBubble) && (e.cancelBubble = true);
        VueUtil.isFunction(e.stopPropagation) && e.stopPropagation();
      },
      Changebg: function(o, x1, x2) {
        o.style.backgroundPosition = (o.style.backgroundPosition == x1) ? x2 : x1;
      },
      Start: function(e, isdrag) {
        var clientX = e.clientX;
        var clientY = e.clientY;
        if (e.touches && e.touches[0]) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        }
        if (!VueUtil.isDef(clientX) || !VueUtil.isDef(clientY) || this.isCancel(e.target)) return;
        if (!isdrag) this.Cancelbubble(e);
        this._Css = isdrag ? {
          x: 'left',
          y: 'top'
        } : {
            x: 'width',
            y: 'height'
          };
        this._isdrag = isdrag;
        this._x = isdrag ? (clientX - this._dragobj.offsetLeft + this.offsetLeft) : (this._dragobj.offsetLeft || 0);
        this._y = isdrag ? (clientY - this._dragobj.offsetTop + this.offsetTop) : (this._dragobj.offsetTop || 0);

        //不允许拖拽出容器
        if(!this.moveOut) {
          var transform = document.defaultView.getComputedStyle(this._dragobj).transform; 
          if(transform && transform != 'none' && transform.split(',').length > 3) {
            this.translate3dX = parseFloat(transform.split(',')[4]);
          } else {
            this.translate3dX = 0;
          }
  
          this.elWidth = this._dragobj.offsetWidth;
          this.elHeight = this._dragobj.offsetHeight;
        }
        //END不允许拖拽出容器
        if (document.all) {
          VueUtil.on(this._dragobj, 'losecapture', this._fS);
          this._dragobj.setCapture();
        } else {
          e.preventDefault();
          VueUtil.on(document, 'blur', this._fS);
        }
        VueUtil.addTouchMove(document, this._fM);
        VueUtil.addTouchEnd(document, this._fS);
      },
      Move: function(e) {
        var clientX = e.clientX;
        var clientY = e.clientY;
        if (e.touches && e.touches[0]) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        }
        if (!VueUtil.isDef(clientX) || !VueUtil.isDef(clientY)) return;
        getSelection ? getSelection().removeAllRanges() : document.selection.empty();
        var i_x = clientX - this._x;
        var i_y = clientY - this._y;
        
        //不允许拖拽出容器
        if(!this.moveOut) {
          if(i_y < 0) {
            i_y = 0;
          } 
          
          if(i_x + this.elWidth + this.translate3dX > document.documentElement.clientWidth) {
            i_x = document.documentElement.clientWidth - this.elWidth - this.translate3dX;
          }

          if(i_y + this.elHeight > document.documentElement.clientHeight) {
            i_y = document.documentElement.clientHeight - this.elHeight;
          }

          if(i_x + this.translate3dX < 0) {
            i_x = 0 - this.translate3dX;
          }
        }
        //END不允许拖拽出容器
        this._dragobj.style[this._Css.x] = (this._isdrag ? i_x : Math.max(i_x, this.Minwidth)) + 'px';
        this._dragobj.style[this._Css.y] = (this._isdrag ? i_y : Math.max(i_y, this.Minheight)) + 'px';
        if (!this._isdrag) {
          VueUtil.setStyle(this._dragobj, 'height', Math.max(i_y, this.Minheight) - 2 * parseInt(VueUtil.getStyle(this._dragobj, 'paddingLeft')) + 'px');
        }
      },
      Stop: function() {
        VueUtil.removeTouchMove(document, this._fM);
        VueUtil.removeTouchEnd(document, this._fS);
        if (document.all) {
          VueUtil.off(this._dragobj, 'losecapture', this._fS);
          this._dragobj.releaseCapture();
        } else {
          VueUtil.off(document, 'blur', this._fS);
        }
      }
    });
    Vue.directive('draggable', {
      inserted: function(el, binding) {
        var cancelObj = [];
        var cancelSelectors = el.getAttribute('draggable-cancel-selector');
        if (cancelSelectors) {
          VueUtil.loop(cancelSelectors.split(','), function(cancelSelector) {
            if (VueUtil.hasClass(el, cancelSelector.split('.')[1])) {
              cancelObj.push(el);
              return false;
            }
            cancelObj.push(el.querySelector(cancelSelector));
          });
        }
        if (cancelObj.indexOf(el) !== -1) return;
        var resizeObj = null;
        var resizeFlg = el.getAttribute('draggable-resize');
        if (resizeFlg) {
          resizeObj = document.createElement('DIV');
          var resizeStyle = {
            bottom: '1px',
            right: '1px',
            cursor: 'nw-resize',
            position: 'absolute',
            width: '10px',
            height: '10px',
            fontSize: 0
          };
          VueUtil.merge(resizeObj.style, resizeStyle);
          el.appendChild(resizeObj);
        }
        var moveOut = el.getAttribute('move-out') !== null;

        Vue.nextTick(function() {
          var positionStyle = VueUtil.getStyle(el, 'position');
          var offsetLeft = el.offsetLeft;
          var offsetTop = el.offsetTop;
          if (positionStyle !== 'fixed') {
            var displayStyle = VueUtil.getStyle(el, 'display');
            VueUtil.setStyle(el, 'display', 'block');
            offsetLeft = el.offsetLeft;
            offsetTop = el.offsetTop;
            VueUtil.setStyle(el, 'display', displayStyle);
            VueUtil.setStyle(el, 'position', 'relative');
            VueUtil.setStyle(el, 'zIndex', VueUtil.nextZIndex());
          }
          new dragEl(el, cancelObj, resizeObj, offsetLeft, offsetTop, moveOut);
        });
      }
    });
  };
  Vue.use(directive);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VueRouter', 'Vuex'], definition);
  } else {
    context.VueLoader = definition(context.Vue, context.VueUtil, context.VueRouter, context.Vuex);
  }
})(this, function(Vue, VueUtil, VueRouter, Vuex) {
  'use strict';
  var promiseLoop = function(arr, cb) {
    var realResult = [];
    var result = Promise.resolve();
    arr.reverse();
    arr.forEach(function(a) {
      result = result.then(function() {
        return cb(a).then(function(res) {
          realResult.push(res);
        });
      });
    });
    return result.then(function() {
      return realResult;
    });
  };
  var scriptCache = [];
  var scriptScopedCache = [];
  var identity = function(value) {
    return value;
  };
  var resolveURL = function(baseURL, url) {
    if (url.substr(0, 2) === './' || url.substr(0, 3) === '../') {
      return baseURL + url;
    }
    return url;
  };
  var StyleContext = function(component, elt) {
    this.component = component;
    this.elt = elt;
  };
  StyleContext.prototype = {
    withBase: function(callback) {
      var tmpBaseElt;
      if (this.component.baseURI) {
        tmpBaseElt = document.createElement('base');
        tmpBaseElt.href = this.component.baseURI;
        var headElt = this.component.getHead();
        headElt.insertBefore(tmpBaseElt, headElt.firstChild);
      }
      callback.call(this);
      if (tmpBaseElt)
        this.component.getHead().removeChild(tmpBaseElt);
    },
    scopeStyles: function(styleElt, scopeName) {

      function process() {

        var sheet = styleElt.sheet;
        var rules = sheet.cssRules;

        for ( var i = 0; i < rules.length; ++i ) {
          var rule = rules[i];
          if ( rule.type !== 1 )
            continue;

          var scopedSelectors = [];

          rule.selectorText.split(/\s*,\s*/).forEach(function(sel) {

            scopedSelectors.push(scopeName+' '+sel);
            var segments = sel.match(/([^ :]+)(.+)?/);
            scopedSelectors.push(segments[1] + scopeName + (segments[2]||''));
          });

          var scopedRule = scopedSelectors.join(',') + rule.cssText.substr(rule.selectorText.length);
          sheet.deleteRule(i);
          sheet.insertRule(scopedRule, i);
        }
      }

      try {
        process();
      } catch (ex) {

        if ( ex instanceof DOMException && ex.code === DOMException.INVALID_ACCESS_ERR ) {

          styleElt.sheet.disabled = true;
          styleElt.addEventListener('load', function onStyleLoaded() {

            styleElt.removeEventListener('load', onStyleLoaded);
            setTimeout(function() {
              process();
              styleElt.sheet.disabled = false;
            });
          });
          return;
        }
        throw ex;
      }
    },
    compile: function() {
      var hasTemplate = this.template !== null;
      var scoped = this.elt.hasAttribute('scoped');
      if (scoped) {
        if (!hasTemplate) return;
        this.elt.removeAttribute('scoped');
      }
      this.withBase(function() {
        this.component.getHead().appendChild(this.elt);
      });
      if (scoped) this.scopeStyles(this.elt, '[' + this.component.getScopeId() + ']');
      return Promise.resolve();
    },
    getContent: function() {
      return this.elt.textContent;
    },
    setContent: function(content) {
      this.withBase(function() {
        this.elt.textContent = content;
      });
    }
  };
  var ScriptContext = function(component, elt) {
    this.component = component;
    this.elt = elt;
    this.module = {
      exports: {}
    };
  };
  ScriptContext.prototype = {
    getContent: function() {
      return this.elt.textContent;
    },
    setContent: function(content) {
      this.elt.textContent = content;
    },
    addContent: function(content) {
      this.elt.textContent = content + this.elt.textContent;
    },
    asynReadContent: function(url) {
      return new Promise(function(resolve, reject) {
        Vue.http.get(url).then(function(reqponse) {
          resolve(reqponse.bodyText);
        }, function(reqponse) {
          reject(reqponse.status);
        });
      });
    },
    compile: function() {
      var childModuleRequire = function(childURL) {
        return httpVueLoader.require(resolveURL(this.component.baseURI, childURL));
      }.bind(this);
      var childLoader = function(childURL) {
        return VueLoader(resolveURL(this.component.baseURI, childURL));
      }.bind(this);
      try {
        //Vue.config.devtools && this.addContent('debugger');
        eval('(function anonymous(exports,require,Vue,VueUtil,VueRouter,Vuex,VueLoader,module) {' + this.getContent() + '})').call(this.module.exports, this.module.exports, childModuleRequire, Vue, VueUtil, VueRouter, Vuex, childLoader, this.module);
        // Function('exports', 'require', 'Vue', 'VueUtil', 'VueRouter', 'Vuex', 'VueLoader', 'module', this.getContent().trim()).call(this.module.exports, this.module.exports, childModuleRequire, Vue, VueUtil, VueRouter, Vuex, childLoader, this.module);
      } catch (ex) {
        Vue.config.productionTip && console.error('[VueLoader error]: in \'' + this.component.url + '\'\n\n' + ex);
      }
      return Promise.resolve(this.module.exports);
    }
  };
  var TemplateContext = function(component, elt) {
    this.component = component;
    this.elt = elt;
  };
  TemplateContext.prototype = {
    getContent: function() {
      return this.elt.innerHTML;
    },
    setContent: function(content) {
      this.elt.innerHTML = content;
    },
    getRootElt: function() {
      var tplElt = this.elt.content || this.elt;
      var firstElt = tplElt.firstElementChild;
      if (VueUtil.isElement(firstElt)) return firstElt;
      for (tplElt = tplElt.firstChild; tplElt !== null; tplElt = tplElt.nextSibling) {
        if (VueUtil.isElement(tplElt)) return tplElt;
      }
      return null;
    },
    compile: function() {
      return Promise.resolve();
    }
  };
  var Component = function() {
    this.template = null;
    this.script = null;
    this.styles = [];
    this._scopeId = '';
    this.url = null;
  };
  Component.prototype = {
    getHead: function() {
      return document.head || document.getElementsByTagName('head')[0];
    },
    getScopeId: function() {
      if (this._scopeId === '') {
        this._scopeId = 'scope-' + VueUtil.createUuid();
        this.template.getRootElt().setAttribute(this._scopeId, '');
      }
      return this._scopeId;
    },
    load: function(componentURL) {
      this.url = componentURL;
      return httpVueLoader.httpRequest(componentURL).then(function(responseText) {
        scriptScopedCache = [];
        this.baseURI = componentURL.substr(0, componentURL.lastIndexOf('/') + 1);
        var doc = document.implementation.createHTMLDocument('');
        doc.body.innerHTML = (this.baseURI ? '<base href="' + this.baseURI + '">' : '') + responseText;
        for (var it = doc.body.firstChild; it; it = it.nextSibling) {
          switch (it.nodeName) {
          case 'TEMPLATE':
            this.template = new TemplateContext(this,it);
            break;
          case 'SCRIPT':
            var srcStr = it.getAttribute('src');
            var scoped = it.getAttribute('scoped');
            if (srcStr) {
              var async = it.getAttribute('async');
              if (VueUtil.isDef(scoped)) {
                if (scriptScopedCache.indexOf(srcStr) === -1) scriptScopedCache.push(srcStr);
              } else {
                if (scriptCache.indexOf(srcStr) === -1) {
                  if (!async || async === 'true') {
                    var newScript = document.createElement('script');
                    newScript.setAttribute('src', srcStr);
                    newScript.async = false;
                    this.getHead().appendChild(newScript);
                    scriptCache.push(srcStr);
                  } else if (async === 'false'){
                    var req = new XMLHttpRequest();
                    req.open('GET', srcStr, false);
                    req.onreadystatechange = function(){
                        if (req.readyState == 4) {
                            var s = document.createElement('script');
                            s.appendChild(document.createTextNode(req.responseText));
                            document.head.appendChild(s);
                        }
                    };
                    req.send(null);
                  }
                
                }
              }
            } else {
              this.script = new ScriptContext(this, it);
            }
            break;
          case 'STYLE':
            this.styles.push(new StyleContext(this,it));
            break;
          }
        }
        return this;
      }.bind(this));
    },
    _normalizeSection: function(eltCx) {
      var p;
      if (eltCx === null || !eltCx.elt.hasAttribute('src')) {
        p = Promise.resolve(null);
      } else {
        p = httpVueLoader.httpRequest(eltCx.elt.getAttribute('src')).then(function(content) {
          eltCx.elt.removeAttribute('src');
          return content;
        });
      }
      return p.then(function(content) {
        if (eltCx !== null && eltCx.elt.hasAttribute('lang')) {
          var lang = eltCx.elt.getAttribute('lang');
          eltCx.elt.removeAttribute('lang');
          return httpVueLoader.langProcessor[lang.toLowerCase()](content === null ? eltCx.getContent() : content);
        }
        return content;
      }).then(function(content) {
        if (content !== null)
          eltCx.setContent(content);
      });
    },
    normalize: function() {
      return Promise.all(VueUtil.mergeArray(this._normalizeSection(this.template), this._normalizeSection(this.script), VueUtil.map(this.styles, this._normalizeSection))).then(function() {
        return this;
      }.bind(this));
    },
    compile: function() {
      return Promise.all(VueUtil.mergeArray(this.template && this.template.compile(), this.script && this.script.compile(), VueUtil.map(this.styles, function(style) {
        return style.compile();
      }))).then(function() {
        return this;
      }.bind(this));
    }
  };
  var httpVueLoader = {
    load: function(url) {
      return function() {
        return new Component().load(url).then(function(component) {
          if (VueUtil.isDef(component.script)) {
            return promiseLoop(scriptScopedCache, component.script.asynReadContent).then(function(responseText){
              component.script.addContent(responseText);
              return component;
            });
          } else {
            return component;
          }
        }).then(function(component) {
          return component.normalize();
        }).then(function(component) {
          return component.compile();
        }).then(function(component) {
          var exports = component.script !== null ? component.script.module.exports : {};
          if (component.template !== null)
            exports.template = component.template.getContent();
          exports._baseURI = component.baseURI;
          return exports;
        });
      };
    },
    require: function(moduleName) {
      return window[moduleName];
    },
    httpRequest: function(url) {
      return new Promise(function(resolve, reject) {
        Vue.http.get(url).then(function(reqponse) {
          resolve(reqponse.bodyText);
        }, function(reqponse) {
          reject(reqponse.status);
        });
      });
    },
    langProcessor: {
      html: identity,
      js: identity,
      css: identity
    }
  };
  var VueLoader = function(url) {
    return httpVueLoader.load(url);
  };
  return VueLoader;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueImgLoad = definition(context.Vue);
    delete context.VueImgLoad;
  }
})(this, function(Vue) {
  'use strict';
  var imgload = function() {
    var loadImg = function(el, binding) {
      if (el.tagName === 'IMG') {
        var img = new Image();
        img.src = binding.value;
        img.onload = function() {
          el.src = img.src;
        };
      }
    };
    Vue.directive('imgload', {
      bind: function(el, binding) {
        el._src_ = el.src;
        loadImg(el, binding);
      },
      update: function(el, binding) {
        el.src = el._src_;
        loadImg(el, binding);
      }
    });
  };
  Vue.use(imgload);
});

/*!
 * Signature Pad v2.3.2
 * https://github.com/szimek/signature_pad
 *
 * Copyright 2017 Szymon Nowak
 * Released under the MIT license
 *
 * The main idea and some parts of the code (e.g. drawing variable width Bézier curve) are taken from:
 * http://corner.squareup.com/2012/07/smoother-signatures.html
 *
 * Implementation of interpolation using cubic Bézier curves is taken from:
 * http://benknowscode.wordpress.com/2012/09/14/path-interpolation-using-cubic-bezier-and-control-point-estimation-in-javascript
 *
 * Algorithm for approximated length of a Bézier curve is taken from:
 * http://www.lemoda.net/maths/bezier-length/index.html
 *
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.SignaturePad = factory());
}(this, (function () { 'use strict';

function Point(x, y, time) {
  this.x = x;
  this.y = y;
  this.time = time || new Date().getTime();
}

Point.prototype.velocityFrom = function (start) {
  return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 1;
};

Point.prototype.distanceTo = function (start) {
  return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
};

Point.prototype.equals = function (other) {
  return this.x === other.x && this.y === other.y && this.time === other.time;
};

function Bezier(startPoint, control1, control2, endPoint) {
  this.startPoint = startPoint;
  this.control1 = control1;
  this.control2 = control2;
  this.endPoint = endPoint;
}

// Returns approximated length.
Bezier.prototype.length = function () {
  var steps = 10;
  var length = 0;
  var px = void 0;
  var py = void 0;

  for (var i = 0; i <= steps; i += 1) {
    var t = i / steps;
    var cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
    var cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
    if (i > 0) {
      var xdiff = cx - px;
      var ydiff = cy - py;
      length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
    }
    px = cx;
    py = cy;
  }

  return length;
};

/* eslint-disable no-multi-spaces, space-in-parens */
Bezier.prototype._point = function (t, start, c1, c2, end) {
  return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;
};

/* eslint-disable */

// http://stackoverflow.com/a/27078401/815507
function throttle(func, wait, options) {
  var context, args, result;
  var timeout = null;
  var previous = 0;
  if (!options) options = {};
  var later = function later() {
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  return function () {
    var now = Date.now();
    if (!previous && options.leading === false) previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
}

function SignaturePad(canvas, options) {
  var self = this;
  var opts = options || {};

  this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;
  this.minWidth = opts.minWidth || 0.5;
  this.maxWidth = opts.maxWidth || 2.5;
  this.throttle = 'throttle' in opts ? opts.throttle : 16; // in miliseconds
  this.minDistance = 'minDistance' in opts ? opts.minDistance : 5;

  if (this.throttle) {
    this._strokeMoveUpdate = throttle(SignaturePad.prototype._strokeUpdate, this.throttle);
  } else {
    this._strokeMoveUpdate = SignaturePad.prototype._strokeUpdate;
  }

  this.dotSize = opts.dotSize || function () {
    return (this.minWidth + this.maxWidth) / 2;
  };
  this.penColor = opts.penColor || 'black';
  this.backgroundColor = opts.backgroundColor || 'rgba(0,0,0,0)';
  this.onBegin = opts.onBegin;
  this.onEnd = opts.onEnd;

  this._canvas = canvas;
  this._ctx = canvas.getContext('2d');
  this.clear();

  // We need add these inline so they are available to unbind while still having
  // access to 'self' we could use _.bind but it's not worth adding a dependency.
  this._handleMouseDown = function (event) {
    if (event.which === 1) {
      self._mouseButtonDown = true;
      self._strokeBegin(event);
    }
  };

  this._handleMouseMove = function (event) {
    if (self._mouseButtonDown) {
      self._strokeMoveUpdate(event);
    }
  };

  this._handleMouseUp = function (event) {
    if (event.which === 1 && self._mouseButtonDown) {
      self._mouseButtonDown = false;
      self._strokeEnd(event);
    }
  };

  this._handleTouchStart = function (event) {
    if (event.targetTouches.length === 1) {
      var touch = event.changedTouches[0];
      self._strokeBegin(touch);
    }
  };

  this._handleTouchMove = function (event) {
    // Prevent scrolling.
    event.preventDefault();

    var touch = event.targetTouches[0];
    self._strokeMoveUpdate(touch);
  };

  this._handleTouchEnd = function (event) {
    var wasCanvasTouched = event.target === self._canvas;
    if (wasCanvasTouched) {
      event.preventDefault();
      self._strokeEnd(event);
    }
  };

  // Enable mouse and touch event handlers
  this.on();
}

// Public methods
SignaturePad.prototype.clear = function () {
  var ctx = this._ctx;
  var canvas = this._canvas;

  ctx.fillStyle = this.backgroundColor;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  this._data = [];
  this._reset();
  this._isEmpty = true;
};

SignaturePad.prototype.fromDataURL = function (dataUrl) {
  var _this = this;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var image = new Image();
  var ratio = options.ratio || window.devicePixelRatio || 1;
  var width = options.width || this._canvas.width / ratio;
  var height = options.height || this._canvas.height / ratio;

  this._reset();
  image.src = dataUrl;
  image.onload = function () {
    _this._ctx.drawImage(image, 0, 0, width, height);
  };
  this._isEmpty = false;
};

SignaturePad.prototype.toDataURL = function (type) {
  var _canvas;

  switch (type) {
    case 'image/svg+xml':
      return this._toSVG();
    default:
      for (var _len = arguments.length, options = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        options[_key - 1] = arguments[_key];
      }

      return (_canvas = this._canvas).toDataURL.apply(_canvas, [type].concat(options));
  }
};

SignaturePad.prototype.on = function () {
  this._handleMouseEvents();
  this._handleTouchEvents();
};

SignaturePad.prototype.off = function () {
  this._canvas.removeEventListener('mousedown', this._handleMouseDown);
  this._canvas.removeEventListener('mousemove', this._handleMouseMove);
  document.removeEventListener('mouseup', this._handleMouseUp);

  this._canvas.removeEventListener('touchstart', this._handleTouchStart);
  this._canvas.removeEventListener('touchmove', this._handleTouchMove);
  this._canvas.removeEventListener('touchend', this._handleTouchEnd);
};

SignaturePad.prototype.isEmpty = function () {
  return this._isEmpty;
};

// Private methods
SignaturePad.prototype._strokeBegin = function (event) {
  this._data.push([]);
  this._reset();
  this._strokeUpdate(event);

  if (typeof this.onBegin === 'function') {
    this.onBegin(event);
  }
};

SignaturePad.prototype._strokeUpdate = function (event) {
  var x = event.clientX;
  var y = event.clientY;

  var point = this._createPoint(x, y);
  var lastPointGroup = this._data[this._data.length - 1];
  var lastPoint = lastPointGroup && lastPointGroup[lastPointGroup.length - 1];
  var isLastPointTooClose = lastPoint && point.distanceTo(lastPoint) < this.minDistance;

  // Skip this point if it's too close to the previous one
  if (!(lastPoint && isLastPointTooClose)) {
    var _addPoint = this._addPoint(point),
        curve = _addPoint.curve,
        widths = _addPoint.widths;

    if (curve && widths) {
      this._drawCurve(curve, widths.start, widths.end);
    }

    this._data[this._data.length - 1].push({
      x: point.x,
      y: point.y,
      time: point.time,
      color: this.penColor
    });
  }
};

SignaturePad.prototype._strokeEnd = function (event) {
  var canDrawCurve = this.points.length > 2;
  var point = this.points[0]; // Point instance

  if (!canDrawCurve && point) {
    this._drawDot(point);
  }

  if (point) {
    var lastPointGroup = this._data[this._data.length - 1];
    var lastPoint = lastPointGroup[lastPointGroup.length - 1]; // plain object

    // When drawing a dot, there's only one point in a group, so without this check
    // such group would end up with exactly the same 2 points.
    if (!point.equals(lastPoint)) {
      lastPointGroup.push({
        x: point.x,
        y: point.y,
        time: point.time,
        color: this.penColor
      });
    }
  }

  if (typeof this.onEnd === 'function') {
    this.onEnd(event);
  }
};

SignaturePad.prototype._handleMouseEvents = function () {
  this._mouseButtonDown = false;

  this._canvas.addEventListener('mousedown', this._handleMouseDown);
  this._canvas.addEventListener('mousemove', this._handleMouseMove);
  document.addEventListener('mouseup', this._handleMouseUp);
};

SignaturePad.prototype._handleTouchEvents = function () {
  // Pass touch events to canvas element on mobile IE11 and Edge.
  this._canvas.style.msTouchAction = 'none';
  this._canvas.style.touchAction = 'none';

  this._canvas.addEventListener('touchstart', this._handleTouchStart);
  this._canvas.addEventListener('touchmove', this._handleTouchMove);
  this._canvas.addEventListener('touchend', this._handleTouchEnd);
};

SignaturePad.prototype._reset = function () {
  this.points = [];
  this._lastVelocity = 0;
  this._lastWidth = (this.minWidth + this.maxWidth) / 2;
  this._ctx.fillStyle = this.penColor;
};

SignaturePad.prototype._createPoint = function (x, y, time) {
  var rect = this._canvas.getBoundingClientRect();

  return new Point(x - rect.left, y - rect.top, time || new Date().getTime());
};

SignaturePad.prototype._addPoint = function (point) {
  var points = this.points;
  var tmp = void 0;

  points.push(point);

  if (points.length > 2) {
    // To reduce the initial lag make it work with 3 points
    // by copying the first point to the beginning.
    if (points.length === 3) points.unshift(points[0]);

    tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
    var c2 = tmp.c2;
    tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
    var c3 = tmp.c1;
    var curve = new Bezier(points[1], c2, c3, points[2]);
    var widths = this._calculateCurveWidths(curve);

    // Remove the first element from the list,
    // so that we always have no more than 4 points in points array.
    points.shift();

    return { curve: curve, widths: widths };
  }

  return {};
};

SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
  var dx1 = s1.x - s2.x;
  var dy1 = s1.y - s2.y;
  var dx2 = s2.x - s3.x;
  var dy2 = s2.y - s3.y;

  var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };
  var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };

  var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

  var dxm = m1.x - m2.x;
  var dym = m1.y - m2.y;

  var k = l2 / (l1 + l2);
  var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };

  var tx = s2.x - cm.x;
  var ty = s2.y - cm.y;

  return {
    c1: new Point(m1.x + tx, m1.y + ty),
    c2: new Point(m2.x + tx, m2.y + ty)
  };
};

SignaturePad.prototype._calculateCurveWidths = function (curve) {
  var startPoint = curve.startPoint;
  var endPoint = curve.endPoint;
  var widths = { start: null, end: null };

  var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - this.velocityFilterWeight) * this._lastVelocity;

  var newWidth = this._strokeWidth(velocity);

  widths.start = this._lastWidth;
  widths.end = newWidth;

  this._lastVelocity = velocity;
  this._lastWidth = newWidth;

  return widths;
};

SignaturePad.prototype._strokeWidth = function (velocity) {
  return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
};

SignaturePad.prototype._drawPoint = function (x, y, size) {
  var ctx = this._ctx;

  ctx.moveTo(x, y);
  ctx.arc(x, y, size, 0, 2 * Math.PI, false);
  this._isEmpty = false;
};

SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
  var ctx = this._ctx;
  var widthDelta = endWidth - startWidth;
  var drawSteps = Math.floor(curve.length());

  ctx.beginPath();

  for (var i = 0; i < drawSteps; i += 1) {
    // Calculate the Bezier (x, y) coordinate for this step.
    var t = i / drawSteps;
    var tt = t * t;
    var ttt = tt * t;
    var u = 1 - t;
    var uu = u * u;
    var uuu = uu * u;

    var x = uuu * curve.startPoint.x;
    x += 3 * uu * t * curve.control1.x;
    x += 3 * u * tt * curve.control2.x;
    x += ttt * curve.endPoint.x;

    var y = uuu * curve.startPoint.y;
    y += 3 * uu * t * curve.control1.y;
    y += 3 * u * tt * curve.control2.y;
    y += ttt * curve.endPoint.y;

    var width = startWidth + ttt * widthDelta;
    this._drawPoint(x, y, width);
  }

  ctx.closePath();
  ctx.fill();
};

SignaturePad.prototype._drawDot = function (point) {
  var ctx = this._ctx;
  var width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;

  ctx.beginPath();
  this._drawPoint(point.x, point.y, width);
  ctx.closePath();
  ctx.fill();
};

SignaturePad.prototype._fromData = function (pointGroups, drawCurve, drawDot) {
  for (var i = 0; i < pointGroups.length; i += 1) {
    var group = pointGroups[i];

    if (group.length > 1) {
      for (var j = 0; j < group.length; j += 1) {
        var rawPoint = group[j];
        var point = new Point(rawPoint.x, rawPoint.y, rawPoint.time);
        var color = rawPoint.color;

        if (j === 0) {
          // First point in a group. Nothing to draw yet.

          // All points in the group have the same color, so it's enough to set
          // penColor just at the beginning.
          this.penColor = color;
          this._reset();

          this._addPoint(point);
        } else if (j !== group.length - 1) {
          // Middle point in a group.
          var _addPoint2 = this._addPoint(point),
              curve = _addPoint2.curve,
              widths = _addPoint2.widths;

          if (curve && widths) {
            drawCurve(curve, widths, color);
          }
        } else {
          // Last point in a group. Do nothing.
        }
      }
    } else {
      this._reset();
      var _rawPoint = group[0];
      drawDot(_rawPoint);
    }
  }
};

SignaturePad.prototype._toSVG = function () {
  var _this2 = this;

  var pointGroups = this._data;
  var canvas = this._canvas;
  var ratio = Math.max(window.devicePixelRatio || 1, 1);
  var minX = 0;
  var minY = 0;
  var maxX = canvas.width / ratio;
  var maxY = canvas.height / ratio;
  var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

  svg.setAttributeNS(null, 'width', canvas.width);
  svg.setAttributeNS(null, 'height', canvas.height);

  this._fromData(pointGroups, function (curve, widths, color) {
    var path = document.createElement('path');

    // Need to check curve for NaN values, these pop up when drawing
    // lines on the canvas that are not continuous. E.g. Sharp corners
    // or stopping mid-stroke and than continuing without lifting mouse.
    if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {
      var attr = 'M ' + curve.startPoint.x.toFixed(3) + ',' + curve.startPoint.y.toFixed(3) + ' ' + ('C ' + curve.control1.x.toFixed(3) + ',' + curve.control1.y.toFixed(3) + ' ') + (curve.control2.x.toFixed(3) + ',' + curve.control2.y.toFixed(3) + ' ') + (curve.endPoint.x.toFixed(3) + ',' + curve.endPoint.y.toFixed(3));

      path.setAttribute('d', attr);
      path.setAttribute('stroke-width', (widths.end * 2.25).toFixed(3));
      path.setAttribute('stroke', color);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke-linecap', 'round');

      svg.appendChild(path);
    }
  }, function (rawPoint) {
    var circle = document.createElement('circle');
    var dotSize = typeof _this2.dotSize === 'function' ? _this2.dotSize() : _this2.dotSize;
    circle.setAttribute('r', dotSize);
    circle.setAttribute('cx', rawPoint.x);
    circle.setAttribute('cy', rawPoint.y);
    circle.setAttribute('fill', rawPoint.color);

    svg.appendChild(circle);
  });

  var prefix = 'data:image/svg+xml;base64,';
  var header = '<svg' + ' xmlns="http://www.w3.org/2000/svg"' + ' xmlns:xlink="http://www.w3.org/1999/xlink"' + (' viewBox="' + minX + ' ' + minY + ' ' + maxX + ' ' + maxY + '"') + (' width="' + maxX + '"') + (' height="' + maxY + '"') + '>';
  var body = svg.innerHTML;

  // IE hack for missing innerHTML property on SVGElement
  if (body === undefined) {
    var dummy = document.createElement('dummy');
    var nodes = svg.childNodes;
    dummy.innerHTML = '';

    for (var i = 0; i < nodes.length; i += 1) {
      dummy.appendChild(nodes[i].cloneNode(true));
    }

    body = dummy.innerHTML;
  }

  var footer = '</svg>';
  var data = header + body + footer;

  return prefix + btoa(data);
};

SignaturePad.prototype.fromData = function (pointGroups) {
  var _this3 = this;

  this.clear();

  this._fromData(pointGroups, function (curve, widths) {
    return _this3._drawCurve(curve, widths.start, widths.end);
  }, function (rawPoint) {
    return _this3._drawDot(rawPoint);
  });

  this._data = pointGroups;
};

SignaturePad.prototype.toData = function () {
  return this._data;
};

return SignaturePad;

})));

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueSignature = definition(context.Vue, context.VueUtil);
    delete context.VueSignature;
  }
})(this, function(Vue, VueUtil) {
  'use strict';

  var DEFAULT_OPTIONS = {
    dotSize: (0.5 + 2.5) / 2,
    minWidth: 0.5,
    maxWidth: 2.5,
    throttle: 16,
    minDistance: 5,
    backgroundColor: 'rgba(0,0,0,0)',
    penColor: 'black',
    velocityFilterWeight: 0.7,
    onBegin: function onBegin() {},
    onEnd: function onEnd() {}
  };

  var convert2NonReactive = function (observerValue) {
    return JSON.parse(JSON.stringify(observerValue));
  };

  var TRANSPARENT_PNG = {
    src:
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=',
    x: 0,
    y: 0
  };
  var VueSignature = {
    name: 'VueSignature',
    props: {
      width: {
        type: String,
        default: '100%'
      },
      height: {
        type: String,
        default: '100%'
      },
      customStyle: {
        type: Object
      },
      saveType: {
        type: String,
        default: 'image/png'
      },
      options: {
        type: Object,
        default: function () {
          return {};
        }
      },
      images: {
        type: Array,
        default: function () {
          return [];
        }
      }
    },
    data: function() {
      return {
        signaturePad: {},
        cacheImages: [],
        signatureData: TRANSPARENT_PNG,
        onResizeHandler: null
      };
    },
    mounted: function() {
      var options = this.options;
      var canvas = this.$refs.signaturePadCanvas;
      var signaturePad = new SignaturePad(canvas, VueUtil.merge({}, DEFAULT_OPTIONS, options));
      this.signaturePad = signaturePad;
  
      this.onResizeHandler = this.resizeCanvas.bind(this);
  
      window.addEventListener('resize', this.onResizeHandler, false);
  
      this.resizeCanvas();
    },
    beforeDestroy: function() {
      if (this.onResizeHandler) {
        window.removeEventListener('resize', this.onResizeHandler, false);
      }
    },
    methods: {
      resizeCanvas: function() {
        var canvas = this.$refs.signaturePadCanvas;
        var data = this.signaturePad.toData();
        var ratio = Math.max(window.devicePixelRatio || 1, 1);
        canvas.width = canvas.offsetWidth * ratio;
        canvas.height = canvas.offsetHeight * ratio;
        canvas.getContext('2d').scale(ratio, ratio);
        this.signaturePad.clear();
        this.signatureData = TRANSPARENT_PNG;
        this.signaturePad.fromData(data);
      },
      saveSignature: function() {
        var signaturePad = this.signaturePad;
        var saveType = this.saveType;
  
        if (['image/png', 'image/jpeg', 'image/svg+xml'].indexOf(saveType) == -1) {
          throw new Error('Image type is incorrect!');
        }
  
        if (signaturePad.isEmpty()) {
          return {
            data: undefined,
            isEmpty: true
          };
        } else {
          this.signatureData = signaturePad.toDataURL(saveType);
  
          return {
            isEmpty: false,
            data: this.signatureData
          };
        }
      },
      undoSignature: function() {
        var signaturePad = this.signaturePad;
        var record = signaturePad.toData();
  
        if (record) {
          return signaturePad.fromData(record.slice(0, -1));
        }
      },
      // mergeImageAndSignature(customSignature) {
      //   this.signatureData = customSignature;
  
      //   return mergeImages([
      //     ...this.images,
      //     ...this.cacheImages,
      //     this.signatureData
      //   ]);
      // },
      // addImages(images = []) {
      //   this.cacheImages = [...this.cacheImages, ...images];
  
      //   return mergeImages([
      //     ...this.images,
      //     ...this.cacheImages,
      //     this.signatureData
      //   ]);
      // },
      fromDataURL: function(data) {
        return this.signaturePad.fromDataURL(data);
      },
      lockSignaturePad: function() {
        return this.signaturePad.off();
      },
      openSignaturePad: function() {
        return this.signaturePad.on();
      },
      isEmpty: function() {
        return this.signaturePad.isEmpty();
      },
      getPropImagesAndCacheImages: function() {
        return this.propsImagesAndCustomImages;
      },
      clearCacheImages: function() {
        this.cacheImages = [];
  
        return this.cacheImages;
      },
      clearSignature: function() {
        return this.signaturePad.clear();
      }
    },
    computed: {
      propsImagesAndCustomImages: function() {
        var nonReactiveProrpImages = convert2NonReactive(this.images);
        var nonReactiveCachImages = convert2NonReactive(this.cacheImages);
  
        return nonReactiveProrpImages.concat(nonReactiveCachImages);
      }
    },
    render: function(createElement) {
      var width = this.width;
      var height = this.height;
      var customStyle = this.customStyle;

      return createElement(
        'div',
        {
          style: VueUtil.merge({
            width: width,
            height: height,
          }, customStyle)
        },
        [
          createElement('canvas', {
            style: {
              width: '100%',
              height: '100%'
            },
            ref: 'signaturePadCanvas'
          })
        ]
      );
    }
  };
  Vue.component(VueSignature.name, VueSignature);
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueRipple = definition(context.Vue, context.VueUtil);
    delete context.VueRipple;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var directive = function() {
    var doRipple = VueUtil.throttle(function(e) {
      var clientX = e.clientX;
      var clientY = e.clientY;
      var el = this;
      el.style.position = 'relative';
      var ripple = el.querySelector('.vue-ripple__container');
      var animation = el.querySelector('.vue-ripple__animation');
      var size = el.clientWidth > el.clientHeight ? el.clientWidth : el.clientHeight;
      animation.style.height = animation.style.width = size + 'px';
      var offset = el.getBoundingClientRect();
      var x = clientX - offset.left + 'px';
      var y = clientY - offset.top + 'px';
      animation.style.left = x;
      animation.style.top = y;
      animation.style.display = '';
      ripple.style.display = '';
      VueUtil.debounce(500, function() {
        animation.style.display = 'none';
        ripple.style.display = 'none';
        el.style.position = el.__originalPosition__;
      }).call();
    });
    Vue.directive('ripple', {
      bind: function(el, binding) {
        VueUtil.debounce(function() {
          el.__originalPosition__ = el.style.position;
          var ripple = el.__ripple__ = document.createElement('div');
          ripple.className = 'vue-ripple__container';
          ripple.style.display = 'none';
          var animation = document.createElement('div');
          animation.style.display = 'none';
          animation.className = 'vue-ripple__animation';
          ripple.appendChild(animation);
          el.appendChild(ripple);
          VueUtil.on(el, 'mousedown', doRipple);
        }).call();
      },
      unbind: function(el) {
        VueUtil.off(el, 'mousedown', doRipple);
      }
    });
  };
  Vue.use(directive);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueAdaptiveGroup = definition(context.Vue, context.VueUtil);
    delete context.VueAdaptiveGroup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueAdaptiveGroup = {
    template: '<div class="vue-adaptive-group">\
                <div v-if="adaptiveType" :class="[customClass, liClass]"><slot></slot><slot v-for="index in slotLen" :name="\'li\' + index"></slot></div>\
                <div v-else><slot></slot>\
                  <vue-dropdown trigger="click" :class="[customClass]">\
                    <vue-button :icon="iconClass" type="text" style="transform: rotate3d(0,0,1,-90deg);"></vue-button>\
                    <vue-dropdown-menu slot="dropdown" :class="[{\'default_dropdown_menu_view\':isMobile},liClass]">\
                      <vue-dropdown-item v-for="index in slotLen" :key="index"><slot :name="\'li\' + index"></slot></vue-dropdown-item>\
                      <span v-if="isMobile" class="dropdown_menu_top"></span>\
                    </vue-dropdown-menu>\
                  </vue-dropdown></div></div>',
    name: 'VueAdaptiveGroup',
    props: {
      size: {
        type: String,
        default: 'md'
      },
      customClass: String,
      liClass: String,
      iconClass: {
        type: String,
        default: 'vue-icon-more'
      },
      isForceActive:{
        type:Boolean,
        default: false
      }
    },
    data: function() {
      return {
        adaptiveType: true,
        soltLiLen: 0,
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
      };
    },
    methods: {
      resetType: function() {
        if(this.isForceActive){
          this.adaptiveType = false;
        }else{
          var size = this.size;
          var sizeMap = Object.create(null);
          sizeMap.lg = 1200;
          sizeMap.md = 992;
          sizeMap.sm = 768;    
          var sizeValue = sizeMap[size];
          if (!VueUtil.isDef(sizeValue)) {
            size = 'md';
            sizeValue = sizeMap[size];
          }
          this.adaptiveType = sizeValue <= innerWidth;
        }
        this.adaptiveType = sizeValue <= innerWidth;
      },
      refresh: function() {
        this.soltLiLen = this.soltLiLen + 1;
      }
    },
    computed: {
      slotLen: function() {
        this.soltLiLen = 0;
        var soltLiLen = this.soltLiLen;
        VueUtil.ownPropertyLoop(this.$slots, function(prop) {
          var propAry = prop.split('li');
          if (propAry[0] === '' && VueUtil.isNumber(propAry[1]*1))
            soltLiLen++;
        });
        return soltLiLen;
      },
    },
    mounted: function() {
      VueUtil.addResizeListener(this.$el, this.resetType);
    },
    beforeDestroy: function() {
      VueUtil.removeResizeListener(this.$el, this.resetType);
    }
  };
  Vue.component(VueAdaptiveGroup.name, VueAdaptiveGroup);
});

'use strict';

function _typeof(obj) { if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; }; } return _typeof(obj); }

(function (root, factory) {
  var namespace = 'VueVirtualList';
  /* istanbul ignore next */

  if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') {
    module.exports = factory(namespace, require('vue'));
  } else if (typeof define === 'function' && define.amd) {
    define(['vue'], factory.bind(root, namespace));
  } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    exports[namespace] = factory(namespace, require('vue'));
  } else {
    root[namespace] = factory(namespace, root['Vue']);
  }
})(this, function (namespace, Vue) {
  /* istanbul ignore next */
  if (_typeof(Vue) === 'object' && typeof Vue.default === 'function') {
    Vue = Vue.default;
  }
  /* istanbul ignore next */


  var _debounce = function _debounce(func, wait, immediate) {
    var timeout;
    return function () {
      var context = this;
      var args = arguments;

      var later = function later() {
        timeout = null;

        if (!immediate) {
          func.apply(context, args);
        }
      };

      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);

      if (callNow) {
        func.apply(context, args);
      }
    };
  };

  return Vue.component(namespace, {
    props: {
      size: {
        type: Number,
        required: true
      },
      remain: {
        type: Number,
        required: true
      },
      rtag: {
        type: String,
        default: 'div'
      },
      wtag: {
        type: String,
        default: 'div'
      },
      wclass: {
        type: String,
        default: ''
      },
      pagemode: {
        type: Boolean,
        default: false
      },
      scrollelement: {
        type: typeof window === 'undefined' ? Object : HTMLElement,
        default: null
      },
      start: {
        type: Number,
        default: 0
      },
      offset: {
        type: Number,
        default: 0
      },
      variable: {
        type: [Function, Boolean],
        default: false
      },
      bench: {
        type: Number,
        default: 0 // also equal to remain

      },
      debounce: {
        type: Number,
        default: 0
      },
      totop: {
        type: [Function, Boolean],
        // Boolean just disable for priviate.
        default: false
      },
      tobottom: {
        type: [Function, Boolean],
        // Boolean just disable for priviate.
        default: false
      },
      onscroll: {
        type: [Function, Boolean],
        // Boolean just disable for priviate.
        default: false
      },
      item: {
        type: Object,
        default: null
      },
      itemcount: {
        type: Number,
        default: 0
      },
      itemprops: {
        type: Function,

        /* istanbul ignore next */
        default: function _default() {}
      }
    },
    // use changeProp to identify which prop change.
    watch: {
      size: function size() {
        this.changeProp = 'size';
      },
      remain: function remain() {
        this.changeProp = 'remain';
      },
      bench: function bench() {
        this.changeProp = 'bench';
        this.itemModeForceRender();
      },
      start: function start() {
        this.changeProp = 'start';
        this.itemModeForceRender();
      },
      offset: function offset() {
        this.changeProp = 'offset';
        this.itemModeForceRender();
      },
      itemcount: function itemcount() {
        this.changeProp = 'itemcount';
        this.itemModeForceRender();
      },
      scrollelement: function scrollelement(newScrollelement, oldScrollelement) {
        if (this.pagemode) {
          return;
        }

        if (oldScrollelement) {
          this.removeScrollListener(oldScrollelement);
        }

        if (newScrollelement) {
          this.addScrollListener(newScrollelement);
        }
      }
    },
    created: function created() {
      var start = this.start >= this.remain ? this.start : 0;
      var keeps = this.remain + (this.bench || this.remain);
      var delta = Object.create(null);
      delta.direction = ''; // current scroll direction, D: down, U: up.

      delta.scrollTop = 0; // current scroll top, use to direction.

      delta.start = start; // start index.

      delta.end = start + keeps - 1; // end index.

      delta.keeps = keeps; // nums keeping in real dom.

      delta.total = 0; // all items count, update in filter.

      delta.offsetAll = 0; // cache all the scrollable offset.

      delta.paddingTop = 0; // container wrapper real padding-top.

      delta.paddingBottom = 0; // container wrapper real padding-bottom.

      delta.varCache = {}; // object to cache variable index height and scroll offset.

      delta.varAverSize = 0; // average/estimate item height before variable be calculated.

      delta.varLastCalcIndex = 0; // last calculated variable height/offset index, always increase.

      this.delta = delta;
    },
    mounted: function mounted() {
      if (this.pagemode) {
        this.addScrollListener(window);
      } else if (this.scrollelement) {
        this.addScrollListener(this.scrollelement);
      }

      if (this.start) {
        var start = this.getZone(this.start).start;
        this.setScrollTop(this.variable ? this.getVarOffset(start) : start * this.size);
      } else if (this.offset) {
        this.setScrollTop(this.offset);
      }
    },
    beforeDestroy: function beforeDestroy() {
      if (this.pagemode) {
        this.removeScrollListener(window);
      } else if (this.scrollelement) {
        this.removeScrollListener(this.scrollelement);
      }
    },
    // check if delta should update when props change.
    beforeUpdate: function beforeUpdate() {
      var delta = this.delta;
      delta.keeps = this.remain + (this.bench || this.remain);
      var calcstart = this.changeProp === 'start' ? this.start : delta.start;
      var zone = this.getZone(calcstart); // if start, size or offset change, update scroll position.

      if (this.changeProp && ['start', 'size', 'offset'].includes(this.changeProp)) {
        var scrollTop = this.changeProp === 'offset' ? this.offset : this.variable ? this.getVarOffset(zone.isLast ? delta.total : zone.start) : zone.isLast && delta.total - calcstart <= this.remain ? delta.total * this.size : calcstart * this.size;
        this.$nextTick(this.setScrollTop.bind(this, scrollTop));
      } // if points out difference, force update once again.


      if (this.changeProp || delta.end !== zone.end || calcstart !== zone.start) {
        this.changeProp = '';
        delta.end = zone.end;
        delta.start = zone.start;
        this.forceRender();
      }
    },
    methods: {
      // add pagemode/scrollelement scroll event listener
      addScrollListener: function addScrollListener(element) {
        this.scrollHandler = this.debounce ? _debounce(this.onScroll.bind(this), this.debounce) : this.onScroll;
        element.addEventListener('scroll', this.scrollHandler, false);
      },
      // remove pagemode/scrollelement scroll event listener
      removeScrollListener: function removeScrollListener(element) {
        element.removeEventListener('scroll', this.scrollHandler, false);
      },
      onScroll: function onScroll(event) {
        var delta = this.delta;
        var vsl = this.$refs.vsl;
        var offset;

        if (this.pagemode) {
          var elemRect = this.$el.getBoundingClientRect();
          offset = -elemRect.top;
        } else if (this.scrollelement) {
          var scrollelementRect = this.scrollelement.getBoundingClientRect();

          var _elemRect = this.$el.getBoundingClientRect();

          offset = scrollelementRect.top - _elemRect.top;
        } else {
          offset = (vsl.$el || vsl).scrollTop || 0;
        }

        delta.direction = offset > delta.scrollTop ? 'D' : 'U';
        delta.scrollTop = offset;

        if (delta.total > delta.keeps) {
          this.updateZone(offset);
        } else {
          delta.end = delta.total - 1;
        }

        var offsetAll = delta.offsetAll;

        if (this.onscroll) {
          var param = Object.create(null);
          param.offset = offset;
          param.offsetAll = offsetAll;
          param.start = delta.start;
          param.end = delta.end;
          this.onscroll(event, param);
        }

        if (!offset && delta.total) {
          this.fireEvent('totop');
        }

        if (offset >= offsetAll) {
          this.fireEvent('tobottom');
        }
      },
      // update render zone by scroll offset.
      updateZone: function updateZone(offset) {
        var delta = this.delta;
        var overs = this.variable ? this.getVarOvers(offset) : Math.floor(offset / this.size); // if scroll up, we'd better decrease it's numbers.

        if (delta.direction === 'U') {
          overs = overs - this.remain + 1;
        }

        var zone = this.getZone(overs);
        var bench = this.bench || this.remain; // for better performance, if scroll pass items within now bench, do not update.
        // and if overs is going to reach last item, we should render next zone immediately.

        var shouldRenderNextZone = Math.abs(overs - delta.start - bench) === 1;

        if (!shouldRenderNextZone && overs - delta.start <= bench && !zone.isLast && overs > delta.start) {
          return;
        } // we'd better make sure forceRender calls as less as possible.


        if (shouldRenderNextZone || zone.start !== delta.start || zone.end !== delta.end) {
          delta.end = zone.end;
          delta.start = zone.start;
          this.forceRender();
        }
      },
      // return the right zone info base on `start/index`.
      getZone: function getZone(index) {
        var start, end;
        var delta = this.delta;
        index = parseInt(index, 10);
        index = Math.max(0, index);
        var lastStart = delta.total - delta.keeps;
        var isLast = index <= delta.total && index >= lastStart || index > delta.total;

        if (isLast) {
          start = Math.max(0, lastStart);
        } else {
          start = index;
        }

        end = start + delta.keeps - 1;
        return {
          end: end,
          start: start,
          isLast: isLast
        };
      },
      // public method, force render ui list if we needed.
      // call this before the next repaint to get better performance.
      forceRender: function forceRender() {
        var _this = this;

        window.requestAnimationFrame(function () {
          _this.$forceUpdate();
        });
      },
      // force render ui if using item-mode.
      itemModeForceRender: function itemModeForceRender() {
        if (this.item) {
          this.forceRender();
        }
      },
      // return the scroll passed items count in variable.
      getVarOvers: function getVarOvers(offset) {
        var low = 0;
        var middle = 0;
        var middleOffset = 0;
        var delta = this.delta;
        var high = delta.total;

        while (low <= high) {
          middle = low + Math.floor((high - low) / 2);
          middleOffset = this.getVarOffset(middle); // calculate the average variable height at first binary search.

          if (!delta.varAverSize) {
            delta.varAverSize = Math.floor(middleOffset / middle);
          }

          if (middleOffset === offset) {
            return middle;
          } else if (middleOffset < offset) {
            low = middle + 1;
          } else if (middleOffset > offset) {
            high = middle - 1;
          }
        }

        return low > 0 ? --low : 0;
      },
      // return a variable scroll offset from given index.
      getVarOffset: function getVarOffset(index, nocache) {
        var delta = this.delta;
        var cache = delta.varCache[index];

        if (!nocache && cache) {
          return cache.offset;
        }

        var offset = 0;

        for (var i = 0; i < index; i++) {
          var size = this.getVarSize(i, nocache);
          delta.varCache[i] = {
            size: size,
            offset: offset
          };
          offset += size;
        }

        delta.varLastCalcIndex = Math.max(delta.varLastCalcIndex, index - 1);
        delta.varLastCalcIndex = Math.min(delta.varLastCalcIndex, delta.total - 1);
        return offset;
      },
      // return a variable size (height) from given index.
      getVarSize: function getVarSize(index, nocache) {
        var cache = this.delta.varCache[index];

        if (!nocache && cache) {
          return cache.size;
        }

        if (typeof this.variable === 'function') {
          return this.variable(index) || 0;
        } else {
          // when using item, it can only get current components height,
          // need to be enhanced, or consider using variable-function instead
          var slot = this.item ? this.$children[index] ? this.$children[index].$vnode : null : this.$slots.default[index];
          var style = slot && slot.data && slot.data.style;

          if (style && style.height) {
            var shm = style.height.match(/^(.*)px$/);
            return shm && +shm[1] || 0;
          }
        }

        return 0;
      },
      // return the variable paddingTop base current zone.
      // @todo: if set a large `start` before variable was calculated,
      // here will also case too much offset calculate when list is very large,
      // consider use estimate paddingTop in this case just like `getVarPaddingBottom`.
      getVarPaddingTop: function getVarPaddingTop() {
        return this.getVarOffset(this.delta.start);
      },
      // return the variable paddingBottom base current zone.
      getVarPaddingBottom: function getVarPaddingBottom() {
        var delta = this.delta;
        var last = delta.total - 1;

        if (delta.total - delta.end <= delta.keeps || delta.varLastCalcIndex === last) {
          return this.getVarOffset(last) - this.getVarOffset(delta.end);
        } else {
          // if unreached last zone or uncalculate real behind offset
          // return the estimate paddingBottom avoid too much calculate.
          return (delta.total - delta.end) * (delta.varAverSize || this.size);
        }
      },
      // retun the variable all heights use to judge reach bottom.
      getVarAllHeight: function getVarAllHeight() {
        var delta = this.delta;

        if (delta.total - delta.end <= delta.keeps || delta.varLastCalcIndex === delta.total - 1) {
          return this.getVarOffset(delta.total);
        } else {
          return this.getVarOffset(delta.start) + (delta.total - delta.end) * (delta.varAverSize || this.size);
        }
      },
      // public method, allow the parent update variable by index.
      updateVariable: function updateVariable(index) {
        // clear/update all the offfsets and heights ahead of index.
        this.getVarOffset(index, true);
      },
      // trigger a props event on parent.
      fireEvent: function fireEvent(event) {
        if (this[event]) {
          this[event]();
        }
      },
      // set manual scroll top.
      setScrollTop: function setScrollTop(scrollTop) {
        if (this.pagemode) {
          window.scrollTo(0, scrollTop);
        } else if (this.scrollelement) {
          this.scrollelement.scrollTo(0, scrollTop);
        } else {
          var vsl = this.$refs.vsl;

          if (vsl) {
            (vsl.$el || vsl).scrollTop = scrollTop;
          }
        }
      },
      // filter the shown items base on `start` and `end`.
      filter: function filter(h) {
        var delta = this.delta;
        var slots = this.$slots.default || []; // item-mode shoud judge from items prop.

        if (this.item) {
          delta.total = this.itemcount;

          if (delta.keeps > delta.total) {
            delta.end = delta.total - 1;
          }
        } else {
          if (!slots.length) {
            delta.start = 0;
          }

          delta.total = slots.length;
        }

        var paddingTop, paddingBottom, allHeight;
        var hasPadding = delta.total > delta.keeps;

        if (this.variable) {
          allHeight = this.getVarAllHeight();
          paddingTop = hasPadding ? this.getVarPaddingTop() : 0;
          paddingBottom = hasPadding ? this.getVarPaddingBottom() : 0;
        } else {
          allHeight = this.size * delta.total;
          paddingTop = this.size * (hasPadding ? delta.start : 0);
          paddingBottom = this.size * (hasPadding ? delta.total - delta.keeps : 0) - paddingTop;
        }

        if (paddingBottom < this.size) {
          paddingBottom = 0;
        }

        delta.paddingTop = paddingTop;
        delta.paddingBottom = paddingBottom;
        delta.offsetAll = allHeight - this.size * this.remain;
        var renders = [];

        for (var i = delta.start; i < delta.total && i <= Math.ceil(delta.end); i++) {
          var slot = null;

          if (this.item) {
            slot = h(this.item, this.itemprops(i));
          } else {
            slot = slots[i];
          }

          renders.push(slot);
        }

        return renders;
      }
    },
    render: function render(h) {
      var dbc = this.debounce;
      var list = this.filter(h);
      var _this$delta = this.delta,
          paddingTop = _this$delta.paddingTop,
          paddingBottom = _this$delta.paddingBottom;
      var renderList = h(this.wtag, {
        'style': {
          'display': 'block',
          'padding-top': paddingTop + 'px',
          'padding-bottom': paddingBottom + 'px'
        },
        'class': this.wclass,
        'attrs': {
          'role': 'group'
        }
      }, list); // page mode just render list, no wraper.

      if (this.pagemode || this.scrollelement) {
        return renderList;
      }

      return h(this.rtag, {
        'ref': 'vsl',
        'style': {
          'display': 'block',
          'overflow-y': 'auto',
          'height': this.size * this.remain + 'px'
        },
        'on': {
          '&scroll': dbc ? _debounce(this.onScroll.bind(this), dbc) : this.onScroll
        }
      }, [renderList]);
    }
  });
});
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */

 //IE11下用的polyfill
(function() {
  'use strict';
  
  // Exit early if we're not running in a browser.
  if (typeof window !== 'object') {
    return;
  }
  
  // Exit early if all IntersectionObserver and IntersectionObserverEntry
  // features are natively supported.
  if ('IntersectionObserver' in window &&
      'IntersectionObserverEntry' in window &&
      'intersectionRatio' in window.IntersectionObserverEntry.prototype) {
  
    // Minimal polyfill for Edge 15's lack of `isIntersecting`
    // See: https://github.com/w3c/IntersectionObserver/issues/211
    if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
      Object.defineProperty(window.IntersectionObserverEntry.prototype,
        'isIntersecting', {
        get: function () {
          return this.intersectionRatio > 0;
        }
      });
    }
    return;
  }
  
  
  /**
   * A local reference to the document.
   */
  var document = window.document;
  
  
  /**
   * An IntersectionObserver registry. This registry exists to hold a strong
   * reference to IntersectionObserver instances currently observing a target
   * element. Without this registry, instances without another reference may be
   * garbage collected.
   */
  var registry = [];
  
  
  /**
   * Creates the global IntersectionObserverEntry constructor.
   * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
   * @param {Object} entry A dictionary of instance properties.
   * @constructor
   */
  function IntersectionObserverEntry(entry) {
    this.time = entry.time;
    this.target = entry.target;
    this.rootBounds = entry.rootBounds;
    this.boundingClientRect = entry.boundingClientRect;
    this.intersectionRect = entry.intersectionRect || getEmptyRect();
    this.isIntersecting = !!entry.intersectionRect;
  
    // Calculates the intersection ratio.
    var targetRect = this.boundingClientRect;
    var targetArea = targetRect.width * targetRect.height;
    var intersectionRect = this.intersectionRect;
    var intersectionArea = intersectionRect.width * intersectionRect.height;
  
    // Sets intersection ratio.
    if (targetArea) {
      // Round the intersection ratio to avoid floating point math issues:
      // https://github.com/w3c/IntersectionObserver/issues/324
      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
    } else {
      // If area is zero and is intersecting, sets to 1, otherwise to 0
      this.intersectionRatio = this.isIntersecting ? 1 : 0;
    }
  }
  
  
  /**
   * Creates the global IntersectionObserver constructor.
   * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
   * @param {Function} callback The function to be invoked after intersection
   *     changes have queued. The function is not invoked if the queue has
   *     been emptied by calling the `takeRecords` method.
   * @param {Object=} opt_options Optional configuration options.
   * @constructor
   */
  function IntersectionObserver(callback, opt_options) {
  
    var options = opt_options || {};
  
    if (typeof callback != 'function') {
      throw new Error('callback must be a function');
    }
  
    if (options.root && options.root.nodeType != 1) {
      throw new Error('root must be an Element');
    }
  
    // Binds and throttles `this._checkForIntersections`.
    this._checkForIntersections = throttle(
        this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);
  
    // Private properties.
    this._callback = callback;
    this._observationTargets = [];
    this._queuedEntries = [];
    this._rootMarginValues = this._parseRootMargin(options.rootMargin);
  
    // Public properties.
    this.thresholds = this._initThresholds(options.threshold);
    this.root = options.root || null;
    this.rootMargin = this._rootMarginValues.map(function(margin) {
      return margin.value + margin.unit;
    }).join(' ');
  }
  
  
  /**
   * The minimum interval within which the document will be checked for
   * intersection changes.
   */
  IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;
  
  
  /**
   * The frequency in which the polyfill polls for intersection changes.
   * this can be updated on a per instance basis and must be set prior to
   * calling `observe` on the first target.
   */
  IntersectionObserver.prototype.POLL_INTERVAL = null;
  
  /**
   * Use a mutation observer on the root element
   * to detect intersection changes.
   */
  IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;
  
  
  /**
   * Starts observing a target element for intersection changes based on
   * the thresholds values.
   * @param {Element} target The DOM element to observe.
   */
  IntersectionObserver.prototype.observe = function(target) {
    var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
      return item.element == target;
    });
  
    if (isTargetAlreadyObserved) {
      return;
    }
  
    if (!(target && target.nodeType == 1)) {
      throw new Error('target must be an Element');
    }
  
    this._registerInstance();
    this._observationTargets.push({element: target, entry: null});
    this._monitorIntersections();
    this._checkForIntersections();
  };
  
  
  /**
   * Stops observing a target element for intersection changes.
   * @param {Element} target The DOM element to observe.
   */
  IntersectionObserver.prototype.unobserve = function(target) {
    this._observationTargets =
        this._observationTargets.filter(function(item) {
  
      return item.element != target;
    });
    if (!this._observationTargets.length) {
      this._unmonitorIntersections();
      this._unregisterInstance();
    }
  };
  
  
  /**
   * Stops observing all target elements for intersection changes.
   */
  IntersectionObserver.prototype.disconnect = function() {
    this._observationTargets = [];
    this._unmonitorIntersections();
    this._unregisterInstance();
  };
  
  
  /**
   * Returns any queue entries that have not yet been reported to the
   * callback and clears the queue. This can be used in conjunction with the
   * callback to obtain the absolute most up-to-date intersection information.
   * @return {Array} The currently queued entries.
   */
  IntersectionObserver.prototype.takeRecords = function() {
    var records = this._queuedEntries.slice();
    this._queuedEntries = [];
    return records;
  };
  
  
  /**
   * Accepts the threshold value from the user configuration object and
   * returns a sorted array of unique threshold values. If a value is not
   * between 0 and 1 and error is thrown.
   * @private
   * @param {Array|number=} opt_threshold An optional threshold value or
   *     a list of threshold values, defaulting to [0].
   * @return {Array} A sorted list of unique and valid threshold values.
   */
  IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
    var threshold = opt_threshold || [0];
    if (!Array.isArray(threshold)) threshold = [threshold];
  
    return threshold.sort().filter(function(t, i, a) {
      if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
        throw new Error('threshold must be a number between 0 and 1 inclusively');
      }
      return t !== a[i - 1];
    });
  };
  
  
  /**
   * Accepts the rootMargin value from the user configuration object
   * and returns an array of the four margin values as an object containing
   * the value and unit properties. If any of the values are not properly
   * formatted or use a unit other than px or %, and error is thrown.
   * @private
   * @param {string=} opt_rootMargin An optional rootMargin value,
   *     defaulting to '0px'.
   * @return {Array<Object>} An array of margin objects with the keys
   *     value and unit.
   */
  IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
    var marginString = opt_rootMargin || '0px';
    var margins = marginString.split(/\s+/).map(function(margin) {
      var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
      if (!parts) {
        throw new Error('rootMargin must be specified in pixels or percent');
      }
      return {value: parseFloat(parts[1]), unit: parts[2]};
    });
  
    // Handles shorthand.
    margins[1] = margins[1] || margins[0];
    margins[2] = margins[2] || margins[0];
    margins[3] = margins[3] || margins[1];
  
    return margins;
  };
  
  
  /**
   * Starts polling for intersection changes if the polling is not already
   * happening, and if the page's visibility state is visible.
   * @private
   */
  IntersectionObserver.prototype._monitorIntersections = function() {
    if (!this._monitoringIntersections) {
      this._monitoringIntersections = true;
  
      // If a poll interval is set, use polling instead of listening to
      // resize and scroll events or DOM mutations.
      if (this.POLL_INTERVAL) {
        this._monitoringInterval = setInterval(
            this._checkForIntersections, this.POLL_INTERVAL);
      }
      else {
        addEvent(window, 'resize', this._checkForIntersections, true);
        addEvent(document, 'scroll', this._checkForIntersections, true);
  
        if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {
          this._domObserver = new MutationObserver(this._checkForIntersections);
          this._domObserver.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
        }
      }
    }
  };
  
  
  /**
   * Stops polling for intersection changes.
   * @private
   */
  IntersectionObserver.prototype._unmonitorIntersections = function() {
    if (this._monitoringIntersections) {
      this._monitoringIntersections = false;
  
      clearInterval(this._monitoringInterval);
      this._monitoringInterval = null;
  
      removeEvent(window, 'resize', this._checkForIntersections, true);
      removeEvent(document, 'scroll', this._checkForIntersections, true);
  
      if (this._domObserver) {
        this._domObserver.disconnect();
        this._domObserver = null;
      }
    }
  };
  
  
  /**
   * Scans each observation target for intersection changes and adds them
   * to the internal entries queue. If new entries are found, it
   * schedules the callback to be invoked.
   * @private
   */
  IntersectionObserver.prototype._checkForIntersections = function() {
    var rootIsInDom = this._rootIsInDom();
    var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();
  
    this._observationTargets.forEach(function(item) {
      var target = item.element;
      var targetRect = getBoundingClientRect(target);
      var rootContainsTarget = this._rootContainsTarget(target);
      var oldEntry = item.entry;
      var intersectionRect = rootIsInDom && rootContainsTarget &&
          this._computeTargetAndRootIntersection(target, rootRect);
  
      var newEntry = item.entry = new IntersectionObserverEntry({
        time: now(),
        target: target,
        boundingClientRect: targetRect,
        rootBounds: rootRect,
        intersectionRect: intersectionRect
      });
  
      if (!oldEntry) {
        this._queuedEntries.push(newEntry);
      } else if (rootIsInDom && rootContainsTarget) {
        // If the new entry intersection ratio has crossed any of the
        // thresholds, add a new entry.
        if (this._hasCrossedThreshold(oldEntry, newEntry)) {
          this._queuedEntries.push(newEntry);
        }
      } else {
        // If the root is not in the DOM or target is not contained within
        // root but the previous entry for this target had an intersection,
        // add a new record indicating removal.
        if (oldEntry && oldEntry.isIntersecting) {
          this._queuedEntries.push(newEntry);
        }
      }
    }, this);
  
    if (this._queuedEntries.length) {
      this._callback(this.takeRecords(), this);
    }
  };
  
  
  /**
   * Accepts a target and root rect computes the intersection between then
   * following the algorithm in the spec.
   * TODO(philipwalton): at this time clip-path is not considered.
   * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
   * @param {Element} target The target DOM element
   * @param {Object} rootRect The bounding rect of the root after being
   *     expanded by the rootMargin value.
   * @return {?Object} The final intersection rect object or undefined if no
   *     intersection is found.
   * @private
   */
  IntersectionObserver.prototype._computeTargetAndRootIntersection =
      function(target, rootRect) {
  
    // If the element isn't displayed, an intersection can't happen.
    if (window.getComputedStyle(target).display == 'none') return;
  
    var targetRect = getBoundingClientRect(target);
    var intersectionRect = targetRect;
    var parent = getParentNode(target);
    var atRoot = false;
  
    while (!atRoot) {
      var parentRect = null;
      var parentComputedStyle = parent.nodeType == 1 ?
          window.getComputedStyle(parent) : {};
  
      // If the parent isn't displayed, an intersection can't happen.
      if (parentComputedStyle.display == 'none') return;
  
      if (parent == this.root || parent == document) {
        atRoot = true;
        parentRect = rootRect;
      } else {
        // If the element has a non-visible overflow, and it's not the <body>
        // or <html> element, update the intersection rect.
        // Note: <body> and <html> cannot be clipped to a rect that's not also
        // the document rect, so no need to compute a new intersection.
        if (parent != document.body &&
            parent != document.documentElement &&
            parentComputedStyle.overflow != 'visible') {
          parentRect = getBoundingClientRect(parent);
        }
      }
  
      // If either of the above conditionals set a new parentRect,
      // calculate new intersection data.
      if (parentRect) {
        intersectionRect = computeRectIntersection(parentRect, intersectionRect);
  
        if (!intersectionRect) break;
      }
      parent = getParentNode(parent);
    }
    return intersectionRect;
  };
  
  
  /**
   * Returns the root rect after being expanded by the rootMargin value.
   * @return {Object} The expanded root rect.
   * @private
   */
  IntersectionObserver.prototype._getRootRect = function() {
    var rootRect;
    if (this.root) {
      rootRect = getBoundingClientRect(this.root);
    } else {
      // Use <html>/<body> instead of window since scroll bars affect size.
      var html = document.documentElement;
      var body = document.body;
      rootRect = {
        top: 0,
        left: 0,
        right: html.clientWidth || body.clientWidth,
        width: html.clientWidth || body.clientWidth,
        bottom: html.clientHeight || body.clientHeight,
        height: html.clientHeight || body.clientHeight
      };
    }
    return this._expandRectByRootMargin(rootRect);
  };
  
  
  /**
   * Accepts a rect and expands it by the rootMargin value.
   * @param {Object} rect The rect object to expand.
   * @return {Object} The expanded rect.
   * @private
   */
  IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
    var margins = this._rootMarginValues.map(function(margin, i) {
      return margin.unit == 'px' ? margin.value :
          margin.value * (i % 2 ? rect.width : rect.height) / 100;
    });
    var newRect = {
      top: rect.top - margins[0],
      right: rect.right + margins[1],
      bottom: rect.bottom + margins[2],
      left: rect.left - margins[3]
    };
    newRect.width = newRect.right - newRect.left;
    newRect.height = newRect.bottom - newRect.top;
  
    return newRect;
  };
  
  
  /**
   * Accepts an old and new entry and returns true if at least one of the
   * threshold values has been crossed.
   * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
   *    particular target element or null if no previous entry exists.
   * @param {IntersectionObserverEntry} newEntry The current entry for a
   *    particular target element.
   * @return {boolean} Returns true if a any threshold has been crossed.
   * @private
   */
  IntersectionObserver.prototype._hasCrossedThreshold =
      function(oldEntry, newEntry) {
  
    // To make comparing easier, an entry that has a ratio of 0
    // but does not actually intersect is given a value of -1
    var oldRatio = oldEntry && oldEntry.isIntersecting ?
        oldEntry.intersectionRatio || 0 : -1;
    var newRatio = newEntry.isIntersecting ?
        newEntry.intersectionRatio || 0 : -1;
  
    // Ignore unchanged ratios
    if (oldRatio === newRatio) return;
  
    for (var i = 0; i < this.thresholds.length; i++) {
      var threshold = this.thresholds[i];
  
      // Return true if an entry matches a threshold or if the new ratio
      // and the old ratio are on the opposite sides of a threshold.
      if (threshold == oldRatio || threshold == newRatio ||
          threshold < oldRatio !== threshold < newRatio) {
        return true;
      }
    }
  };
  
  
  /**
   * Returns whether or not the root element is an element and is in the DOM.
   * @return {boolean} True if the root element is an element and is in the DOM.
   * @private
   */
  IntersectionObserver.prototype._rootIsInDom = function() {
    return !this.root || containsDeep(document, this.root);
  };
  
  
  /**
   * Returns whether or not the target element is a child of root.
   * @param {Element} target The target element to check.
   * @return {boolean} True if the target element is a child of root.
   * @private
   */
  IntersectionObserver.prototype._rootContainsTarget = function(target) {
    return containsDeep(this.root || document, target);
  };
  
  
  /**
   * Adds the instance to the global IntersectionObserver registry if it isn't
   * already present.
   * @private
   */
  IntersectionObserver.prototype._registerInstance = function() {
    if (registry.indexOf(this) < 0) {
      registry.push(this);
    }
  };
  
  
  /**
   * Removes the instance from the global IntersectionObserver registry.
   * @private
   */
  IntersectionObserver.prototype._unregisterInstance = function() {
    var index = registry.indexOf(this);
    if (index != -1) registry.splice(index, 1);
  };
  
  
  /**
   * Returns the result of the performance.now() method or null in browsers
   * that don't support the API.
   * @return {number} The elapsed time since the page was requested.
   */
  function now() {
    return window.performance && performance.now && performance.now();
  }
  
  
  /**
   * Throttles a function and delays its execution, so it's only called at most
   * once within a given time period.
   * @param {Function} fn The function to throttle.
   * @param {number} timeout The amount of time that must pass before the
   *     function can be called again.
   * @return {Function} The throttled function.
   */
  function throttle(fn, timeout) {
    var timer = null;
    return function () {
      if (!timer) {
        timer = setTimeout(function() {
          fn();
          timer = null;
        }, timeout);
      }
    };
  }
  
  
  /**
   * Adds an event handler to a DOM node ensuring cross-browser compatibility.
   * @param {Node} node The DOM node to add the event handler to.
   * @param {string} event The event name.
   * @param {Function} fn The event handler to add.
   * @param {boolean} opt_useCapture Optionally adds the even to the capture
   *     phase. Note: this only works in modern browsers.
   */
  function addEvent(node, event, fn, opt_useCapture) {
    if (typeof node.addEventListener == 'function') {
      node.addEventListener(event, fn, opt_useCapture || false);
    }
    else if (typeof node.attachEvent == 'function') {
      node.attachEvent('on' + event, fn);
    }
  }
  
  
  /**
   * Removes a previously added event handler from a DOM node.
   * @param {Node} node The DOM node to remove the event handler from.
   * @param {string} event The event name.
   * @param {Function} fn The event handler to remove.
   * @param {boolean} opt_useCapture If the event handler was added with this
   *     flag set to true, it should be set to true here in order to remove it.
   */
  function removeEvent(node, event, fn, opt_useCapture) {
    if (typeof node.removeEventListener == 'function') {
      node.removeEventListener(event, fn, opt_useCapture || false);
    }
    else if (typeof node.detatchEvent == 'function') {
      node.detatchEvent('on' + event, fn);
    }
  }
  
  
  /**
   * Returns the intersection between two rect objects.
   * @param {Object} rect1 The first rect.
   * @param {Object} rect2 The second rect.
   * @return {?Object} The intersection rect or undefined if no intersection
   *     is found.
   */
  function computeRectIntersection(rect1, rect2) {
    var top = Math.max(rect1.top, rect2.top);
    var bottom = Math.min(rect1.bottom, rect2.bottom);
    var left = Math.max(rect1.left, rect2.left);
    var right = Math.min(rect1.right, rect2.right);
    var width = right - left;
    var height = bottom - top;
  
    return (width >= 0 && height >= 0) && {
      top: top,
      bottom: bottom,
      left: left,
      right: right,
      width: width,
      height: height
    };
  }
  
  
  /**
   * Shims the native getBoundingClientRect for compatibility with older IE.
   * @param {Element} el The element whose bounding rect to get.
   * @return {Object} The (possibly shimmed) rect of the element.
   */
  function getBoundingClientRect(el) {
    var rect;
  
    try {
      rect = el.getBoundingClientRect();
    } catch (err) {
      // Ignore Windows 7 IE11 "Unspecified error"
      // https://github.com/w3c/IntersectionObserver/pull/205
    }
  
    if (!rect) return getEmptyRect();
  
    // Older IE
    if (!(rect.width && rect.height)) {
      rect = {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };
    }
    return rect;
  }
  
  
  /**
   * Returns an empty rect object. An empty rect is returned when an element
   * is not in the DOM.
   * @return {Object} The empty rect.
   */
  function getEmptyRect() {
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }
  
  /**
   * Checks to see if a parent element contains a child element (including inside
   * shadow DOM).
   * @param {Node} parent The parent element.
   * @param {Node} child The child element.
   * @return {boolean} True if the parent node contains the child node.
   */
  function containsDeep(parent, child) {
    var node = child;
    while (node) {
      if (node == parent) return true;
  
      node = getParentNode(node);
    }
    return false;
  }
  
  
  /**
   * Gets the parent node of an element or its host element if the parent node
   * is a shadow root.
   * @param {Node} node The node whose parent to get.
   * @return {Node|null} The parent node or null if no parent exists.
   */
  function getParentNode(node) {
    var parent = node.parentNode;
  
    if (parent && parent.nodeType == 11 && parent.host) {
      // If the parent is a shadow root, return the host element.
      return parent.host;
    }
  
    if (parent && parent.assignedSlot) {
      // If the parent is distributed in a <slot>, return the parent of a slot.
      return parent.assignedSlot.parentNode;
    }
  
    return parent;
  }
  
  
  // Exposes the constructors globally.
  window.IntersectionObserver = IntersectionObserver;
  window.IntersectionObserverEntry = IntersectionObserverEntry;
  
  }());
  


(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
	typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
	(factory((global['vue-virtual-scroller'] = {}),global.Vue));
}(this, (function (exports,Vue) { 'use strict';

Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;

var config = {
  itemsLimit: 1000
};

function getInternetExplorerVersion() {
	var ua = window.navigator.userAgent;

	var msie = ua.indexOf('MSIE ');
	if (msie > 0) {
		// IE 10 or older => return version number
		return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
	}

	var trident = ua.indexOf('Trident/');
	if (trident > 0) {
		// IE 11 => return version number
		var rv = ua.indexOf('rv:');
		return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
	}

	var edge = ua.indexOf('Edge/');
	if (edge > 0) {
		// Edge (IE 12+) => return version number
		return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
	}

	// other browser
	return -1;
}

var isIE = void 0;

function initCompat() {
	if (!initCompat.init) {
		initCompat.init = true;
		isIE = getInternetExplorerVersion() !== -1;
	}
}

var ResizeObserver = { render: function render() {
		var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: 'resize-observer', attrs: { 'tabindex': '-1' } });
	}, staticRenderFns: [], _scopeId: 'data-v-b329ee4c',
	name: 'resize-observer',

	methods: {
		compareAndNotify: function compareAndNotify() {
			if (this._w !== this.$el.offsetWidth || this._h !== this.$el.offsetHeight) {
				this._w = this.$el.offsetWidth;
				this._h = this.$el.offsetHeight;
				this.$emit('notify');
			}
		},
		addResizeHandlers: function addResizeHandlers() {
			this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);
			this.compareAndNotify();
		},
		removeResizeHandlers: function removeResizeHandlers() {
			if (this._resizeObject && this._resizeObject.onload) {
				if (!isIE && this._resizeObject.contentDocument) {
					this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);
				}
				delete this._resizeObject.onload;
			}
		}
	},

	mounted: function mounted() {
		var _this = this;

		initCompat();
		this.$nextTick(function () {
			_this._w = _this.$el.offsetWidth;
			_this._h = _this.$el.offsetHeight;
		});
		var object = document.createElement('object');
		this._resizeObject = object;
		object.setAttribute('aria-hidden', 'true');
		object.setAttribute('tabindex', -1);
		object.onload = this.addResizeHandlers;
		object.type = 'text/html';
		if (isIE) {
			this.$el.appendChild(object);
		}
		object.data = 'about:blank';
		if (!isIE) {
			this.$el.appendChild(object);
		}
	},
	beforeDestroy: function beforeDestroy() {
		this.removeResizeHandlers();
	}
};

// Install the components
function install(Vue$$1) {
	Vue$$1.component('resize-observer', ResizeObserver);
	Vue$$1.component('ResizeObserver', ResizeObserver);
}

// Plugin
var plugin$2 = {
	// eslint-disable-next-line no-undef
	version: '0.4.5',
	install: install
};

// Auto-install
var GlobalVue$1 = null;
if (typeof window !== 'undefined') {
	GlobalVue$1 = window.Vue;
} else if (typeof global !== 'undefined') {
	GlobalVue$1 = global.Vue;
}
if (GlobalVue$1) {
	GlobalVue$1.use(plugin$2);
}

var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume('next', arg);
          }, function (arg) {
            resume('throw', arg);
          });
        } else {
          settle(result.done ? 'return' : 'normal', result.value);
        }
      } catch (err) {
        settle('throw', err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case 'return':
          front.resolve({
            value: value,
            done: true
          });
          break;

        case 'throw':
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== 'function') {
      this.return = undefined;
    }
  }

  if (typeof Symbol === 'function' && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke('next', arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke('throw', arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke('return', arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function');
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ('value' in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









































var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

function processOptions(value) {
	var options = void 0;
	if (typeof value === 'function') {
		// Simple options (callback-only)
		options = {
			callback: value
		};
	} else {
		// Options object
		options = value;
	}
	return options;
}

function throttle(callback, delay) {
	var timeout = void 0;
	var lastState = void 0;
	var currentArgs = void 0;
	var throttled = function throttled(state) {
		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		currentArgs = args;
		if (timeout && state === lastState) return;
		lastState = state;
		clearTimeout(timeout);
		timeout = setTimeout(function () {
			callback.apply(undefined, [state].concat(toConsumableArray(currentArgs)));
			timeout = 0;
		}, delay);
	};
	throttled._clear = function () {
		clearTimeout(timeout);
	};
	return throttled;
}

function deepEqual(val1, val2) {
	if (val1 === val2) return true;
	if ((typeof val1 === 'undefined' ? 'undefined' : _typeof(val1)) === 'object') {
		for (var key in val1) {
			if (!deepEqual(val1[key], val2[key])) {
				return false;
			}
		}
		return true;
	}
	return false;
}

var VisibilityState = function () {
	function VisibilityState(el, options, vnode) {
		classCallCheck(this, VisibilityState);

		this.el = el;
		this.observer = null;
		this.frozen = false;
		this.createObserver(options, vnode);
	}

	createClass(VisibilityState, [{
		key: 'createObserver',
		value: function createObserver(options, vnode) {
			var _this = this;

			if (this.observer) {
				this.destroyObserver();
			}

			if (this.frozen) return;

			this.options = processOptions(options);

			this.callback = this.options.callback;
			// Throttle
			if (this.callback && this.options.throttle) {
				this.callback = throttle(this.callback, this.options.throttle);
			}

			this.oldResult = undefined;

			this.observer = new IntersectionObserver(function (entries) {
				var entry = entries[0];
				if (_this.callback) {
					// Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.
					var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;
					if (result === _this.oldResult) return;
					_this.oldResult = result;
					_this.callback(result, entry);
					if (result && _this.options.once) {
						_this.frozen = true;
						_this.destroyObserver();
					}
				}
			}, this.options.intersection);

			// Wait for the element to be in document
			vnode.context.$nextTick(function () {
				_this.observer.observe(_this.el);
			});
		}
	}, {
		key: 'destroyObserver',
		value: function destroyObserver() {
			if (this.observer) {
				this.observer.disconnect();
				this.observer = null;
			}

			// Cancel throttled call
			if (this.callback && this.callback._clear) {
				this.callback._clear();
				this.callback = null;
			}
		}
	}, {
		key: 'threshold',
		get: function get$$1() {
			return this.options.intersection && this.options.intersection.threshold || 0;
		}
	}]);
	return VisibilityState;
}();

function bind(el, _ref, vnode) {
	var value = _ref.value;

	if (typeof IntersectionObserver === 'undefined') {
		console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');
	} else {
		var state = new VisibilityState(el, value, vnode);
		el._vue_visibilityState = state;
	}
}

function update(el, _ref2, vnode) {
	var value = _ref2.value,
	    oldValue = _ref2.oldValue;

	if (deepEqual(value, oldValue)) return;
	var state = el._vue_visibilityState;
	if (state) {
		state.createObserver(value, vnode);
	} else {
		bind(el, { value: value }, vnode);
	}
}

function unbind(el) {
	var state = el._vue_visibilityState;
	if (state) {
		state.destroyObserver();
		delete el._vue_visibilityState;
	}
}

var ObserveVisibility = {
	bind: bind,
	update: update,
	unbind: unbind
};

// Install the components
function install$1(Vue$$1) {
	Vue$$1.directive('observe-visibility', ObserveVisibility);
	/* -- Add more components here -- */
}

/* -- Plugin definition & Auto-install -- */
/* You shouldn't have to modify the code below */

// Plugin
var plugin$4 = {
	// eslint-disable-next-line no-undef
	version: '0.4.3',
	install: install$1
};

// Auto-install
var GlobalVue$2 = null;
if (typeof window !== 'undefined') {
	GlobalVue$2 = window.Vue;
} else if (typeof global !== 'undefined') {
	GlobalVue$2 = global.Vue;
}
if (GlobalVue$2) {
	GlobalVue$2.use(plugin$4);
}

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var scrollparent = createCommonjsModule(function (module) {
(function (root, factory) {
  if (typeof undefined === 'function' && undefined.amd) {
    undefined([], factory);
  } else if ('object' === 'object' && module.exports) {
    module.exports = factory();
  } else {
    root.Scrollparent = factory();
  }
}(commonjsGlobal, function () {
  var regex = /(auto|scroll)/;

  var parents = function (node, ps) {
    if (node.parentNode === null) { return ps; }

    return parents(node.parentNode, ps.concat([node]));
  };

  var style = function (node, prop) {
    return getComputedStyle(node, null).getPropertyValue(prop);
  };

  var overflow = function (node) {
    return style(node, 'overflow') + style(node, 'overflow-y') + style(node, 'overflow-x');
  };

  var scroll = function (node) {
   return regex.test(overflow(node));
  };

  var scrollParent = function (node) {
    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {
      return ;
    }

    var ps = parents(node.parentNode, []);

    for (var i = 0; i < ps.length; i += 1) {
      if (scroll(ps[i])) {
        return ps[i];
      }
    }

    return document.scrollingElement || document.documentElement;
  };

  return scrollParent;
}));
});

var _typeof$1 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
};





var asyncGenerator$1 = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume('next', arg);
          }, function (arg) {
            resume('throw', arg);
          });
        } else {
          settle(result.done ? 'return' : 'normal', result.value);
        }
      } catch (err) {
        settle('throw', err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case 'return':
          front.resolve({
            value: value,
            done: true
          });
          break;

        case 'throw':
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== 'function') {
      this.return = undefined;
    }
  }

  if (typeof Symbol === 'function' && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke('next', arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke('throw', arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke('return', arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();













var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var props = {
  items: {
    type: Array,
    required: true
  },

  keyField: {
    type: String,
    default: 'id'
  },

  direction: {
    type: String,
    default: 'vertical',
    validator: function validator(value) {
      return ['vertical', 'horizontal'].indexOf(value) > -1;
    }
  }
};

function simpleArray() {
  return this.items.length && _typeof$1(this.items[0]) !== 'object';
}

var supportsPassive = false;

if (typeof window !== 'undefined') {
  supportsPassive = false;
  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        supportsPassive = true;
      }
    });
    window.addEventListener('test', null, opts);
  } catch (e) {}
}

var uid = 0;

var RecycleScroller = {
  
  render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { directives: [{ name: 'observe-visibility', rawName: 'v-observe-visibility', value: _vm.handleVisibilityChange, expression: 'handleVisibilityChange' }], staticClass: 'vue-recycle-scroller', class: defineProperty({ ready: _vm.ready, 'page-mode': _vm.pageMode }, 'direction-' + _vm.direction, true), on: { '&scroll': function scroll($event) {
          return _vm.handleScroll($event);
        } } }, [_vm.$slots.before ? _c('div', { staticClass: 'vue-recycle-scroller__slot' }, [_vm._t('before')], 2) : _vm._e(), _vm._v(' '), _c('div', { ref: 'wrapper', staticClass: 'vue-recycle-scroller__item-wrapper', style: defineProperty({}, _vm.direction === 'vertical' ? 'minHeight' : 'minWidth', _vm.totalSize + 'px') }, _vm._l(_vm.pool, function (view) {
      return _c('div', { key: view.nr.id, staticClass: 'vue-recycle-scroller__item-view', class: { hover: _vm.hoverKey === view.nr.key }, style: _vm.ready ? { transform: 'translate' + (_vm.direction === 'vertical' ? 'Y' : 'X') + '(' + view.position + 'px)' } : null, on: { 'mouseenter': function mouseenter($event) {
            _vm.hoverKey = view.nr.key;
          }, 'mouseleave': function mouseleave($event) {
            _vm.hoverKey = null;
          } } }, [_vm._t('default', null, { item: view.item, index: view.nr.index, active: view.nr.used })], 2);
    }), 0), _vm._v(' '), _vm.$slots.after ? _c('div', { staticClass: 'vue-recycle-scroller__slot' }, [_vm._t('after')], 2) : _vm._e(), _vm._v(' '), _c('ResizeObserver', { on: { 'notify': _vm.handleResize } })], 1);
  }, staticRenderFns: [],
  name: 'RecycleScroller',

  components: {
    ResizeObserver: ResizeObserver
  },

  directives: {
    ObserveVisibility: ObserveVisibility
  },

  props: _extends({}, props, {

    itemSize: {
      type: Number,
      default: null
    },

    minItemSize: {
      type: [Number, String],
      default: null
    },

    sizeField: {
      type: String,
      default: 'size'
    },

    typeField: {
      type: String,
      default: 'type'
    },

    buffer: {
      type: Number,
      default: 200
    },

    pageMode: {
      type: Boolean,
      default: false
    },

    prerender: {
      type: Number,
      default: 0
    },

    emitUpdate: {
      type: Boolean,
      default: false
    }
  }),

  data: function data() {
    return {
      pool: [],
      totalSize: 0,
      ready: false,
      hoverKey: null
    };
  },


  computed: {
    sizes: function sizes() {
      if (this.itemSize === null) {
        var sizes = {
          '-1': { accumulator: 0 }
        };
        var items = this.items;
        var field = this.sizeField;
        var minItemSize = this.minItemSize;
        var accumulator = 0;
        var current = void 0;
        for (var i = 0, l = items.length; i < l; i++) {
          current = items[i][field] || minItemSize;
          accumulator += current;
          sizes[i] = { accumulator: accumulator, size: current };
        }
        return sizes;
      }
      return [];
    },


    simpleArray: simpleArray
  },

  watch: {
    items: function items() {
      this.updateVisibleItems(true);
    },
    pageMode: function pageMode() {
      this.applyPageMode();
      this.updateVisibleItems(false);
    },


    sizes: {
      handler: function handler() {
        this.updateVisibleItems(false);
      },

      deep: true
    }
  },

  created: function created() {
    this.$_startIndex = 0;
    this.$_endIndex = 0;
    this.$_views = new Map();
    this.$_unusedViews = new Map();
    this.$_scrollDirty = false;

    if (this.$isServer) {
      this.updateVisibleItems(false);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.applyPageMode();
    this.$nextTick(function () {
      _this.updateVisibleItems(true);
      _this.ready = true;
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.removeListeners();
  },


  methods: {
    addView: function addView(pool, index, item, key, type) {
      var view = {
        item: item,
        position: 0
      };
      var nonReactive = {
        id: uid++,
        index: index,
        used: true,
        key: key,
        type: type
      };
      Object.defineProperty(view, 'nr', {
        configurable: false,
        value: nonReactive
      });
      pool.push(view);
      return view;
    },
    unuseView: function unuseView(view) {
      var fake = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var unusedViews = this.$_unusedViews;
      var type = view.nr.type;
      var unusedPool = unusedViews.get(type);
      if (!unusedPool) {
        unusedPool = [];
        unusedViews.set(type, unusedPool);
      }
      unusedPool.push(view);
      if (!fake) {
        view.nr.used = false;
        view.position = -9999;
        this.$_views.delete(view.nr.key);
      }
    },
    handleResize: function handleResize() {
      this.$emit('resize');
      if (this.ready) this.updateVisibleItems(false);
    },
    handleScroll: function handleScroll(event) {
      var _this2 = this;

      if (!this.$_scrollDirty) {
        this.$_scrollDirty = true;
        requestAnimationFrame(function () {
          _this2.$_scrollDirty = false;

          var _updateVisibleItems = _this2.updateVisibleItems(false),
              continuous = _updateVisibleItems.continuous;

          // It seems sometimes chrome doesn't fire scroll event :/
          // When non continous scrolling is ending, we force a refresh


          if (!continuous) {
            clearTimeout(_this2.$_refreshTimout);
            _this2.$_refreshTimout = setTimeout(_this2.handleScroll, 100);
          }
        });
      }
    },
    handleVisibilityChange: function handleVisibilityChange(isVisible, entry) {
      var _this3 = this;

      if (this.ready) {
        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {
          this.$emit('visible');
          requestAnimationFrame(function () {
            _this3.updateVisibleItems(false);
          });
        } else {
          this.$emit('hidden');
        }
      }
    },
    updateVisibleItems: function updateVisibleItems(checkItem) {
      var itemSize = this.itemSize;
      var typeField = this.typeField;
      var keyField = this.simpleArray ? null : this.keyField;
      var items = this.items;
      var count = items.length;
      var sizes = this.sizes;
      var views = this.$_views;
      var unusedViews = this.$_unusedViews;
      var pool = this.pool;
      var startIndex = void 0,
          endIndex = void 0;
      var totalSize = void 0;

      if (!count) {
        startIndex = endIndex = totalSize = 0;
      } else if (this.$isServer) {
        startIndex = 0;
        endIndex = this.prerender;
        totalSize = null;
      } else {
        var scroll = this.getScroll();
        var buffer = this.buffer;
        scroll.start -= buffer;
        scroll.end += buffer;

        // Variable size mode
        if (itemSize === null) {
          var h = void 0;
          var a = 0;
          var b = count - 1;
          var i = ~~(count / 2);
          var oldI = void 0;

          // Searching for startIndex
          do {
            oldI = i;
            h = sizes[i].accumulator;
            if (h < scroll.start) {
              a = i;
            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {
              b = i;
            }
            i = ~~((a + b) / 2);
          } while (i !== oldI);
          i < 0 && (i = 0);
          startIndex = i;

          // For container style
          totalSize = sizes[count - 1].accumulator;

          // Searching for endIndex
          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++) {}
          if (endIndex === -1) {
            endIndex = items.length - 1;
          } else {
            endIndex++;
            // Bounds
            endIndex > count && (endIndex = count);
          }
        } else {
          // Fixed size mode
          startIndex = ~~(scroll.start / itemSize);
          endIndex = Math.ceil(scroll.end / itemSize);

          // Bounds
          startIndex < 0 && (startIndex = 0);
          endIndex > count && (endIndex = count);

          totalSize = count * itemSize;
        }
      }

      if (endIndex - startIndex > config.itemsLimit) {
        this.itemsLimitError();
      }

      this.totalSize = totalSize;

      var view = void 0;

      var continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex;
      var unusedIndex = void 0;

      if (this.$_continuous !== continuous) {
        if (continuous) {
          views.clear();
          unusedViews.clear();
          for (var _i = 0, l = pool.length; _i < l; _i++) {
            view = pool[_i];
            this.unuseView(view);
          }
        }
        this.$_continuous = continuous;
      } else if (continuous) {
        for (var _i2 = 0, _l = pool.length; _i2 < _l; _i2++) {
          view = pool[_i2];
          if (view.nr.used) {
            // Update view item index
            if (checkItem) {
              view.nr.index = VueUtil.findIndex(items, function (item) {
                return keyField ? item[keyField] === view.item[keyField] : item === view.item;
              });
            }

            // Check if index is still in visible range
            if (view.nr.index === -1 || view.nr.index < startIndex || view.nr.index >= endIndex) {
              this.unuseView(view);
            }
          }
        }
      }

      if (!continuous) {
        unusedIndex = new Map();
      }

      var item = void 0,
          type = void 0,
          unusedPool = void 0;
      var v = void 0;
      for (var _i3 = startIndex; _i3 < endIndex; _i3++) {
        item = items[_i3];
        var key = keyField ? item[keyField] : item;
        view = views.get(key);

        if (!itemSize && !sizes[_i3].size) {
          if (view) this.unuseView(view);
          continue;
        }

        // No view assigned to item
        if (!view) {
          type = item[typeField];

          if (continuous) {
            unusedPool = unusedViews.get(type);
            // Reuse existing view
            if (unusedPool && unusedPool.length) {
              view = unusedPool.pop();
              view.item = item;
              view.nr.used = true;
              view.nr.index = _i3;
              view.nr.key = key;
              view.nr.type = type;
            } else {
              view = this.addView(pool, _i3, item, key, type);
            }
          } else {
            unusedPool = unusedViews.get(type);
            v = unusedIndex.get(type) || 0;
            // Use existing view
            // We don't care if they are already used
            // because we are not in continous scrolling
            if (unusedPool && v < unusedPool.length) {
              view = unusedPool[v];
              view.item = item;
              view.nr.used = true;
              view.nr.index = _i3;
              view.nr.key = key;
              view.nr.type = type;
              unusedIndex.set(type, v + 1);
            } else {
              view = this.addView(pool, _i3, item, key, type);
              this.unuseView(view, true);
            }
            v++;
          }
          views.set(key, view);
        } else {
          view.nr.used = true;
          view.item = item;
        }

        // Update position
        if (itemSize === null) {
          view.position = sizes[_i3 - 1].accumulator;
        } else {
          view.position = _i3 * itemSize;
        }
      }

      this.$_startIndex = startIndex;
      this.$_endIndex = endIndex;

      if (this.emitUpdate) this.$emit('update', startIndex, endIndex);

      return {
        continuous: continuous
      };
    },
    getListenerTarget: function getListenerTarget() {
      var target = scrollparent(this.$el);
      // Fix global scroll target for Chrome and Safari
      if (window.document && (target === window.document.documentElement || target === window.document.body)) {
        target = window;
      }
      return target;
    },
    getScroll: function getScroll() {
      var el = this.$el,
          direction = this.direction;

      var isVertical = direction === 'vertical';
      var scrollState = void 0;

      if (this.pageMode) {
        var bounds = el.getBoundingClientRect();
        var boundsSize = isVertical ? bounds.height : bounds.width;
        var start = -(isVertical ? bounds.top : bounds.left);
        var size = isVertical ? window.innerHeight : window.innerWidth;
        if (start < 0) {
          size += start;
          start = 0;
        }
        if (start + size > boundsSize) {
          size = boundsSize - start;
        }
        scrollState = {
          start: start,
          end: start + size
        };
      } else if (isVertical) {
        scrollState = {
          start: el.scrollTop,
          end: el.scrollTop + el.clientHeight
        };
      } else {
        scrollState = {
          start: el.scrollLeft,
          end: el.scrollLeft + el.clientWidth
        };
      }

      return scrollState;
    },
    applyPageMode: function applyPageMode() {
      if (this.pageMode) {
        this.addListeners();
      } else {
        this.removeListeners();
      }
    },
    addListeners: function addListeners() {
      this.listenerTarget = this.getListenerTarget();
      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {
        passive: true
      } : false);
      this.listenerTarget.addEventListener('resize', this.handleResize);
    },
    removeListeners: function removeListeners() {
      if (!this.listenerTarget) {
        return;
      }

      this.listenerTarget.removeEventListener('scroll', this.handleScroll);
      this.listenerTarget.removeEventListener('resize', this.handleResize);

      this.listenerTarget = null;
    },
    scrollToItem: function scrollToItem(index) {
      var scroll = void 0;
      if (this.itemSize === null) {
        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0;
      } else {
        scroll = index * this.itemSize;
      }
      this.scrollToPosition(scroll);
    },
    scrollToPosition: function scrollToPosition(position) {
      if (this.direction === 'vertical') {
        this.$el.scrollTop = position;
      } else {
        this.$el.scrollLeft = position;
      }
    },
    itemsLimitError: function itemsLimitError() {
      var _this4 = this;

      setTimeout(function () {
        console.log('It seems the scroller element isn\'t scrolling, so it tries to render all the items at once.', 'Scroller:', _this4.$el);
        console.log('Make sure the scroller has a fixed height (or width) and \'overflow-y\' (or \'overflow-x\') set to \'auto\' so it can scroll correctly and only render the items visible in the scroll viewport.');
      });
      throw new Error('Rendered items limit reached');
    }
  }
};

var DynamicScroller = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('RecycleScroller', _vm._g(_vm._b({ ref: 'scroller', attrs: { 'items': _vm.itemsWithSize, 'min-item-size': _vm.minItemSize, 'direction': _vm.direction, 'key-field': 'id' }, on: { 'resize': _vm.onScrollerResize, 'visible': _vm.onScrollerVisible }, scopedSlots: _vm._u([{ key: 'default', fn: function fn(_ref) {
          var itemWithSize = _ref.item,
              index = _ref.index,
              active = _ref.active;
          return [_vm._t('default', null, null, {
            item: itemWithSize.item,
            index: index,
            active: active,
            itemWithSize: itemWithSize
          })];
        } }]) }, 'RecycleScroller', _vm.$attrs, false), _vm.listeners), [_c('template', { slot: 'before' }, [_vm._t('before')], 2), _vm._v(' '), _c('template', { slot: 'after' }, [_vm._t('after')], 2)], 2);
  }, staticRenderFns: [],
  name: 'DynamicScroller',

  components: {
    RecycleScroller: RecycleScroller
  },

  inheritAttrs: false,

  provide: function provide() {
    return {
      vscrollData: this.vscrollData,
      vscrollParent: this
    };
  },


  props: _extends({}, props, {

    minItemSize: {
      type: [Number, String],
      required: true
    }
  }),

  data: function data() {
    return {
      vscrollData: {
        active: true,
        sizes: {},
        validSizes: {},
        keyField: this.keyField,
        simpleArray: false
      }
    };
  },


  computed: {
    simpleArray: simpleArray,

    itemsWithSize: function itemsWithSize() {
      var result = [];
      var items = this.items,
          keyField = this.keyField,
          simpleArray$$1 = this.simpleArray;

      var sizes = this.vscrollData.sizes;
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var id = simpleArray$$1 ? i : item[keyField];
        var size = sizes[id];
        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {
          // eslint-disable-next-line vue/no-side-effects-in-computed-properties
          this.$_undefinedSizes++;
          // eslint-disable-next-line vue/no-side-effects-in-computed-properties
          this.$_undefinedMap[id] = true;
          size = 0;
        }
        result.push({
          item: item,
          id: id,
          size: size
        });
      }
      return result;
    },
    listeners: function listeners() {
      var listeners = {};
      for (var key in this.$listeners) {
        if (key !== 'resize' && key !== 'visible') {
          listeners[key] = this.$listeners[key];
        }
      }
      return listeners;
    }
  },

  watch: {
    items: function items() {
      this.forceUpdate(false);
    },


    simpleArray: {
      handler: function handler(value) {
        this.vscrollData.simpleArray = value;
      },

      immediate: true
    },

    direction: function direction(value) {
      this.forceUpdate(true);
    }
  },

  created: function created() {
    this.$_updates = [];
    this.$_undefinedSizes = 0;
    this.$_undefinedMap = {};
  },
  activated: function activated() {
    this.vscrollData.active = true;
  },
  deactivated: function deactivated() {
    this.vscrollData.active = false;
  },


  methods: {
    onScrollerResize: function onScrollerResize() {
      var scroller = this.$refs.scroller;
      if (scroller) {
        this.forceUpdate();
      }
      this.$emit('resize');
    },
    onScrollerVisible: function onScrollerVisible() {
      this.$emit('vscroll:update', { force: false });
      this.$emit('visible');
    },
    forceUpdate: function forceUpdate() {
      var clear = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (clear || this.simpleArray) {
        this.vscrollData.validSizes = {};
      }
      this.$emit('vscroll:update', { force: true });
    },
    scrollToItem: function scrollToItem(index) {
      var scroller = this.$refs.scroller;
      if (scroller) scroller.scrollToItem(index);
    },
    getItemSize: function getItemSize(item) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      var id = this.simpleArray ? index != null ? index : this.items.indexOf(item) : item[this.keyField];
      return this.vscrollData.sizes[id] || 0;
    },
    scrollToBottom: function scrollToBottom() {
      var _this = this;

      if (this.$_scrollingToBottom) return;
      this.$_scrollingToBottom = true;
      var el = this.$el;
      // Item is inserted to the DOM
      this.$nextTick(function () {
        // Item sizes are computed
        var cb = function cb() {
          el.scrollTop = el.scrollHeight;
          if (_this.$_undefinedSizes === 0) {
            _this.$_scrollingToBottom = false;
          } else {
            requestAnimationFrame(cb);
          }
        };
        requestAnimationFrame(cb);
      });
    }
  }
};

var DynamicScrollerItem = {
  name: 'DynamicScrollerItem',

  inject: ['vscrollData', 'vscrollParent'],

  props: {
    item: {
      required: true
    },

    watchData: {
      type: Boolean,
      default: false
    },

    active: {
      type: Boolean,
      required: true
    },

    index: {
      type: Number,
      default: undefined
    },

    sizeDependencies: {
      type: [Array, Object],
      default: null
    },

    emitResize: {
      type: Boolean,
      default: false
    },

    tag: {
      type: String,
      default: 'div'
    }
  },

  computed: {
    id: function id() {
      return this.vscrollData.simpleArray ? this.index : this.item[this.vscrollData.keyField];
    },
    size: function size() {
      return this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id] || 0;
    }
  },

  watch: {
    watchData: 'updateWatchData',

    id: function id() {
      if (!this.size) {
        this.onDataUpdate();
      }
    },
    active: function active(value) {
      if (value && this.$_pendingVScrollUpdate === this.id) {
        this.updateSize();
      }
    }
  },

  created: function created() {
    var _this = this;

    if (this.$isServer) return;

    this.$_forceNextVScrollUpdate = null;
    this.updateWatchData();

    var _loop = function _loop(k) {
      _this.$watch(function () {
        return _this.sizeDependencies[k];
      }, _this.onDataUpdate);
    };

    for (var k in this.sizeDependencies) {
      _loop(k);
    }

    this.vscrollParent.$on('vscroll:update', this.onVscrollUpdate);
    this.vscrollParent.$on('vscroll:update-size', this.onVscrollUpdateSize);
  },
  mounted: function mounted() {
    if (this.vscrollData.active) {
      this.updateSize();
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.vscrollParent.$off('vscroll:update', this.onVscrollUpdate);
    this.vscrollParent.$off('vscroll:update-size', this.onVscrollUpdateSize);
  },


  methods: {
    updateSize: function updateSize() {
      if (this.active && this.vscrollData.active) {
        if (this.$_pendingSizeUpdate !== this.id) {
          this.$_pendingSizeUpdate = this.id;
          this.$_forceNextVScrollUpdate = null;
          this.$_pendingVScrollUpdate = null;
          if (this.active && this.vscrollData.active) {
            this.computeSize(this.id);
          }
        }
      } else {
        this.$_forceNextVScrollUpdate = this.id;
      }
    },
    getBounds: function getBounds() {
      return this.$el.getBoundingClientRect();
    },
    updateWatchData: function updateWatchData() {
      var _this2 = this;

      if (this.watchData) {
        this.$_watchData = this.$watch('data', function () {
          _this2.onDataUpdate();
        }, {
          deep: true
        });
      } else if (this.$_watchData) {
        this.$_watchData();
        this.$_watchData = null;
      }
    },
    onVscrollUpdate: function onVscrollUpdate(_ref) {
      var force = _ref.force;

      if (!this.active && force) {
        this.$_pendingVScrollUpdate = this.id;
      }
      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {
        this.updateSize();
      }
    },
    onDataUpdate: function onDataUpdate() {
      this.updateSize();
    },
    computeSize: function computeSize(id) {
      var _this3 = this;

      this.$nextTick(function () {
        if (_this3.id === id) {
          var bounds = _this3.getBounds();
          var size = Math.round(_this3.vscrollParent.direction === 'vertical' ? bounds.height : bounds.width);
          if (size && _this3.size !== size) {
            if (_this3.vscrollParent.$_undefinedMap[id]) {
              _this3.vscrollParent.$_undefinedSizes--;
              _this3.vscrollParent.$_undefinedMap[id] = undefined;
            }
            _this3.$set(_this3.vscrollData.sizes, _this3.id, size);
            _this3.$set(_this3.vscrollData.validSizes, _this3.id, true);
            if (_this3.emitResize) _this3.$emit('resize', _this3.id);
          }
        }
        _this3.$_pendingSizeUpdate = null;
      });
    }
  },

  render: function render(h) {
    return h(this.tag, this.$slots.default);
  }
};

var IdState = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$idProp = _ref.idProp,
      idProp = _ref$idProp === undefined ? function (vm) {
    return vm.item.id;
  } : _ref$idProp;

  var store = {};
  var vm = new Vue({
    data: function data() {
      return {
        store: store
      };
    }
  });

  // @vue/component
  return {
    data: function data() {
      return {
        idState: null
      };
    },
    created: function created() {
      var _this = this;

      this.$_id = null;
      if (typeof idProp === 'function') {
        this.$_getId = function () {
          return idProp.call(_this, _this);
        };
      } else {
        this.$_getId = function () {
          return _this[idProp];
        };
      }
      this.$watch(this.$_getId, {
        handler: function handler(value) {
          var _this2 = this;

          this.$nextTick(function () {
            _this2.$_id = value;
          });
        },

        immediate: true
      });
      this.$_updateIdState();
    },
    beforeUpdate: function beforeUpdate() {
      this.$_updateIdState();
    },


    methods: {
      /**
       * Initialize an idState
       * @param {number|string} id Unique id for the data
       */
      $_idStateInit: function $_idStateInit(id) {
        var factory = this.$options.idState;
        if (typeof factory === 'function') {
          var data = factory.call(this, this);
          vm.$set(store, id, data);
          this.$_id = id;
          return data;
        } else {
          throw new Error('[mixin IdState] Missing `idState` function on component definition.');
        }
      },


      /**
       * Ensure idState is created and up-to-date
       */
      $_updateIdState: function $_updateIdState() {
        var id = this.$_getId();
        if (id == null) {
          console.warn('No id found for IdState with idProp: \'' + idProp + '\'.');
        }
        if (id !== this.$_id) {
          if (!store[id]) {
            this.$_idStateInit(id);
          }
          this.idState = store[id];
        }
      }
    }
  };
};

function registerComponents(Vue$$1, prefix) {
  Vue$$1.component(prefix + 'recycle-scroller', RecycleScroller);
  Vue$$1.component(prefix + 'RecycleScroller', RecycleScroller);
  Vue$$1.component(prefix + 'dynamic-scroller', DynamicScroller);
  Vue$$1.component(prefix + 'DynamicScroller', DynamicScroller);
  Vue$$1.component(prefix + 'dynamic-scroller-item', DynamicScrollerItem);
  Vue$$1.component(prefix + 'DynamicScrollerItem', DynamicScrollerItem);
}

var plugin = {
  // eslint-disable-next-line no-undef
  version: '1.0.0-rc.2',
  install: function install(Vue$$1, options) {
    var finalOptions = VueUtil.merge({}, {
      installComponents: true,
      componentsPrefix: 'vue-'
    }, options);

    for (var key in finalOptions) {
      if (typeof finalOptions[key] !== 'undefined') {
        config[key] = finalOptions[key];
      }
    }

    if (finalOptions.installComponents) {
      registerComponents(Vue$$1, finalOptions.componentsPrefix);
    }
  }
};

// Auto-install
var GlobalVue = null;
if (typeof window !== 'undefined') {
  GlobalVue = window.Vue;
} else if (typeof global !== 'undefined') {
  GlobalVue = global.Vue;
}
if (GlobalVue) {
  GlobalVue.use(plugin);
}

exports.RecycleScroller = RecycleScroller;
exports.DynamicScroller = DynamicScroller;
exports.DynamicScrollerItem = DynamicScrollerItem;
exports['default'] = plugin;
exports.IdState = IdState;

Object.defineProperty(exports, '__esModule', { value: true });

})));
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueLang = definition(context.Vue, context.VueUtil);
    delete context.VueLang;
    delete context.VuePopper;
    delete context.VuePopup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueLang = {
    zh: {
      vue: {
        colorpicker: {
          confirm: '确定',
          clear: '清空'
        },
        datepicker: {
          now: '此刻',
          today: '今天',
          thisMonth: '本月',
          cancel: '取消',
          clear: '清空',
          confirm: '确定',
          selectDate: '选择日期',
          selectTime: '选择时间',
          startDate: '开始日期',
          startTime: '开始时间',
          endDate: '结束日期',
          endTime: '结束时间',
          year: '年',
          month1: '1 月',
          month2: '2 月',
          month3: '3 月',
          month4: '4 月',
          month5: '5 月',
          month6: '6 月',
          month7: '7 月',
          month8: '8 月',
          month9: '9 月',
          month10: '10 月',
          month11: '11 月',
          month12: '12 月',
          week: '周',
          weeks: {
            sun: '日',
            mon: '一',
            tue: '二',
            wed: '三',
            thu: '四',
            fri: '五',
            sat: '六'
          },
          months: {
            jan: '一月',
            feb: '二月',
            mar: '三月',
            apr: '四月',
            may: '五月',
            jun: '六月',
            jul: '七月',
            aug: '八月',
            sep: '九月',
            oct: '十月',
            nov: '十一月',
            dec: '十二月'
          }
        },
        select: {
          loading: '加载中',
          noMatch: '无匹配数据',
          noData: '无数据',
          placeholder: '请选择'
        },
        cascader: {
          noMatch: '无匹配数据',
          placeholder: '请选择'
        },
        pagination: {
          goto: '前往',
          pagesize: '条/页',
          total: '共 {total} 条',
          pageClassifier: '页'
        },
        messagebox: {
          title: '提示',
          confirm: '确定',
          cancel: '取消',
          error: '输入的数据不合法!'
        },
        upload: {
          delete: '删除',
          preview: '查看图片',
          continue: '继续上传'
        },
        table: {
          emptyText: '暂无数据',
          confirmFilter: '筛选',
          resetFilter: '重置',
          clearFilter: '全部',
          sumText: '合计',
          countText: '总数',
          averageText: '平均值',
          minText: '最小值',
          maxText: '最大值',
          contextMenu: '快捷菜单',
          pin: '固定列',
          leftPin: '固定至左边',
          rightPin: '固定至右边',
          sort: '排序',
          sortBy: '排序集',
          filter: '过滤',
          column: '字段',
          conditions: '条件',
          filterBy: '过滤集',
          display: '列显示',
          exportData: '数据导出',
          fileName: '文件名',
          exportOrgData: '导出原始数据',
          exportHandleData: '导出数据'
        },
        tree: {
          emptyText: '暂无数据'
        },
        screenfull: {
          canot: '不兼容您的浏览器!'
        },
        image:{
          error: '加载失败'
        },
        xtable: {
          error: {
            groupFixed: '如果使用分组表头，固定列必须在左右两侧',
            // scrollXNotResizable: '横向虚拟滚动不支持 "resizable"',
            cellEditRender: '渲染器 "cell-render" 和 "edit-render" 不能同时使用',
            treeFixedExpand: '树结构的固定列与展开行功能有冲突',
            scrollOriginal: '虚拟滚动启用后只能导出源数据，请将设置 "original=true"',
            scrollXNotGroup: '横向虚拟滚动不支持分组表头',
            scrollYReqProp: '纵向虚拟滚动需要设置 {0}',
            unableInsert: '无法插入到指定位置',
            useErr: '安装 {0} 模块时发生错误，顺序不正确',
            barUnableLink: '工具栏无法关联表格',
            toolbarId: '工具栏需要设置唯一 "id"',
            toolbarDelBtn: '工具栏按钮 {0} 已废弃，请使用 {1}',
            reqModule: '缺少 {0} 模块',
            emptyProp: '参数 {0} 不允许为空',
            notFunc: '{0} 方法不存在',
            noTree: '树结构不支持 {0}',
            delFunc: '方法 {0} 已废弃，请使用 {1}',
            delProp: '参数 {0} 已废弃，请使用 {1}',
            notType: '不支持的文件类型 "{0}"',
            notExp: '该浏览器不支持导入/导出功能',
            impFields: '导入失败，请检查字段名和数据格式是否正确',
            fixColumnDrag: '固定列不允许拖动！'
          },
          table: {
            emptyText: '暂无数据',
            confirmFilter: '筛选',
            resetFilter: '重置',
            allFilter: '全部',
            impSuccess: '导入成功',
            expSuccess: '导出成功'
          },
          column: {
            indexTitle: '#'
          },
          grid: {
            selectOneRecord: '请至少选择一条记录！',
            deleteSelectRecord: '您确定要删除所选记录吗？',
            removeSelectRecord: '您确定要移除所选记录吗？',
            dataUnchanged: '数据未改动！ ',
            saveSuccess: '保存成功'
          },
          pager: {
            goto: '前往',
            pagesize: '条/页',
            total: '共 {total} 条记录',
            pageClassifier: '页'
          },
          types: {
            csv: 'CSV (逗号分隔)(*.csv)',
            html: '网页(*.html)',
            xml: 'XML 数据(*.xml)',
            txt: '文本文件(制表符分隔)(*.txt)',
            xlsx: 'Excel 工作簿(*.xlsx)',
            pdf: 'PDF (*.pdf)'
          },
          toolbar: {
            impTitle: '导入参数设置',
            impFile: '文件名',
            impSelect: '选择文件',
            impType: '文件类型',
            impOpts: '导入选项',
            impConfirm: '导入',
            impModeCovering: '覆盖',
            impModeAppend: '追加',
            expTitle: '导出参数设置',
            expName: '文件名',
            expNamePlaceholder: '请输入文件名',
            expSheetName: '工作表名称',
            expSheetNamePlaceholder: '请输入工作表名称',
            expType: '保存类型',
            expMode: '要导出的数据',
            expAll: '全部数据',
            expSelected: '选中数据',
            expAllColumn: '全部字段',
            expColumn: '要导出的字段',
            expOpts: '导出选项',
            expOptHeader: '表头',
            expOptFooter: '表尾',
            expOptOriginal: '源(支持导入)',
            expPrint: '打印',
            expConfirm: '导出',
            refresh: '刷新',
            addRow: '新增行',
            insertRow: '插入行',
            delRow: '删除行',
          }
        }
      }
    },
    ja: {
      vue: {
        colorpicker: {
          confirm: 'はい',
          clear: 'クリア'
        },
        datepicker: {
          now: '現在',
          today: '今日',
          thisMonth: '今月',
          cancel: 'キャンセル',
          clear: 'クリア',
          confirm: 'はい',
          selectDate: '日付を選択',
          selectTime: '時間を選択',
          startDate: '開始日',
          startTime: '開始時間',
          endDate: '終了日',
          endTime: '終了時間',
          year: '年',
          week: '週',
          month1: '1月',
          month2: '2月',
          month3: '3月',
          month4: '4月',
          month5: '5月',
          month6: '6月',
          month7: '7月',
          month8: '8月',
          month9: '9月',
          month10: '10月',
          month11: '11月',
          month12: '12月',
          weeks: {
            sun: '日',
            mon: '月',
            tue: '火',
            wed: '水',
            thu: '木',
            fri: '金',
            sat: '土'
          },
          months: {
            jan: '1月',
            feb: '2月',
            mar: '3月',
            apr: '4月',
            may: '5月',
            jun: '6月',
            jul: '7月',
            aug: '8月',
            sep: '9月',
            oct: '10月',
            nov: '11月',
            dec: '12月'
          }
        },
        select: {
          loading: 'ロード中',
          noMatch: 'データなし',
          noData: 'データなし',
          placeholder: '選択してください'
        },
        cascader: {
          noMatch: 'データなし',
          placeholder: '選択してください'
        },
        pagination: {
          goto: '',
          pagesize: '件/ページ',
          total: '総計 {total} 件',
          pageClassifier: 'ページ目へ'
        },
        messagebox: {
          title: 'メッセージ',
          confirm: 'はい',
          cancel: 'キャンセル',
          error: '正しくない入力'
        },
        upload: {
          delete: '削除する',
          preview: 'プレビュー',
          continue: '続行する'
        },
        table: {
          emptyText: 'データなし',
          confirmFilter: '確認',
          resetFilter: '初期化',
          clearFilter: 'すべて',
          sumText: '合計',
          countText: '総数',
          averageText: '平均値',
          minText: '最小値',
          maxText: '最大値',
          contextMenu: 'コンテキスト・メニュー',
          pin: '固定列',
          leftPin: '左に固定',
          rightPin: '右に固定',
          sort: 'ソート',
          sortBy: 'ソート集',
          filter: 'フィルター',
          column: 'カラム',
          conditions: '条件',
          filterBy: 'フィルター集',
          display: '列表示',
          exportData: 'データ出力',
          fileName: 'ファイル名',
          exportOrgData: '元データ出力',
          exportHandleData: 'データ出力'
        },
        tree: {
          emptyText: 'データなし'
        },
        screenfull: {
          canot: 'ブラウザは実行できません!'
        },
        image: {
          error: '読み込みに失敗しました'
        },
        xtable: {
          error: {
            groupFixed: 'Grouping headersが使われている場合、fixed columnsは左右になくてはなりません',
            // scrollXNotResizable: 'Horizontal virtual scrollingは"resizable"をサポートしていません',
            cellEditRender: 'Rendererは"cell-render"と"edit-render"を同時に仕様できません',
            treeFixedExpand: '樹木構造の固定柱は展開された行と矛盾する。',
            scrollOriginal: 'Virtual scrollingはsource dataのみエクスポートできます、"original=true"を設定してください',
            scrollXNotGroup: '横向虚拟滚动不支持分组表头',
            scrollYReqProp: 'Virtual scrollingを有効にするには"{{0}}を設定してください',
            unableInsert: '指定された位置に挿入できない',
            useErr: '{0} モジュールのインストール時にエラーが発生し、エラーのインストール順序',
            barUnableLink: 'ツールバーはフォームを関連付けることができない',
            toolbarId: 'ツールバーはユニーク"id"を設定する必要がある',
            toolbarDelBtn: '工具栏按钮 {0} 已废弃，请使用 {1}',
            reqModule: '{0}モジュールが必要',
            emptyProp: '{0} propertyはemptyが許可されていません',
            notFunc: '{0} methodがありません',
            noTree: 'Tree structureは {0} をサポートしていません',
            delFunc: '{0} functionは非推奨です、{1}を使用してください',
            delProp: '{0} propertyは非推奨です、{1}を使用してください',
            notType: 'サポートされていないファイルタイプ {0}',
            notExp: 'ブラウザはインポート/エクスポート機能をサポートしていません',
            impFields: 'インポートに失敗しました。フィールド名とデータ形式が正しいことを確認してください',
            fixColumnDrag: '固定列はドラッグできません！'
          },
          table: {
            emptyText: 'データがありません',
            confirmFilter: '完了',
            resetFilter: 'リセット',
            allFilter: '全て',
            impSuccess: 'インポートに成功しました',
            expSuccess: 'エクスポートに成功しました'
          },
          column: {
            indexTitle: '#'
          },
          grid: {
            selectOneRecord: '少なくとも1つのレコードを選択してください',
            deleteSelectRecord: 'レコードを削除してもよろしいですか？',
            removeSelectRecord: 'レコードを削除してもよろしいですか？',
            dataUnchanged: 'データは変更されませんでした',
            saveSuccess: '保存しました'
          },
          pager: {
            goto: '移動',
            pagesize: '件/ページ',
            total: '全 {total} 件',
            pageClassifier: ''
          },
          types: {
            csv: 'CSV (カンマ区切り)(*.csv)',
            html: 'ウェブページ(*.html)',
            xml: 'XML データ(*.xml)',
            txt: 'テキスト(タブ区切り)(*.txt)',
            xlsx: 'Excel ワークブック(*.xlsx)',
            pdf: 'PDF (*.pdf)'
          },
          toolbar: {
            impTitle: 'インポート設定',
            impFile: 'ファイル名',
            impSelect: 'ファイルを選択',
            impType: 'ファイルタイプ',
            impOpts: 'オプション',
            impConfirm: 'インポート',
            impModeCovering: '上書きする',
            impModeAppend: '追加',
            expTitle: 'エクスポート設定',
            expName: 'ファイル名',
            expNamePlaceholder: 'ファイル名を入力してください',
            expSheetName: 'シート名',
            expSheetNamePlaceholder: 'シート名を入力してください',
            expType: 'エクスポートタイプ',
            expMode: 'エクスポートするデータ',
            expAll: 'すべてエクスポート',
            expSelected: '選択したデータ',
            expAllColumn: 'すべての列',
            expColumn: 'エクスポートする列',
            expOpts: 'オプション',
            expOptHeader: 'ヘッダー',
            expOptFooter: 'フッター',
            expOptOriginal: 'ソース（インポートをサポート）',
            expPrint: 'プリント',
            expConfirm: 'エクスポート',
            refresh: 'リフレッシュ',
            addRow: '行追加',
            insertRow: '行挿入',
            delRow: '行削除',
          }
        }
      }
    },
    en: {
      vue: {
        colorpicker: {
          confirm: 'OK',
          clear: 'Clear'
        },
        datepicker: {
          now: 'Now',
          today: 'Today',
          thisMonth: 'This Month',
          cancel: 'Cancel',
          clear: 'Clear',
          confirm: 'OK',
          selectDate: 'Select date',
          selectTime: 'Select time',
          startDate: 'Start Date',
          startTime: 'Start Time',
          endDate: 'End Date',
          endTime: 'End Time',
          year: '',
          week: 'Wk',
          month1: 'Jan',
          month2: 'Feb',
          month3: 'Mar',
          month4: 'Apr',
          month5: 'May',
          month6: 'Jun',
          month7: 'Jul',
          month8: 'Aug',
          month9: 'Sep',
          month10: 'Oct',
          month11: 'Nov',
          month12: 'Dec',
          weeks: {
            sun: 'Sun',
            mon: 'Mon',
            tue: 'Tue',
            wed: 'Wed',
            thu: 'Thu',
            fri: 'Fri',
            sat: 'Sat'
          },
          months: {
            jan: 'Jan',
            feb: 'Feb',
            mar: 'Mar',
            apr: 'Apr',
            may: 'May',
            jun: 'Jun',
            jul: 'Jul',
            aug: 'Aug',
            sep: 'Sep',
            oct: 'Oct',
            nov: 'Nov',
            dec: 'Dec'
          }
        },
        select: {
          loading: 'Loading',
          noMatch: 'No matching data',
          noData: 'No data',
          placeholder: 'Select'
        },
        cascader: {
          noMatch: 'No matching data',
          placeholder: 'Select'
        },
        pagination: {
          goto: 'Go to',
          pagesize: '/page',
          total: 'Total {total}',
          pageClassifier: ''
        },
        messagebox: {
          title: 'Message',
          confirm: 'OK',
          cancel: 'Cancel',
          error: 'Illegal input'
        },
        upload: {
          delete: 'Delete',
          preview: 'Preview',
          continue: 'Continue'
        },
        table: {
          emptyText: 'No Data',
          confirmFilter: 'Confirm',
          resetFilter: 'Reset',
          clearFilter: 'All',
          sumText: 'Sum',
          countText: 'Count',
          averageText: 'Average',
          minText: 'Mix',
          maxText: 'Max',
          contextMenu: 'Context Menu',
          pin: 'Pin',
          leftPin: 'Left Pin',
          rightPin: 'Right Pin',
          sort: 'Sort',
          sortBy: 'Sort By',
          filter: 'Filter',
          column: 'Column',
          conditions: 'Conditions',
          filterBy: 'Filter By',
          display: 'Display',
          exportData: 'Data Export',
          fileName: 'File Name',
          exportOrgData: 'Original Data Export',
          exportHandleData: 'Data Export'
        },
        tree: {
          emptyText: 'No Data'
        },
        screenfull: {
          canot: 'You browser can\'t work!'
        },
        image:{
          error: 'Failed to load'
        },
        xtable: {
          error: {
            groupFixed: 'If grouping headers are used, fixed columns must be on the left and right sides.',
            // scrollXNotResizable: 'Horizontal virtual scrolling does not support "resizable".',
            cellEditRender: 'The renderer "cell-render" and "edit-render" cannot be used together.',
            treeFixedExpand: 'The fixed columns of the tree structure conflict with the expanded row.',
            scrollOriginal: 'Virtual scrolling can only export source data, please set "original=true".',
            scrollXNotGroup: 'Horizontal Virtual scrolling does not support grouping headers',
            scrollYReqProp: 'Vertical virtual scrolling requires setting the {0}.',
            unableInsert: 'Unable to insert to the specified location.',
            useErr: 'An error occurred while installing {0} module. The sequence is not correct.',
            barUnableLink: 'Toolbar cannot associate table.',
            toolbarId: 'Toolbar must have a unique "id"',
            toolbarDelBtn: 'Toolbar button {0} is deprecated, please use {1}',
            reqModule: 'require {0} module.',
            emptyProp: 'The property {0} is not allowed to be empty.',
            notFunc: '{0} method not exist.',
            noTree: 'The tree structure does not support {0}.',
            delFunc: 'The property {0} is deprecated, please use {1}.',
            delProp: 'The function {0} is deprecated, please use {1}.',
            notType: 'Unsupported file types {0}',
            notExp: 'The browser does not support import / export.',
            impFields: 'Import failed, please check that the field name and data format are correct.',
            fixColumnDrag: 'Fixed columns are not allowed to drag!'
          },
          table: {
            emptyText: 'No Data',
            confirmFilter: 'Confirm',
            resetFilter: 'Reset',
            allFilter: 'All',
            impSuccess: 'Import success',
            expSuccess: 'Export success'
          },
          column: {
            indexTitle: '#'
          },
          grid: {
            selectOneRecord: 'Please choose at least one piece of record!',
            deleteSelectRecord: 'Are you sure you want to delete the selected record?',
            removeSelectRecord: 'Are you sure you want to remove the selected record?',
            dataUnchanged: 'Data unchanged! ',
            saveSuccess: 'save successfully.'
          },
          pager: {
            goto: 'Go to',
            pagesize: '/page',
            total: 'Total {total} record',
            pageClassifier: ''
          },
          types: {
            csv: 'CSV (Comma separated) (*.csv)',
            html: 'Web Page (*.html)',
            xml: 'XML Data(*.xml)',
            txt: 'Text (Tab delimited) (*.txt)',
            xlsx: 'Excel Workbook (*.xlsx)',
            pdf: 'PDF (*.pdf)'
          },
          toolbar: {
            impTitle: 'Import parameter settings',
            impFile: 'Filename',
            impSelect: 'Select file',
            impType: 'File type',
            impOpts: 'Import option',
            impConfirm: 'Import',
            impModeCovering: 'Covering',
            impModeAppend: 'Append',
            expTitle: 'Export parameter settings',
            expName: 'Filename',
            expNamePlaceholder: 'Please enter filename',
            expSheetName: 'Sheet name',
            expSheetNamePlaceholder: 'Please enter a sheet name.',
            expType: 'Save the type',
            expMode: 'Data to export',
            expAll: 'All data',
            expSelected: 'Selected data',
            expAllColumn: 'All the field',
            expColumn: 'The field to export',
            expOpts: 'Export option',
            expOptHeader: 'Header',
            expOptFooter: 'Footer',
            expOptOriginal: 'Original (Support for importing)',
            expPrint: 'Print',
            expConfirm: 'Export',
            refresh: 'Refresh',
            addRow: 'Add Row',
            insertRow: 'Insert Row',
            delRow: 'Delete Row',
          }
        }
      }
    }
  };
  VueUtil.setLocale('zh', VueLang.zh);
  VueUtil.setLocale('ja', VueLang.ja);
  VueUtil.setLocale('en', VueLang.en);
  VueUtil.setLang('zh');

  if(typeof bundleModule != 'undefined') {
    bundleModule.lang = VueLang;
  }
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueFormatter = definition();
  }
})(this, function() {
  
  'use strict';

  // var format = function(value, regex) {
  //   var res = '';
  //   if(!regex.test(value)) {
  //     for (var i = 0; i < value.length; i++) {
  //       var char = value.charAt(i);
  //       if(regex.test(char)) {
  //         res += char;
  //       }
  //     }
  //   } else {
  //     res = value;
  //   }
  //   return res;
  // };

  var alpha = function(value) {
    // return format(value, /^([a-zA-Z]+)$/);
    return value.replace(/([^a-zA-Z])/, '');
  };
  var alnum = function(value) {
    //return format(value, /^([a-zA-Z0-9\.]+)$/);
    return value.replace(/([^a-zA-Z0-9.])/, '');
  };
  var alint = function(value) {
    // return format(value, /^([a-zA-Z0-9]+)$/);
    return value.replace(/([^a-zA-Z0-9])/, '');
  };
  // //todo 由于英文被禁止，输入法无法输入日语。
  // var halfwidthkana = function(value) {
  //   return format(value, /^([ｧ-ﾝﾞﾟ ]+)$/);
  // };
  // var hiragana = function(value) {
  //   return format(value, /^([ぁ-ん 　]+)$/);
  // };
  // var katakana = function(value) {
  //   return format(value, /^([ァ-ヶー 　]+)$/);
  // };
  // var fullwithkana = function(value) {
  //   return format(value, /^([ァ-ヶーぁ-ん 　]+)$/);
  // };
  // //end todo

  var alnumsymbol = function(value) {
    // return format(value, /^([0-9a-zA-Z\!\"\#\$\%\&\'\(\)\-\=\^\~\\\|\@\`\[\{\;\+\:\*\]\}\,\>\.\<;\/\?\_ ]+)$/);
    return value.replace(/([^0-9a-zA-Z\!\"\#\$\%\&\'\(\)\-\=\^\~\\\|\@\`\[\{\;\+\:\*\]\}\,\>\.\<;\/\?\_ ])/, '');
  };
  var alnumhyphenasterisk = function(value) {
    return value.replace(/([^0-9a-zA-Z\-*])/, '');
  };
  var alnumhyphen = function(value) {
    // return format(value, /^([0-9a-zA-Z\-]+)$/);
    return value.replace(/([^0-9a-zA-Z\-])/, '');
  };
  var VueFormatter = {
    alpha: alpha,
    alnum: alnum,
    alint: alint,
    // halfwidthkana: halfwidthkana,
    // hiragana: hiragana,
    // katakana: katakana,
    // fullwithkana: fullwithkana,
    alnumsymbol: alnumsymbol,
    alnumhyphenasterisk: alnumhyphenasterisk,
    alnumhyphen: alnumhyphen,
  };
  Vue.prototype.$formatter = VueFormatter;
  return VueFormatter;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueRules = definition();
  }
})(this, function() {
  'use strict';

  var basicRule = function(rule, value, callback, regex) {
    if (regex.test(value)) {
      callback();
    } else {
      callback(new Error(rule.message));
    }
  };

  var halfwidthkana = function(rule, value, callback) {
    return basicRule(rule, value, callback, /^([ｧ-ﾝﾞﾟ ]+)$/);
  };
  var hiragana = function(rule, value, callback) {
    return basicRule(rule, value, callback, /^([ぁ-ん 　]+)$/);
  };
  var katakana = function(rule, value, callback) {
    return basicRule(rule, value, callback, /^([ァ-ヶー 　]+)$/);
  };
  var fullwithkana = function(rule, value, callback) {
    return basicRule(rule, value, callback, /^([ァ-ヶーぁ-ん 　]+)$/);
  };

  var VueRules = {
    halfwidthkana: halfwidthkana,
    hiragana: hiragana,
    katakana: katakana,
    fullwithkana: fullwithkana,
  };
  Vue.prototype.$rules = VueRules;
  return VueRules;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.ImageViewer = definition(context.Vue, context.VueUtil);
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var isServer = Vue.prototype.$isServer;
  var template= '\
    <transition name="viewer-fade"> \
      <div class="vue-image-viewer__wrapper" :style="{ \'z-index\': zIndex }" > \
        <div :class="[\'vue-image-viewer__mask\',{\'mask__dark\':isMobile}]"></div> \
        <span v-if="isMobile && !isSingle" class="vue-image-view__titile">{{imgIndex+1+\' / \'+ imgsLength}}</span>\
        <!-- CLOSE --> \
        <span :class="[\'vue-image-viewer__btn\',isMobile ? \'vue-image-viewer__close_light\':\'vue-image-viewer__close\']" class=" " @click="hide"> \
          <i class="vue-icon-close"></i> \
        </span> \
        <!-- ARROW --> \
        <template v-if="!isSingle && !isMobile"> \
          <span class="vue-image-viewer__btn vue-image-viewer__prev" :class="{ \'is-disabled\': !infinite && isFirst }" \
            @click="prev"> \
            <i class="vue-icon-arrow-left"/> \
          </span> \
          <span class="vue-image-viewer__btn vue-image-viewer__next" \
            :class="{ \'is-disabled\': !infinite && isLast }" @click="next"> \
            <i class="vue-icon-arrow-right"/> \
          </span> \
        </template> \
        <!-- ACTIONS --> \
        <div class="vue-image-viewer__btn vue-image-viewer__actions"> \
          <div class="vue-image-viewer__actions__inner"> \
            <i class="vue-icon-zoom-out" @click="handleActions(\'zoomOut\')"></i> \
            <i class="vue-icon-zoom-in" @click="handleActions(\'zoomIn\')"></i> \
            <i class="vue-image-viewer__actions__divider"></i> \
            <i v-if="!isMobile" :class="mode.icon" @click="toggleMode"></i> \
            <i v-if="!isMobile" class="vue-image-viewer__actions__divider"></i> \
            <i class="vue-icon-rotate-left" @click="handleActions(\'anticlocelise\')"></i> \
            <i class="vue-icon-rotate-right" @click="handleActions(\'clocelise\')"></i> \
          </div> \
        </div> \
        <!-- CANVAS --> \
        <div @touchstart="touchStart" @touchmove="touchMove" @touchend="touchEnd" class="vue-image-viewer__canvas"> \
          <img v-for="(url, i) in urlList" \
            v-if="i === imgIndex" ref="img" \
            :key="url" :src="currentImg" :style="imgStyle" @load="handleImgLoad" \
            @error="handleImgError" @mousedown="handleMouseDown" /> \
        </div> \
      </div> \
    </transition>';

  var on = VueUtil.on,off=VueUtil.off;
  var rafThrottle = function(fn) {
    var locked = false;
    return function() {
     var args = [];
     for(var i=0;i<arguments.length;i++){
         args.push(arguments[i]);
     }
     if (locked) return;
       locked = true;
        var self = this;
        window.requestAnimationFrame(function(){
        fn.apply(self, args);
        locked = false;
        });
    };
  },
  isFirefox = function() {
    return !Vue.prototype.$isServer && !!window.navigator.userAgent.match(/firefox/i);
  };
  
  
  var Mode = {
    CONTAIN: {
      name: 'contain',
      icon: 'vue-icon-enlarge'
    },
    ORIGINAL: {
      name: 'original',
      icon: 'vue-icon-shrink'
    }
  };
  
  var mousewheelEventName = isFirefox() ? 'DOMMouseScroll' : 'mousewheel';
  
  //export default {
  var ImageViewer = {
    template: template,
    name: 'VueImageViewer',
  
    props: {
      urlList: {
        type: Array,
        default: function(){ return [];}
      },
      zIndex: {
        type: Number,
        default: 2000
      },
      activeIndex: {
        type: Number,
        default: 0
      },
      onSwitch: {
        type: Function,
        default: function(){ return {};}
      },
      onClose: {
        type: Function,
        default: function(){ return {};}
      }
    },
  
    data: function() {
      return {
        isShow: false,
        infinite: true,
        loading: false,
        mode: Mode.CONTAIN,
        transform: {
          scale: 1,
          deg: 0,
          offsetX: 0,
          offsetY: 0,
          enableTransition: false
        },
        isMobile: VueUtil.getSystemInfo().device == 'Mobile' && VueUtil.getSystemInfo().isLoadMobileJs ? true : false,
        mTouchStartX:0,
        mTouchEndX:0,
        imgIndex:this.activeIndex
      };
    },
    computed: {
      imgsLength: function (){
        return this.urlList.length;
      },
      isSingle: function() {
        return this.urlList.length <= 1;
      },
      isFirst: function() {
        return this.imgIndex === 0;
      },
      isLast: function() {
        return this.imgIndex === this.urlList.length - 1;
      },
      currentImg: function() {
        return this.urlList[this.imgIndex];
      },
      imgStyle: function() {
        var transform = this.transform;
        var scale = transform['scale'],
            deg = transform['deg'],
            offsetX = transform['offsetX'],
            offsetY = transform['offsetY'],
            enableTransition = transform['enableTransition'];
        var style = {
          transform: 'scale('+scale+') rotate('+deg+'deg)',
          transition: enableTransition ? 'transform .3s' : '',
          'margin-left': offsetX+'px',
          'margin-top': offsetY+'px'
        };
        if (this.mode === Mode.CONTAIN) {
          style.maxWidth = style.maxHeight = '100%';
        }
        return style;
      }
    },
    watch: {
      imgIndex: {
        handler: function(val) {
          this.reset();
          this.onSwitch(val);
        }
      },
      currentImg: function(val) {
        var self = this;
        this.$nextTick(function(){
          var $img = self.$refs.img[0];
          if (!$img.complete) {
            self.loading = true;
          }
        });
      }
    },
    methods: {
      hide: function() {
        this.deviceSupportUninstall();
        this.onClose();
      },
      deviceSupportInstall: function() {
        var self = this;
        this._keyDownHandler = rafThrottle(function(e) {
          var keyCode = e.keyCode;
          switch (keyCode) {
            // ESC
            case 27:
              self.hide();
              break;
            // SPACE
            case 32:
              self.toggleMode();
              break;
            // LEFT_ARROW
            case 37:
              self.prev();
              break;
            // UP_ARROW
            case 38:
              self.handleActions('zoomIn');
              break;
            // RIGHT_ARROW
            case 39:
              self.next();
              break;
            // DOWN_ARROW
            case 40:
              self.handleActions('zoomOut');
              break;
          }
        });
        self._mouseWheelHandler = rafThrottle(function(e){
          var delta = e.wheelDelta ? e.wheelDelta : -e.detail;
          if (delta > 0) {
            self.handleActions('zoomIn', {
              zoomRate: 0.015,
              enableTransition: false
            });
          } else {
            self.handleActions('zoomOut', {
              zoomRate: 0.015,
              enableTransition: false
            });
          }
        });
        on(document, 'keydown', self._keyDownHandler);
        on(document, mousewheelEventName, self._mouseWheelHandler);
      },
      deviceSupportUninstall: function() {
        off(document, 'keydown', this._keyDownHandler);
        off(document, mousewheelEventName, this._mouseWheelHandler);
        this._keyDownHandler = null;
        this._mouseWheelHandler = null;
      },
      handleImgLoad: function(e) {
        this.loading = false;
      },
      handleImgError: function(e) {
        this.loading = false;
        e.target.alt = '加载失败';
      },
      handleMouseDown: function(e) {
        // if(this.isMobile)
        // return;
        var self = this;
        if (self.loading || e.button !== 0) return;
  
        var offsetX = self.transform['offsetX'],
            offsetY = self.transform['offsetY'];
        var startX = e.pageX;
        var startY = e.pageY;
        self._dragHandler = rafThrottle(function(ev){
          self.transform.offsetX = offsetX + ev.pageX - startX;
          self.transform.offsetY = offsetY + ev.pageY - startY;
        });
        on(document, 'mousemove', self._dragHandler);
        on(document, 'mouseup', function() {
          off(document, 'mousemove', self._dragHandler);
        });

        e.preventDefault();
      },
      reset: function() {
        this.transform = {
          scale: 1,
          deg: 0,
          offsetX: 0,
          offsetY: 0,
          enableTransition: false
        };
      },
      toggleMode: function() {
        if (this.loading) return;

        var modeNames = Object.keys(Mode);
        //var modeValues = Object.values(Mode);
        var modeValues = [];
        for(var i=0;i<modeNames.length;i++){
            modeValues.push(Mode[modeNames[i]]);
        }
        var index = modeValues.indexOf(this.mode);
        var nextIndex = (index + 1) % modeNames.length;
        this.mode = Mode[modeNames[nextIndex]];
        this.reset();
      },
      touchStart:function(event) {
        // if(!this.isMobile)
        // return;
        this.mTouchStartX = event.changedTouches[0].clientX;
        // event.preventDefault();
        
      },
      touchMove:function() {
        // if(!this.isMobile)
        // return;
        // event.preventDefault();
      },
      touchEnd:function(event) {
        // if(!this.isMobile)
        // return;
        this.mTouchEndX = event.changedTouches[0].clientX;
        var moveRange = this.mTouchStartX - this.mTouchEndX;
        if(moveRange>0)
        this.next();
        else
        this.prev();
      },
      prev: function() {
        if (this.isFirst && !this.infinite) return;
        var len = this.urlList.length;
        this.imgIndex = (this.imgIndex - 1 + len) % len;
      },
      next: function() {
        if (this.isLast && !this.infinite) return;
        var len = this.urlList.length;
        this.imgIndex = (this.imgIndex + 1) % len;
      },
      handleActions: function(action, options) {
        if(!VueUtil.isDef(options)){
            options = {};
        }
        if (this.loading) return;
        var temp = {
          zoomRate: 0.2,
          rotateDeg: 90,
          enableTransition: true,
          options:options
        };
        var zoomRate = temp.zoomRate,
        rotateDeg = temp.rotateDeg,
        enableTransition = temp.enableTransition;
        var transform = this.transform;
        switch (action) {
          case 'zoomOut':
            if (transform.scale > 0.2) {
              transform.scale = parseFloat((transform.scale - zoomRate).toFixed(3));
            }
            break;
          case 'zoomIn':
            transform.scale = parseFloat((transform.scale + zoomRate).toFixed(3));
            break;
          case 'clocelise':
            transform.deg += rotateDeg;
            break;
          case 'anticlocelise':
            transform.deg -= rotateDeg;
            break;
        }
        transform.enableTransition = enableTransition;
      }
    },
    mounted: function() {
      this.deviceSupportInstall();
    }
  };
  Vue.component(ImageViewer.name, ImageViewer);
  return ImageViewer;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil','ImageViewer'], definition);
  } else {
    context.VueImage = definition(context.Vue, context.VueUtil,context.ImageViewer);
    delete context.VueImage;
    delete context.ImageViewer;
  }
})(this, function(Vue, VueUtil,ImageViewer) {
  'use strict';
  var template = ' \
    <div :class="{\'vue-image\':true,\'vue-image__lazy\':lazy,\'vue-image__round\':round}"> \
      <span v-if="showText" class="vue-image__label"\
        v-bind="$attrs" v-on="$listeners" \
        @click="clickHandler" :class="{\'vue-image__preview\': preview }">{{imgLabel}}</span>\
      <slot v-else-if="loading" name="placeholder"> \
        <div class="vue-image__placeholder"></div> \
      </slot> \
      <slot v-else-if="error" name="error"> \
        <div class="vue-image__error">{{$t("vue.image.error")}}</div> \
      </slot> \
      <img \
        v-else \
        class="vue-image__inner" \
        v-bind="$attrs" \
        v-on="$listeners" \
        @click="clickHandler" \
        :src="src" \
        :style="imageStyle" \
        :class="{ \'vue-image__inner--center\': alignCenter, \'vue-image__preview\': preview }"> \
      <vue-image-viewer :z-index="zIndex" v-if="preview && showViewer" :on-close="closeViewer" :url-list="previewSrcList"/> \
    </div>';
    
  var isServer = Vue.prototype.$isServer;
  var Locale  = {};
  var on = VueUtil.on,off=VueUtil.off;
  var getStyle = VueUtil.getStyle,
  isScroll = function(el, vertical){
    if (isServer) return;
    var determinedDirection = vertical !== null || vertical !== undefined;
    var overflow = determinedDirection
      ? vertical ? getStyle(el, 'overflow-y') : getStyle(el, 'overflow-x')
      : getStyle(el, 'overflow');
    return overflow.match(/(scroll|auto)/);
  },
  getScrollContainer = function(el, vertical){
    if (isServer) return;
    var parent = el;
    while (parent) {
      //if ([window, document, document.documentElement].includes(parent)) {
      if ([window, document, document.documentElement].indexOf(parent)>-1) {
        return window;
      }
      if (isScroll(parent, vertical)) {
        return parent;
      }
      parent = parent.parentNode;
    }
    return parent;
  },
  isInContainer = function(el, container){
    if (isServer || !el || !container) return false;
  
    var elRect = el.getBoundingClientRect();
    var containerRect;

    //if ([window, document, document.documentElement, null, undefined].includes(container)) {
    if ([window, document, document.documentElement, null, undefined].indexOf(container)>-1) {
      containerRect = {
        top: 0,
        right: window.innerWidth,
        bottom: window.innerHeight,
        left: 0
      };
    } else {
      containerRect = container.getBoundingClientRect();
    }
  
    return elRect.top < containerRect.bottom &&
      elRect.bottom > containerRect.top &&
      elRect.right > containerRect.left &&
      elRect.left < containerRect.right;
  };
  var isString = VueUtil.isString,
      isHtmlElement = function(node) { return node && node.nodeType === Node.ELEMENT_NODE; };
  var throttle=VueUtil.throttle;

  var isSupportObjectFit = function(){
      return document.documentElement.style.objectFit !== undefined;
  };

  var ObjectFit = {
    NONE: 'none',
    CONTAIN: 'contain',
    COVER: 'cover',
    FILL: 'fill',
    SCALE_DOWN: 'scale-down'
  };

  //export default {
  var VueImage = {
    template:template,
    name: 'VueImage',

    mixins: [Locale],
    inheritAttrs: false,

    components: {
      ImageViewer:ImageViewer
    },

    props: {
      download:Boolean,
      src: String,
      fit: String,
      lazy: Boolean,
      scrollContainer: {},
      previewSrcList: {
        type: Array,
        default: function(){return [];}
      },
      zIndex: {
        type: Number,
        default: 2000
      },
      imgLabel: String,
      round: Boolean
    },

    data:function() {
      return {
        loading: true,
        error: false,
        show: !this.lazy,
        imageWidth: 0,
        imageHeight: 0,
        showViewer: false
      };
    },

    computed: {
      imageStyle: function() {
        var fit = this.fit;
        if (!this.$isServer && fit) {
          return isSupportObjectFit()
            ? { 'object-fit': fit }
            : this.getImageStyle(fit);
        }
        return {};
      },
      alignCenter: function() {
        return !this.$isServer && !isSupportObjectFit() && this.fit !== ObjectFit.FILL;
      },
      preview: function() {
        var previewSrcList = this.previewSrcList;
        return Array.isArray(previewSrcList) && previewSrcList.length > 0;
      },
      showText: function() {
        return (typeof this.imgLabel != 'undefined' && this.imgLabel != '');
      }
    },

    watch: {
      src:function(val) {
        this.show && this.loadImage();
      },
      show:function(val) {
        val && this.loadImage();
      }
    },

    mounted: function() {
      if (this.lazy) {
        this.addLazyLoadListener();
      } else {
        this.loadImage();
      }
    },

    beforeDestroy: function() {
      this.lazy && this.removeLazyLoadListener();
    },

    methods: {
      loadImage: function() {
        if (this.$isServer) return;

        // reset status
        this.loading = true;
        this.error = false;

        var img = new Image();
        var self = this;
        img.onload = function(e){self.handleLoad(e, img);};
        img.onerror = self.handleError.bind(self);

        // bind html attrs
        // so it can behave consistently
        Object.keys(self.$attrs)
          .forEach(function(key){
            var value = self.$attrs[key];
            img.setAttribute(key, value);
          });
        img.src = self.src;
      },
      handleLoad: function(e, img) {
        this.error = false;
        this.imageWidth = img.width;
        this.imageHeight = img.height;
        this.loading = false;
      },
      handleError: function(e) {
        this.loading = false;
        this.error = true;
        this.$emit('error', e);
      },
      handleLazyLoad: function() {
        if (isInContainer(this.$el, this._scrollContainer)) {
          this.show = true;
          this.removeLazyLoadListener();
        }
      },
      addLazyLoadListener: function() {
        if (this.$isServer) return;

        var scrollContainer = this.scrollContainer;
        var _scrollContainer = null;

        if (isHtmlElement(scrollContainer)) {
          _scrollContainer = scrollContainer;
        } else if (isString(scrollContainer)) {
          _scrollContainer = document.querySelector(scrollContainer);
        } else {
          _scrollContainer = getScrollContainer(this.$el);
        }

        if (_scrollContainer) {
          this._scrollContainer = _scrollContainer;
          this._lazyLoadHandler = throttle(200, this.handleLazyLoad);
          on(_scrollContainer, 'scroll', this._lazyLoadHandler);
          this.handleLazyLoad();
        }
      },
      removeLazyLoadListener: function() {
        var _scrollContainer = this._scrollContainer,
        _lazyLoadHandler = this._lazyLoadHandler;

        if (this.$isServer || !_scrollContainer || !_lazyLoadHandler) return;

        off(_scrollContainer, 'scroll', _lazyLoadHandler);
        this._scrollContainer = null;
        this._lazyLoadHandler = null;
      },
      /**
       * simulate object-fit behavior to compatible with IE11 and other browsers which not support object-fit
       */
      getImageStyle: function(fit) {
        var imageWidth = this.imageWidth,
            imageHeight = this.imageHeight;
        var containerWidth = this.$el.clientWidth,
            containerHeight = this.$el.clientHeight;

        if (!imageWidth || !imageHeight || !containerWidth || !containerHeight) return {};

        var vertical = imageWidth / imageHeight < 1;

        if (fit === ObjectFit.SCALE_DOWN) {
          var isSmaller = imageWidth < containerWidth && imageHeight < containerHeight;
          fit = isSmaller ? ObjectFit.NONE : ObjectFit.CONTAIN;
        }

        switch (fit) {
          case ObjectFit.NONE:
            return { width: 'auto', height: 'auto' };
          case ObjectFit.CONTAIN:
            return vertical ? { width: 'auto' } : { height: 'auto' };
          case ObjectFit.COVER:
            return vertical ? { height: 'auto' } : { width: 'auto' };
          default:
            return {};
        }
      },
  clickDownload: function(){
		var src = this.src,
      imgLabel = this.imgLabel;
		if(typeof src == 'undefined' || src == '') return;
		
		var a = document.createElement('a');
        var event = new MouseEvent('click');
        a.download = imgLabel;
        a.href = src;
        a.dispatchEvent(event);    
    },
      clickHandler: function() {
		if(this.download){
			this.clickDownload();
		}else{
			this.showViewer = true;
		}
      },
      closeViewer: function() {
        this.showViewer = false;
      }
    }
  };
  Vue.component(VueImage.name, VueImage);
});
(function (context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([''], definition);
  } else {
    context.GlobalConfig = definition();
  }
})(this, function () {
  var GlobalConfig = {
    // showOverflow: null,
    // showHeaderOverflow: null,
    // resizeInterval: 250,
    // size: null,
    // validConfig: {
    //   message: 'default'
    // },
    // tooltipConfig: {
    //   enterable: false
    // },
    // resizable: false,
    // stripe: false,
    // border: false,
    fit: true,
    emptyCell: '　',
    showHeader: true,
    zIndex: 100,
    rowId: '_XID',
    // 行数据的唯一主键字段名
    version: 0,
    // 版本号，对于某些带数据缓存的功能有用到，上升版本号可以用于重置数据
    optimization: {
      animat: true,
      delayHover: 250,
      // rHeights: {
      //   default: 48,
      //   medium: 44,
      //   small: 40,
      //   mini: 36
      // },
      scrollX: {
        gt: 100 // oSize: 0,
        // rSize: 0
        // vSize: 0

      },
      scrollY: {
        gt: 500 // oSize: 0,
        // rSize: 0
        // vSize: 0,
        // rHeight: 0

      }
    },
    icon: {
      sortAsc: 'vue-xtable-icon--caret-top',
      sortDesc: 'vue-xtable-icon--caret-bottom',
      filter: 'vue-xtable-icon--funnel',
      edit: 'vue-xtable-icon--edit-outline',
      tree: 'vue-xtable-icon--caret-right',
      refresh: 'vue-icon-refresh',
      addRow: 'vue-icon-add-row',
      insertRow: 'vue-icon-insert-row',
      delRow: 'vue-icon-del-row',
      import: 'vue-icon-import-file',
      importRemove: 'vue-xtable-icon--close',
      export: 'vue-icon-export-file',
      custom: 'vue-icon-menu',
      fixed: 'vue-icon-sort',
      jumpPrev: 'vue-xtable-icon--d-arrow-left',
      jumpNext: 'vue-xtable-icon--d-arrow-right',
      prevPage: 'vue-xtable-icon--arrow-left',
      nextPage: 'vue-xtable-icon--arrow-right',
      zoomIn: 'vue-xtable-icon--zoomin',
      zoomOut: 'vue-xtable-icon--zoomout',
      caretBottom: 'vue-xtable-icon--caret-bottom',
      dropdownBottom: 'vue-xtable-icon--arrow-bottom',
      btnLoading: 'vue-xtable-icon--refresh roll'
    },
    grid: {},
    menu: {},
    tooltip: {
      trigger: 'hover',
      theme: 'dark',
      leaveDelay: 300
    },
    pager: {// perfect: true,
      // pageSize: 10,
      // pagerCount: 7,
      // pageSizes: [10, 15, 20, 50, 100],
      // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
    },
    toolbar: {// import: {
      //   mode: 'covering'
      // },
      // export: {
      //   types: ['csv', 'html', 'xml', 'txt']
      // },
      // resizable: {
      //   storage: false
      // },
      // export: false,
      // setting: {
      //   storage: false
      // },
      // addRow: {
      //   handler: handler, record:record, callback: callback
      // },
      // insertRow: {
      //   position:position, handler: handler, record:record, callback: callback
      // },
      // delRow: {
      //   handler: handler, callback: callback
      // }
      // buttons: []
    },
    i18n: function i18n(key) {
      return Vue.t(key);
    }
  };

  return GlobalConfig;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['utils'], definition);
  } else {
    context.tools = definition(context.GlobalConfig);
  }
})(this, function(GlobalConfig) {
  //dom.js
  var htmlElem = document.querySelector('html');
  var bodyElem = document.body;

  function getClsRE(cls) {
    if (!reClsMap[cls]) {
      reClsMap[cls] = new RegExp('(?:^|\\s)'.concat(cls, '(?!\\S)'), 'g');
    }

    return reClsMap[cls];
  }

  var reClsMap = {};
  var DomTools = {
    isPx: function isPx(val) {
      return val && /^\d+(px)?$/.test(val);
    },
    isScale: function isScale(val) {
      return val && /^\d+%$/.test(val);
    },
    hasClass: function hasClass(elem, cls) {
      return elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls));
    },
    removeClass: function removeClass(elem, cls) {
      if (elem && DomTools.hasClass(elem, cls)) {
        elem.className = elem.className.replace(getClsRE(cls), '');
      }
    },
    addClass: function addClass(elem, cls) {
      if (elem && !DomTools.hasClass(elem, cls)) {
        DomTools.removeClass(elem, cls);
        elem.className = ''.concat(elem.className, ' ').concat(cls);
      }
    },
    updateCellTitle: function updateCellTitle(evnt) {
      var cellElem = evnt.currentTarget.querySelector('.vue-xtable-cell');
      var content = cellElem.innerText;

      if (cellElem.getAttribute('title') !== content) {
        cellElem.setAttribute('title', content);
      }
    },
    rowToVisible: function rowToVisible($table, row) {
      var bodyElem = $table.$refs.tableBody.$el;
      var trElem = bodyElem.querySelector('[data-rowid="'.concat(UtilTools.getRowid($table, row), '"]'));

      if (trElem) {
        var bodyHeight = bodyElem.clientHeight;
        var bodySrcollTop = bodyElem.scrollTop;
        var trOffsetTop = trElem.offsetTop + (trElem.offsetParent ? trElem.offsetParent.offsetTop : 0);
        var trHeight = trElem.clientHeight; // 检测行是否在可视区中

        if (trOffsetTop < bodySrcollTop || trOffsetTop > bodySrcollTop + bodyHeight) {
          // 向上定位
          return $table.scrollTo(null, trOffsetTop);
        } else if (trOffsetTop + trHeight >= bodyHeight + bodySrcollTop) {
          // 向下定位
          return $table.scrollTo(null, bodySrcollTop + trHeight);
        }
      } else {
        // 如果是虚拟渲染跨行滚动
        if ($table.scrollYLoad) {
          return $table.scrollTo(null, ($table.afterFullData.indexOf(row) - 1) * $table.scrollYStore.rowHeight);
        }
      }

      return Promise.resolve();
    },
    colToVisible: function colToVisible($table, column) {
      var bodyElem = $table.$refs.tableBody.$el;
      var tdElem = bodyElem.querySelector('.'.concat(column.id));

      if (tdElem) {
        var bodyWidth = bodyElem.clientWidth;
        var bodySrcollLeft = bodyElem.scrollLeft;
        var tdOffsetLeft = tdElem.offsetLeft + (tdElem.offsetParent ? tdElem.offsetParent.offsetLeft : 0);
        var tdWidth = tdElem.clientWidth; // 检测行是否在可视区中

        if (tdOffsetLeft < bodySrcollLeft || tdOffsetLeft > bodySrcollLeft + bodyWidth) {
          // 向左定位
          return $table.scrollTo(tdOffsetLeft);
        } else if (tdOffsetLeft + tdWidth >= bodyWidth + bodySrcollLeft) {
          // 向右定位
          return $table.scrollTo(bodySrcollLeft + tdWidth);
        }
      } else {
        // 如果是虚拟渲染跨行滚动
        if ($table.scrollXLoad) {
          var visibleColumn = $table.visibleColumn;
          var scrollLeft = 0;

          for (var index = 0; index < visibleColumn.length; index++) {
            if (visibleColumn[index] === column) {
              break;
            }

            scrollLeft += visibleColumn[index].renderWidth;
          }

          return $table.scrollTo(scrollLeft);
        }
      }

      return Promise.resolve();
    },
    getDomNode: function getDomNode() {
      var documentElement = document.documentElement;
      var bodyElem = document.body;
      return {
        scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
        scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
        visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
        visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
      };
    },

    /**
     * 检查触发源是否属于目标节点
     */
    getEventTargetNode: function getEventTargetNode(evnt, container, queryCls, findPopper) {
      var targetElem;
      var target = evnt.target;
      var popper;

      while (target && target.nodeType && target !== document) {
        if (queryCls && DomTools.hasClass(target, queryCls)) {
          targetElem = target;
        } else if (target === container) {
          return {
            flag: queryCls ? !!targetElem : true,
            container: container,
            targetElem: targetElem
          };
        } else if (findPopper && target.getAttribute('x-placement')) {
          popper = target;
        }

        target = target.parentNode;
      }

      if (popper && VueUtil.get(popper, 'editor.$parent.$el')) {
        return getEventTargetNode({target: popper.editor.$parent.$el}, container);
      }

      return {
        flag: false
      };
    },

    /**
     * 获取元素相对于 document 的位置
     */
    getOffsetPos: function getOffsetPos(elem, container) {
      return getNodeOffset(elem, container, {
        left: 0,
        top: 0
      });
    },
    getAbsolutePos: function getAbsolutePos(elem) {
      var bounding = elem.getBoundingClientRect();

      var _DomTools$getDomNode = DomTools.getDomNode(),
          scrollTop = _DomTools$getDomNode.scrollTop,
          scrollLeft = _DomTools$getDomNode.scrollLeft;

      return {
        top: scrollTop + bounding.top,
        left: scrollLeft + bounding.left
      };
    },

    /**
     * 获取单元格节点索引
     */
    getCellNodeIndex: function getCellNodeIndex(cell) {
      var trElem = cell.parentNode;
      var columnIndex = VueUtil.arrayIndexOfVal(trElem.children, cell);
      var rowIndex = VueUtil.arrayIndexOfVal(trElem.parentNode.children, trElem);
      return {
        columnIndex: columnIndex,
        rowIndex: rowIndex
      };
    },

    /**
     * 获取选中单元格矩阵范围
     */
    getRowNodes: function getRowNodes(trList, cellNode, targetCellNode) {
      var startColIndex = cellNode.columnIndex;
      var startRowIndex = cellNode.rowIndex;
      var targetColIndex = targetCellNode.columnIndex;
      var targetRowIndex = targetCellNode.rowIndex;
      var rows = [];

      for (var rowIndex = Math.min(startRowIndex, targetRowIndex), rowLen = Math.max(startRowIndex, targetRowIndex); rowIndex <= rowLen; rowIndex++) {
        var cells = [];
        var trElem = trList[rowIndex];

        for (var colIndex = Math.min(startColIndex, targetColIndex), colLen = Math.max(startColIndex, targetColIndex); colIndex <= colLen; colIndex++) {
          var tdElem = trElem.children[colIndex];
          cells.push(tdElem);
        }

        rows.push(cells);
      }

      return rows;
    },
    getCellIndexs: function getCellIndexs(cell) {
      var trElem = cell.parentNode;
      var rowid = trElem.getAttribute('data-rowid');
      var columnIndex = [].indexOf.call(trElem.children, cell);
      var rowIndex = [].indexOf.call(trElem.parentNode.children, trElem);
      return {
        rowid: rowid,
        rowIndex: rowIndex,
        columnIndex: columnIndex
      };
    },
    getCell: function getCell($table, params) {
      var row = params.row,
          column = params.column;
      var rowid = UtilTools.getRowid($table, row);

      var bodyElem = $table.$refs[''.concat(column.fixed || 'table', 'Body')];
      var tableEl = (bodyElem || $table.$refs.tableBody).$el;
      var cell = tableEl.querySelector('.vue-xtable-body--row[data-rowid="'.concat(rowid, '"] .').concat(column.id));

      // rowspan colspan等情况下取不到被隐藏掉的cell
      if(!cell) {
        cell = this.getTableSpanCell($table, params);
      } else {
        params.offset = undefined;
      }
      return cell;
    },

    getTableSpanCell: function($table, params) {

      var tableEl = (bodyElem || $table.$refs.tableBody).$el;
      var table = tableEl.querySelector('table');
      var rowIndex = $table.getRowIndex(params.row);
      var columnIndex = $table.getColumnIndex(params.column);

      var range = 30;
      var tableDefine = [];
      var cell;

      var startIndexRow = $table.scrollYStore.startIndex || 0;
      var startIndexCol = $table.scrollXStore.startIndex || 0;

      for (var t = 0; t < table.rows.length; t++) tableDefine[t] = [];

      for (var tempRowIndex = 0; tempRowIndex < table.rows.length; tempRowIndex++) {
          if (rowIndex - tempRowIndex - startIndexRow > range) continue;
          if (tempRowIndex > rowIndex) break;
          var offset = 0;

          for (var tempColIndex = 0; tempColIndex < table.rows[tempRowIndex].cells.length; tempColIndex++) {
            while (tableDefine[tempRowIndex][tempColIndex + offset]) offset++;
            if (columnIndex - tempColIndex - startIndexCol > range) continue;
            if (tempColIndex + offset > columnIndex) break;

              cell = table.rows[tempRowIndex].cells[tempColIndex];

              var rowSpans = parseInt(cell.getAttribute('rowspan') || 1);
              var colSpans = parseInt(cell.getAttribute('colspan') || 1);

              for (var rowSpan = 0; rowSpan < rowSpans; rowSpan++) {
                  for (var colSpan = 0; colSpan < colSpans; colSpan++) {
                      if (tempRowIndex + rowSpan < table.rows.length) tableDefine[tempRowIndex + rowSpan][tempColIndex + offset + colSpan] = [tempRowIndex, tempColIndex];
                  }
              }
          }
      }

      try {
        var spanCellXY = tableDefine[rowIndex - startIndexRow][columnIndex - startIndexCol];
        var domRow = table.rows[spanCellXY[0]];
        var domCell = domRow.cells[spanCellXY[1]];
        var rowId = domRow.dataset.rowid;
        var row = $table.getRowById(rowId);
        var column = $table.fullColumnIdData[domCell.dataset.colid].column;
        var newRowIndex = $table.getRowIndex(row);
        var newColumnIndex = $table.getColumnIndex(column);

        params.offset = [params.row, params.column];

        params.row = row;
        params.column = column;
        params.rowIndex = newRowIndex;
        params.columnIndex = newColumnIndex;

      } catch (error) {
        return null;
      }

      return domCell;
    },
    toView: function toView(elem) {
      var scrollIntoViewIfNeeded = 'scrollIntoViewIfNeeded';
      var scrollIntoView = 'scrollIntoView';

      if (elem) {
        if (elem[scrollIntoViewIfNeeded]) {
          elem[scrollIntoViewIfNeeded]();
        } else if (elem[scrollIntoView]) {
          elem[scrollIntoView]();
        }
      }
    }
  };

  function getNodeOffset(elem, container, rest) {
    if (elem) {
      var parentElem = elem.parentNode;
      rest.top += elem.offsetTop;
      rest.left += elem.offsetLeft;

      if (parentElem && parentElem !== htmlElem && parentElem !== bodyElem) {
        rest.top -= parentElem.scrollTop;
        rest.left -= parentElem.scrollLeft;
      }

      if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
        return getNodeOffset(elem.offsetParent, container, rest);
      }
    }

    return rest;
  }

  // events.js
  // 监听全局事件
  var wheelName = /Firefox/i.test(navigator.userAgent) ? 'DOMMouseScroll' : 'mousewheel';
  var eventStore = [];
  var GlobalEvent = {
    on: function on(comp, type, cb) {
      if (cb) {
        eventStore.push({
          comp: comp,
          type: type,
          cb: cb
        });
      }
    },
    off: function off(comp, type) {
      VueUtil.remove(eventStore, function (item) {
        return item.comp === comp && item.type === type;
      });
    },
    trigger: function trigger(evnt) {
      eventStore.forEach(function (_ref) {
        var comp = _ref.comp,
            type = _ref.type,
            cb = _ref.cb;

        if (type === evnt.type || type === 'mousewheel' && evnt.type === wheelName) {
          cb.call(comp, evnt);
        }
      });
    }
  };
  document.addEventListener('keydown', GlobalEvent.trigger, false);
  document.addEventListener('contextmenu', GlobalEvent.trigger, false);
  document.addEventListener('paste', GlobalEvent.trigger, false);
  window.addEventListener('mousedown', GlobalEvent.trigger, false);
  window.addEventListener('blur', GlobalEvent.trigger, false);
  window.addEventListener('resize', GlobalEvent.trigger, false);
  window.addEventListener(wheelName, GlobalEvent.trigger, false);

  //utils.js
  

  // babel创建的特殊函数，统一定义在此处
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
  
  var columnUniqueId = 0;

  var ColumnConfig =
  /*#__PURE__*/
  function () {
    function ColumnConfig(_vm) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          renderHeader = _ref.renderHeader,
          renderCell = _ref.renderCell,
          renderData = _ref.renderData;

      _classCallCheck(this, ColumnConfig);

      if (_vm.cellRender && _vm.editRender) {
        UtilTools.warn('vue.xtable.error.cellEditRender');
      }

      if (_vm.type === 'selection') {
        UtilTools.warn('vue.xtable.error.delProp', ['selection', 'checkbox']);
      }

      VueUtil.assign(this, {
        // 基本属性
        id: 'col_'.concat(++columnUniqueId),
        type: _vm.type,
        prop: _vm.prop,
        property: _vm.field || _vm.prop,
        title: _vm.title,
        label: _vm.label,
        width: _vm.width,
        minWidth: _vm.minWidth,
        resizable: _vm.resizable,
        fixed: _vm.fixed,
        align: _vm.align,
        headerAlign: _vm.headerAlign,
        footerAlign: _vm.footerAlign,
        showOverflow: _vm.showOverflow,
        showHeaderOverflow: _vm.showHeaderOverflow,
        className: _vm.class || _vm.className,
        headerClassName: _vm.headerClassName,
        footerClassName: _vm.footerClassName,
        indexMethod: _vm.indexMethod,
        formatter: _vm.formatter,
        sortable: _vm.sortable,
        sortBy: _vm.sortBy,
        sortMethod: _vm.sortMethod,
        remoteSort: _vm.remoteSort,
        filters: UtilTools.getFilters(_vm.filters),
        filterMultiple: VueUtil.isBoolean(_vm.filterMultiple) ? _vm.filterMultiple : true,
        filterMethod: _vm.filterMethod,
        filterRender: _vm.filterRender,
        copyFormatter: _vm.copyFormatter,
        pasteFormatter: _vm.pasteFormatter,
        treeNode: _vm.treeNode,
        cellRender: _vm.cellRender,
        editRender: _vm.editRender,
        // 自定义参数
        checked: false,
        params: _vm.params,
        // 渲染属性
        visible: _vm.visible === false ? false : true,
        level: 1,
        rowSpan: 1,
        colSpan: 1,
        order: null,
        renderWidth: 0,
        renderHeight: 0,
        resizeWidth: 0,
        renderLeft: 0,
        model: {},
        renderHeader: renderHeader || _vm.renderHeader,
        renderCell: renderCell || _vm.renderCell,
        renderData: renderData,
        // 单元格插槽，只对 grid 有效
        slots: _vm.slots,
        own: _vm
      });
    }

    _createClass(ColumnConfig, [{
      key: 'getTitle',
      value: function getTitle() {
        // 在 v3.0 中废弃 label
        return UtilTools.getFuncText(this.own.title || this.own.label || (this.type === 'index' ? GlobalConfig.i18n('vue.xtable.column.indexTitle') : ''));
      }
    }, {
      key: 'update',
      value: function update(name, value) {
        // 不支持双向的属性
        if (!VueUtil.includes(['filters'], name)) {
          this[name] = value;
        }
      }
    }]);

    return ColumnConfig;
  }();

  function outLog(type) {
    return function (message, params) {
      var msg = UtilTools.getLog(message, params);
      console[type](msg);
      return msg;
    };
  }

  var UtilTools = {
    warn: outLog('warn'),
    error: outLog('error'),
    getLog: function getLog(message, params) {
      return '[vue-xtable] '.concat(Vue.t(message, params));
    },
    getSize: function getSize(_ref2) {
      var size = _ref2.size,
          $parent = _ref2.$parent;
      return size || ($parent && ['medium', 'small', 'mini'].indexOf($parent.size) > -1 ? $parent.size : null);
    },
    getFuncText: function getFuncText(content) {
      return VueUtil.isFunction(content) ? content() : GlobalConfig.translate ? GlobalConfig.translate(content) : content;
    },
    nextZIndex: function nextZIndex($table) {
      if ($table && $table.zIndex) {
        return $table.zIndex;
      }
      return VueUtil.nextZIndex();
    },
    getLastZIndex: function getLastZIndex() {
      return VueUtil.component.popupManager.zIndex;
    },
    // 行主键 key
    getRowkey: function getRowkey($table) {
      return $table.rowId;
    },
    // 行主键 value
    getRowid: function getRowid($table, row) {
      var rowId = VueUtil.get(row, UtilTools.getRowkey($table));
      return rowId ? encodeURIComponent(rowId) : '';
    },
    // 触发事件
    emitEvent: function emitEvent(_vm, type, args) {
      if (_vm.$listeners[type]) {
        _vm.$emit.apply(_vm, [type].concat(args));
      }
    },
    // 获取所有的列，排除分组
    getColumnList: function getColumnList(columns) {
      var result = [];
      columns.forEach(function (column) {
        result.push.apply(result, column.children && column.children.length ? UtilTools.getColumnList(column.children) : [column]);
      });
      return result;
    },
    getClass: function getClass(property, params) {
      return property ? VueUtil.isFunction(property) ? property(params) : property : '';
    },
    getFilters: function getFilters(filters) {
      return (filters || []).map(function (_ref3) {
        var label = _ref3.label,
            value = _ref3.value,
            data = _ref3.data,
            checked = _ref3.checked;
        return {
          label: label,
          value: value,
          data: data,
          _data: data,
          checked: !!checked
        };
      });
    },
    formatText: function formatText(value, placeholder) {
      return '' + (value === null || value === void 0 ? placeholder ? GlobalConfig.emptyCell : '' : value);
    },
    getCellValue: function getCellValue(row, column) {
      return VueUtil.get(row, column.property);
    },
    getCellLabel: function getCellLabel(row, column, params) {
      var formatter = column.formatter;
      var cellValue = UtilTools.getCellValue(row, column);
      var cellLabel = cellValue;

      if (params && formatter) {
        var rest, formatData;
        var $table = params.$table;
        var colid = column.id;
        var cacheFormat = $table && $table.fullAllDataRowMap.has(row);

        if (cacheFormat) {
          rest = $table.fullAllDataRowMap.get(row);
          formatData = rest.formatData;

          if (!formatData) {
            formatData = $table.fullAllDataRowMap.get(row).formatData = {};
          }
        }

        if (rest && formatData[colid]) {
          if (formatData[colid].value === cellValue) {
            return formatData[colid].label;
          }
        }
        if (VueUtil.isString(formatter)) {
          cellLabel = VueUtil.get(VueUtil, formatter)(cellValue);
        } else if (VueUtil.isArray(formatter)) {
          cellLabel = VueUtil.get(VueUtil, formatter[0]).apply(VueUtil, [cellValue].concat(formatter.slice(1)));
        } else {
          cellLabel = formatter(VueUtil.assign({
            cellValue: cellValue
          }, params));
        }

        if (formatData) {
          formatData[colid] = {
            value: cellValue,
            label: cellLabel
          };
        }
      }

      return cellLabel;
    },
    setCellValue: function setCellValue(row, column, value) {
      return VueUtil.set(row, column.property, value);
    },
    getColumnConfig: function getColumnConfig(_vm, options) {
      return _vm instanceof ColumnConfig ? _vm : new ColumnConfig(_vm, options);
    },
    // 组装列配置
    assemColumn: function assemColumn(_vm) {
      var $table = _vm.$table,
          $column = _vm.$column,
          columnConfig = _vm.columnConfig;
      var groupConfig = $column ? $column.columnConfig : null;
      columnConfig.slots = _vm.$scopedSlots;

      if (groupConfig && $column.$children.length > 0) {
        if (!groupConfig.children) {
          groupConfig.children = [];
        }

        groupConfig.children.splice([].indexOf.call($column.$el.children, _vm.$el), 0, columnConfig);
      } else {
        $table.collectColumn.splice([].indexOf.call($table.$refs.hideColumn.children, _vm.$el), 0, columnConfig);
      }
    },
    // 销毁列
    destroyColumn: function destroyColumn(_vm) {
      var $table = _vm.$table,
          columnConfig = _vm.columnConfig;
      var matchObj = VueUtil.findTree($table.collectColumn, function (column) {
        return column === columnConfig;
      });

      if (matchObj) {
        matchObj.items.splice(matchObj.index, 1);
      }
    },
    hasChildrenList: function hasChildrenList(item) {
      return item && item.children && item.children.length > 0;
    },
    parseFile: function parseFile(file) {
      var name = file.name;
      var tIndex = name.lastIndexOf('.');
      var type = name.substring(tIndex + 1, name.length);
      var filename = name.substring(0, tIndex);
      return {
        filename: filename,
        type: type
      };
    },
    defineProperties: _defineProperties,
    defineProperty: _defineProperty,
    createClass: _createClass,
    classCallCheck: _classCallCheck
    
  };

  return {
    DomTools: DomTools,
    GlobalEvent: GlobalEvent,
    UtilTools: UtilTools
  };
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define( definition);
  } else {
    context.baseTable = definition(context.GlobalConfig, context.tools);
  }
})(this, function(GlobalConfig, tools) {
  var mod = {};
  var UtilTools = tools.UtilTools;
  var _defineProperty = tools.UtilTools.defineProperty;
  
  (function() {
    // 全局的工具栏按钮
    var _storeMap = {};
    var Buttons = {
      mixin: function mixin(map) {
        VueUtil.assign(_storeMap, map);
        return Buttons;
      },
      get: function get(type) {
        return _storeMap[type];
      },
      add: function add(type, callback) {
        _storeMap[type] = callback;
        return Buttons;
      },
      delete: function _delete(type) {
        delete _storeMap[type];
        return Buttons;
      }
    };
    mod.Buttons = Buttons;
  })();

  (function() {
    function toType(type) {
      return VueUtil.toString(type).replace('_', '').toLowerCase();
    }

    var eventTypes = 'created,mounted,activated,beforeDestroy,destroyed,event.clearActived,event.clearFilter,event.showMenu,event.keydown,event.export,event.import'.split(',').map(toType);
    var _storeMap = {};
    var Interceptor = {
      mixin: function mixin(map) {
        VueUtil.forEach(map, function (callback, type) {
          return Interceptor.add(type, callback);
        });
        return Interceptor;
      },
      get: function get(type) {
        return _storeMap[toType(type)] || [];
      },
      add: function add(type, callback) {
        type = toType(type);

        if (callback && VueUtil.includes(eventTypes, type)) {
          var eList = _storeMap[type];

          if (!eList) {
            eList = _storeMap[type] = [];
          }

          eList.push(callback);
        }

        return Interceptor;
      },
      delete: function _delete(type, callback) {
        var eList = _storeMap[toType(type)];

        if (eList) {
          VueUtil.remove(eList, function (cb) {
            return cb === callback;
          });
        }

        return Interceptor;
      }
    };
    mod.Interceptor = Interceptor;
  })();

  (function() {
    // 全局的快捷菜单
    var _storeMap = {};
    var Menus = {
      mixin: function mixin(map) {
        VueUtil.assign(_storeMap, map);
        return Menus;
      },
      get: function get(type) {
        return _storeMap[type];
      },
      add: function add(type, callback) {
        _storeMap[type] = callback;
        return Menus;
      },
      delete: function _delete(type) {
        delete _storeMap[type];
        return Menus;
      }
    };
    mod.Menus = Menus;
  })();

  (function() {
      function getAttrs(_ref) {
          var name = _ref.name,
              attrs = _ref.attrs;
      
          if (name === 'input') {
            attrs = VueUtil.assign({
              type: 'text'
            }, attrs);
          }
      
          return attrs;
        }
      
        function isSyncCell(renderOpts, params, context) {
          return renderOpts.immediate || renderOpts.type === 'visible' || context.$type === 'cell';
        }
        /**
         * 内置渲染器
         * 支持原生的 input、textarea、select
         */
      
      
        function defaultEditRender(h, renderOpts, params, context) {
          var row = params.row,
              column = params.column;
          var name = renderOpts.name;
          var attrs = getAttrs(renderOpts);
          var cellValue = isSyncCell(renderOpts, params, context) ? UtilTools.getCellValue(row, column) : column.model.value;
          return [h(name, {
            class: 'vue-xtable-default-'.concat(name),
            attrs: attrs,
            domProps: {
              value: cellValue
            },
            on: getEvents(renderOpts, params, context)
          })];
        }
      
        function getEvents(renderOpts, params, context) {
          var name = renderOpts.name,
              events = renderOpts.events;
          var $table = params.$table,
              row = params.row,
              column = params.column;
          var model = column.model;
          var isSelect = name === 'select';
          var type = isSelect ? 'change' : 'input';
      
          var on = UtilTools.defineProperty({}, type, function (evnt) {
            var cellValue = evnt.target.value;
      
            if (isSyncCell(renderOpts, params, context)) {
              UtilTools.setCellValue(row, column, cellValue);
            } else {
              model.update = true;
              model.value = cellValue;
            }
      
            $table.updateStatus(params, cellValue);
      
            if (events && events[type]) {
              events[type](params, evnt);
            }
          });
      
          if (events) {
            return VueUtil.assign({}, VueUtil.mapValues(events, function (cb) {
              return function () {
                cb.apply(null, [params].concat.apply(params, arguments));
              };
            }), on);
          }
      
          return on;
        }
      
        function renderOptgroups(h, renderOpts, params, context) {
          var optionGroups = renderOpts.optionGroups,
              _renderOpts$optionGro = renderOpts.optionGroupProps,
              optionGroupProps = _renderOpts$optionGro === void 0 ? {} : _renderOpts$optionGro;
          var groupOptions = optionGroupProps.options || 'options';
          var groupLabel = optionGroupProps.label || 'label';
          return optionGroups.map(function (group, gIndex) {
            return h('optgroup', {
              domProps: {
                label: group[groupLabel]
              },
              key: gIndex
            }, renderOptions(h, group[groupOptions], renderOpts, params, context));
          });
        }
      
        function renderOptions(h, options, renderOpts, params, context) {
          var _renderOpts$optionPro = renderOpts.optionProps,
              optionProps = _renderOpts$optionPro === void 0 ? {} : _renderOpts$optionPro;
          var row = params.row,
              column = params.column;
          var labelProp = optionProps.label || 'label';
          var valueProp = optionProps.value || 'value';
          var disabledProp = optionProps.disabled || 'disabled';
          var cellValue = isSyncCell(renderOpts, params, context) ? UtilTools.getCellValue(row, column) : column.model.value;
          return options.map(function (item, index) {
            return h('option', {
              attrs: {
                value: item[valueProp],
                disabled: item[disabledProp]
              },
              domProps: {
                selected: item[valueProp] === cellValue
              },
              key: index
            }, item[labelProp]);
          });
        }
      
        function getFilterEvents(item, renderOpts, params, context) {
          var _params = params,
              column = _params.column;
          var events = renderOpts.events;
          var type = name === 'select' ? 'change' : 'input';
      
          var on = UtilTools.defineProperty({}, type, function (evnt) {
            item.data = evnt.target.value;
            handleConfirmFilter(context, column, !!item.data, item);
      
            if (events && events[type]) {
              events[type](VueUtil.assign({
                context: context
              }, params), evnt);
            }
          });
      
          if (events) {
            return VueUtil.assign({}, VueUtil.mapValues(events, function (cb) {
              return function () {
                params = VueUtil.assign({
                  context: context
                }, params);
                cb.apply(null, [params].concat.apply(params, arguments));
              };
            }), on);
          }
      
          return on;
        }
      
        function defaultFilterRender(h, renderOpts, params, context) {
          var column = params.column;
          var name = renderOpts.name;
          var attrs = getAttrs(renderOpts);
          return column.filters.map(function (item) {
            return h(name, {
              class: 'vue-xtable-default-'.concat(name),
              attrs: attrs,
              domProps: {
                value: item.data
              },
              on: getFilterEvents(item, renderOpts, params, context)
            });
          });
        }
      
        function handleConfirmFilter(context, column, checked, item) {
          context[column.filterMultiple ? 'changeMultipleOption' : 'changeRadioOption']({}, checked, item);
        }
      
        function defaultFilterMethod(_ref2) {
          var option = _ref2.option,
              row = _ref2.row,
              column = _ref2.column;
          var data = option.data;
          var cellValue = VueUtil.get(row, column.property);
          /* eslint-disable eqeqeq */
      
          return cellValue == data;
        }
      
        function renderSelectEdit(h, renderOpts, params, context) {
          return [h('select', {
            class: 'vue-xtable-default-select',
            on: getEvents(renderOpts, params, context)
          }, renderOpts.optionGroups ? renderOptgroups(h, renderOpts, params, context) : renderOptions(h, renderOpts.options, renderOpts, params, context))];
        }
      
        var renderMap = {
          input: {
            autofocus: 'input',
            renderEdit: defaultEditRender,
            renderDefault: defaultEditRender,
            renderFilter: defaultFilterRender,
            filterMethod: defaultFilterMethod
          },
          textarea: {
            autofocus: 'textarea',
            renderEdit: defaultEditRender,
            renderDefault: defaultEditRender,
            renderFilter: defaultFilterRender,
            filterMethod: defaultFilterMethod
          },
          select: {
            renderEdit: renderSelectEdit,
            renderDefault: renderSelectEdit,
            renderCell: function renderCell(h, renderOpts, params, context) {
              var options = renderOpts.options,
                  optionGroups = renderOpts.optionGroups,
                  _renderOpts$optionPro2 = renderOpts.optionProps,
                  optionProps = _renderOpts$optionPro2 === void 0 ? {} : _renderOpts$optionPro2,
                  _renderOpts$optionGro2 = renderOpts.optionGroupProps,
                  optionGroupProps = _renderOpts$optionGro2 === void 0 ? {} : _renderOpts$optionGro2;
              var row = params.row,
                  column = params.column;
              var cellValue = VueUtil.get(row, column.property);
              var selectItem;
              var labelProp = optionProps.label || 'label';
              var valueProp = optionProps.value || 'value';
      
              if (optionGroups) {
                var groupOptions = optionGroupProps.options || 'options';
      
                for (var index = 0; index < optionGroups.length; index++) {
                  selectItem = VueUtil.find(optionGroups[index][groupOptions], function (item) {
                    return item[valueProp] === cellValue;
                  });
      
                  if (selectItem) {
                    break;
                  }
                }
      
                return selectItem ? selectItem[labelProp] : cellValue;
              } else {
                selectItem = VueUtil.find(options, function (item) {
                  return item[valueProp] === cellValue;
                });
                return selectItem ? selectItem[labelProp] : cellValue;
              }
            },
            renderFilter: function renderFilter(h, renderOpts, params, context) {
              var column = params.column;
              var attrs = renderOpts.attrs;
              return column.filters.map(function (item) {
                return h('select', {
                  class: 'vue-xtable-default-select',
                  attrs: attrs,
                  on: getFilterEvents(item, renderOpts, params, context)
                }, renderOpts.optionGroups ? renderOptgroups(h, renderOpts, params) : renderOptions(h, renderOpts.options, renderOpts, params, context));
              });
            },
            filterMethod: defaultFilterMethod
          }
        };

        function fallbackEditRender(h, renderOpts, params, context) {
          var row = params.row,
              column = params.column;
          var name = renderOpts.name;
          var attrs = VueUtil.assign({}, getAttrs(renderOpts));
          var cellValue = isSyncCell(renderOpts, params, context) ? UtilTools.getCellValue(row, column) : column.model.value;
          if(!attrs.value){
            attrs.value=cellValue;
          }
          return [h(name, {
            class: 'vue-default-'.concat(name),
            attrs: attrs,
            on: getFallbackEvents(renderOpts, params, context)
          })];
        }
        
        function getFallbackEvents(renderOpts, params, context) {
          var name = renderOpts.name,
              events = renderOpts.events;
          var $table = params.$table,
              row = params.row,
              column = params.column;
          var model = column.model;
          var type = name === 'select' ? 'change' : 'input';
        
          var on = _defineProperty({}, type, function (evnt) {
            var cellValue = evnt;
        
            if (isSyncCell(renderOpts, params, context)) {
              UtilTools.setCellValue(row, column, cellValue);
            } else {
              model.update = true;
              model.value = cellValue;
            }
            $table.updateStatus(params, cellValue);
          });
        
          if (events) {
            VueUtil.assign(on, VueUtil.mapValues(events, function (cb) {
              return function () {
                cb.apply(null, [params].concat.apply(params, arguments));
              };
            }));
          }
        
          return on;
        }

        var fallbackRender = function(name){
          return {
              autofocus: name,
              renderEdit: fallbackEditRender,
              renderDefault: fallbackEditRender,
              renderFilter: defaultFilterRender,
              filterMethod: defaultFilterMethod
            };
        };
        /**
         * 全局渲染器
         */
      
        var Renderer = {
          mixin: function mixin(map) {
            VueUtil.forEach(map, function (options, name) {
              return Renderer.add(name, options);
            });
            return Renderer;
          },
          get: function get(name) {
            return renderMap[name] || fallbackRender(name) || null;
          },
          add: function add(name, options) {
            if (name && options) {
              var renders = renderMap[name];
      
              if (renders) {
                VueUtil.assign(renders, options);
              } else {
                renderMap[name] = options;
              }
            }
      
            return Renderer;
          },
          delete: function _delete(name) {
            delete renderMap[name];
            return Renderer;
          }
        };
        mod.Renderer = Renderer;
  })();

  (function() {
    function mergeOpts(data1, data2) {
      if (data1 && VueUtil.isObject(data2)) {
        VueUtil.forEach(data2, function (val, key) {
          data1[key] = data1[key] && val ? mergeOpts(data1[key], val) : val;
        });
        return data1;
      }

      return data2;
    }
    /**
     * 全局参数设置
     */
    function setup() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      mergeOpts(GlobalConfig, options);
    }
    mod.setup = setup;
  })();

  var installedPlugins = [];

  function use(Plugin, options) {
    if (Plugin && Plugin.install) {
      if (installedPlugins.indexOf(Plugin) === -1) {
        Plugin.install(baseTable, options);
        installedPlugins.push(Plugin);
      }
    }

    return baseTable;
  }
  /**
   * 检测模块的安装顺序是否正确
   */


  function reg(key) {
    if (baseTable.Table) {
      UtilTools.error('vue.xtable.error.useErr', [key]);
    }

    baseTable['_'.concat(key)] = 1;
  }
  var baseTable = {
    t: function t(key) {
      return GlobalConfig.i18n(key);
    },
    v: 'v2',
    reg: reg,
    use: use,
    types: {},
    setup: mod.setup,
    interceptor: mod.Interceptor,
    renderer: mod.Renderer,
    buttons: mod.Buttons,
    menus: mod.Menus,
    Interceptor: mod.Interceptor,
    Renderer: mod.Renderer,
    Buttons: mod.Buttons,
    Menus: mod.Menus,
  };
  /**
   * 获取当前的 zIndex
   */

  Object.defineProperty(baseTable, 'zIndex', {
    get: UtilTools.getLastZIndex
  });
  /**
   * 获取下一个 zIndex
   */

  Object.defineProperty(baseTable, 'nextZIndex', {
    get: UtilTools.nextZIndex
  });
  /**
   * 获取所有导出类型
   */

  Object.defineProperty(baseTable, 'exportTypes', {
    get: function get() {
      return VueUtil.keys(baseTable.types);
    }
  });
  /**
   * 获取所有导入类型
   */

  Object.defineProperty(baseTable, 'importTypes', {
    get: function get() {
      var rest = [];
      VueUtil.forEach(baseTable.types, function (flag, type) {
        if (flag) {
          rest.push(type);
        }
      });
      return rest;
    }
  });

  return baseTable;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.cell = definition(context.baseTable, context.tools);
  }
})(this, function(baseTable, tools) {
  var _defineProperty = tools.UtilTools.defineProperty;
  var Cell = {
    createColumn: function createColumn($table, _vm) {
      var type = _vm.type,
          sortable = _vm.sortable,
          remoteSort = _vm.remoteSort,
          filters = _vm.filters,
          editRender = _vm.editRender,
          treeNode = _vm.treeNode;
      var treeConfig = $table.treeConfig; // 在 v3.0 中废弃 selectConfig
  
      var checkboxConfig = $table.checkboxConfig || $table.selectConfig;
      var isTreeNode = treeConfig && treeNode;
      var renMaps = {
        renderHeader: this.renderHeader,
        renderCell: isTreeNode ? this.renderTreeCell : this.renderCell
      };
  
      switch (type) {
        case 'index':
          renMaps.renderHeader = this.renderIndexHeader;
          renMaps.renderCell = isTreeNode ? this.renderTreeIndexCell : this.renderIndexCell;
          break;
  
        case 'radio':
          renMaps.renderHeader = this.renderRadioHeader;
          renMaps.renderCell = isTreeNode ? this.renderTreeRadioCell : this.renderRadioCell;
          break;
        // 在 v3.0 中废弃 type=selection
  
        case 'checkbox':
        case 'selection':
          renMaps.renderHeader = this.renderSelectionHeader;
          renMaps.renderCell = checkboxConfig && checkboxConfig.checkField ? isTreeNode ? this.renderTreeSelectionCellByProp : this.renderSelectionCellByProp : isTreeNode ? this.renderTreeSelectionCell : this.renderSelectionCell;
          break;
  
        case 'expand':
          renMaps.renderCell = this.renderExpandCell;
          renMaps.renderData = this.renderExpandData;
          break;

        case 'drag':
          renMaps.renderHeader = this.renderDragHeader;
          renMaps.renderCell = this.renderDragCell;
          break;
  
        default:
          if (editRender) {
            renMaps.renderHeader = this.renderEditHeader;
            renMaps.renderCell = $table.editConfig && $table.editConfig.mode === 'cell' ? isTreeNode ? this.renderTreeCellEdit : this.renderCellEdit : isTreeNode ? this.renderTreeRadioCell : this.renderRowEdit;
          } else if (filters && filters.length && (sortable || remoteSort)) {
            renMaps.renderHeader = this.renderSortAndFilterHeader;
          } else if (sortable || remoteSort) {
            renMaps.renderHeader = this.renderSortHeader;
          } else if (filters && filters.length) {
            renMaps.renderHeader = this.renderFilterHeader;
          }
  
      }
  
      return tools.UtilTools.getColumnConfig(_vm, renMaps);
    },
  
    /**
     * 单元格
     */
    renderHeader: function renderHeader(h, params) {
      var column = params.column;
      var slots = column.slots,
          own = column.own;
  
      if (slots && slots.header) {
        return slots.header(params, h);
      } // 在 v3.0 中废弃 label
  
  
      return [tools.UtilTools.formatText(tools.UtilTools.getFuncText(own.title || own.label), 1)];
    },
    renderCell: function renderCell(h, params) {
      var cellValue;
      var $table = params.$table,
          row = params.row,
          column = params.column;
      var slots = column.slots,
          own = column.own;
      var renderOpts = own.editRender || own.cellRender;
  
      if (slots && slots.default) {
        return slots.default(params, h);
      }
  
      if (renderOpts) {
        var funName = own.editRender ? 'renderCell' : 'renderDefault';
  
        var compConf = baseTable.Renderer.get(renderOpts.name);
  
        if (compConf && compConf[funName]) {
          return compConf[funName].call($table, h, renderOpts, params, {
            $type: own.editRender ? 'edit' : 'cell',
            $excel: $table.$parent,
            $table: $table,
            $column: column
          });
        }
      }
  
      cellValue = tools.UtilTools.getCellLabel(row, column, params);
      return [tools.UtilTools.formatText(cellValue, 1)];
    },
    renderTreeCell: function renderTreeCell(h, params) {
      return Cell.renderTreeIcon(h, params).concat(Cell.renderCell.call(this, h, params));
    },
  
    /**
     * 树节点
     */
    renderTreeIcon: function renderTreeIcon(h, params) {
      var _GlobalConfig = GlobalConfig,
          icon = _GlobalConfig.icon;
      var $table = params.$table;
      var treeConfig = $table.treeConfig,
          treeExpandeds = $table.treeExpandeds;
      var row = params.row,
          level = params.level;
      var children = treeConfig.children,
          indent = treeConfig.indent,
          trigger = treeConfig.trigger;
      var rowChildren = row[children];
      var on = {};
  
      if (!trigger || trigger === 'default') {
        on.click = function (evnt) {
          return $table.triggerTreeExpandEvent(evnt, params);
        };
      }
  
      return [h('span', {
        class: 'vue-xtable-tree--indent',
        style: {
          width: ''.concat(level * (indent || 16), 'px')
        }
      }), h('span', {
        class: ['vue-xtable-tree-wrapper', {
          'is--active': treeExpandeds.indexOf(row) > -1
        }],
        on: on
      }, rowChildren && rowChildren.length ? [h('i', {
        class: 'vue-xtable-tree--node-btn '.concat(icon.tree)
      })] : [])];
    },
  
    /**
     * 索引
     */
    renderIndexHeader: function renderIndexHeader(h, params) {
      var column = params.column;
      var slots = column.slots;
  
      if (slots && slots.header) {
        return slots.header(params, h);
      }
  
      return [tools.UtilTools.formatText(column.getTitle(), 1)];
    },
    renderIndexCell: function renderIndexCell(h, params) {
      var $table = params.$table,
          column = params.column;
      var startIndex = $table.startIndex;
      var slots = column.slots,
          indexMethod = column.indexMethod;
  
      if (slots && slots.default) {
        return slots.default(params, h);
      }
  
      var $seq = params.$seq,
          seq = params.seq,
          level = params.level;
      return [tools.UtilTools.formatText(indexMethod ? indexMethod(params) : level ? ''.concat($seq, '.').concat(seq) : startIndex + seq, 1)];
    },
    renderTreeIndexCell: function renderTreeIndexCell(h, params) {
      return Cell.renderTreeIcon(h, params).concat(Cell.renderIndexCell(h, params));
    },
  
    /**
     * 单选
     */
    renderRadioHeader: function renderRadioHeader(h, params) {
      var column = params.column;
      var slots = column.slots,
          own = column.own;
  
      if (slots && slots.header) {
        return slots.header(params, h);
      } // 在 v3.0 中废弃 label
  
  
      return [tools.UtilTools.formatText(tools.UtilTools.getFuncText(own.title || own.label), 1)];
    },
    renderRadioCell: function renderRadioCell(h, params) {
      var _ref;
  
      var $table = params.$table,
          column = params.column,
          isHidden = params.isHidden;
      var vSize = $table.vSize,
          _$table$radioConfig = $table.radioConfig,
          radioConfig = _$table$radioConfig === void 0 ? {} : _$table$radioConfig;
      var slots = column.slots;
      var labelField = radioConfig.labelField,
          checkMethod = radioConfig.checkMethod;
      var isDisabled = !!checkMethod;
  
      if (slots && slots.default) {
        return slots.default(params, h);
      }
  
      var selectRow = $table.selectRow;
      var row = params.row;
      var options = {
        attrs: {
          type: 'radio',
          name: 'vue-xtable-radio--'.concat($table.id)
        }
      };
  
      if (!isHidden) {
        if (checkMethod) {
          isDisabled = !checkMethod(params);
          options.attrs.disabled = isDisabled;
        }
  
        options.domProps = {
          checked: row === selectRow
        };
        options.on = {
          change: function change(evnt) {
            $table.triggerRadioRowEvent(evnt, params);
          }
        };
      }
  
      return [h('label', {
        class: ['vue-xtable-radio', (_ref = {}, _defineProperty(_ref, 'size--'.concat(vSize), vSize), _defineProperty(_ref, 'is--disabled', isDisabled), _ref)]
      }, [h('input', options), h('span', {
        class: 'vue-xtable-radio--icon'
      }), labelField ? h('span', {
        class: 'vue-xtable-radio--label'
      }, VueUtil.get(row, labelField)) : null])];
    },
    renderTreeRadioCell: function renderTreeRadioCell(h, params) {
      return Cell.renderTreeIcon(h, params).concat(Cell.renderRadioCell(h, params));
    },
  
    /**
     * 多选
     */
    renderSelectionHeader: function renderSelectionHeader(h, params) {
      var _ref2;
  
      var $table = params.$table,
          column = params.column,
          isHidden = params.isHidden;
      var vSize = $table.vSize,
          isIndeterminate = $table.isIndeterminate,
          isAllCheckboxDisabled = $table.isAllCheckboxDisabled;
      var slots = column.slots,
          own = column.own; // 在 v3.0 中废弃 selectConfig
  
      var checkboxConfig = $table.checkboxConfig || $table.selectConfig; // 在 v3.0 中废弃 label
  
      var headerTitle = own.title || own.label;
      var options = {
        attrs: {
          type: 'checkbox',
          disabled: isAllCheckboxDisabled
        }
      };
  
      if (slots && slots.header) {
        return slots.header(params, h);
      }
  
      if (checkboxConfig && (checkboxConfig.checkStrictly ? !checkboxConfig.showHeader : checkboxConfig.showHeader === false)) {
        return [];
      }
  
      if (!isHidden) {
        options.domProps = {
          checked: isAllCheckboxDisabled ? false : $table.isAllSelected
        };
        options.on = {
          change: function change(evnt) {
            $table.triggerCheckAllEvent(evnt, evnt.target.checked);
          }
        };
      }
  
      return [h('label', {
        class: ['vue-xtable-checkbox', (_ref2 = {}, _defineProperty(_ref2, 'size--'.concat(vSize), vSize), _defineProperty(_ref2, 'is--disabled', options.attrs.disabled), _defineProperty(_ref2, 'is--indeterminate', isIndeterminate), _ref2)]
      }, [h('input', options), h('span', {
        class: 'vue-xtable-checkbox--icon'
      }), headerTitle ? h('span', {
        class: 'vue-xtable-checkbox--label'
      }, tools.UtilTools.getFuncText(headerTitle)) : null])];
    },

    /**
     * 行拖动
     */
    renderDragHeader: function renderDragHeader(h, params) {
      var column = params.column;
      var slots = column.slots;
  
      if (slots && slots.header) {
        return slots.header(params, h);
      }
      
      return [tools.UtilTools.formatText(column.getTitle(), 1)];
    },

    renderSelectionCell: function renderSelectionCell(h, params) {
      var _ref3;
  
      var $table = params.$table,
          row = params.row,
          column = params.column,
          isHidden = params.isHidden;
      var vSize = $table.vSize,
          treeConfig = $table.treeConfig,
          treeIndeterminates = $table.treeIndeterminates; // 在 v3.0 中废弃 selectConfig
  
      var checkboxConfig = $table.checkboxConfig || $table.selectConfig || {};
      var labelField = checkboxConfig.labelField,
          checkMethod = checkboxConfig.checkMethod;
      var slots = column.slots;
      var indeterminate = false;
      var isDisabled = !!checkMethod;
      var options = {
        attrs: {
          type: 'checkbox'
        }
      };
  
      if (slots && slots.default) {
        return slots.default(params, h);
      }
  
      if (!isHidden) {
        if (checkMethod) {
          isDisabled = !checkMethod(params);
          options.attrs.disabled = isDisabled;
        }
  
        if (treeConfig) {
          indeterminate = treeIndeterminates.indexOf(row) > -1;
        }
  
        options.domProps = {
          checked: $table.selection.indexOf(row) > -1
        };
        options.on = {
          change: function change(evnt) {
            $table.triggerCheckRowEvent(evnt, params, evnt.target.checked);
          }
        };
      }
  
      return [h('label', {
        class: ['vue-xtable-checkbox', (_ref3 = {}, _defineProperty(_ref3, 'size--'.concat(vSize), vSize), _defineProperty(_ref3, 'is--indeterminate', indeterminate), _defineProperty(_ref3, 'is--disabled', isDisabled), _ref3)]
      }, [h('input', options), h('span', {
        class: 'vue-xtable-checkbox--icon'
      }), labelField ? h('span', {
        class: 'vue-xtable-checkbox--label'
      }, VueUtil.get(row, labelField)) : null])];
    },
    renderTreeSelectionCell: function renderTreeSelectionCell(h, params) {
      return Cell.renderTreeIcon(h, params).concat(Cell.renderSelectionCell(h, params));
    },
    renderSelectionCellByProp: function renderSelectionCellByProp(h, params) {
      var _ref4;
  
      var $table = params.$table,
          row = params.row,
          column = params.column,
          isHidden = params.isHidden;
      var vSize = $table.vSize,
          treeConfig = $table.treeConfig,
          treeIndeterminates = $table.treeIndeterminates; // 在 v3.0 中废弃 selectConfig
  
      var checkboxConfig = $table.checkboxConfig || $table.selectConfig || {};
      var labelField = checkboxConfig.labelField,
          property = checkboxConfig.checkField,
          checkMethod = checkboxConfig.checkMethod;
      var slots = column.slots;
      var indeterminate = false;
      var isDisabled = !!checkMethod;
      var options = {
        attrs: {
          type: 'checkbox'
        }
      };
  
      if (slots && slots.default) {
        return slots.default(params, h);
      }
  
      if (!isHidden) {
        if (checkMethod) {
          isDisabled = !checkMethod(params);
          options.attrs.disabled = isDisabled;
        }
  
        if (treeConfig) {
          indeterminate = treeIndeterminates.indexOf(row) > -1;
        }
  
        options.domProps = {
          checked: VueUtil.get(row, property)
        };
        options.on = {
          change: function change(evnt) {
            $table.triggerCheckRowEvent(evnt, params, evnt.target.checked);
          }
        };
      }
  
      return [h('label', {
        class: ['vue-xtable-checkbox', (_ref4 = {}, _defineProperty(_ref4, 'size--'.concat(vSize), vSize), _defineProperty(_ref4, 'is--indeterminate', indeterminate), _defineProperty(_ref4, 'is--disabled', isDisabled), _ref4)]
      }, [h('input', options), h('span', {
        class: 'vue-xtable-checkbox--icon'
      }), labelField ? h('span', {
        class: 'vue-xtable-checkbox--label'
      }, VueUtil.get(row, labelField)) : null])];
    },
    renderTreeSelectionCellByProp: function renderTreeSelectionCellByProp(h, params) {
      return Cell.renderTreeIcon(h, params).concat(Cell.renderSelectionCellByProp(h, params));
    },
  
    /**
     * 展开行
     */
    renderExpandCell: function renderExpandCell(h, params) {
      var $table = params.$table,
          isHidden = params.isHidden;
      var expandActive = false;
  
      if (!isHidden) {
        expandActive = $table.expandeds.indexOf(params.row) > -1;
      }
  
      return [h('span', {
        class: ['vue-xtable-table--expanded', {
          'expand--active': expandActive
        }],
        on: {
          click: function click(evnt) {
            $table.triggerRowExpandEvent(evnt, params);
          }
        }
      }, [h('i', {
        class: 'vue-xtable-table--expand-icon'
      })])];
    },

    /**
     * 行拖动
     */
    renderDragCell: function renderDragCell(h, params) {
      return [h('span', {
        class: ['vue-xtable-table--drag', 'vue-icon-menu'],
      })];
    },

    renderExpandData: function renderExpandData(h, params) {
      var column = params.column;
      var slots = column.slots;
  
      if (slots && slots.default) {
        return slots.default(params, h);
      }
  
      return [];
    },
  
    /**
     * 排序和筛选
     */
    renderSortAndFilterHeader: function renderSortAndFilterHeader(h, params) {
      return Cell.renderHeader(h, params).concat(Cell.renderSortIcon(h, params)).concat(Cell.renderFilterIcon(h, params));
    },
  
    /**
     * 排序
     */
    renderSortHeader: function renderSortHeader(h, params) {
      return Cell.renderHeader(h, params).concat(Cell.renderSortIcon(h, params));
    },
    renderSortIcon: function renderSortIcon(h, params) {
      var _GlobalConfig2 = GlobalConfig,
          icon = _GlobalConfig2.icon;
      var $table = params.$table,
          column = params.column;
      return [h('span', {
        class: 'vue-xtable-sort-wrapper'
      }, [h('i', {
        class: ['vue-xtable-sort--asc-btn', icon.sortAsc, {
          'sort--active': column.order === 'asc'
        }],
        on: {
          click: function click(evnt) {
            $table.triggerSortEvent(evnt, column, 'asc');
          }
        }
      }), h('i', {
        class: ['vue-xtable-sort--desc-btn', icon.sortDesc, {
          'sort--active': column.order === 'desc'
        }],
        on: {
          click: function click(evnt) {
            $table.triggerSortEvent(evnt, column, 'desc');
          }
        }
      })])];
    },
  
    /**
     * 筛选
     */
    renderFilterHeader: function renderFilterHeader(h, params) {
      return Cell.renderHeader(h, params).concat(Cell.renderFilterIcon(h, params));
    },
    renderFilterIcon: function renderFilterIcon(h, params) {
      var _GlobalConfig3 = GlobalConfig,
          icon = _GlobalConfig3.icon;
      var $table = params.$table,
          column = params.column;
      var filterStore = $table.filterStore;
      return [h('span', {
        class: ['vue-xtable-filter-wrapper', {
          'is--active': filterStore.visible && filterStore.column === column
        }]
      }, [h('i', {
        class: 'vue-xtable-filter--btn '.concat(icon.filter),
        on: {
          click: function click(evnt) {
            $table.triggerFilterEvent(evnt, params.column, params);
          }
        }
      })])];
    },
  
    /**
     * 可编辑
     */
    renderEditHeader: function renderEditHeader(h, params) {
      var _GlobalConfig4 = GlobalConfig,
          icon = _GlobalConfig4.icon;
      var $table = params.$table,
          column = params.column;
      var editRules = $table.editRules,
          editConfig = $table.editConfig;
      var sortable = column.sortable,
          remoteSort = column.remoteSort,
          filters = column.filters;
      var isRequired;
  
      if (editRules) {
        function getIsRequiredByOne(property){
            var columnRules = VueUtil.get(editRules, property);

            if (columnRules) {
              isRequired = columnRules.some(function (rule) {
                return rule.required;
              });
            }
		}
		if(VueUtil.isArray(params.column.property)){
			params.column.property.some(function (item) {
				getIsRequiredByOne(item);
				if(isRequired){ return true; }
			});
		}else{
			getIsRequiredByOne(params.column.property);
		}
      }
  
      return [isRequired ? h('i', {
        class: 'vue-xtable-required-icon'
      }) : null, editConfig && editConfig.showIcon === false ? null : h('i', {
        class: 'vue-xtable-edit-icon '.concat(icon.edit)
      })].concat(Cell.renderHeader(h, params)).concat(sortable || remoteSort ? Cell.renderSortIcon(h, params) : []).concat(filters && filters.length ? Cell.renderFilterIcon(h, params) : []);
    },
    // 行格编辑模式
    renderRowEdit: function renderRowEdit(h, params) {
      var $table = params.$table;
      var actived = $table.editStore.actived;
      var activeMethod = $table.editConfig.activeMethod;
      return Cell.runRenderer(h, params, this, actived && actived.row === params.row && (!activeMethod || activeMethod(params)));
    },
    renderTreeRowEdit: function renderTreeRowEdit(h, params) {
      return Cell.renderTreeIcon(h, params).concat(Cell.renderRowEdit(h, params));
    },
    // 单元格编辑模式
    renderCellEdit: function renderCellEdit(h, params) {
      var $table = params.$table;
      var actived = $table.editStore.actived;
      return Cell.runRenderer(h, params, this, actived && actived.row === params.row && actived.column === params.column);
    },
    renderTreeCellEdit: function renderTreeCellEdit(h, params) {
      return Cell.renderTreeIcon(h, params).concat(Cell.renderCellEdit(h, params));
    },
    runRenderer: function runRenderer(h, params, _vm, isEdit) {
      var $table = params.$table,
          row = params.row,
          column = params.column;
      var slots = column.slots,
          own = column.own,
          formatter = column.formatter;
      var editRender = own.editRender;
  
      var compConf = baseTable.Renderer.get(editRender.name);
  
      if (editRender.type === 'visible' || isEdit) {
        if (slots && slots.edit) {
          return slots.edit(params, h);
        }
  
        return compConf && compConf.renderEdit ? compConf.renderEdit.call($table, h, editRender, params, {
          $type: 'edit',
          $excel: $table.$parent,
          $table: $table,
          $column: column
        }) : [];
      }
  
      if (slots && slots.default) {
        return slots.default(params, h);
      }
  
      if (formatter) {
        return [tools.UtilTools.formatText(tools.UtilTools.getCellLabel(row, column, params), 1)];
      }
  
      return Cell.renderCell.call(_vm, h, params);
    }
  };

  return Cell;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueXtable = definition(context.baseTable, context.tools, context.cell);
  }
})(this, function(baseTable, tools, cell) {
  // 多列排序方法 github.com/Teun/thenBy.js
  var firstBy = (function () {
    function identity(v) { return v; }

    function ignoreCase(v) { return typeof (v) === 'string' ? v.toLowerCase() : v; }

    function makeCompareFunction(f, opt) {
      opt = typeof (opt) === 'number' ? { direction: opt } : opt || {};
      if (typeof (f) != 'function') {
        var prop = f;
        // make unary function
        f = function (v1) { return v1[prop] ? v1[prop] : ''; };
      }
      if (f.length === 1) {
        // f is a unary function mapping a single item to its sort score
        var uf = f;
        var preprocess = opt.ignoreCase ? ignoreCase : identity;
        var cmp = opt.cmp || function (v1, v2) { return v1 < v2 ? -1 : v1 > v2 ? 1 : 0; };
        f = function (v1, v2) { return cmp(preprocess(uf(v1)), preprocess(uf(v2))); };
      }
      if (opt.direction === -1) return function (v1, v2) { return -f(v1, v2); };
      return f;
    }

    function tb(func, opt) {
      var x = (typeof (this) == 'function' && !this.firstBy) ? this : false;
      var y = makeCompareFunction(func, opt);
      var f = x ? function (a, b) {
        return x(a, b) || y(a, b);
      }
        : y;
      f.thenBy = tb;
      return f;
    }
    tb.firstBy = tb;
    return tb;
  })();
  
  // methods.js
  var mod = {};
  (function() {
    var rowUniqueId = 0;
    var isWebkit = !!document.documentElement['webkitMatchesSelector'] && !VueUtil.isEdge;
    var debounceScrollYDuration = VueUtil.isIE ? 40 : 20; // 分组表头的属性
    
    var headerProps = {
      children: 'children'
    };
    /**
     * 生成行的唯一主键
     */
    
    function getRowUniqueId() {
      return 'row_'.concat(++rowUniqueId);
    }
    
    function isTargetRadioOrCheckbox(evnt, column, colType, targetType) {
      var target = evnt.target;
      return target && column.type === colType && target.tagName.toLowerCase() === 'input' && target.type === (targetType || colType);
    }
    
    var Methods = {
      /**
       * 获取父容器元素
       */
      getParentElem: function getParentElem() {
        return this.$grid ? this.$grid.$el.parentNode : this.$el.parentNode;
      },
    
      /**
       * 获取父容器的高度
       */
      getParentHeight: function getParentHeight() {
        return this.$grid ? this.$grid.getParentHeight() : this.getParentElem().clientHeight;
      },
    
      /**
       * 获取需要排除的高度
       * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度
       * 如果存在表尾合计滚动条，则需要排除滚动条高度
       */
      getExcludeHeight: function getExcludeHeight() {
        return this.$grid ? this.$grid.getExcludeHeight() : 0;
      },
    
      /**
       * 重置表格的一切数据状态
       */
      clearAll: function clearAll() {
        this.clearSort();
        this.clearCurrentRow();
        this.clearCurrentColumn();
        this.clearSelection();
        this.clearRowExpand();
        this.clearTreeExpand();
        this.clearActived();
    
        if (baseTable._filter) {
          this.clearFilter();
        }
    
        if (this.keyboardConfig || this.mouseConfig) {
          this.clearIndexChecked();
          this.clearHeaderChecked();
          this.clearChecked();
          this.clearSelected();
          this.clearCopyed();
        }
    
        return this.clearScroll();
      },
    
      /**
       * 同步刷新 data 数据
       * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑
       * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到
       */
      refreshData: function refreshData() {
        var _this = this;
    
        return this.$nextTick().then(function () {
          _this.tableData = [];
          return _this.$nextTick().then(function () {
            return _this.loadTableData(_this.tableFullData);
          });
        });
      },
    
      /**
       * 手动处理数据
       * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到
       */
      updateData: function updateData() {
        return this.handleTableData(true).then(this.updateFooter).then(this.recalculate);
      },
      handleTableData: function handleTableData(force) {
        if (this.keyboardConfig || this.mouseConfig) {
          this.clearIndexChecked();
          this.clearHeaderChecked();
          this.clearChecked();
          this.clearCopyed();
        }
        
        var scrollYLoad = this.scrollYLoad,
            scrollYStore = this.scrollYStore;
        var fullData = force ? this.updateAfterFullData() : this.afterFullData;
        this.tableData = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.startIndex + scrollYStore.renderSize) : fullData.slice(0);
        return this.$nextTick();
      },
    
      /**
       * 加载表格数据
       * @param {Array} datas 数据
       * @param {Boolean} notRefresh 是否不重新运算列宽
       */
      loadTableData: function loadTableData(datas, notRefresh) {
        var _this2 = this;
    
        var height = this.height,
            maxHeight = this.maxHeight,
            showOverflow = this.showOverflow,
            treeConfig = this.treeConfig,
            editStore = this.editStore,
            optimizeOpts = this.optimizeOpts,
            scrollYStore = this.scrollYStore;
        var scrollY = optimizeOpts.scrollY;
        var tableFullData = datas ? datas.slice(0) : [];
        var scrollYLoad = !treeConfig && scrollY && scrollY.gt && scrollY.gt < tableFullData.length;
        scrollYStore.startIndex = 0;
        scrollYStore.visibleIndex = 0;
        editStore.insertList = [];
        editStore.removeList = []; // 全量数据
    
        this.tableFullData = tableFullData; // 缓存数据
    
        this.updateCache(true); // 原始数据
    
        this.tableSynchData = datas;
        this.tableSourceData = VueUtil.cloneDeep(tableFullData);
        this.scrollYLoad = scrollYLoad;
    
        if (scrollYLoad && !(height || maxHeight)) {
          tools.UtilTools.error('vue.xtable.error.scrollYReqProp', ['height | max-height']);
        }
    
        if (scrollYLoad && !showOverflow) {
          tools.UtilTools.warn('vue.xtable.error.scrollYReqProp', ['show-overflow']);
        }
    
        var rest = Promise.resolve();
    
        if (scrollYLoad) {
          rest = this.computeScrollLoad();
        }
    
        return rest.then(function () {
          // 是否加载了数据
          _this2.isLoadData = true;
    
          _this2.handleTableData(true);
    
          _this2.reserveCheckSelection();
    
          _this2.checkSelectionStatus();
    
          rest = _this2.$nextTick();
    
          if (!notRefresh) {
            rest = rest.then(_this2.recalculate);
          }
    
          return rest.then(_this2.refreshScroll);
        });
      },
    
      /**
       * 重新加载数据，不会清空表格状态
       * @param {Array} datas 数据
       */
      loadData: function loadData(datas) {
        return this.loadTableData(datas).then(this.recalculate);
      },
    
      /**
       * 重新加载数据，会清空表格状态
       * @param {Array} datas 数据
       */
      reloadData: function reloadData(datas) {
        var _this3 = this;
    
        return this.clearAll().then(function () {
          return _this3.loadTableData(datas);
        }).then(this.handleDefault);
      },
    
      /**
       * 局部加载行数据并恢复到初始状态
       * 对于行数据需要局部更改的场景中可能会用到
       * @param {Row} row 行对象
       * @param {Object} record 新数据
       * @param {String} field 字段名
       */
      reloadRow: function reloadRow(row, record, field) {
        var tableSourceData = this.tableSourceData,
            tableData = this.tableData;
        var rowIndex = this.getRowIndex(row);
        var oRow = tableSourceData[rowIndex];
    
        if (oRow && row) {
          if (field) {
            VueUtil.set(oRow, field, VueUtil.get(record || row, field));
          } else {
            if (record) {
              tableSourceData[rowIndex] = record;

              VueUtil.forEach(row, function(val,key) {
                row[key] = undefined;
              });
              
              VueUtil.assign(row, this.defineField(VueUtil.assign({}, record)));
              this.updateCache(true);
            } else {
              VueUtil.destructuring(oRow, VueUtil.cloneDeep(row));
            }
          }
        }
    
        this.tableData = tableData.slice(0);
        return this.$nextTick();
      },
    
      /**
       * 加载列配置
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnConfig} columns 列配置
       */
      loadColumn: function loadColumn(columns) {
        var _this4 = this;

        this.collectColumn = VueUtil.mapTree(columns, function (column) {
          return cell.createColumn(_this4, column);
        }, headerProps);
        return this.$nextTick();
      },
    
      /**
       * 加载列配置并恢复到初始状态
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnConfig} columns 列配置
       */
      reloadColumn: function reloadColumn(columns) {
        this.clearAll();
        return this.loadColumn(columns);
      },
    
      /**
       * 更新数据行的 Map
       * 牺牲数据组装的耗时，用来换取使用过程中的流畅
       */
      updateCache: function updateCache(source) {
        var _this5 = this;
    
        var treeConfig = this.treeConfig,
            tableFullData = this.tableFullData,
            fullDataRowIdData = this.fullDataRowIdData,
            fullDataRowMap = this.fullDataRowMap,
            fullAllDataRowMap = this.fullAllDataRowMap,
            fullAllDataRowIdData = this.fullAllDataRowIdData;
    
        var rowkey = tools.UtilTools.getRowkey(this);
    
        var handleCache = function handleCache(row, index) {
          var rowid = tools.UtilTools.getRowid(_this5, row);
    
          if (!rowid) {
            rowid = getRowUniqueId();
            VueUtil.set(row, rowkey, rowid);
          }
    
          var rest = {
            row: row,
            rowid: rowid,
            index: index
          };
    
          if (source) {
            fullDataRowIdData[rowid] = rest;
            fullDataRowMap.set(row, rest);
          }
    
          fullAllDataRowIdData[rowid] = rest;
          fullAllDataRowMap.set(row, rest);
        };
    
        if (source) {
          fullDataRowIdData = this.fullDataRowIdData = {};
          fullDataRowMap.clear();
        }
    
        fullAllDataRowIdData = this.fullAllDataRowIdData = {};
        fullAllDataRowMap.clear();
    
        if (treeConfig) {
          VueUtil.eachTree(tableFullData, handleCache, treeConfig);
        } else {
          tableFullData.forEach(handleCache);
        }
      },
    
      /**
       * 更新数据列的 Map
       * 牺牲数据组装的耗时，用来换取使用过程中的流畅
       */
      cacheColumnMap: function cacheColumnMap() {
        var tableFullColumn = this.tableFullColumn,
            fullColumnMap = this.fullColumnMap;
        var fullColumnIdData = this.fullColumnIdData = {};
        fullColumnMap.clear();
        tableFullColumn.forEach(function (column, index) {
          var rest = {
            column: column,
            colid: column.id,
            index: index
          };
          fullColumnIdData[column.id] = rest;
          fullColumnMap.set(column, rest);
        });
      },
    
      /**
       * 根据 tr 元素获取对应的 row 信息
       * @param {Element} tr 元素
       */
      getRowNode: function getRowNode(tr) {
        var _this6 = this;
    
        if (tr) {
          var treeConfig = this.treeConfig,
              tableFullData = this.tableFullData,
              fullAllDataRowIdData = this.fullAllDataRowIdData;
          var rowid = tr.getAttribute('data-rowid');
    
          if (treeConfig) {
            var matchObj = VueUtil.findTree(tableFullData, function (row) {
              return tools.UtilTools.getRowid(_this6, row) === rowid;
            }, treeConfig);
    
            if (matchObj) {
              return matchObj;
            }
          } else {
            if (fullAllDataRowIdData[rowid]) {
              var rest = fullAllDataRowIdData[rowid];
              return {
                item: rest.row,
                index: rest.index,
                items: tableFullData
              };
            }
          }
        }
    
        return null;
      },
    
      /**
       * 根据 th/td 元素获取对应的 column 信息
       * @param {Element} cell 元素
       */
      getColumnNode: function getColumnNode(cell) {
        if (cell) {
          var isGroup = this.isGroup,
              fullColumnIdData = this.fullColumnIdData,
              tableFullColumn = this.tableFullColumn;
          var colid = cell.getAttribute('data-colid');
    
          if (isGroup) {
            var matchObj = VueUtil.findTree(tableFullColumn, function (column) {
              return column.id === colid;
            }, headerProps);
    
            if (matchObj) {
              return matchObj;
            }
          } else {
            var _fullColumnIdData$col = fullColumnIdData[colid],
                column = _fullColumnIdData$col.column,
                index = _fullColumnIdData$col.index;
            return {
              item: column,
              index: index,
              items: tableFullColumn
            };
          }
        }
    
        return null;
      },
    
      /**
       * 根据 row 获取相对于 data 中的索引
       * @param {Row} row 行对象
       */
      getRowIndex: function getRowIndex(row) {
        return this.fullDataRowMap.has(row) ? this.fullDataRowMap.get(row).index : -1;
      },
    
      /**
       * 根据 column 获取相对于 columns 中的索引
       * @param {ColumnConfig} column 列配置
       */
      getColumnIndex: function getColumnIndex(column) {
        return this.fullColumnMap.has(column) ? this.fullColumnMap.get(column).index : -1;
      },
    
      /**
       * 判断是否为索引列
       * @param {ColumnConfig} column 列配置
       */
      hasIndexColumn: function hasIndexColumn(column) {
        return column && column.type === 'index';
      },
    
      /**
       * 定义行数据中的列属性，如果不存在则定义
       * @param {Row} row 行数据
       */
      defineField: function defineField(row) {
        var rowkey = tools.UtilTools.getRowkey(this);
    
        this.visibleColumn.forEach(function (_ref) {
          var property = _ref.property,
              editRender = _ref.editRender;
    
          function setDefaultByOne(propertyItem){
              if (propertyItem && !VueUtil.hasIn(row, propertyItem)) {
                VueUtil.set(row, propertyItem, editRender && !VueUtil.isUndefined(editRender.defaultValue) ? editRender.defaultValue : null);
              }
          }
          if(VueUtil.isArray(property)){
             property.forEach(function(item){
                  setDefaultByOne(item);
              });
          }else{
              setDefaultByOne(property);
          }
        }); // 必须有行数据的唯一主键，可以自行设置；也可以默认生成一个随机数
    
        if (!VueUtil.get(row, rowkey)) {
          VueUtil.set(row, rowkey, getRowUniqueId());
        }
    
        return row;
      },
    
      /**
       * 创建 data 对象
       * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义
       * @param {Array} records 新数据
       */
      createData: function createData(records) {
        var _this7 = this;
    
        return this.$nextTick().then(function () {
          return records.map(_this7.defineField);
        });
      },
    
      /**
       * 创建 Row|Rows 对象
       * 对于某些特殊场景需要对数据进行手动插入时可能会用到
       * @param {Array/Object} records 新数据
       */
      createRow: function createRow(records) {
        var _this8 = this;
    
        var isArr = VueUtil.isArray(records);
    
        if (!isArr) {
          records = [records];
        }
    
        return this.$nextTick().then(function () {
          var rows = records.map(function (record) {
            return _this8.defineField(VueUtil.assign({}, record));
          });
          return isArr ? rows : rows[0];
        });
      },
    
      /**
       * 清空单元格内容
       * 如果不创参数，则清空整个表格内容
       * 如果传 row 则清空一行内容
       * 如果传 rows 则清空多行内容
       * 如果还额外传了 field 则清空指定单元格内容
       * @param {Array/Row} rows 行数据
       * @param {String} field 字段名
       */
      clearData: function clearData(rows, field) {
        var tableFullData = this.tableFullData,
            visibleColumn = this.visibleColumn;
    
        if (!arguments.length) {
          rows = tableFullData;
        } else if (rows && !VueUtil.isArray(rows)) {
          rows = [rows];
        }
    
        if (field) {
          rows.forEach(function (row) {
            return VueUtil.set(row, field, null);
          });
        } else {
          rows.forEach(function (row) {
            visibleColumn.forEach(function (column) {
              if (column.property) {
                tools.UtilTools.setCellValue(row, column, null);
              }
            });
          });
        }
    
        return this.$nextTick();
      },
    
      /**
       * 检查是否为临时行数据
       * @param {Row} row 行对象
       */
      isInsertByRow: function isInsertByRow(row) {
        return this.editStore.insertList.indexOf(row) > -1;
      },
      // 在 v3.0 中废弃 hasRowChange
      hasRowChange: function hasRowChange(row, field) {
        tools.UtilTools.warn('vue.xtable.error.delFunc', ['hasRowChange', 'isUpdateByRow']);
    
        return this.isUpdateByRow(row, field);
      },
    
      /**
       * 检查行或列数据是否发生改变
       * @param {Row} row 行对象
       * @param {String} field 字段名
       */
      isUpdateByRow: function isUpdateByRow(row, field) {
        var _this9 = this;
    
        var oRow, property;
        var visibleColumn = this.visibleColumn,
            treeConfig = this.treeConfig,
            tableSourceData = this.tableSourceData,
            fullDataRowIdData = this.fullDataRowIdData;
    
        var rowid = tools.UtilTools.getRowid(this, row); // 新增的数据不需要检测
    
    
        if (!fullDataRowIdData[rowid]) {
          return false;
        }
    
        if (treeConfig) {
          var children = treeConfig.children;
          var matchObj = VueUtil.findTree(tableSourceData, function (item) {
            return rowid === tools.UtilTools.getRowid(_this9, item);
          }, treeConfig);
          row = VueUtil.assign({}, row, tools.UtilTools.defineProperty({}, children, null));
    
          if (matchObj) {
            oRow = VueUtil.assign({}, matchObj.item, tools.UtilTools.defineProperty({}, children, null));
          }
        } else {
          var oRowIndex = fullDataRowIdData[rowid].index;
          oRow = tableSourceData[oRowIndex];
        }
    
        if (oRow) {
		  function isEqualsByListOrOne(obj,cb){
			  if(VueUtil.isArray(obj)){
				return obj.some(function(item){
					if(cb(item)){
						 return true;
					 }
				});
			  }else{
				return cb(obj);
			  }
		  }
          if (arguments.length > 1) {
            function isEqualByOne(item){
				 return !VueUtil.isEqual(VueUtil.get(oRow, item), VueUtil.get(row, item));
			 }
			 return isEqualsByListOrOne(field,isEqualByOne);
          }
    
          for (var index = 0, len = visibleColumn.length; index < len; index++) {
            property = visibleColumn[index].property;
            function isEqualByOne(item){
				if (property && !VueUtil.isEqual(VueUtil.get(oRow, item), VueUtil.get(row, item))) {
					return true;
				}
			}
			if(isEqualsByListOrOne(property,isEqualByOne)){
				return true;
			}
          }
        }
    
        return false;
      },
    
      /**
       * 获取表格的可视列，也可以指定索引获取列
       * @param {Number} columnIndex 索引
       */
      getColumns: function getColumns(columnIndex) {
        var columns = this.visibleColumn;
        return arguments.length ? columns[columnIndex] : columns.slice(0);
      },
    
      /**
       * 根据列的唯一主键获取列
       * @param {String} colid 列主键
       */
      getColumnById: function getColumnById(colid) {
        var fullColumnIdData = this.fullColumnIdData;
        return fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;
      },
    
      /**
       * 根据列的字段名获取列
       * @param {String} field 字段名
       */
      getColumnByField: function getColumnByField(field) {
        var isArrayField = VueUtil.isArray(field);

        return VueUtil.find(this.visibleColumn, function (column) {
          return isArrayField ? VueUtil.isEqual(column.property, field) : column.property === field;
        });
      },
    
      /**
       * 获取当前表格的列
       * 完整的全量表头列、处理条件之后的全量表头列、当前渲染中的表头列
       */
      getTableColumn: function getTableColumn() {
        return {
          fullColumn: this.tableFullColumn.slice(0),
          visibleColumn: this.visibleColumn.slice(0),
          tableColumn: this.tableColumn.slice(0)
        };
      },
      // 在 v3.0 中废弃 getRecords
      getRecords: function getRecords() {
        tools.UtilTools.warn('vue.xtable.error.delFunc', ['getRecords', 'getData']);
    
        return this.getData.apply(this, arguments);
      },
    
      /**
       * 获取数据，和 data 的行为一致，也可以指定索引获取数据
       */
      getData: function getData(rowIndex) {
        var tableSynchData = this.data || this.tableSynchData;
        return arguments.length ? tableSynchData[rowIndex] : tableSynchData.slice(0);
      },
      // 在 v3.0 中废弃 getAllRecords
      getAllRecords: function getAllRecords() {
        tools.UtilTools.warn('vue.xtable.error.delFunc', ['getAllRecords', 'getRecordset']);
    
        return this.getRecordset();
      },
    
      /**
       * 用于多选行，获取已选中的数据
       */
      getSelectRecords: function getSelectRecords() {
        var tableFullData = this.tableFullData,
            treeConfig = this.treeConfig; // 在 v3.0 中废弃 selectConfig
    
        var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
        var property = checkboxConfig.checkField;
        var rowList = [];
    
        if (property) {
          if (treeConfig) {
            rowList = VueUtil.filterTree(tableFullData, function (row) {
              return VueUtil.get(row, property);
            }, treeConfig);
          } else {
            rowList = tableFullData.filter(function (row) {
              return VueUtil.get(row, property);
            });
          }
    
        } else {
          var selection = this.selection;
    
          if (treeConfig) {
            rowList = VueUtil.filterTree(tableFullData, function (row) {
              return selection.indexOf(row) > -1;
            }, treeConfig);
          } else {
            rowList = tableFullData.filter(function (row) {
              return selection.indexOf(row) > -1;
            });
          }
    
        }
    
        return rowList;
      },
    
      /**
       * 获取处理后全量的表格数据
       * 如果存在筛选条件，继续处理
       */
      updateAfterFullData: function updateAfterFullData() {
        var visibleColumn = this.visibleColumn,
            tableFullData = this.tableFullData,
            remoteSort = this.remoteSort,
            remoteFilter = this.remoteFilter;
        var tableData = tableFullData;
        var filterColumn = visibleColumn.filter(function (_ref2) {
          var filters = _ref2.filters;
          return filters && filters.length;
        });
        tableData = tableData.filter(function (row) {
          return filterColumn.every(function (column) {
            var filters = column.filters,
                filterRender = column.filterRender;
            var compConf = filterRender ? baseTable.Renderer.get(filterRender.name) : null;
            var valueList = [];
            var itemList = [];
    
            if (filters && filters.length) {
              filters.forEach(function (item) {
                if (item.checked) {
                  itemList.push(item);
                  valueList.push(item.value);
                }
              });
    
              if (valueList.length && !remoteFilter) {
                var property = column.property,
                    filterMethod = column.filterMethod;
    
                if (!filterMethod && compConf && compConf.renderFilter) {
                  filterMethod = compConf.filterMethod;
                }
    
                return filterMethod ? itemList.some(function (item) {
                  return filterMethod({
                    value: item.value,
                    option: item,
                    row: row,
                    column: column
                  });
                }) : valueList.indexOf(VueUtil.get(row, property)) > -1;
              }
            }
    
            return true;
          });
        });
    
        if (this.sortingColumns && this.sortingColumns.length > 0) {
          var iteratees = this.sortingColumns.map(function(column) {
            return column.sortMethod || column.property;
          });

          var orders = this.sortingColumns.map(function(column) {
            return column.order;
          });
          
          if (!remoteSort) {
            if (this.sortMethod) {
              tableData = this.sortMethod({
                data: tableData,
                column: VueUtil.clone(this.sortingColumns),
                property: iteratees,
                order: orders,
                $table: this
              }) || tableData;
            } else {
              var sortAry = [];
              this.sortingColumns.forEach(function(column) {
                if(VueUtil.isArray(column.sortBy) && column.sortBy.length > 0) {
                  column.sortBy.forEach(function (sortBy) {
                    sortAry.push({
                      prop: sortBy,
                      order: column.order === 'desc' ? -1 : undefined
                    });
                  });
                } else {
                  sortAry.push({
                    prop: column.sortMethod || column.property,
                    order: column.order === 'desc' ? -1 : undefined
                  });
                }
              });
      
              var sortFunc = firstBy(sortAry[0].prop, sortAry[0].order);
              for (var index = 1; index < sortAry.length; index++) {
                sortFunc = sortFunc.thenBy(sortAry[index].prop, sortAry[index].order);
              }
              tableData = tableData.sort(sortFunc);
            }
          }
        }

        this.afterFullData = tableData;
        return tableData;
      },
    
      /**
       * 根据行的唯一主键获取行
       * @param {String/Number} rowid 行主键
       */
      getRowById: function getRowById(rowid) {
        var fullDataRowIdData = this.fullDataRowIdData;
        return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : null;
      },
    
      /**
       * 根据行获取行的唯一主键
       * @param {Row} row 行对象
       */
      getRowid: function getRowid(row) {
        var fullAllDataRowMap = this.fullAllDataRowMap;
        return fullAllDataRowMap.has(row) ? fullAllDataRowMap.get(row).rowid : null;
      },
    
      /**
       * 获取处理后的表格数据
       * 如果存在筛选条件，继续处理
       * 如果存在排序，继续处理
       */
      getTableData: function getTableData() {
        var tableFullData = this.tableFullData,
            afterFullData = this.afterFullData,
            tableData = this.tableData,
            footerData = this.footerData;
        return {
          fullData: tableFullData.slice(0),
          visibleData: afterFullData.slice(0),
          tableData: tableData.slice(0),
          footerData: footerData.slice(0)
        };
      },
      handleDefault: function handleDefault() {
        var _this10 = this;
    
        // 在 v3.0 中废弃 selectConfig
        var checkboxConfig = this.checkboxConfig || this.selectConfig;
    
        if (checkboxConfig) {
          this.handleSelectionDefChecked();
        }
    
        if (this.radioConfig) {
          this.handleRadioDefChecked();
        }
    
        if (this.expandConfig) {
          this.handleDefaultRowExpand();
        }
    
        if (this.treeConfig) {
          this.handleDefaultTreeExpand();
        }
    
        this.updateFooter();
        this.$nextTick(function () {
          return setTimeout(_this10.recalculate);
        });
      },
    
      /**
       * 动态列处理
       */
      mergeCustomColumn: function mergeCustomColumn(customColumns) {
        var tableFullColumn = this.tableFullColumn;
        this.isUpdateCustoms = true;
    
        if (customColumns.length) {
          tableFullColumn.forEach(function (column) {
            // 在 v3.0 中废弃 prop
            var item = VueUtil.find(customColumns, function (item) {
              return column.property && (item.field || item.prop) === column.property;
            });
    
            if (item) {
              if (VueUtil.isNumber(item.resizeWidth)) {
                column.resizeWidth = item.resizeWidth;
              }
    
              if (VueUtil.isBoolean(item.visible)) {
                column.visible = item.visible;
              }

              if (item.fixed === 'left' || item.fixed === 'right' ) {
                column.fixed = item.fixed;
              }
            }
          });
        }
    
        this.$emit('update:customs', tableFullColumn);
      },
    
      /**
       * 手动重置列的所有操作，还原到初始状态
       * 如果已关联工具栏，则会同步更新
       */
      resetAll: function resetAll() {
        this.resetFixColumn();
        this.resetCustoms();
        this.resetResizable();
        this.resetColumnDrag();
      },
    
      /**
       * 隐藏指定列
       * @param {ColumnConfig} column 列配置
       */
      hideColumn: function hideColumn(column) {
        return this.handleVisibleColumn(column, false);
      },
    
      /**
       * 显示指定列
       * @param {ColumnConfig} column 列配置
       */
      showColumn: function showColumn(column) {
        return this.handleVisibleColumn(column, true);
      },

      /**
       * 固定指定列
       * @param {ColumnConfig} column 列配置
       */
      fixColumn: function fixColumn(column, position) {
        if (arguments.length) {
          column.fixed = position === false ? undefined : position === 'right' ? position : 'left';
        } else {
          this.tableFullColumn.forEach(function (column) {
            column.fixed = undefined;
          });
        }
        
        if (this.$toolbar) {
          this.$toolbar.updateFixed();
        }
      },

      resetFixColumn: function() {
        this.fixColumn();
      },
    
      /**
       * 手动重置列的显示/隐藏操作，还原到初始状态
       * 如果已关联工具栏，则会同步更新
       */
      resetCustoms: function resetCustoms() {
        return this.handleVisibleColumn();
      },
      handleVisibleColumn: function handleVisibleColumn(column, visible) {
        if (arguments.length) {
          column.visible = visible;
        } else {
          this.tableFullColumn.forEach(function (column) {
            column.visible = true;
          });
        }
    
        if (this.$toolbar) {
          this.$toolbar.updateSetting();
        }
    
        return this.$nextTick();
      },
    
      /**
       * 初始化加载显示/隐藏列
       * 对于异步更新的场景下可能会用到
       * @param {Array} customColumns 自定义列数组
       */
      reloadCustoms: function reloadCustoms(customColumns) {
        var _this11 = this;
    
        return this.$nextTick().then(function () {
          _this11.mergeCustomColumn(customColumns);
    
          return _this11.refreshColumn().then(function () {
            return _this11.tableFullColumn;
          });
        });
      },
    
      /**
       * 刷新列信息
       * 将固定的列左边、右边分别靠边
       * 如果使用了分组表头，固定列必须在左侧或者右侧
       */
      refreshColumn: function refreshColumn() {
        var _this12 = this;
    
        var isColspan;
        var letIndex = 0;
        var leftList = [];
        var leftStartIndex = null;
        var rightEndIndex = null;
        var centerList = [];
        var rightList = [];
        var tableFullColumn = this.tableFullColumn,
            isGroup = this.isGroup,
            columnStore = this.columnStore,
            scrollXStore = this.scrollXStore,
            optimizeOpts = this.optimizeOpts;
        var scrollX = optimizeOpts.scrollX; // 如果是分组表头，如果子列全部被隐藏，则根列也隐藏
    
        if (isGroup) {
          VueUtil.eachTree(this.collectColumn, function (column) {
            if (column.children && column.children.length) {
              column.visible = !!VueUtil.findTree(column.children, function (subColumn) {
                return subColumn.children && subColumn.children.length ? 0 : subColumn.visible;
              }, headerProps);
            }
          }, headerProps);
        } // 重新分配列
    
    
        tableFullColumn.filter(function (column) {
          return column.visible;
        }).forEach(function (column, columnIndex) {
          if (column.fixed === 'left') {
            if (leftStartIndex === null) {
              leftStartIndex = letIndex;
            }
    
            if (!isColspan) {
              if (columnIndex - letIndex !== 0) {
                isColspan = true;
              } else {
                letIndex++;
              }
            }
    
            leftList.push(column);
          } else if (column.fixed === 'right') {
            if (!isColspan) {
              if (rightEndIndex === null) {
                rightEndIndex = columnIndex;
              }
    
              if (columnIndex - rightEndIndex !== 0) {
                isColspan = true;
              } else {
                rightEndIndex++;
              }
            }
    
            rightList.push(column);
          } else {
            centerList.push(column);
          }
        });
        var visibleColumn = leftList.concat(centerList).concat(rightList);
        var scrollXLoad = scrollX && scrollX.gt && scrollX.gt < tableFullColumn.length;
        VueUtil.assign(columnStore, {
          leftList: leftList,
          centerList: centerList,
          rightList: rightList
        });
    
        if (scrollXLoad) {
          if (this.isGroup) {
            tools.UtilTools.warn('vue.xtable.error.scrollXNotGroup');
          } // if (this.resizable || visibleColumn.some(column => column.resizable)) {
          //   UtilTools.warn('vue.xtable.error.scrollXNotResizable')
          // }
    
    
          VueUtil.assign(scrollXStore, {
            startIndex: 0,
            visibleIndex: 0
          });
          visibleColumn = visibleColumn.slice(scrollXStore.startIndex, scrollXStore.startIndex + scrollXStore.renderSize);
        }
    
        this.scrollXLoad = scrollXLoad;
        this.tableColumn = visibleColumn;
        return this.$nextTick().then(function () {
          _this12.updateFooter();
    
          _this12.recalculate(true);
        });
      },
    
      /**
       * 指定列宽的列进行拆分
       */
      analyColumnWidth: function analyColumnWidth() {
        var columnWidth = this.columnWidth,
            columnMinWidth = this.columnMinWidth;
        var resizeList = [];
        var pxList = [];
        var pxMinList = [];
        var scaleList = [];
        var scaleMinList = [];
        var autoList = [];
        this.tableFullColumn.forEach(function (column) {
          if (columnWidth && !column.width) {
            column.width = columnWidth;
          }
    
          if (columnMinWidth && !column.minWidth) {
            column.minWidth = columnMinWidth;
          }
    
          if (column.visible) {
            if (column.resizeWidth) {
              resizeList.push(column);
            } else if (tools.DomTools.isPx(column.width)) {
              pxList.push(column);
            } else if (tools.DomTools.isScale(column.width)) {
              scaleList.push(column);
            } else if (tools.DomTools.isPx(column.minWidth)) {
              pxMinList.push(column);
            } else if (tools.DomTools.isScale(column.minWidth)) {
              scaleMinList.push(column);
            } else {
              autoList.push(column);
            }
          }
        });
        VueUtil.assign(this.columnStore, {
          resizeList: resizeList,
          pxList: pxList,
          pxMinList: pxMinList,
          scaleList: scaleList,
          scaleMinList: scaleMinList,
          autoList: autoList
        });
      },
    
      /**
       * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）
       */
      refreshScroll: function refreshScroll() {
        var _this13 = this;
    
        var lastScrollLeft = this.lastScrollLeft,
            lastScrollTop = this.lastScrollTop;
        this.clearScroll();
        return this.$nextTick().then(function () {
          if (lastScrollLeft || lastScrollTop) {
            // 重置最后滚动状态
            _this13.lastScrollLeft = 0;
            _this13.lastScrollTop = 0; // 还原滚动状态
    
            return _this13.scrollTo(lastScrollLeft, lastScrollTop);
          }
        });
      },
    
      /**
       * 计算单元格列宽，动态分配可用剩余空间
       * 支持 width=? width=?px width=?% min-width=? min-width=?px min-width=?%
       */
      recalculate: function recalculate(refull) {
        var _this14 = this;
    
        var $refs = this.$refs;
        var tableBody = $refs.tableBody,
            tableHeader = $refs.tableHeader,
            tableFooter = $refs.tableFooter;
        var bodyElem = tableBody ? tableBody.$el : null;
        var headerElem = tableHeader ? tableHeader.$el : null;
        var footerElem = tableFooter ? tableFooter.$el : null; // DomTools.addClass($el, 'is--recalculate')
    
        if (bodyElem) {
          this.autoCellWidth(headerElem, bodyElem, footerElem);
    
          if (refull === true) {
            // 初始化时需要在列计算之后再执行优化运算，达到最优显示效果
            return this.computeScrollLoad().then(function () {
              _this14.autoCellWidth(headerElem, bodyElem, footerElem);
    
              _this14.computeScrollLoad(); // DomTools.removeClass($el, 'is--recalculate')
    
            });
          }
        } // DomTools.removeClass($el, 'is--recalculate')
    
    
        return this.computeScrollLoad();
      },
      // 列宽计算
      autoCellWidth: function autoCellWidth(headerElem, bodyElem, footerElem) {
        var meanWidth;
        var tableWidth = 0;
        var minCellWidth = 40; // 列宽最少限制 40px
    
        var bodyWidth = bodyElem.clientWidth;
        var remainWidth = bodyWidth;
        var fit = this.fit,
            columnStore = this.columnStore;
        var resizeList = columnStore.resizeList,
            pxMinList = columnStore.pxMinList,
            pxList = columnStore.pxList,
            scaleList = columnStore.scaleList,
            scaleMinList = columnStore.scaleMinList,
            autoList = columnStore.autoList; // 最小宽
    
        pxMinList.forEach(function (column) {
          var minWidth = parseInt(column.minWidth);
          tableWidth += minWidth;
          column.renderWidth = minWidth;
        }); // 最小百分比
    
        meanWidth = remainWidth / 100;
        scaleMinList.forEach(function (column) {
          var scaleWidth = Math.floor(parseInt(column.minWidth) * meanWidth);
          tableWidth += scaleWidth;
          column.renderWidth = scaleWidth;
        }); // 固定百分比
    
        scaleList.forEach(function (column) {
          var scaleWidth = Math.floor(parseInt(column.width) * meanWidth);
          tableWidth += scaleWidth;
          column.renderWidth = scaleWidth;
        }); // 固定宽
    
        pxList.forEach(function (column) {
          var width = parseInt(column.width);
          tableWidth += width;
          column.renderWidth = width;
        }); // 调整了列宽
    
        resizeList.forEach(function (column) {
          var width = parseInt(column.resizeWidth);
          tableWidth += width;
          column.renderWidth = width;
        });
        remainWidth -= tableWidth;
        meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoList.length)) : 0;
    
        if (fit) {
          if (remainWidth > 0) {
            scaleMinList.concat(pxMinList).forEach(function (column) {
              tableWidth += meanWidth;
              column.renderWidth += meanWidth;
            });
          }
        } else {
          meanWidth = minCellWidth;
        } // 自适应
    
    
        autoList.forEach(function (column, index) {
          var width = Math.max(meanWidth, minCellWidth);
          column.renderWidth = width;
          tableWidth += width;
    
          if (fit && index === autoList.length - 1) {
            // 如果所有列足够放的情况下，修补列之间的误差
            var odiffer = bodyWidth - tableWidth;
    
            if (odiffer > 0) {
              column.renderWidth += odiffer;
              tableWidth = bodyWidth;
            }
          }
        });
        var tableHeight = bodyElem.offsetHeight;
        var overflowY = bodyElem.scrollHeight > bodyElem.clientHeight;
        this.scrollbarWidth = overflowY ? bodyElem.offsetWidth - bodyWidth : 0;
        this.overflowY = overflowY;
        this.tableWidth = tableWidth;
        this.tableHeight = tableHeight;
        this.parentHeight = this.getParentHeight();
    
        if (headerElem) {
          this.headerHeight = headerElem.offsetHeight; // 检测是否同步滚动
    
          if (headerElem.scrollLeft !== bodyElem.scrollLeft) {
            headerElem.scrollLeft = bodyElem.scrollLeft;
          }
        }
    
        if (footerElem) {
          var footerHeight = footerElem.offsetHeight;
          this.scrollbarHeight = Math.max(footerHeight - footerElem.clientHeight, 0);
          this.overflowX = tableWidth > footerElem.clientWidth;
          this.footerHeight = footerHeight;
        } else {
          this.scrollbarHeight = Math.max(tableHeight - bodyElem.clientHeight, 0);
          this.overflowX = tableWidth > bodyWidth;
        }
    
        if (this.overflowX) {
          this.checkScrolling();
        }
      },
    
      /**
       * 手动重置列宽拖动的操作，还原到初始状态
       * 如果已关联工具栏，则会同步更新
       */
      resetResizable: function resetResizable() {
        this.visibleColumn.forEach(function (column) {
          column.resizeWidth = 0;
        });
    
        if (this.$toolbar) {
          this.$toolbar.resetResizable();
        }
    
        this.analyColumnWidth();
        return this.recalculate(true);
      },
    
      /**
       * 放弃 vue 的双向 dom 绑定，使用原生的方式更新 Dom，性能翻倍提升
       */
      updateStyle: function updateStyle() {
        var $refs = this.$refs,
            fullColumnIdData = this.fullColumnIdData,
            maxHeight = this.maxHeight,
            height = this.height,
            parentHeight = this.parentHeight,
            border = this.border,
            tableColumn = this.tableColumn,
            headerHeight = this.headerHeight,
            allColumnHeaderOverflow = this.showHeaderOverflow,
            showFooter = this.showFooter,
            allColumnOverflow = this.showOverflow,
            footerHeight = this.footerHeight,
            tableHeight = this.tableHeight,
            tableWidth = this.tableWidth,
            scrollbarHeight = this.scrollbarHeight,
            scrollbarWidth = this.scrollbarWidth,
            scrollXLoad = this.scrollXLoad,
            scrollYLoad = this.scrollYLoad,
            columnStore = this.columnStore,
            elemStore = this.elemStore,
            editStore = this.editStore,
            currentRow = this.currentRow,
            mouseConfig = this.mouseConfig;
        var containerList = ['main', 'left', 'right'];
        var customHeight = height === 'auto' ? parentHeight : (tools.DomTools.isScale(height) ? Math.floor(parseInt(height) / 100 * parentHeight) : (parseFloat(height)) - this.getExcludeHeight() || 0);
    
        if (showFooter) {
          customHeight += scrollbarHeight + 1;
        }
    
        containerList.forEach(function (name, index) {
          var fixedType = index > 0 ? name : '';
          var layoutList = ['header', 'body', 'footer'];
          var fixedColumn = columnStore[''.concat(fixedType, 'List')];
          var fixedWrapperElem = $refs[''.concat(fixedType, 'Container')];
          layoutList.forEach(function (layout) {
            var wrapperElem = elemStore[''.concat(name, '-').concat(layout, '-wrapper')];
            var tableElem = elemStore[''.concat(name, '-').concat(layout, '-table')];
    
            if (layout === 'header') {
              // 表头体样式处理
              // 横向滚动渲染
              var tWidth = tableWidth;
    
              if (scrollXLoad) {
                if (fixedType) {
                  tableColumn = fixedColumn;
                }
    
                tWidth = tableColumn.reduce(function (previous, column) {
                  return previous + column.renderWidth;
                }, 0);
              }
    
              if (tableElem) {
                tableElem.style.width = tWidth === null ? tWidth : ''.concat(tWidth + scrollbarWidth, 'px');
              }
    
              var repairElem = elemStore[''.concat(name, '-').concat(layout, '-repair')];
    
              if (repairElem) {
                repairElem.style.width = ''.concat(tableWidth, 'px');
              } // let listElem = elemStore[`${name}-${layout}-list`]
              // if (listElem) {
              //   VueUtil.loop(listElem.querySelectorAll(`.col--gutter`), thElem => {
              //     thElem.style.width = `${scrollbarWidth}px`
              //   })
              // }
    
            } else if (layout === 'body') {
              var emptyBlockElem = elemStore[''.concat(name, '-').concat(layout, '-emptyBlock')];
    
              if (wrapperElem) {
                if (customHeight > 0) {
                  wrapperElem.style.height = ''.concat(fixedType ? (customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) - (showFooter ? 0 : scrollbarHeight) : customHeight - headerHeight - footerHeight, 'px');
                } else if (maxHeight) {
                  maxHeight = tools.DomTools.isScale(maxHeight) ? Math.floor(parseInt(maxHeight) / 100 * parentHeight) : (parseFloat(maxHeight) || 0);
                  wrapperElem.style.maxHeight = ''.concat(fixedType ? maxHeight - headerHeight - (showFooter ? 0 : scrollbarHeight) : maxHeight - headerHeight, 'px');
                }
              } // 如果是固定列
    
    
              if (fixedWrapperElem) {
                var isRightFixed = fixedType === 'right';
                var _fixedColumn = columnStore[''.concat(fixedType, 'List')];
                wrapperElem.style.top = ''.concat(headerHeight, 'px');
                fixedWrapperElem.style.height = ''.concat((customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) + headerHeight + footerHeight - scrollbarHeight * (showFooter ? 2 : 1), 'px');
                fixedWrapperElem.style.width = ''.concat(_fixedColumn.reduce(function (previous, column) {
                  return previous + column.renderWidth;
                }, isRightFixed ? scrollbarWidth : 0), 'px');
              }
    
              var _tWidth = tableWidth; // 如果是固定列与设置了超出隐藏
    
              if (fixedType && allColumnOverflow) {
                tableColumn = fixedColumn;
                _tWidth = tableColumn.reduce(function (previous, column) {
                  return previous + column.renderWidth;
                }, 0);
              } else if (scrollXLoad) {
                if (fixedType) {
                  tableColumn = fixedColumn;
                }
    
                _tWidth = tableColumn.reduce(function (previous, column) {
                  return previous + column.renderWidth;
                }, 0);
              }
    
              if (tableElem) {
                tableElem.style.width = _tWidth ? ''.concat(_tWidth, 'px') : _tWidth; // 兼容性处理
    
                tableElem.style.paddingRight = scrollbarWidth && fixedType && (VueUtil.isFirefox || VueUtil.isSafari) ? ''.concat(scrollbarWidth, 'px') : '';
              }
    
              if (emptyBlockElem) {
                emptyBlockElem.style.width = _tWidth ? ''.concat(_tWidth, 'px') : _tWidth;
              }
            } else if (layout === 'footer') {
              // 如果是使用优化模式
              var _tWidth2 = tableWidth;
    
              if (fixedType && allColumnOverflow) {
                tableColumn = fixedColumn;
                _tWidth2 = tableColumn.reduce(function (previous, column) {
                  return previous + column.renderWidth;
                }, 0);
              } else if (scrollXLoad) {
                if (fixedType) {
                  tableColumn = fixedColumn;
                }
    
                _tWidth2 = tableColumn.reduce(function (previous, column) {
                  return previous + column.renderWidth;
                }, 0);
              }
    
              if (wrapperElem) {
                // 如果是固定列
                if (fixedWrapperElem) {
                  wrapperElem.style.top = ''.concat(customHeight > 0 ? customHeight - footerHeight : tableHeight + headerHeight, 'px');
                }
    
                wrapperElem.style.marginTop = ''.concat(-scrollbarHeight - 1, 'px');
              }
    
              if (tableElem) {
                tableElem.style.width = _tWidth2 === null ? _tWidth2 : ''.concat(_tWidth2 + scrollbarWidth, 'px');
              } // let listElem = elemStore[`${name}-${layout}-list`]
              // if (listElem) {
              //   VueUtil.loop(listElem.querySelectorAll(`.col--gutter`), thElem => {
              //     thElem.style.width = `${scrollbarWidth}px`
              //   })
              // }
    
            }
    
            var colgroupElem = elemStore[''.concat(name, '-').concat(layout, '-colgroup')];
    
            if (colgroupElem) {
              VueUtil.loop(colgroupElem.children, function (colElem) {
                var colid = colElem.getAttribute('name');
    
                if (colid === 'col_gutter') {
                  colElem.width = ''.concat(scrollbarWidth || '');
                }
    
                if (fullColumnIdData[colid]) {
                  var column = fullColumnIdData[colid].column;
                  var showHeaderOverflow = column.showHeaderOverflow,
                      showOverflow = column.showOverflow,
                      renderWidth = column.renderWidth;
                  var cellOverflow;
                  colElem.width = ''.concat(column.renderWidth || '');
    
                  if (layout === 'header') {
                    cellOverflow = VueUtil.isUndefined(showHeaderOverflow) || VueUtil.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
                  } else {
                    cellOverflow = VueUtil.isUndefined(showOverflow) || VueUtil.isNull(showOverflow) ? allColumnOverflow : showOverflow;
                  }
    
                  var showEllipsis = cellOverflow === 'ellipsis';
                  var showTitle = cellOverflow === 'title';
                  var showTooltip = cellOverflow === true || cellOverflow === 'tooltip';
                  var hasEllipsis = showTitle || showTooltip || showEllipsis;
                  var listElem = elemStore[''.concat(name, '-').concat(layout, '-list')]; // 滚动的渲染不支持动态行高
    
                  if ((scrollXLoad || scrollYLoad) && !hasEllipsis) {
                    hasEllipsis = true;
                  }
    
                  if (listElem) {
                    VueUtil.loop(listElem.querySelectorAll('.'.concat(column.id)), function (thElem) {
                      var cellElem = thElem.querySelector('.vue-xtable-cell');
    
                      if (cellElem) {
                        cellElem.style.width = ''.concat(border ? renderWidth - 1 : renderWidth, 'px');
                      }
                    });
                  }
                }
              });
            }
          });
        });
    
        if (currentRow) {
          this.setCurrentRow(currentRow);
        }
    
        if (mouseConfig && mouseConfig.selected && editStore.selected.row && editStore.selected.column) {
          this.addColSdCls();
        }
    
        return this.$nextTick();
      },
    
      /**
       * 处理固定列的显示状态
       */
      checkScrolling: function checkScrolling() {
        var _this$$refs = this.$refs,
            tableBody = _this$$refs.tableBody,
            leftContainer = _this$$refs.leftContainer,
            rightContainer = _this$$refs.rightContainer;
        var bodyElem = tableBody ? tableBody.$el : null;
    
        if (bodyElem) {
          if (leftContainer) {
            tools.DomTools[bodyElem.scrollLeft > 0 ? 'addClass' : 'removeClass'](leftContainer, 'scrolling--middle');
          }
    
          if (rightContainer) {
            tools.DomTools[bodyElem.clientWidth < bodyElem.scrollWidth - bodyElem.scrollLeft ? 'addClass' : 'removeClass'](rightContainer, 'scrolling--middle');
          }
        }
      },
      preventEvent: function preventEvent(evnt, type, args, next, end) {
        var _this15 = this;
    
        var evntList = baseTable.interceptor.get(type);
    
        var rest;
    
        if (!evntList.some(function (func) {
          return func(args, evnt, _this15) === false;
        })) {
          if (next) {
            rest = next();
          }
        }
    
        if (end) {
          end();
        }
    
        return rest;
      },
    
      /**
       * 全局按下事件处理
       */
      handleGlobalMousedownEvent: function handleGlobalMousedownEvent(evnt) {
        var _this16 = this;
    
        var $el = this.$el,
            $refs = this.$refs,
            editStore = this.editStore,
            ctxMenuStore = this.ctxMenuStore,
            _this$editConfig = this.editConfig,
            editConfig = _this$editConfig === void 0 ? {} : _this$editConfig,
            filterStore = this.filterStore,
            getEventTargetNode = this.getEventTargetNode,
            getRowNode = this.getRowNode;
        var actived = editStore.actived;
        var filterWrapper = $refs.filterWrapper,
            validTip = $refs.validTip;
    
        if (filterWrapper) {
          if (getEventTargetNode(evnt, $el, 'vue-xtable-filter-wrapper').flag) {// 如果点击了筛选按钮
          } else if (getEventTargetNode(evnt, filterWrapper.$el).flag) {// 如果点击筛选容器
          } else {
            this.preventEvent(evnt, 'event.clearFilter', filterStore.args, this.closeFilter);
          }
        } // 如果已激活了编辑状态
    
    
        if (actived.row) {
          if (!(editConfig.autoClear === false)) {
            if (validTip && getEventTargetNode(evnt, validTip.$el).flag) {// 如果是激活状态，且点击了校验提示框
            } else if (!this.lastCallTime || this.lastCallTime + 50 < Date.now()) {
              // 如果手动调用了激活单元格，避免触发源被移除后导致重复关闭
              this.preventEvent(evnt, 'event.clearActived', actived.args, function () {
                var isClear;
    
                if (editConfig.mode === 'row') {
                  var rowNode = getEventTargetNode(evnt, $el, 'vue-xtable-body--row'); // row 方式，如果点击了不同行
    
                  isClear = rowNode.flag ? getRowNode(rowNode.targetElem).item !== getRowNode(actived.args.cell.parentNode).item : 0;
                } else {
                  // cell 方式，如果是非编辑列
                  isClear = !getEventTargetNode(evnt, $el, 'col--edit', true).flag;
                }
    
                if (isClear || // 如果点击了当前表格之外
                !getEventTargetNode(evnt, $el, undefined, true).flag) {
                  setTimeout(function () {
                    return _this16.clearActived(evnt);
                  });
                }
              });
            }
          }
        } // 如果配置了快捷菜单且，点击了其他地方则关闭
    
    
        if (ctxMenuStore.visible && this.$refs.ctxWrapper && !getEventTargetNode(evnt, this.$refs.ctxWrapper.$el).flag) {
          this.closeMenu();
        } // 最后激活的表格
    
        this.isActivated = getEventTargetNode(evnt, this.$el).flag;
      },
    
      /**
       * 窗口失焦事件处理
       */
      handleGlobalBlurEvent: function handleGlobalBlurEvent(evnt) {
        this.closeFilter();
        this.closeMenu();
      },
    
      /**
       * 全局滚动事件
       */
      handleGlobalMousewheelEvent: function handleGlobalMousewheelEvent(evnt) {
        this.clostTooltip();
        this.closeMenu();
      },
    
      /**
       * 全局键盘事件
       */
      handleGlobalKeydownEvent: function handleGlobalKeydownEvent(evnt) {
        var _this17 = this;
    
        // 该行为只对当前激活的表格有效
        if (this.isActivated) {
          this.preventEvent(evnt, 'event.keydown', {
            $table: this
          }, function () {
            var isCtxMenu = _this17.isCtxMenu,
                ctxMenuStore = _this17.ctxMenuStore,
                editStore = _this17.editStore,
                _this17$mouseConfig = _this17.mouseConfig,
                mouseConfig = _this17$mouseConfig === void 0 ? {} : _this17$mouseConfig,
                _this17$keyboardConfi = _this17.keyboardConfig,
                keyboardConfig = _this17$keyboardConfi === void 0 ? {} : _this17$keyboardConfi,
                treeConfig = _this17.treeConfig,
                highlightCurrentRow = _this17.highlightCurrentRow,
                currentRow = _this17.currentRow;
            var selected = editStore.selected,
                actived = editStore.actived;
            var keyCode = evnt.keyCode;
            var isBack = keyCode === 8;
            var isTab = keyCode === 9;
            var isEnter = keyCode === 13;
            var isEsc = keyCode === 27;
            var isSpacebar = keyCode === 32;
            var isLeftArrow = keyCode === 37;
            var isUpArrow = keyCode === 38;
            var isRightArrow = keyCode === 39;
            var isDwArrow = keyCode === 40;
            var isDel = keyCode === 46;
            var isA = keyCode === 65;
            var isC = keyCode === 67;
            var isX = keyCode === 88;
            var isF2 = keyCode === 113;
            var isCtrlKey = evnt.ctrlKey;
            var isShiftKey = evnt.shiftKey;
            var operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
            var operCtxMenu = isCtxMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);
            var params;
    
            if (isEsc) {
              // 如果按下了 Esc 键，关闭快捷菜单、筛选
              _this17.closeMenu();
    
              _this17.closeFilter(); // 如果是激活编辑状态，则取消编辑
    
              var activedRow = actived.row;
              if (activedRow) {
                params = actived.args;
                _this17.clearActived(evnt); // 如果配置了选中功能，则为选中状态
                if (_this17.currentActiveRowOldValue !== null) {
                  VueUtil.destructuring(activedRow, _this17.currentActiveRowOldValue);
                }
    
    
                if (mouseConfig.selected) {
                  _this17.$nextTick(function () {
                    return _this17.handleSelected(params, evnt);
                  });
                }
              }
            } else if (isSpacebar && (keyboardConfig.isArrow || keyboardConfig.isTab) && selected.row && selected.column && (selected.column.type === 'checkbox' || selected.column.type === 'selection' || selected.column.type === 'radio')) {
              // 在 v3.0 中废弃 type=selection
              // 空格键支持选中复选列
              evnt.preventDefault(); // 在 v3.0 中废弃 type=selection
    
              if (selected.column.type === 'checkbox' || selected.column.type === 'selection') {
                _this17.handleToggleCheckRowEvent(selected.args, evnt);
              } else {
                _this17.triggerRadioRowEvent(evnt, selected.args);
              }
            } else if (isEnter && (keyboardConfig.isArrow || keyboardConfig.isTab) && (selected.row || actived.row || treeConfig && highlightCurrentRow && currentRow)) {
              // 如果是激活状态，退则出到下一行
              if (selected.row || actived.row) {
                _this17.moveSelected(selected.row ? selected.args : actived.args, isLeftArrow, isUpArrow, isRightArrow, true, evnt);
              } else if (treeConfig && highlightCurrentRow && currentRow) {
                // 如果是树形表格当前行回车移动到子节点
                var childrens = currentRow[treeConfig.children];
    
                if (childrens && childrens.length) {
                  evnt.preventDefault();
                  var targetRow = childrens[0];
                  params = {
                    $table: _this17,
                    row: targetRow
                  };
    
                  _this17.setTreeExpansion(currentRow, true).then(function () {
                    return _this17.scrollToRow(targetRow);
                  }).then(function () {
                    return _this17.triggerCurrentRowEvent(evnt, params);
                  });
                }
              }
            } else if (operCtxMenu) {
              // 如果配置了右键菜单; 支持方向键操作、回车
              evnt.preventDefault();
    
              if (ctxMenuStore.showChild && tools.UtilTools.hasChildrenList(ctxMenuStore.selected)) {
                _this17.moveCtxMenu(evnt, keyCode, ctxMenuStore, 'selectChild', 37, false, ctxMenuStore.selected.children);
              } else {
                _this17.moveCtxMenu(evnt, keyCode, ctxMenuStore, 'selected', 39, true, _this17.ctxMenuList);
              }
            } else if (isF2) {
              // 如果按下了 F2 键
              if (selected.row && selected.column) {
                evnt.preventDefault();
    
                _this17.handleActived(selected.args, evnt);
              }
            } else if (operArrow && keyboardConfig.isArrow) {
              // 如果按下了方向键
              if (selected.row && selected.column) {
                _this17.moveSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);
              } else if ((isUpArrow || isDwArrow) && highlightCurrentRow && currentRow) {
                // 当前行按键上下移动
                _this17.moveCurrentRow(isUpArrow, isDwArrow, evnt);
              }
            } else if (isTab && keyboardConfig.isTab) {
              // 如果按下了 Tab 键切换
              if (selected.row || selected.column) {
                _this17.moveTabSelected(selected.args, isShiftKey, evnt);
              } else if (actived.row || actived.column) {
                _this17.moveTabSelected(actived.args, isShiftKey, evnt);
              }
            } else if (isDel || (treeConfig && highlightCurrentRow && currentRow ? isBack && keyboardConfig.isArrow : isBack)) {
              // 如果是删除键
              if (keyboardConfig.isDel && (selected.row || selected.column)) {
                tools.UtilTools.setCellValue(selected.row, selected.column, null);
    
                if (isBack) {
                  _this17.handleActived(selected.args, evnt);
                }
              } else if (isBack && keyboardConfig.isArrow && treeConfig && highlightCurrentRow && currentRow) {
                // 如果树形表格回退键关闭当前行返回父节点
                var findTreeData = VueUtil.findTree(_this17.afterFullData, function (item) {
                  return item === currentRow;
                }, treeConfig),
                    parentRow = findTreeData.parent;
    
                if (parentRow) {
                  evnt.preventDefault();
                  params = {
                    $table: _this17,
                    row: parentRow
                  };
    
                  _this17.setTreeExpansion(parentRow, false).then(function () {
                    return _this17.scrollToRow(parentRow);
                  }).then(function () {
                    return _this17.triggerCurrentRowEvent(evnt, params);
                  });
                }
              }
            } else if (keyboardConfig.isCut && isCtrlKey && (isA || isX || isC)) {
              // 如果开启复制功能
              if (isA) {
                _this17.handleAllChecked(evnt);
              } else if (isX || isC) {
                if (!editStore.actived.column && !editStore.actived.row) {
                  _this17.handleCopyed(isX, evnt);
                }
              }
            } else if (keyboardConfig.isEdit && !isCtrlKey && (keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222 || keyCode === 32)) {
              // 如果是按下非功能键之外允许直接编辑
              if (selected.column && selected.row && selected.column.editRender) {
                if (!keyboardConfig.editMethod || !(keyboardConfig.editMethod(selected.args, evnt) === false)) {
                  // tools.UtilTools.setCellValue(selected.row, selected.column, null);
    
                  _this17.handleActived(selected.args, evnt, selected.column);
                }
              }
            }
          });
        }
      },

      handleGlobalPaste: function(evnt) {
        if (this.isActivated) {
          this.handlePaste(evnt);
        }
      },
      handleGlobalResizeEvent: function handleGlobalResizeEvent() {
        this.recalculate();
      },
      handleTooltipLeaveEvent: function handleTooltipLeaveEvent(evnt) {
        var _this18 = this;
    
        var _this$tooltipConfig = this.tooltipConfig,
            tooltipConfig = _this$tooltipConfig === void 0 ? {} : _this$tooltipConfig;
        setTimeout(function () {
          if (!_this18.tooltipActive) {
            _this18.clostTooltip();
          }
        }, tooltipConfig.leaveDelay || GlobalConfig.tooltip.leaveDelay);
      },
      handleTargetEnterEvent: function handleTargetEnterEvent(evnt) {
        clearTimeout(this.tooltipTimeout);
        this.tooltipActive = true;
        this.clostTooltip();
      },
      handleTargetLeaveEvent: function handleTargetLeaveEvent(evnt) {
        var _this19 = this;
    
        var _this$tooltipConfig2 = this.tooltipConfig,
            tooltipConfig = _this$tooltipConfig2 === void 0 ? {} : _this$tooltipConfig2;
        this.tooltipActive = false;
    
        if (tooltipConfig.enterable) {
          this.tooltipTimeout = setTimeout(function () {
            if (!_this19.$refs.tooltip.isHover) {
              _this19.clostTooltip();
            }
          }, tooltipConfig.leaveDelay || GlobalConfig.tooltip.leaveDelay);
        } else {
          this.clostTooltip();
        }
      },
    
      /**
       * 触发表头 tooltip 事件
       */
      triggerHeaderTooltipEvent: function triggerHeaderTooltipEvent(evnt, params) {
        var tooltipStore = this.tooltipStore;
        var column = params.column;
        this.handleTargetEnterEvent();
    
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          // 在 v3.0 中废弃 label
          this.handleTooltip(evnt, column);
        }
      },
    
      /**
       * 触发表尾 tooltip 事件
       */
      triggerFooterTooltipEvent: function triggerFooterTooltipEvent(evnt, params) {
        var column = params.column;
        var tooltipStore = this.tooltipStore;
        this.handleTargetEnterEvent();
    
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          this.handleTooltip(evnt, column);
        }
      },
    
      /**
       * 触发 tooltip 事件
       */
      triggerTooltipEvent: function triggerTooltipEvent(evnt, params) {
        var editConfig = this.editConfig,
            editStore = this.editStore,
            tooltipStore = this.tooltipStore;
        var actived = editStore.actived;
        var row = params.row,
            column = params.column;
        this.handleTargetEnterEvent();
    
        if (editConfig) {
          if (editConfig.mode === 'row' && actived.row === row || actived.row === row && actived.column === column) {
            return;
          }
        }
    
        if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {
          this.handleTooltip(evnt, column, row);
        }
      },
    
      /**
       * 处理显示 tooltip
       * @param {Event} evnt 事件
       * @param {ColumnConfig} column 列配置
       * @param {Row} row 行对象
       */
      handleTooltip: function handleTooltip(evnt, column, row) {
        var cell = evnt.currentTarget;
        var tooltip = this.$refs.tooltip;
        var wrapperElem = cell.children[0];
        var content = cell.innerText;
    
        if (content && wrapperElem.scrollWidth > wrapperElem.clientWidth) {
          VueUtil.assign(this.tooltipStore, {
            row: row,
            column: column,
            visible: true
          });
    
          if (tooltip) {
            tooltip.toVisible(cell, tools.UtilTools.formatText(content));
          }
        }
    
        return this.$nextTick();
      },
    
      /**
       * 关闭 tooltip
       */
      clostTooltip: function clostTooltip() {
        var tooltip = this.$refs.tooltip;
        VueUtil.assign(this.tooltipStore, {
          row: null,
          column: null,
          content: null,
          visible: false
        });
    
        if (tooltip) {
          tooltip.close();
        }
    
        return this.$nextTick();
      },
    
      /**
       * 处理默认勾选
       */
      handleSelectionDefChecked: function handleSelectionDefChecked() {
        var fullDataRowIdData = this.fullDataRowIdData; // 在 v3.0 中废弃 selectConfig
    
        var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
        var checkAll = checkboxConfig.checkAll,
            checkRowKeys = checkboxConfig.checkRowKeys;
    
        if (checkAll) {
          this.setAllSelection(true);
        } else if (checkRowKeys) {
          var defSelection = [];
          checkRowKeys.forEach(function (rowid) {
            if (fullDataRowIdData[rowid]) {
              defSelection.push(fullDataRowIdData[rowid].row);
            }
          });
          this.setSelection(defSelection, true);
        }
      },
    
      /**
       * 用于多选行，设置行为选中状态，第二个参数为选中与否
       * @param {Array/Row} rows 行数据
       * @param {Boolean} value 是否选中
       */
      setSelection: function setSelection(rows, value) {
        var _this20 = this;
    
        if (rows && !VueUtil.isArray(rows)) {
          rows = [rows];
        }
    
        rows.forEach(function (row) {
          return _this20.handleSelectRow({
            row: row
          }, !!value);
        });
        return this.$nextTick();
      },
    
      /**
       * 多选，行选中事件
       * value 选中true 不选false 不确定-1
       */
      handleSelectRow: function handleSelectRow(_ref3, value) {
        var row = _ref3.row;
        var selection = this.selection,
            tableFullData = this.tableFullData,
            treeConfig = this.treeConfig,
            treeIndeterminates = this.treeIndeterminates; // 在 v3.0 中废弃 selectConfig
    
        var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
        var property = checkboxConfig.checkField,
            checkStrictly = checkboxConfig.checkStrictly,
            checkMethod = checkboxConfig.checkMethod;
    
        if (property) {
          if (treeConfig && !checkStrictly) {
            if (value === -1) {
              treeIndeterminates.push(row);
              VueUtil.set(row, property, false);
            } else {
              // 更新子节点状态
              VueUtil.eachTree([row], function (item, $rowIndex) {
                if (row === item || !checkMethod || checkMethod({
                  row: item,
                  $rowIndex: $rowIndex
                })) {
                  VueUtil.set(item, property, value);
                }
              }, treeConfig);
              VueUtil.remove(treeIndeterminates, function (item) {
                return item === row;
              });
            } // 如果存在父节点，更新父节点状态
    
    
            var matchObj = VueUtil.findTree(tableFullData, function (item) {
              return item === row;
            }, treeConfig);
    
            if (matchObj && matchObj.parent) {
              var parentStatus;
              var vItems = checkMethod ? matchObj.items.filter(function (item, $rowIndex) {
                return checkMethod({
                  row: item,
                  $rowIndex: $rowIndex
                });
              }) : matchObj.items;
              var indeterminatesItem = VueUtil.find(matchObj.items, function (item) {
                return treeIndeterminates.indexOf(item) > -1;
              });
    
              if (indeterminatesItem) {
                parentStatus = -1;
              } else {
                var selectItems = matchObj.items.filter(function (item) {
                  return VueUtil.get(item, property);
                });
                parentStatus = selectItems.filter(function (item) {
                  return vItems.indexOf(item) > -1;
                }).length === vItems.length ? true : selectItems.length || value === -1 ? -1 : false;
              }
    
              return this.handleSelectRow({
                row: matchObj.parent
              }, parentStatus);
            }
          } else {
            VueUtil.set(row, property, value);
          }
        } else {
          if (treeConfig && !checkStrictly) {
            if (value === -1) {
              treeIndeterminates.push(row);
              VueUtil.remove(selection, function (item) {
                return item === row;
              });
            } else {
              // 更新子节点状态
              VueUtil.eachTree([row], function (item, $rowIndex) {
                if (row === item || !checkMethod || checkMethod({
                  row: item,
                  $rowIndex: $rowIndex
                })) {
                  if (value) {
                    selection.push(item);
                  } else {
                    VueUtil.remove(selection, function (select) {
                      return select === item;
                    });
                  }
                }
              }, treeConfig);
              VueUtil.remove(treeIndeterminates, function (item) {
                return item === row;
              });
            } // 如果存在父节点，更新父节点状态
    
    
            var _matchObj = VueUtil.findTree(tableFullData, function (item) {
              return item === row;
            }, treeConfig);
    
            if (_matchObj && _matchObj.parent) {
              var _parentStatus;
    
              var _vItems = checkMethod ? _matchObj.items.filter(function (item, $rowIndex) {
                return checkMethod({
                  row: item,
                  $rowIndex: $rowIndex
                });
              }) : _matchObj.items;
    
              var _indeterminatesItem = VueUtil.find(_matchObj.items, function (item) {
                return treeIndeterminates.indexOf(item) > -1;
              });
    
              if (_indeterminatesItem) {
                _parentStatus = -1;
              } else {
                var _selectItems = _matchObj.items.filter(function (item) {
                  return selection.indexOf(item) > -1;
                });
    
                _parentStatus = _selectItems.filter(function (item) {
                  return _vItems.indexOf(item) > -1;
                }).length === _vItems.length ? true : _selectItems.length || value === -1 ? -1 : false;
              }
    
              return this.handleSelectRow({
                row: _matchObj.parent
              }, _parentStatus);
            }
          } else {
            if (value) {
              if (selection.indexOf(row) === -1) {
                selection.push(row);
              }
            } else {
              VueUtil.remove(selection, function (item) {
                return item === row;
              });
            }
          }
        }
    
        this.checkSelectionStatus();
      },
      handleToggleCheckRowEvent: function handleToggleCheckRowEvent(params, evnt) {
        var selection = this.selection; // 在 v3.0 中废弃 selectConfig
    
        var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
        var property = checkboxConfig.checkField;
        var row = params.row;
        var value = property ? !VueUtil.get(row, property) : selection.indexOf(row) === -1;
    
        if (evnt) {
          this.triggerCheckRowEvent(evnt, params, value);
        } else {
          this.handleSelectRow(params, value);
        }
      },
      triggerCheckRowEvent: function triggerCheckRowEvent(evnt, params, value) {
        // 在 v3.0 中废弃 selectConfig
        var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
        var checkMethod = checkboxConfig.checkMethod;
    
        if (!checkMethod || checkMethod({
          row: params.row,
          rowIndex: params.rowIndex,
          $rowIndex: params.$rowIndex
        })) {
          this.handleSelectRow(params, value);
    
          tools.UtilTools.emitEvent(this, 'select-change', [VueUtil.assign({
            selection: this.getSelectRecords(),
            reserves: this.getSelectReserveRecords(),
            checked: value,
            $table: this
          }, params), evnt]);
        }
      },
    
      /**
       * 多选，切换某一行的选中状态
       */
      toggleRowSelection: function toggleRowSelection(row) {
        this.handleToggleCheckRowEvent({
          row: row
        });
        return this.$nextTick();
      },
    
      /**
       * 用于多选行，设置所有行的选中状态
       * @param {Boolean} value 是否选中
       */
      setAllSelection: function setAllSelection(value) {
        var tableFullData = this.tableFullData,
            treeConfig = this.treeConfig,
            selection = this.selection; // 在 v3.0 中废弃 selectConfig
    
        var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
        var property = checkboxConfig.checkField,
            reserve = checkboxConfig.reserve,
            checkStrictly = checkboxConfig.checkStrictly,
            checkMethod = checkboxConfig.checkMethod;
        var selectRows = []; // 包含新增的数据
    
        if (!checkStrictly) {
          if (property) {
            var indexKey = ''.concat(treeConfig ? '$' : '', 'rowIndex');
    
            var setValFn = function setValFn(row, rowIndex) {
              var _checkMethod;
    
              if (!checkMethod || checkMethod((_checkMethod = {
                row: row
              }, tools.UtilTools.defineProperty(_checkMethod, indexKey, rowIndex), tools.UtilTools.defineProperty(_checkMethod, '$rowIndex', rowIndex), _checkMethod))) {
                VueUtil.set(row, property, value);
              }
            };
    
            var clearValFn = function clearValFn(row, rowIndex) {
              var _checkMethod2;
    
              if (!checkMethod || (checkMethod((_checkMethod2 = {
                row: row
              }, tools.UtilTools.defineProperty(_checkMethod2, indexKey, rowIndex), tools.UtilTools.defineProperty(_checkMethod2, '$rowIndex', rowIndex), _checkMethod2)) ? 0 : selection.indexOf(row) > -1)) {
                VueUtil.set(row, property, value);
              }
            };
    
            if (treeConfig) {
              VueUtil.eachTree(tableFullData, value ? setValFn : clearValFn, treeConfig);
            } else {
              tableFullData.forEach(value ? setValFn : clearValFn);
            }
          } else {
            if (treeConfig) {
              if (value) {
                VueUtil.eachTree(tableFullData, function (row, $rowIndex) {
                  if (!checkMethod || checkMethod({
                    row: row,
                    $rowIndex: $rowIndex
                  })) {
                    selectRows.push(row);
                  }
                }, treeConfig);
              } else {
                if (checkMethod) {
                  VueUtil.eachTree(tableFullData, function (row, $rowIndex) {
                    if (checkMethod({
                      row: row,
                      $rowIndex: $rowIndex
                    }) ? 0 : selection.indexOf(row) > -1) {
                      selectRows.push(row);
                    }
                  }, treeConfig);
                }
              }
            } else {
              if (value) {
                if (checkMethod) {
                  selectRows = tableFullData.filter(function (row, rowIndex) {
                    return selection.indexOf(row) > -1 || checkMethod({
                      row: row,
                      rowIndex: rowIndex,
                      $rowIndex: rowIndex
                    });
                  });
                } else {
                  selectRows = tableFullData.slice(0);
                }
              } else {
                if (checkMethod) {
                  selectRows = tableFullData.filter(function (row, rowIndex) {
                    return checkMethod({
                      row: row,
                      rowIndex: rowIndex,
                      $rowIndex: rowIndex
                    }) ? 0 : selection.indexOf(row) > -1;
                  });
                }
              }
            }
          }
    
          this.selection = value && reserve ? selection.concat(selectRows.filter(function (row) {
            return selection.indexOf(row) === -1;
          })) : selectRows;
        }
    
        this.treeIndeterminates = [];
        this.checkSelectionStatus();
      },
      checkSelectionStatus: function checkSelectionStatus() {
        var tableFullData = this.tableFullData,
            editStore = this.editStore,
            selection = this.selection,
            treeIndeterminates = this.treeIndeterminates; // 在 v3.0 中废弃 selectConfig
    
        var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
        var property = checkboxConfig.checkField,
            checkStrictly = checkboxConfig.checkStrictly,
            checkMethod = checkboxConfig.checkMethod;
        var insertList = editStore.insertList; // 包含新增的数据
    
        if (insertList.length) {
          tableFullData = tableFullData.concat(insertList);
        }
    
        if (!checkStrictly) {
          var allDisabled = true;
          if (property) {
            this.isAllSelected = tableFullData.length && tableFullData.every(checkMethod ? function (row, rowIndex) {
              var canCheck = checkMethod({
                row: row,
                rowIndex: rowIndex,
                $rowIndex: rowIndex
              });

              if(canCheck) {
                allDisabled = false;
                return VueUtil.get(row, property);
              } else {
                return true;
              }

            } : function (row) {
              return VueUtil.get(row, property);
            }) && !allDisabled;
            this.isIndeterminate = !this.isAllSelected && tableFullData.some(function (row) {
              return VueUtil.get(row, property) || treeIndeterminates.indexOf(row) > -1;
            });
          } else {
            this.isAllSelected = tableFullData.length && tableFullData.every(checkMethod ? function (row, rowIndex) {

              var canCheck = checkMethod({
                row: row,
                rowIndex: rowIndex,
                $rowIndex: rowIndex
              });

              if(canCheck) {
                allDisabled = false;
                return selection.indexOf(row) > -1;
              } else {
                return true;
              }
            } : function (row) {
              return selection.indexOf(row) > -1;
            }) && !allDisabled;
            this.isIndeterminate = !this.isAllSelected && tableFullData.some(function (row) {
              return treeIndeterminates.indexOf(row) > -1 || selection.indexOf(row) > -1;
            });
          }
        }
      },
      // 保留选中状态
      reserveCheckSelection: function reserveCheckSelection() {
        var selection = this.selection,
            fullDataRowIdData = this.fullDataRowIdData; // 在 v3.0 中废弃 selectConfig
    
        var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
        var reserve = checkboxConfig.reserve;
    
        var rowkey = tools.UtilTools.getRowkey(this);
    
        if (reserve && selection.length) {
          this.selection = selection.map(function (row) {
            var rowid = '' + VueUtil.get(row, rowkey);
            return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : row;
          });
        }
      },
    
      /**
       * 获取保留选中的行
       */
      getSelectReserveRecords: function getSelectReserveRecords() {
        var selection = this.selection,
            fullDataRowIdData = this.fullDataRowIdData; // 在 v3.0 中废弃 selectConfig
    
        var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
        var reserve = checkboxConfig.reserve;
    
        var rowkey = tools.UtilTools.getRowkey(this);
    
        if (reserve && selection.length) {
          return selection.filter(function (row) {
            return !fullDataRowIdData['' + VueUtil.get(row, rowkey)];
          });
        }
    
        return [];
      },
    
      /**
       * 多选，选中所有事件
       */
      triggerCheckAllEvent: function triggerCheckAllEvent(evnt, value) {
        this.setAllSelection(value);
    
        tools.UtilTools.emitEvent(this, 'select-all', [{
          selection: this.getSelectRecords(),
          reserves: this.getSelectReserveRecords(),
          checked: value,
          $table: this
        }, evnt]);
      },
    
      /**
       * 多选，切换所有行的选中状态
       */
      toggleAllSelection: function toggleAllSelection() {
        this.triggerCheckAllEvent(null, !this.isAllSelected);
        return this.$nextTick();
      },
    
      /**
       * 用于多选行，手动清空用户的选择
       */
      clearSelection: function clearSelection() {
        var tableFullData = this.tableFullData,
            treeConfig = this.treeConfig; // 在 v3.0 中废弃 selectConfig
    
        var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
        var property = checkboxConfig.checkField;
    
        if (property) {
          if (treeConfig) {
            VueUtil.eachTree(tableFullData, function (item) {
              return VueUtil.set(item, property, false);
            }, treeConfig);
          } else {
            tableFullData.forEach(function (item) {
              return VueUtil.set(item, property, false);
            });
          }
        }
    
        this.isAllSelected = false;
        this.isIndeterminate = false;
        this.selection = [];
        this.treeIndeterminates = [];
        return this.$nextTick();
      },
    
      /**
       * 处理单选框默认勾选
       */
      handleRadioDefChecked: function handleRadioDefChecked() {
        var _this$radioConfig = this.radioConfig,
            radioConfig = _this$radioConfig === void 0 ? {} : _this$radioConfig,
            fullDataRowIdData = this.fullDataRowIdData;
        var rowid = radioConfig.checkRowKey;
    
        if (rowid && fullDataRowIdData[rowid]) {
          this.setRadioRow(fullDataRowIdData[rowid].row);
        }
      },
    
      /**
       * 单选，行选中事件
       */
      triggerRadioRowEvent: function triggerRadioRowEvent(evnt, params) {
        var _this$radioConfig2 = this.radioConfig,
            radioConfig = _this$radioConfig2 === void 0 ? {} : _this$radioConfig2;
        var checkMethod = radioConfig.checkMethod;
    
        if (!checkMethod || checkMethod({
          row: params.row,
          rowIndex: params.rowIndex,
          $rowIndex: params.$rowIndex
        })) {
          var isChange = this.selectRow !== params.row;
          this.setRadioRow(params.row);
    
          if (isChange) {
            tools.UtilTools.emitEvent(this, 'radio-change', [params, evnt]);
          }
        }
      },
      triggerCurrentRowEvent: function triggerCurrentRowEvent(evnt, params) {
        var isChange = this.currentRow !== params.row;
        this.setCurrentRow(params.row);
    
        if (isChange) {
          tools.UtilTools.emitEvent(this, 'current-change', [params, evnt]);
        }
      },
    
      /**
       * 用于当前行，设置某一行为高亮状态
       * @param {Row} row 行对象
       */
      setCurrentRow: function setCurrentRow(row, column) {

        if(this.currentRow != row) {
          this.scrollToRow(row, column);
        }

        this.clearCurrentRow();
        this.clearCurrentColumn();
        this.currentRow = row;
    
        if (this.highlightCurrentRow) {
          VueUtil.loop(this.$el.querySelectorAll('[data-rowid="'.concat(tools.UtilTools.getRowid(this, row), '"]')), function (elem) {
            return tools.DomTools.addClass(elem, 'row--current');
          });
        }
        
        return this.$nextTick();
      },
    
      /**
       * 用于单选行，设置某一行为选中状态
       * @param {Row} row 行对象
       */
      setRadioRow: function setRadioRow(row) {
        if (this.selectRow !== row) {
          this.clearRadioRow();
        }
    
        this.selectRow = row;
        return this.$nextTick();
      },
    
      /**
       * 用于当前行，手动清空当前高亮的状态
       */
      clearCurrentRow: function clearCurrentRow() {
        this.currentRow = null;
        this.hoverRow = null;
        VueUtil.loop(this.$el.querySelectorAll('.row--current'), function (elem) {
          return tools.DomTools.removeClass(elem, 'row--current');
        });
        return this.$nextTick();
      },
    
      /**
       * 用于单选行，手动清空用户的选择
       */
      clearRadioRow: function clearRadioRow() {
        this.selectRow = null;
        return this.$nextTick();
      },
    
      /**
       * 用于当前行，获取当前行的数据
       */
      getCurrentRow: function getCurrentRow() {
        return this.currentRow;
      },
    
      /**
       * 用于单选行，获取当已选中的数据
       */
      getRadioRow: function getRadioRow() {
        return this.selectRow;
      },
    
      /**
       * 行 hover 事件
       */
      triggerHoverEvent: function triggerHoverEvent(evnt, _ref4) {
        var row = _ref4.row;
        this.setHoverRow(row);
      },
      setHoverRow: function setHoverRow(row) {
        var rowid = tools.UtilTools.getRowid(this, row);
    
        this.clearHoverRow();
        VueUtil.loop(this.$el.querySelectorAll('[data-rowid="'.concat(rowid, '"]')), function (elem) {
          return tools.DomTools.addClass(elem, 'row--hover');
        });
        this.hoverRow = row;
      },
      clearHoverRow: function clearHoverRow() {
        VueUtil.loop(this.$el.querySelectorAll('.vue-xtable-body--row.row--hover'), function (elem) {
          return tools.DomTools.removeClass(elem, 'row--hover');
        });
        this.hoverRow = null;
      },
      triggerHeaderCellClickEvent: function triggerHeaderCellClickEvent(evnt, params) {
        var _lastResizeTime = this._lastResizeTime,
            sortOpts = this.sortOpts;
        var column = params.column,
            cell = params.cell;
    
        var triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;
    
        var triggerSort = this.getEventTargetNode(evnt, cell, 'vue-xtable-sort-wrapper').flag;
        var triggerFilter = this.getEventTargetNode(evnt, cell, 'vue-xtable-filter-wrapper').flag;
    
        if (sortOpts.trigger === 'cell' && !(triggerResizable || triggerSort || triggerFilter)) {
          this.triggerSortEvent(evnt, column, column.order === 'desc' ? 'asc' : column.order === 'asc' ? 'asc' : 'desc');
        }
    
        tools.UtilTools.emitEvent(this, 'header-cell-click', [VueUtil.assign({
          triggerResizable: triggerResizable,
          triggerSort: triggerSort,
          triggerFilter: triggerFilter
        }, params), evnt]);
    
        if (this.highlightCurrentColumn) {
          return this.setCurrentColumn(column, true);
        }
    
        return this.$nextTick();
      },
    
      /**
       * 用于当前列，设置某列行为高亮状态
       * @param {ColumnConfig} column 列配置
       */
      setCurrentColumn: function setCurrentColumn(column) {
        this.clearCurrentRow();
        this.clearCurrentColumn();
        this.currentColumn = column;
        VueUtil.loop(this.$el.querySelectorAll('.'.concat(column.id)), function (elem) {
          return tools.DomTools.addClass(elem, 'col--current');
        });
        return this.$nextTick();
      },
    
      /**
       * 用于当前列，手动清空当前高亮的状态
       */
      clearCurrentColumn: function clearCurrentColumn() {
        this.currentColumn = null;
        VueUtil.loop(this.$el.querySelectorAll('.col--current'), function (elem) {
          return tools.DomTools.removeClass(elem, 'col--current');
        });
        return this.$nextTick();
      },
      checkValidate: function checkValidate(type) {
        if (baseTable._valid) {
          return this.triggerValidate(type);
        }
    
        return this.$nextTick();
      },
    
      /**
       * 当单元格发生改变时
       * 如果存在规则，则校验
       */
      handleChangeCell: function handleChangeCell(evnt, params) {
        var _this21 = this;
    
        this.checkValidate('blur').catch(function (e) {
          return e;
        }).then(function () {
          _this21.handleActived(params, evnt).then(function () {
            return _this21.checkValidate('change');
          }).catch(function (e) {
            return e;
          });
        });
      },
    
      /**
       * 列点击事件
       * 如果是单击模式，则激活为编辑状态
       * 如果是双击模式，则单击后选中状态
       */
      triggerCellClickEvent: function triggerCellClickEvent(evnt, params) {
        var $el = this.$el,
            highlightCurrentRow = this.highlightCurrentRow,
            editStore = this.editStore,
            _this$radioConfig3 = this.radioConfig,
            radioConfig = _this$radioConfig3 === void 0 ? {} : _this$radioConfig3,
            _this$expandConfig = this.expandConfig,
            expandConfig = _this$expandConfig === void 0 ? {} : _this$expandConfig,
            _this$treeConfig = this.treeConfig,
            treeConfig = _this$treeConfig === void 0 ? {} : _this$treeConfig,
            editConfig = this.editConfig,
            _this$mouseConfig = this.mouseConfig,
            mouseConfig = _this$mouseConfig === void 0 ? {} : _this$mouseConfig;
        var actived = editStore.actived;
        var row = params.row,
            column = params.column,
            cell = params.cell; // 在 v3.0 中废弃 selectConfig
    
        var checkboxConfig = this.checkboxConfig || this.selectConfig || {}; // 解决 checkbox 重复触发两次问题
    
        if (isTargetRadioOrCheckbox(evnt, column, 'radio') || isTargetRadioOrCheckbox(evnt, column, 'checkbox', 'checkbox') || isTargetRadioOrCheckbox(evnt, column, 'selection', 'checkbox')) {
          // 在 v3.0 中废弃 type=selection
          return;
        } // 如果是展开行
    
    
        if ((expandConfig.trigger === 'row' || column.type === 'expand' && expandConfig.trigger === 'cell') && !this.getEventTargetNode(evnt, $el, 'vue-xtable-table--expanded').flag) {
          this.triggerRowExpandEvent(evnt, params);
        } // 如果是树形表格
    
    
        if (treeConfig.trigger === 'row' || column.treeNode && treeConfig.trigger === 'cell') {
          this.triggerTreeExpandEvent(evnt, params);
        }
    
        if ((!column.treeNode || !this.getEventTargetNode(evnt, $el, 'vue-xtable-tree-wrapper').flag) && (column.type !== 'expand' || !this.getEventTargetNode(evnt, $el, 'vue-xtable-table--expanded').flag)) {
          // 如果是高亮行
          // 为修复行高亮和单元格选中，不在同一个事件下的bug，把高亮行的实现移动到mousedown事件中
          // if (highlightCurrentRow) {
          //   if (radioConfig.trigger === 'row' || !this.getEventTargetNode(evnt, $el, 'vue-xtable-checkbox').flag && !this.getEventTargetNode(evnt, $el, 'vue-xtable-radio').flag) {
          //     this.triggerCurrentRowEvent(evnt, params);
          //   }
          // }
           // 如果是单选框
    
    
          if ((radioConfig.trigger === 'row' || column.type === 'radio' && radioConfig.trigger === 'cell') && !this.getEventTargetNode(evnt, $el, 'vue-xtable-radio').flag) {
            this.triggerRadioRowEvent(evnt, params);
          } // 如果是复选框
    
    
          if ((checkboxConfig.trigger === 'row' || (column.type === 'checkbox' || column.type === 'selection') && checkboxConfig.trigger === 'cell') && !this.getEventTargetNode(evnt, params.cell, 'vue-xtable-checkbox').flag) {
            // 在 v3.0 中废弃 type=selection
            this.handleToggleCheckRowEvent(params, evnt);
          } // 如果设置了单元格选中功能，则不会使用点击事件去处理（只能支持双击模式）
    
    
          if (!mouseConfig.checked) {
            if (editConfig) {
              if (editConfig.trigger === 'manual') {
                if (actived.args && actived.row === row && column !== actived.column) {
                  this.handleChangeCell(evnt, params);
                }
              } else if (!actived.args || cell !== actived.args.cell) {
                if (editConfig.trigger === 'click') {
                  this.handleChangeCell(evnt, params);
                } else if (editConfig.trigger === 'dblclick') {
                  if (editConfig.mode === 'row' && actived.row === params.row) {
                    this.handleChangeCell(evnt, params);
                  } else {
                    this.handleSelected(params, evnt);
                  }
                }
              }
            }
          }
        }
    
        tools.UtilTools.emitEvent(this, 'cell-click', [params, evnt]);
      },
    
      /**
       * 列双击点击事件
       * 如果是双击模式，则激活为编辑状态
       */
      triggerCellDBLClickEvent: function triggerCellDBLClickEvent(evnt, params) {
        var _this22 = this;
    
        var editStore = this.editStore,
            editConfig = this.editConfig;
        var actived = editStore.actived;
    
        if (editConfig && editConfig.trigger === 'dblclick') {
          if (!actived.args || evnt.currentTarget !== actived.args.cell) {
            if (editConfig.mode === 'row') {
              this.checkValidate('blur').catch(function (e) {
                return e;
              }).then(function () {
                _this22.handleActived(params, evnt).then(function () {
                  return _this22.checkValidate('change');
                }).catch(function (e) {
                  return e;
                });
              });
            } else if (editConfig.mode === 'cell') {
              this.handleActived(params, evnt).then(function () {
                return _this22.checkValidate('change');
              }).catch(function (e) {
                return e;
              });
            }
          }
        }
    
        tools.UtilTools.emitEvent(this, 'cell-dblclick', [params, evnt]);
      },
    
      /**
       * 点击排序事件
       */
      triggerSortEvent: function triggerSortEvent(evnt, column, order) {
        var property = column.property;
    
        if (column.sortable || column.remoteSort) {
          var evntParams = {
            column: column,
            property: property,
            field: property,
            prop: property,
            $table: this
          };
    
          if (column.order === order) {
            this.clearSort(column.property);
          } else {
            this.sort(property, order);
          }

          var orderParam = [];
          for (var j = 0; j < this.sortingColumns.length; j++) {
            var sortingColumn = this.sortingColumns[j];
            if (sortingColumn.property && sortingColumn.order) {
              orderParam.push({
                property: sortingColumn.property,
                order: sortingColumn.order
              });
            }
          }

          evntParams.order = orderParam;
    
          tools.UtilTools.emitEvent(this, 'sort-change', [evntParams, evnt]);
        }
      },
      sort: function sort(field, order) {
        var visibleColumn = this.visibleColumn,
            tableFullColumn = this.tableFullColumn,
            remoteSort = this.remoteSort,
            singleSort = this.singleSort;
        var column = VueUtil.find(visibleColumn, function (item) {
          return item.property === field;
        });
        var isRemote = VueUtil.isBoolean(column.remoteSort) ? column.remoteSort : remoteSort;
    
        if (column.sortable || column.remoteSort) {
          if (!order) {
            order = column.order === 'desc' ? 'asc' : 'desc';
          }
    
          if (column.order !== order) {
            if(singleSort) {
              tableFullColumn.forEach(function (column) {
                  column.order = null;
              });
              this.sortingColumns = [];
            }
            column.order = order; // 如果是服务端排序，则跳过本地排序处理
            if(this.sortingColumns.indexOf(column) == -1)  this.sortingColumns.push(column); //加入排序顺序数组

            if (!isRemote) {
              this.handleTableData(true);
            }
          }
    
          return this.$nextTick().then(this.updateStyle);
        }
    
        return this.$nextTick();
      },
    
      /**
       * 手动清空排序条件，数据会恢复成未排序的状态
       */
      clearSort: function clearSort(property) {
        var self = this;
        this.tableFullColumn.forEach(function (column) {
          if(!property || property == column.property) {
            column.order = null;
            VueUtil.remove(self.sortingColumns, function(item) {
              return item === column;
            });
          }
        });
        return this.handleTableData(true);
      },
    
      /**
       * 关闭筛选
       * @param {Event} evnt 事件
       */
      closeFilter: function closeFilter(evnt) {
        VueUtil.assign(this.filterStore, {
          isAllSelected: false,
          isIndeterminate: false,
          options: [],
          visible: false
        });
        return this.$nextTick();
      },
    
      /**
       * 展开行事件
       */
      triggerRowExpandEvent: function triggerRowExpandEvent(evnt, _ref5) {
        var row = _ref5.row;
        var rest = this.toggleRowExpansion(row);
    
        tools.UtilTools.emitEvent(this, 'toggle-expand-change', [{
          row: row,
          rowIndex: this.getRowIndex(row),
          $table: this
        }, evnt]);
    
        return rest;
      },
    
      /**
       * 切换展开行
       */
      toggleRowExpansion: function toggleRowExpansion(row) {
        return this.setRowExpansion(row);
      },
    
      /**
       * 处理默认展开行
       */
      handleDefaultRowExpand: function handleDefaultRowExpand() {
        var _this$expandConfig2 = this.expandConfig,
            expandConfig = _this$expandConfig2 === void 0 ? {} : _this$expandConfig2,
            tableFullData = this.tableFullData,
            fullDataRowIdData = this.fullDataRowIdData;
        var expandAll = expandConfig.expandAll,
            expandRowKeys = expandConfig.expandRowKeys;
    
        if (expandAll) {
          this.expandeds = tableFullData.slice(0);
        } else if (expandRowKeys) {
          var defExpandeds = [];
          expandRowKeys.forEach(function (rowid) {
            if (fullDataRowIdData[rowid]) {
              defExpandeds.push(fullDataRowIdData[rowid].row);
            }
          });
          this.expandeds = defExpandeds;
        }
      },
    
      /**
       * 设置所有行的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllRowExpansion: function setAllRowExpansion(expanded) {
        this.expandeds = expanded ? this.tableFullData.slice(0) : [];
        return this.$nextTick().then(this.recalculate);
      },
    
      /**
       * 设置展开行，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setRowExpansion: function setRowExpansion(rows, expanded) {
        var expandeds = this.expandeds,
            _this$expandConfig3 = this.expandConfig,
            expandConfig = _this$expandConfig3 === void 0 ? {} : _this$expandConfig3;
        var isToggle = arguments.length === 1;
    
        if (rows) {
          if (!VueUtil.isArray(rows)) {
            rows = [rows];
          }
    
          if (expandConfig.accordion) {
            // 只能同时展开一个
            expandeds.length = 0;
            rows = rows.slice(rows.length - 1, rows.length);
          }
    
          rows.forEach(function (row) {
            var index = expandeds.indexOf(row);
    
            if (index > -1) {
              if (isToggle || !expanded) {
                expandeds.splice(index, 1);
              }
            } else {
              if (isToggle || expanded) {
                expandeds.push(row);
              }
            }
          });
        }
    
        return this.$nextTick().then(this.recalculate);
      },
      // 在 v3.0 中废弃 getRecords
      hasRowExpand: function hasRowExpand(row) {
        tools.UtilTools.warn('vue.xtable.error.delFunc', ['hasRowExpand', 'isExpandByRow']);
    
        return this.isExpandByRow(row);
      },
    
      /**
       * 判断行是否为展开状态
       * @param {Row} row 行对象
       */
      isExpandByRow: function isExpandByRow(row) {
        return this.expandeds.indexOf(row) > -1;
      },
    
      /**
       * 手动清空展开行状态，数据会恢复成未展开的状态
       */
      clearRowExpand: function clearRowExpand() {
        var _this23 = this;
    
        var isExists = this.expandeds.length;
        this.expandeds = [];
        return this.$nextTick().then(function () {
          return isExists ? _this23.recalculate() : 0;
        });
      },
      getRowExpandRecords: function getRowExpandRecords() {
        return this.expandeds.slice(0);
      },
      getTreeExpandRecords: function getTreeExpandRecords() {
        return this.treeExpandeds.slice(0);
      },
    
      /**
       * 获取数表格状态
       */
      getTreeStatus: function getTreeStatus() {
        if (this.treeConfig) {
          return {
            config: this.treeConfig,
            expandeds: this.getTreeExpandRecords()
          };
        }
    
        return null;
      },
    
      /**
       * 展开树节点事件
       */
      triggerTreeExpandEvent: function triggerTreeExpandEvent(evnt, _ref6) {
        var _this24 = this;
    
        var row = _ref6.row;
        var rest = this.toggleTreeExpansion(row);
    
        tools.UtilTools.emitEvent(this, 'toggle-tree-change', [{
          row: row,
          rowIndex: this.getRowIndex(row),
          $table: this
        }, evnt]);
    
        this.$nextTick(function () {
          var currentRow = _this24.currentRow,
              currentColumn = _this24.currentColumn;
    
          if (currentRow) {
            _this24.setCurrentRow(currentRow);
          } else if (currentColumn) {
            _this24.setCurrentColumn(currentColumn);
          }
        });
        return rest;
      },
    
      /**
       * 切换/展开树节点
       */
      toggleTreeExpansion: function toggleTreeExpansion(row) {
        return this.setTreeExpansion(row);
      },
    
      /**
       * 处理默认展开树节点
       */
      handleDefaultTreeExpand: function handleDefaultTreeExpand() {
        var treeConfig = this.treeConfig,
            tableFullData = this.tableFullData;
    
        if (treeConfig) {
          var expandAll = treeConfig.expandAll,
              expandRowKeys = treeConfig.expandRowKeys;
          var children = treeConfig.children;
          var treeExpandeds = [];
    
          if (expandAll) {
            VueUtil.filterTree(tableFullData, function (row) {
              var rowChildren = row[children];
    
              if (rowChildren && rowChildren.length) {
                treeExpandeds.push(row);
              }
            }, treeConfig);
            this.treeExpandeds = treeExpandeds;
          } else if (expandRowKeys) {
            var rowkey = tools.UtilTools.getRowkey(this);
    
            expandRowKeys.forEach(function (rowid) {
              var matchObj = VueUtil.findTree(tableFullData, function (item) {
                return rowid === VueUtil.get(item, rowkey);
              }, treeConfig);
              var rowChildren = matchObj ? matchObj.item[children] : 0;
    
              if (rowChildren && rowChildren.length) {
                treeExpandeds.push(matchObj.item);
              }
            });
            this.treeExpandeds = treeExpandeds;
          }
        }
      },
    
      /**
       * 设置所有树节点的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllTreeExpansion: function setAllTreeExpansion(expanded) {
        var tableFullData = this.tableFullData,
            treeConfig = this.treeConfig;
        var children = treeConfig.children;
        var treeExpandeds = [];
    
        if (expanded) {
          VueUtil.eachTree(tableFullData, function (row) {
            var rowChildren = row[children];
    
            if (rowChildren && rowChildren.length) {
              treeExpandeds.push(row);
            }
          }, treeConfig);
        }
    
        this.treeExpandeds = treeExpandeds;
        return this.$nextTick().then(this.recalculate);
      },
    
      /**
       * 设置展开树形节点，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setTreeExpansion: function setTreeExpansion(rows, expanded) {
        var tableFullData = this.tableFullData,
            treeExpandeds = this.treeExpandeds,
            treeConfig = this.treeConfig;
        var children = treeConfig.children;
        var isToggle = arguments.length === 1;
    
        if (rows) {
          if (!VueUtil.isArray(rows)) {
            rows = [rows];
          }
    
          if (treeConfig.accordion) {
            rows = rows.slice(rows.length - 1, rows.length);
          }
    
          rows.forEach(function (row) {
            var rowChildren = row[children];
    
            if (rowChildren && rowChildren.length) {
              var index = treeExpandeds.indexOf(row);
    
              if (treeConfig.accordion) {
                // 同一级只能展开一个
                var matchObj = VueUtil.findTree(tableFullData, function (item) {
                  return item === row;
                }, treeConfig);
                VueUtil.remove(treeExpandeds, function (item) {
                  return matchObj.items.indexOf(item) > -1;
                });
              }
    
              if (index > -1) {
                if (isToggle || !expanded) {
                  treeExpandeds.splice(index, 1);
                }
              } else {
                if (isToggle || expanded) {
                  treeExpandeds.push(row);
                }
              }
            }
          });
        }
    
        return this.$nextTick().then(this.recalculate);
      },
      // 在 v3.0 中废弃 hasTreeExpand
      hasTreeExpand: function hasTreeExpand(row) {
        tools.UtilTools.warn('vue.xtable.error.delFunc', ['hasTreeExpand', 'isTreeExpandByRow']);
    
        return this.isTreeExpandByRow(row);
      },
    
      /**
       * 判断行是否为树形节点展开状态
       * @param {Row} row 行对象
       */
      isTreeExpandByRow: function isTreeExpandByRow(row) {
        return this.treeExpandeds.indexOf(row) > -1;
      },
    
      /**
       * 手动清空树形节点的展开状态，数据会恢复成未展开的状态
       */
      clearTreeExpand: function clearTreeExpand() {
        var _this25 = this;
    
        var isExists = this.treeExpandeds.length;
        this.treeExpandeds = [];
        return this.$nextTick().then(function () {
          return isExists ? _this25.recalculate() : 0;
        });
      },
    
      /**
       * 获取虚拟滚动状态
       */
      getVirtualScroller: function getVirtualScroller() {
        var $refs = this.$refs,
            scrollXLoad = this.scrollXLoad,
            scrollYLoad = this.scrollYLoad;
        var bodyElem = $refs.tableBody.$el;
        return {
          scrollX: scrollXLoad,
          scrollY: scrollYLoad,
          scrollTop: bodyElem.scrollTop,
          scrollLeft: bodyElem.scrollLeft
        };
      },
    
      /**
       * 横向 X 可视渲染事件处理
       */
      triggerScrollXEvent: function triggerScrollXEvent(evnt) {
        this.updateVirtualScrollX();
      },
      updateVirtualScrollX: function updateVirtualScrollX(force) {
        var $refs = this.$refs,
            visibleColumn = this.visibleColumn,
            scrollXStore = this.scrollXStore;
        var startIndex = scrollXStore.startIndex,
            renderSize = scrollXStore.renderSize,
            offsetSize = scrollXStore.offsetSize,
            visibleSize = scrollXStore.visibleSize;
        var scrollBodyElem = $refs.tableBody.$el;
        var scrollLeft = scrollBodyElem.scrollLeft;
        var toVisibleIndex = 0;
        var width = 0;
        var preload = force || false;
    
        for (var index = 0; index < visibleColumn.length; index++) {
          width += visibleColumn[index].renderWidth;
    
          if (scrollLeft < width) {
            toVisibleIndex = index;
            break;
          }
        }
    
        if (force || scrollXStore.visibleIndex !== toVisibleIndex) {
          var marginSize = 0;
          // var marginSize = Math.min(Math.floor((renderSize - visibleSize) / 2), visibleSize);
          if (scrollXStore.visibleIndex === toVisibleIndex) {
            scrollXStore.startIndex = toVisibleIndex;
          } else if (scrollXStore.visibleIndex > toVisibleIndex) {
            // 向左
            preload = toVisibleIndex - offsetSize <= startIndex;
    
            if (preload) {
              scrollXStore.startIndex = Math.max(0, Math.max(marginSize, toVisibleIndex - marginSize));
            }
          } else {
            // 向右
            preload = toVisibleIndex + visibleSize + offsetSize >= startIndex + renderSize;
    
            if (preload) {
              scrollXStore.startIndex = Math.max(0, Math.min(visibleColumn.length - renderSize, toVisibleIndex - marginSize));
            }
          }
    
          if (preload) {
            this.updateScrollXData();
          }
    
          scrollXStore.visibleIndex = toVisibleIndex;
        }
    
        this.clostTooltip();
      },
    
      /**
       * 纵向 Y 可视渲染事件处理
       */
      triggerScrollYEvent: function triggerScrollYEvent(evnt) {
        // webkit 浏览器使用最佳的渲染方式
        if (isWebkit && this.scrollYStore.adaptive) {
          this.loadScrollYData(evnt);
        } else {
          this.debounceScrollY(evnt);
        }
      },
      debounceScrollY: VueUtil._debounce(function (evnt) {
        this.loadScrollYData(evnt);
      }, debounceScrollYDuration, {
        leading: false,
        trailing: true
      }),
    
      /**
       * 纵向 Y 可视渲染处理
       */
      loadScrollYData: function loadScrollYData(evnt) {
        var afterFullData = this.afterFullData,
            scrollYStore = this.scrollYStore,
            isLoadData = this.isLoadData;
        var startIndex = scrollYStore.startIndex,
            renderSize = scrollYStore.renderSize,
            offsetSize = scrollYStore.offsetSize,
            visibleSize = scrollYStore.visibleSize,
            rowHeight = scrollYStore.rowHeight;
        var scrollBodyElem = evnt.target;
        var scrollTop = scrollBodyElem.scrollTop;
        var toVisibleIndex = Math.ceil(scrollTop / rowHeight);
        var preload = false;
    
        if (isLoadData || scrollYStore.visibleIndex !== toVisibleIndex) {
          var marginSize = Math.min(Math.floor((renderSize - visibleSize) / 2), visibleSize);
    
          if (scrollYStore.visibleIndex > toVisibleIndex) {
            // 向上
            preload = toVisibleIndex - offsetSize <= startIndex;
    
            if (preload) {
              scrollYStore.startIndex = Math.max(0, toVisibleIndex - Math.max(marginSize, renderSize - visibleSize));
            }
          } else {
            // 向下
            preload = toVisibleIndex + visibleSize + offsetSize >= startIndex + renderSize;
    
            if (preload) {
              scrollYStore.startIndex = Math.max(0, Math.min(afterFullData.length - renderSize, toVisibleIndex - marginSize));
            }
          }
    
          if (preload) {
            this.updateScrollYData();
          }
    
          scrollYStore.visibleIndex = toVisibleIndex;
          this.isLoadData = false;
        }
      },
      // 计算可视渲染相关数据
      computeScrollLoad: function computeScrollLoad() {
        var _this26 = this;
    
        return this.$nextTick().then(function () {
          var vSize = _this26.vSize,
              scrollXLoad = _this26.scrollXLoad,
              scrollYLoad = _this26.scrollYLoad,
              scrollYStore = _this26.scrollYStore,
              scrollXStore = _this26.scrollXStore,
              visibleColumn = _this26.visibleColumn,
              optimizeOpts = _this26.optimizeOpts,
              rowHeightMaps = _this26.rowHeightMaps;
          var scrollX = optimizeOpts.scrollX,
              scrollY = optimizeOpts.scrollY;
          var tableBody = _this26.$refs.tableBody;
          var tableBodyElem = tableBody ? tableBody.$el : null;
          var tableHeader = _this26.$refs.tableHeader;
    
          if (tableBodyElem) {
            // 计算 X 逻辑
            if (scrollXLoad) {
              var firstColumn = visibleColumn[0];
              var cWidth = firstColumn ? firstColumn.renderWidth : 40;
              var visibleXSize = (parseFloat(scrollX.vSize || Math.ceil(tableBodyElem.clientWidth / cWidth)) || 0);
              scrollXStore.visibleSize = visibleXSize; // 自动优化
    
              if (!scrollX.oSize) {
                scrollXStore.offsetSize = visibleXSize;
              }
    
              if (!scrollX.rSize) {
                scrollXStore.renderSize = visibleXSize + 6;
              }
    
              _this26.updateScrollXData();
            } else {
              _this26.updateScrollXSpace();
            } // 计算 Y 逻辑
    
    
            if (scrollYLoad) {
              var rHeight;
    
              if (scrollY.rHeight) {
                rHeight = scrollY.rHeight;
              } else {
                var firstTrElem = tableBodyElem.querySelector('tbody>tr');
    
                if (!firstTrElem && tableHeader) {
                  firstTrElem = tableHeader.$el.querySelector('thead>tr');
                }
    
                if (firstTrElem) {
                  rHeight = firstTrElem.clientHeight;
                }
              } // 默认的行高
    
    
              if (!rHeight) {
                rHeight = rowHeightMaps[vSize || 'default'];
              }
    
              var clientHeight = tableBodyElem.clientHeight;
              var propsHeight = parseInt(_this26.height);
              var calcHeight = propsHeight ? propsHeight : clientHeight;
              var visibleYSize = (parseFloat(scrollY.vSize || Math.ceil(calcHeight / rHeight)) || 0);
              scrollYStore.visibleSize = visibleYSize;
              scrollYStore.rowHeight = rHeight; // 自动优化
    
              if (!scrollY.oSize) {
                scrollYStore.offsetSize = visibleYSize;
              }
    
              if (!scrollY.rSize) {
                scrollYStore.renderSize = VueUtil.isFirefox ? visibleYSize * 6 : VueUtil.isEdge ? visibleYSize * 10 : isWebkit ? visibleYSize + 2 : visibleYSize * 6;
              }
    
              _this26.updateScrollYData();
            } else {
              _this26.updateScrollYSpace();
            }
          }
    
          _this26.$nextTick(_this26.updateStyle);
        });
      },
      updateScrollXData: function updateScrollXData() {
        var visibleColumn = this.visibleColumn,
            scrollXStore = this.scrollXStore;
        this.tableColumn = visibleColumn.slice(scrollXStore.startIndex, scrollXStore.startIndex + scrollXStore.renderSize);
        this.updateScrollXSpace();
      },
      // 更新横向 X 可视渲染上下剩余空间大小
      updateScrollXSpace: function updateScrollXSpace() {
        var $refs = this.$refs,
            elemStore = this.elemStore,
            visibleColumn = this.visibleColumn,
            scrollXStore = this.scrollXStore,
            scrollXLoad = this.scrollXLoad,
            tableWidth = this.tableWidth,
            scrollbarWidth = this.scrollbarWidth;
        var tableHeader = $refs.tableHeader,
            tableBody = $refs.tableBody,
            tableFooter = $refs.tableFooter;
        var headerElem = tableHeader ? tableHeader.$el.querySelector('.vue-xtable-table--header') : null;
        var bodyElem = tableBody.$el.querySelector('.vue-xtable-table--body');
        var footerElem = tableFooter ? tableFooter.$el.querySelector('.vue-xtable-table--footer') : null;
        var leftSpaceWidth = visibleColumn.slice(0, scrollXStore.startIndex).reduce(function (previous, column) {
          return previous + column.renderWidth;
        }, 0);
        var marginLeft = '';
    
        if (scrollXLoad) {
          marginLeft = ''.concat(leftSpaceWidth, 'px');
        }
    
        if (headerElem) {
          headerElem.style.marginLeft = marginLeft;
        }
    
        bodyElem.style.marginLeft = marginLeft;
    
        if (footerElem) {
          footerElem.style.marginLeft = marginLeft;
        }
    
        var containerList = ['main'];
        containerList.forEach(function (name) {
          var layoutList = ['header', 'body', 'footer'];
          layoutList.forEach(function (layout) {
            var xSpaceElem = elemStore[''.concat(name, '-').concat(layout, '-xSpace')];
    
            if (xSpaceElem) {
              xSpaceElem.style.width = scrollXLoad ? ''.concat(tableWidth + (layout === 'header' ? scrollbarWidth : 0), 'px') : '';
            }
          });
        });
        this.$nextTick(this.updateStyle);
      },
      updateScrollYData: function updateScrollYData() {
        this.handleTableData();
        this.updateScrollYSpace();
      },
      // 更新纵向 Y 可视渲染上下剩余空间大小
      updateScrollYSpace: function updateScrollYSpace() {
        var elemStore = this.elemStore,
            scrollYStore = this.scrollYStore,
            scrollYLoad = this.scrollYLoad,
            afterFullData = this.afterFullData;
        var bodyHeight = afterFullData.length * scrollYStore.rowHeight;
        var topSpaceHeight = Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0);
        var containerList = ['main', 'left', 'right'];
        var marginTop = '';
        var ySpaceHeight = '';
    
        if (scrollYLoad) {
          marginTop = ''.concat(topSpaceHeight, 'px');
          ySpaceHeight = ''.concat(bodyHeight, 'px');
        }
    
        containerList.forEach(function (name) {
          var layoutList = ['header', 'body', 'footer'];
          var tableElem = elemStore[''.concat(name, '-body-table')];
    
          if (tableElem) {
            tableElem.style.marginTop = marginTop;
          }
    
          layoutList.forEach(function (layout) {
            var ySpaceElem = elemStore[''.concat(name, '-').concat(layout, '-ySpace')];
    
            if (ySpaceElem) {
              ySpaceElem.style.height = ySpaceHeight;
            }
          });
        });
        this.$nextTick(this.updateStyle);
      },
    
      /**
       * 如果有滚动条，则滚动到对应的位置
       * @param {Number} scrollLeft 左距离
       * @param {Number} scrollTop 上距离
       */
      scrollTo: function scrollTo(scrollLeft, scrollTop) {
        var _this27 = this;
    
        var bodyElem = this.$refs.tableBody.$el;
    
        if (VueUtil.isNumber(scrollLeft)) {
          var tableFooter = this.$refs.tableFooter;
    
          if (tableFooter) {
            tableFooter.$el.scrollLeft = scrollLeft;
          } else {
            bodyElem.scrollLeft = scrollLeft;
          }
        }
    
        if (VueUtil.isNumber(scrollTop)) {
          var rightBody = this.$refs.rightBody;
    
          if (rightBody) {
            rightBody.$el.scrollTop = scrollTop;
          }
    
          bodyElem.scrollTop = scrollTop;
        }
    
        if (this.scrollXLoad || this.scrollYLoad) {
          return new Promise(function (resolve) {
            return setTimeout(function () {
              return resolve(_this27.$nextTick());
            }, 50);
          });
        }
    
        return this.$nextTick();
      },
    
      /**
       * 如果有滚动条，则滚动到对应的行
       * @param {Row} row 行对象
       * @param {ColumnConfig} column 列配置
       */
      scrollToRow: function scrollToRow(row, column) {
        var rest = [];
    
        if (row && this.fullAllDataRowMap.has(row)) {
          rest.push(tools.DomTools.rowToVisible(this, row));
        }
    
        rest.push(this.scrollToColumn(column));
        return Promise.all(rest);
      },
    
      /**
       * 如果有滚动条，则滚动到对应的列
       * @param {ColumnConfig} column 列配置
       */
      scrollToColumn: function scrollToColumn(column) {
        if (column && this.fullColumnMap.has(column)) {
          return tools.DomTools.colToVisible(this, column);
        }
    
        return this.$nextTick();
      },
    
      /**
       * 对于树形结构中，可以直接滚动到指定深层节点中
       * 对于某些特定的场景可能会用到，比如定位到某一节点
       * @param {Row} row 行对象
       */
      scrollToTreeRow: function scrollToTreeRow(row) {
        var _this28 = this;
    
        var tableFullData = this.tableFullData,
            treeConfig = this.treeConfig;
    
        if (treeConfig) {
          var matchObj = VueUtil.findTree(tableFullData, function (item) {
            return item === row;
          }, treeConfig);
    
          if (matchObj) {
            var nodes = matchObj.nodes;
            nodes.forEach(function (row, index) {
              if (index < nodes.length - 1 && !_this28.isTreeExpandByRow(row)) {
                _this28.setTreeExpansion(row, true);
              }
            });
          }
        }
    
        return this.$nextTick();
      },
    
      /**
       * 手动清除滚动相关信息，还原到初始状态
       */
      clearScroll: function clearScroll() {
        var _this29 = this;
    
        var $refs = this.$refs;
        var tableBody = $refs.tableBody;
        var tableBodyElem = tableBody ? tableBody.$el : null;
        var tableFooter = $refs.tableFooter;
        var tableFooterElem = tableFooter ? tableFooter.$el : null;
        var footerTargetElem = tableFooterElem || tableBodyElem;
    
        if (tableBodyElem) {
          tableBodyElem.scrollTop = 0;
        }
    
        if (footerTargetElem) {
          footerTargetElem.scrollLeft = 0;
        }
    
        return new Promise(function (resolve) {
          return setTimeout(function () {
            return resolve(_this29.$nextTick());
          });
        });
      },
    
      /**
       * 更新表尾合计
       */
      updateFooter: function updateFooter() {
        var showFooter = this.showFooter,
            tableColumn = this.tableColumn,
            footerMethod = this.footerMethod;
    
        if (showFooter && footerMethod) {
          this.footerData = tableColumn.length ? footerMethod({
            columns: tableColumn,
            data: this.afterFullData
          }) : [];
        }
    
        return this.$nextTick();
      },
    
      /**
       * 更新列状态
       * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态
       * 如果单元格配置了校验规则，则会进行校验
       */
      updateStatus: function updateStatus(scope, cellValue) {
        var _this30 = this;
    
        var customVal = !VueUtil.isUndefined(cellValue);
        return this.$nextTick().then(function () {
          var $refs = _this30.$refs,
              tableData = _this30.tableData,
              editRules = _this30.editRules,
              validStore = _this30.validStore;
    
          if (scope && $refs.tableBody && editRules) {
            var row = scope.row,
                column = scope.column;
            var type = 'change';
    
            var hasCellRule = _this30.hasCellRules(type, row, column);
            var rowIndex = tableData.indexOf(row);
  
            var cell = tools.DomTools.getCell(_this30, {
              row: row,
              rowIndex: rowIndex,
              column: column
            });
  
            if (cell) {

              if (_this30.validResults.length > 0) {
                var rowId = tools.UtilTools.getRowid(_this30, row);

                var f = _this30.validResults.filter(function(result) {
                  if (result.rowId != rowId || result.property != column.property) {
                    _this30.clearValidate();
                    return true;
                  }
                });

                if (f.length != _this30.validResults.length) {
                  _this30.validResults = f;
                }
              }

              if (hasCellRule) {
                return _this30.validCellRules(type, row, column, cellValue).then(function () {
                  if (customVal && validStore.visible) {
                    tools.UtilTools.setCellValue(row, column, cellValue);
                  }
    
                  _this30.clearValidate();
                }).catch(function (_ref7) {
                  var rule = _ref7.rule;
    
                  if (customVal) {
                    tools.UtilTools.setCellValue(row, column, cellValue);
                  }
    
                  _this30.showValidTooltip({
                    rule: rule,
                    row: row,
                    column: column,
                    cell: cell
                  });
                });
              }
            }
          }
        });
      },
      updateZindex: function updateZindex() {
        if (this.tZindex < tools.UtilTools.getLastZIndex()) {
          this.tZindex = tools.UtilTools.nextZIndex(this);
        }
      },
    
      getUserSetting: function() {
        var setting = {
          width: {},
          hidden: [],
          fixed: {},
          filters: {},
          order: [],
          drag: [],
        };
        var table = this;
        var tableFullColumn = this.tableFullColumn;
        var sortingColumns = this.sortingColumns;
        var isGroup = this.isGroup;

        for (var i = 0; i < tableFullColumn.length; i++) {
          var column = tableFullColumn[i];
          var property = column.property;
          var visible = column.visible;
          var resizeWidth = column.resizeWidth;
          var renderWidth = column.renderWidth;
          var fixed = column.fixed;
          var filters = column.filters;
          var dragged = column.dragged;

          if (property && !visible) {
            setting.hidden.push(property);
          }
          if (property && resizeWidth) {
            setting.width[property] = renderWidth;
          }
          if (property && fixed) {
            setting.fixed[property] = fixed;
          }
          if (property && filters && filters.length) {
            if (filters.length > 0) {
              setting.filters[property] = [];
            } 
            filters.forEach(function(filter) {
              if (filter.checked) {
                setting.filters[property].push(filter);
              }
            });
          }
          if (!isGroup && property && dragged) {
            setting.drag.push({
              property: property,
              index: this.getColumnIndex(column)
            });
          }
        }

        if(isGroup) {
          this.collectColumn.forEach(function(collectColumn, index) {
            if (collectColumn.dragged) {
              setting.drag.push({
                property: table.beforeDragColumn.indexOf(collectColumn),
                index: index
              });
            }
          });
        }

        for (var j = 0; j < sortingColumns.length; j++) {
          var sortingColumn = sortingColumns[j];
          if (sortingColumn.property && sortingColumn.order) {
            setting.order.push({
              property: sortingColumn.property,
              order: sortingColumn.order
            });
          }
        }

        // 解决重复
        setting.order = VueUtil.uniqBy(setting.order, 'property');

        return JSON.stringify(setting);
      },

      safeGetColumnByField: function(property) {
        var col = this.getColumnByField(property);

        if (!col) {
          col = VueUtil.find(this.tableFullColumn, function (columnConfig) {
            return columnConfig.property === property;
          });
        }

        return col;
      },

      setUserSetting: function(settingStr) {
        var setting =  JSON.parse(settingStr);
        var tableFullColumn = this.tableFullColumn;
        var table = this;
        for (var i = 0; i < tableFullColumn.length; i++) {
          var column = tableFullColumn[i];
          var property = column.property;

          if (property && setting.hidden && setting.hidden.indexOf(property) > -1) {
            column.visible = false;
          }

          if (property && setting.width && setting.width.hasOwnProperty(property)) {
            column.resizeWidth = setting.width[property];
          }

          if (property && setting.fixed && setting.fixed.hasOwnProperty(property)) {
            column.fixed = setting.fixed[property];
          }

          if (property && setting.filters && setting.filters.hasOwnProperty(property)) {
            setting.filters[property].forEach(function(settingFilter) {
              var columnFilter = VueUtil.find(column.filters, function(columnFilter) {
                return(settingFilter.value && columnFilter.value === settingFilter.value)
                  || (settingFilter.data && VueUtil.isEqual(columnFilter.data, settingFilter.data));
              });

              if (columnFilter) {
                columnFilter.checked = true;
              } else {
                column.filters.push(settingFilter);
              }
            });
          }
        }

        if (setting.order) {
          setting.order.forEach(function(orderObj) {
            var sortingColumn = table.safeGetColumnByField(orderObj.property);
            table.sortingColumns.push(sortingColumn);
            sortingColumn.order = orderObj.order;
          });
        }

        var dragColumns = setting.drag;
        dragColumns.sort(function(a, b) {
          var aIndex = table.getColumnIndex(table.safeGetColumnByField(a.property));
          var bIndex = table.getColumnIndex(table.safeGetColumnByField(b.property));
          return aIndex - bIndex;
        });

        VueUtil.forEach(dragColumns, function(dragObj) {
          var property = dragObj.property;
          var index = dragObj.index;
          var cols = table.isGroup ? table.collectColumn : tableFullColumn;

          if (!table.originColumn) {
            table.originColumn = cols.slice(0);
          }

          var column = table.isGroup ? table.beforeDragColumn[property] : table.safeGetColumnByField(property);
          var oldColumnIndex = cols.indexOf(column);
          var newColumnIndex = index;

          var currRow = cols.splice(oldColumnIndex, 1)[0];
          currRow.dragged = 'dragged';
          cols.splice(newColumnIndex, 0, currRow);
        });
        
        if (this.$toolbar) {
          this.$toolbar.resetResizable();
        }
    
        if (setting.width && setting.width.length > 0) {
          this.analyColumnWidth();
          this.recalculate(true);
        }

        this.handleTableData(true);
        this.cacheColumnMap();
        return this.refreshColumn();
      },

      columnDragHandler: function () {
        var self = this;

        this.$nextTick(function () {
          if(this.isGroup && !this.beforeDragColumn) {
            this.beforeDragColumn = this.collectColumn.slice(0);
          }
          self.columnDragSortable = Sortable.create(self.$el.querySelector('.body--wrapper>.vue-xtable-table--header .vue-xtable-header--row'), {
            handle: '.vue-xtable-header--column:not(.col--fixed):not(.col--index):not(.col--drag)',
            onEnd: this.onDragEnd,
            onMove: function(evt) {
              if (evt.related.classList.contains('col--fixed') || evt.related.classList.contains('col--gutter') || evt.related.classList.contains('col--index') || evt.related.classList.contains('col--drag')) return false;
            },
            scroll: self.$el.querySelector('.body--wrapper.vue-xtable-table--body-wrapper'),
          });
        });
      },

      onDragEnd: function (param) {
        // var item = param.item;
        var newIndex = param.newIndex;
        var oldIndex = param.oldIndex;
        var xTable = this;

        var cols = xTable.getTableColumn(),
            fullColumn = cols.fullColumn,
            tableColumn = cols.tableColumn;

        // var targetThElem = item;
        // var wrapperElem = targetThElem.parentNode;
        // var newColumn = fullColumn[newIndex];
        // if (newColumn.fixed) {
        //   // 错误的移动
        //   if (newIndex > oldIndex) {
        //     wrapperElem.insertBefore(targetThElem, wrapperElem.children[oldIndex]);
        //   } else {
        //     wrapperElem.insertBefore(wrapperElem.children[oldIndex], targetThElem);
        //   }

        //   return xTable.$notify.error({
        //     message: this.$t('vue.xtable.error.fixColumnDrag')
        //   });
        // } // 转换真实索引
        var col = this.isGroup ? this.collectColumn.slice(0) : fullColumn;

        if (!xTable.originColumn) {
          xTable.originColumn = col.slice(0);
        }

        var oldColumnIndex = xTable.getColumnIndex(tableColumn[oldIndex]);
        var newColumnIndex = xTable.getColumnIndex(tableColumn[newIndex]); // 移动到目标列
        var currCol = col.splice(oldColumnIndex, 1)[0];
        currCol.dragged = 'dragged';
        col.splice(newColumnIndex, 0, currCol);
        xTable.loadColumn(col);
        xTable.$emit('column-drag', {
          newIndex: newIndex,
          oldIndex: oldIndex,
          column: currCol,
        });
      },

      resetColumnDrag: function() {
        if(this.originColumn) {
          this.loadColumn(this.originColumn);
        }
      },

      /*************************
       * Publish methods
       *************************/
      // 与工具栏对接
      connect: function connect(_ref8) {
        var toolbar = _ref8.toolbar;
        this.$toolbar = toolbar;
      },
      // 检查触发源是否属于目标节点
      getEventTargetNode: tools.DomTools.getEventTargetNode,
      /*************************
       * Publish methods
       *************************/


      initRowDrag: function () {
        var self = this;
        self.$nextTick(function () {
          self.rowSortable = Sortable.create(self.$el.querySelector('.body--wrapper>.vue-xtable-table--body tbody'), {
            handle: '.col--drag',
            onEnd: function (obj) {

              var newIndex = obj.newIndex,
                oldIndex = obj.oldIndex;
              var data = self.tableData;
              var currRow = data.splice(oldIndex, 1)[0];
              data.splice(newIndex, 0, currRow);
              self.setCurrentRow(currRow);

              self.clearSelected();
              self.clearChecked();
              self.clearCopyed();
              self.clearIndexChecked();
              self.clearHeaderChecked();

              self.editStore.checked.rowNodes = null;
              self.editStore.selected.args = null;

              self.$emit('row-drag', {
                newIndex: newIndex,
                oldIndex: oldIndex,
                row: currRow,
              });
            }
          });
        });
      },
    
      getVisibleIndexFromColumnIndex: function(columnIndex) {
        return this.tableColumn.indexOf(this.tableFullColumn[columnIndex]);
      },

      getColumnIndexFromVisibleIndex: function(visibleIndex) {
        return this.tableFullColumn.indexOf(this.tableColumn[visibleIndex]);
      }
    }; // Module methods
    
    var funcs = 'filter,clearFilter,closeMenu,getMouseSelecteds,getMouseCheckeds,clearCopyed,clearChecked,clearHeaderChecked,clearIndexChecked,clearSelected,insert,insertAt,insertRow,delRow,remove,removeSelecteds,revert,revertData,getRecordset,getInsertRecords,getRemoveRecords,getUpdateRecords,clearActived,getActiveRow,hasActiveRow,isActiveByRow,setActiveRow,setActiveCell,setSelectCell,clearValidate,fullValidate,validate,exportCsv,openExport,exportData,openImport,importData,readFile,importByFile,print'.split(',');
    funcs.forEach(function (name) {
      Methods[name] = function () {
        return this['_'.concat(name)] ? this['_'.concat(name)].apply(this, arguments) : null;
      };
    });
    mod.methods = Methods;
  })();

  /**
   * 渲染浮固定列
   * 分别渲染左边固定列和右边固定列
   * 如果宽度足够情况下，则不需要渲染固定列
   * @param {Function} h 创建 VNode 函数
   * @param {Object} $table 表格实例
   * @param {String} fixedType 固定列类型
   */
  function renderFixed(h, $table, fixedType) {
      var tableData = $table.tableData,
          tableColumn = $table.tableColumn,
          visibleColumn = $table.visibleColumn,
          collectColumn = $table.collectColumn,
          isGroup = $table.isGroup,
          vSize = $table.vSize,
          showHeader = $table.showHeader,
          showFooter = $table.showFooter,
          columnStore = $table.columnStore,
          footerData = $table.footerData;
      var fixedColumn = columnStore[''.concat(fixedType, 'List')];
      return h('div', {
        class: 'vue-xtable-table--fixed-'.concat(fixedType, '-wrapper'),
        ref: ''.concat(fixedType, 'Container')
      }, [showHeader ? h('vue-xtable-header', {
        props: {
          fixedType: fixedType,
          tableData: tableData,
          tableColumn: tableColumn,
          visibleColumn: visibleColumn,
          collectColumn: collectColumn,
          size: vSize,
          fixedColumn: fixedColumn,
          isGroup: isGroup
        },
        ref: ''.concat(fixedType, 'Header')
      }) : null, h('vue-xtable-body', {
        props: {
          fixedType: fixedType,
          tableData: tableData,
          tableColumn: tableColumn,
          visibleColumn: visibleColumn,
          collectColumn: collectColumn,
          fixedColumn: fixedColumn,
          size: vSize,
          isGroup: isGroup
        },
        ref: ''.concat(fixedType, 'Body')
      }), showFooter ? h('vue-xtable-footer', {
        props: {
          fixedType: fixedType,
          footerData: footerData,
          tableColumn: tableColumn,
          visibleColumn: visibleColumn,
          size: vSize,
          fixedColumn: fixedColumn
        },
        ref: ''.concat(fixedType, 'Footer')
      }) : null]);
    }
    
    var VueXtable = {
      name: 'VueXtable',
      props: {
        /** 基本属性 */
        // 数据
        data: Array,
        // 初始化绑定动态列
        customs: Array,
        // 表格的高度
        height: [Number, String],
        // 表格的最大高度
        maxHeight: [Number, String],
        // 所有列是否允许拖动列宽调整大小
        resizable: {
          type: Boolean,
          default: function _default() {
            return GlobalConfig.resizable;
          }
        },
        // 是否带有斑马纹
        stripe: {
          type: Boolean,
          default: function _default() {
            return GlobalConfig.stripe;
          }
        },
        // 是否带有纵向边框
        border: {
          type: Boolean,
          default: function _default() {
            return GlobalConfig.border;
          }
        },
        // 表格的尺寸
        size: {
          type: String,
          default: function _default() {
            return GlobalConfig.size;
          }
        },
        // 列的宽度是否自撑开
        fit: {
          type: Boolean,
          default: function _default() {
            return GlobalConfig.fit;
          }
        },
        // 表格是否加载中
        loading: Boolean,
        // 所有的列对其方式
        align: {
          type: String,
          default: function _default() {
            return GlobalConfig.align;
          }
        },
        // 所有的表头列的对齐方式
        headerAlign: {
          type: String,
          default: function _default() {
            return GlobalConfig.headerAlign;
          }
        },
        // 所有的表尾列的对齐方式
        footerAlign: {
          type: String,
          default: function _default() {
            return GlobalConfig.footerAlign;
          }
        },
        // 是否显示表头
        showHeader: {
          type: Boolean,
          default: function _default() {
            return GlobalConfig.showHeader;
          }
        },
        // 只对 type=index 时有效，自定义序号的起始值
        startIndex: {
          type: Number,
          default: 0
        },
        // 是否要高亮当前选中行
        highlightCurrentRow: {
          type: Boolean,
          default: function _default() {
            return GlobalConfig.highlightCurrentRow;
          }
        },
        // 鼠标移到行是否要高亮显示
        highlightHoverRow: {
          type: Boolean,
          default: function _default() {
            return GlobalConfig.highlightHoverRow;
          }
        },
        // 是否要高亮当前选中列
        highlightCurrentColumn: {
          type: Boolean,
          default: function _default() {
            return GlobalConfig.highlightCurrentColumn;
          }
        },
        // 鼠标移到列是否要高亮显示
        highlightHoverColumn: {
          type: Boolean,
          default: function _default() {
            return GlobalConfig.highlightHoverColumn;
          }
        },
        // 激活单元格编辑时是否高亮显示
        highlightCell: Boolean,
        // 是否显示表尾合计
        showFooter: Boolean,
        // 表尾合计的计算方法
        footerMethod: Function,
        // 给行附加 className
        rowClassName: [String, Function],
        // 给单元格附加 className
        cellClassName: [String, Function],
        // 给表头的行附加 className
        headerRowClassName: [String, Function],
        // 给表头的单元格附加 className
        headerCellClassName: [String, Function],
        // 给表尾的行附加 className
        footerRowClassName: [String, Function],
        // 给表尾的单元格附加 className
        footerCellClassName: [String, Function],
        // 给单元格附加样式
        cellStyle: [Object, Function],
        // 给表头单元格附加样式
        headerCellStyle: [Object, Function],
        // 给表尾单元格附加样式
        footerCellStyle: [Object, Function],
        // 给行附加样式
        rowStyle: [Object, Function],
        // 给表头行附加样式
        headerRowStyle: [Object, Function],
        // 给表尾行附加样式
        footerRowStyle: [Object, Function],
        // 合并行或列
        spanMethod: Function,
        // 表尾合并行或列
        footerSpanMethod: Function,
        // 设置所有内容过长时显示为省略号
        showOverflow: {
          type: [Boolean, String],
          default: function _default() {
            return GlobalConfig.showOverflow;
          }
        },
        // 设置表头所有内容过长时显示为省略号
        showHeaderOverflow: {
          type: [Boolean, String],
          default: function _default() {
            return GlobalConfig.showHeaderOverflow;
          }
        },
        // 是否所有服务端筛选
        remoteFilter: Boolean,
        // 是否所有服务端排序
        remoteSort: Boolean,
        // 只允许单列排序
        singleSort: Boolean,
        // 自定义所有列的排序方法
        sortMethod: Function,
        // 所有列宽度
        columnWidth: [Number, String],
        // 所有列最小宽度，把剩余宽度按比例分配
        columnMinWidth: [Number, String],
    
        /** 高级属性 */
        // 主键配置
        columnKey: Boolean,
        rowKey: Boolean,
        rowId: {
          type: String,
          default: function _default() {
            return GlobalConfig.rowId;
          }
        },
        zIndex: Number,
        // 是否自动监听父容器变化去更新响应式表格宽高
        autoResize: Boolean,
        // 是否自动根据状态属性去更新响应式表格宽高
        syncResize: [Boolean, String, Number],
        // 排序配置项
        sortConfig: Object,
        // 单选框配置
        radioConfig: Object,
        // （v3.0 废弃）
        selectConfig: Object,
        // 复选框配置项
        checkboxConfig: Object,
        // tooltip 配置项
        tooltipConfig: Object,
        // 展开行配置项
        expandConfig: Object,
        // 树形结构配置项
        treeConfig: Object,
        // 快捷菜单配置项
        contextMenu: Object,
        // 鼠标配置项
        mouseConfig: Object,
        // 按键配置项
        keyboardConfig: Object,
        // 编辑配置项
        editConfig: Object,
        // 校验配置项
        validConfig: Object,
        // 校验规则配置项
        editRules: Object,
        // 优化配置项
        optimization: Object,
        // 额外的参数
        params: Object,
        //允许列拖拽排序
        columnDrag: Boolean,
      },
      provide: function provide() {
        return {
          $table: this
        };
      },
      inject: {
        $grid: {
          default: null
        }
      },
      mixins: [],
      data: function data() {
        return {
          id: VueUtil.uniqueId(),
          // 列分组配置
          collectColumn: [],
          // 完整所有列
          tableFullColumn: [],
          // 渲染的列
          tableColumn: [],
          // 渲染中的数据
          tableData: [],
          // 是否启用了横向 X 可视渲染方式加载
          scrollXLoad: false,
          // 是否启用了纵向 Y 可视渲染方式加载
          scrollYLoad: false,
          // 是否存在纵向滚动条
          overflowY: true,
          // 是否存在横向滚动条
          overflowX: false,
          // 纵向滚动条的宽度
          scrollbarWidth: 0,
          // 横向滚动条的高度
          scrollbarHeight: 0,
          // 复选框属性，是否全选
          isAllSelected: false,
          // 复选框属性，有选中且非全选状态
          isIndeterminate: false,
          // 复选框属性，已选中的列
          selection: [],
          // 当前行
          currentRow: null,
          // 单选框属性，选中行
          selectRow: null,
          // 表尾合计数据
          footerData: [],
          // 已展开的行
          expandeds: [],
          // 已展开树节点
          treeExpandeds: [],
          // 树节点不确定状态的列表
          treeIndeterminates: [],
          // 当前选中的筛选列
          filterStore: {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          },
          // 存放列相关的信息
          columnStore: {
            leftList: [],
            centerList: [],
            rightList: [],
            resizeList: [],
            pxList: [],
            pxMinList: [],
            scaleList: [],
            scaleMinList: [],
            autoList: []
          },
          // 存放快捷菜单的信息
          ctxMenuStore: {
            selected: null,
            visible: false,
            showChild: false,
            selectChild: null,
            list: [],
            style: null
          },
          // 存放可编辑相关信息
          editStore: {
            indexs: {
              columns: []
            },
            titles: {
              columns: []
            },
            // 所有选中
            checked: {
              rows: [],
              columns: [],
              tRows: [],
              tColumns: []
            },
            // 选中源
            selected: {
              row: null,
              column: null
            },
            // 已复制源
            copyed: {
              cut: false,
              rows: [],
              columns: []
            },
            // 激活
            actived: {
              row: null,
              column: null
            },
            insertList: [],
            removeList: []
          },
          // 存放数据校验相关信息
          validStore: {
            visible: false,
            row: null,
            column: null,
            content: '',
            rule: null,
            isArrow: false
          },
          validResults: [],
          printUrl: '',
          // 存放排序列顺序
          sortingColumns: []
        };
      },
      computed: {
        vSize: function vSize() {
          return this.size || this.$parent.size || this.$parent.vSize;
        },
        validOpts: function validOpts() {
          return VueUtil.assign({
            message: 'default'
          }, GlobalConfig.validConfig, this.validConfig);
        },
        optimizeOpts: function optimizeOpts() {
          return VueUtil.assign({}, GlobalConfig.optimization, this.optimization);
        },
        rowHeightMaps: function rowHeightMaps() {
          return VueUtil.assign({
            default: 48,
            medium: 44,
            small: 40,
            mini: 36
          }, this.optimizeOpts.rHeights);
        },
        vaildTipOpts: function vaildTipOpts() {
          return VueUtil.assign({
            isArrow: false
          }, this.tooltipConfig);
        },
        sortOpts: function sortOpts() {
          return VueUtil.assign({}, GlobalConfig.sortConfig, this.sortConfig);
        },
        // 是否使用了分组表头
        isGroup: function isGroup() {
          return this.collectColumn.some(function (column) {
            return tools.UtilTools.hasChildrenList(column);
          });
        },
        hasTip: function hasTip() {
          return baseTable._tooltip;
        },
        visibleColumn: function visibleColumn() {
          return this.tableFullColumn ? this.tableFullColumn.filter(function (column) {
            return column.visible;
          }) : [];
        },
        isResizable: function isResizable() {
          return this.resizable || this.tableFullColumn.some(function (column) {
            return column.resizable;
          });
        },
        hasFilter: function hasFilter() {
          return this.tableColumn.some(function (column) {
            return column.filters && column.filters.length;
          });
        },
        headerCtxMenu: function headerCtxMenu() {
          return this.ctxMenuOpts.header && this.ctxMenuOpts.header.options ? this.ctxMenuOpts.header.options : [];
        },
        bodyCtxMenu: function bodyCtxMenu() {
          return this.ctxMenuOpts.body && this.ctxMenuOpts.body.options ? this.ctxMenuOpts.body.options : [];
        },
        isCtxMenu: function isCtxMenu() {
          return this.headerCtxMenu.length || this.bodyCtxMenu.length;
        },
        ctxMenuOpts: function ctxMenuOpts() {
          return VueUtil.assign({}, GlobalConfig.menu, this.contextMenu);
        },
        ctxMenuList: function ctxMenuList() {
          var rest = [];
          this.ctxMenuStore.list.forEach(function (list) {
            list.forEach(function (item) {
              rest.push(item);
            });
          });
          return rest;
        },
    
        /**
         * 判断列全选的复选框是否禁用
         */
        isAllCheckboxDisabled: function isAllCheckboxDisabled() {
          var tableFullData = this.tableFullData,
              treeConfig = this.treeConfig; // 在 v3.0 中废弃 selectConfig
    
          var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
          var strict = checkboxConfig.strict,
              checkMethod = checkboxConfig.checkMethod;
    
          if (strict) {
            if (tableFullData.length) {
              if (checkMethod) {
                if (treeConfig) {} // 暂时不支持树形结构
                // 如果所有行都被禁用
    
    
                return tableFullData.every(function (row, rowIndex) {
                  return !checkMethod({
                    row: row,
                    rowIndex: rowIndex,
                    $rowIndex: rowIndex
                  });
                });
              }
    
              return false;
            }
    
            return true;
          }
    
          return false;
        },
        validResultsCell: function() {
          var res = {};
          VueUtil.loop(this.validResults, function(result) {
            if (!res[result.rowId]) {
              res[result.rowId] = {};
            }
            if (!res[result.rowId][result.property]) {
              res[result.rowId][result.property] = [];
            }
            res[result.rowId][result.property].push(result);
          });
          return res;
        }
      },
      watch: {
        data: function data(value) {
          if (!this._isUpdateData) {
            this.loadTableData(value, true).then(this.handleDefault);
          }
    
          this._isUpdateData = false;
        },
        customs: function customs(value) {
          if (!this.isUpdateCustoms) {
            this.mergeCustomColumn(value);
          }
    
          this.isUpdateCustoms = false;
        },
        collectColumn: function collectColumn(value) {
          var _this = this;
    
          var tableFullColumn = tools.UtilTools.getColumnList(value);
    
          this.tableFullColumn = tableFullColumn;
          this.cacheColumnMap();
    
          if (this.customs) {
            this.mergeCustomColumn(this.customs);
          }
    
          this.refreshColumn().then(function () {
            if (_this.scrollXLoad) {
              _this.updateVirtualScrollX(true);
            }
          });
          this.handleTableData(true);
    
          if (this.$toolbar) {
            this.$toolbar.updateColumn(tableFullColumn);
          } // 在 v3.0 中废弃 prop、label
    
    
          if (tableFullColumn.length) {
            var cIndex = Math.floor((tableFullColumn.length - 1) / 2);
    
            if (tableFullColumn[cIndex].prop) {
              tools.UtilTools.warn('vue.xtable.error.delProp', ['prop', 'field']);
            }
    
            if (tableFullColumn[cIndex].label) {
              tools.UtilTools.warn('vue.xtable.error.delProp', ['label', 'title']);
            }
          }
    
          if (this.treeConfig && tableFullColumn.some(function (column) {
            return column.fixed;
          }) && tableFullColumn.some(function (column) {
            return column.type === 'expand';
          })) {
            tools.UtilTools.warn('vue.xtable.error.treeFixedExpand');
          }
        },
        tableColumn: function tableColumn() {
          this.analyColumnWidth();
        },
        height: function height() {
          this.$nextTick(this.recalculate);
        },
        loading: function loading() {
          if (!this._isLoading) {
            this._isLoading = true;
          }
        },
        syncResize: function syncResize(value) {
          if (value) {
            this.$nextTick(this.recalculate);
          }
        },
        columnDrag: {
          handler: function(val) {
            if(val) {
              this.columnDragHandler();
            } else {
              if (this.columnDragSortable) {
                this.columnDragSortable.destroy();
              }
            }
          },
          immediate: true
        },
      },
      created: function created() {
        var _this2 = this;
    
        var _Object$assign = VueUtil.assign(this, {
          tZindex: 0,
          elemStore: {},
          // 存放横向 X 虚拟滚动相关的信息
          scrollXStore: {},
          // 存放纵向 Y 虚拟滚动相关信息
          scrollYStore: {},
          // 存放 tooltip 相关信息
          tooltipStore: {},
          // 表格父容器的高度
          parentHeight: 0,
          // 表格宽度
          tableWidth: 0,
          // 表格高度
          tableHeight: 0,
          // 表头高度
          headerHeight: 0,
          // 表尾高度
          footerHeight: 0,
          // 单选框属性，选中列
          // currentColumn: null,
          // 当前 hover 行
          // hoverRow: null,
          // 最后滚动位置
          lastScrollLeft: 0,
          lastScrollTop: 0,
          // 完整数据、条件处理后
          tableFullData: [],
          afterFullData: [],
          // 缓存数据集
          fullAllDataRowMap: new Map(),
          fullAllDataRowIdData: {},
          fullDataRowMap: new Map(),
          fullDataRowIdData: {},
          fullColumnMap: new Map(),
          fullColumnIdData: {}
        }),
            scrollXStore = _Object$assign.scrollXStore,
            scrollYStore = _Object$assign.scrollYStore,
            optimizeOpts = _Object$assign.optimizeOpts,
            data = _Object$assign.data,
            loading = _Object$assign.loading;
    
        var scrollX = optimizeOpts.scrollX,
            scrollY = optimizeOpts.scrollY; // 是否加载过 Loading 模块
    
        this._isLoading = loading;
    
        if (!tools.UtilTools.getRowkey(this)) {
          tools.UtilTools.error('vue.xtable.error.emptyProp', ['row-id']);
        } // if (this.selectConfig) {
        //   UtilTools.warn('vue.xtable.error.delProp', ['select-config', 'checkbox-config'])
        // }
        // 检查是否有安装需要的模块
    
    
        var errorModuleName;
    
        if (!baseTable._edit && this.editConfig) {
          errorModuleName = 'Edit';
        } else if (!baseTable._valid && this.editRules) {
          errorModuleName = 'Validator';
        } else if (!baseTable._keyboard && (this.keyboardConfig || this.mouseConfig)) {
          errorModuleName = 'Keyboard';
        } else if (!baseTable._resize && this.autoResize) {
          errorModuleName = 'Resize';
        }
    
        if (errorModuleName) {
          throw new Error(tools.UtilTools.getLog('vue.xtable.error.reqModule', [errorModuleName]));
        }
    
        if (scrollY) {
          VueUtil.assign(scrollYStore, {
            startIndex: 0,
            visibleIndex: 0,
            adaptive: VueUtil.isBoolean(scrollY.adaptive) ? scrollY.adaptive : true,
            renderSize: (parseFloat(scrollY.rSize) || 0),
            offsetSize: (parseFloat(scrollY.oSize) || 0)
          });
        }
    
        if (scrollX) {
          VueUtil.assign(scrollXStore, {
            startIndex: 0,
            visibleIndex: 0,
            renderSize: (parseFloat(scrollX.rSize) || 0),
            offsetSize: (parseFloat(scrollX.oSize) || 0)
          });
        }
    
        this.loadTableData(data, true).then(function () {
          _this2.handleDefault();
    
          _this2.updateStyle();
        });
    
        tools.GlobalEvent.on(this, 'mousedown', this.handleGlobalMousedownEvent);
    
        tools.GlobalEvent.on(this, 'blur', this.handleGlobalBlurEvent);
    
        tools.GlobalEvent.on(this, 'mousewheel', this.handleGlobalMousewheelEvent);
    
        tools.GlobalEvent.on(this, 'keydown', this.handleGlobalKeydownEvent);

        tools.GlobalEvent.on(this, 'paste', this.handleGlobalPaste);
    
        tools.GlobalEvent.on(this, 'resize', this.handleGlobalResizeEvent);
    
        tools.GlobalEvent.on(this, 'contextmenu', this.handleGlobalContextmenuEvent);
    
        this.preventEvent(null, 'created', {
          $table: this
        });
      },
      mounted: function mounted() {
        if (this.autoResize && baseTable._resize) {
          this.bindResize();
        }
    
        document.body.appendChild(this.$refs.tableWrapper);
        this.preventEvent(null, 'mounted', {
          $table: this
        });
        this.$nextTick(function() {
          var hasDragCol = VueUtil.find(this.tableColumn, function (col) {
            return col.type === 'drag';
          });
          if(hasDragCol) {
            this.initRowDrag();
          }
        });

      },
      activated: function activated() {
        this.refreshScroll();
        this.preventEvent(null, 'activated', {
          $table: this
        });
      },
      deactivated: function deactivated() {
        this.preventEvent(null, 'deactivated', {
          $table: this
        });
      },
      beforeDestroy: function beforeDestroy() {
        var tableWrapper = this.$refs.tableWrapper;
    
        if (tableWrapper && tableWrapper.parentNode) {
          tableWrapper.parentNode.removeChild(tableWrapper);
        }
    
        if (baseTable._resize) {
          this.unbindResize();
        }
    
        this.closeFilter();
        this.closeMenu();
        this.preventEvent(null, 'beforeDestroy', {
          $table: this
        });

        if (this.columnDragSortable) {
          this.columnDragSortable.destroy();
        }

        if (this.rowSortable) {
          this.rowSortable.destroy();
        }
      },
      destroyed: function destroyed() {
        tools.GlobalEvent.off(this, 'mousedown');
    
        tools.GlobalEvent.off(this, 'blur');
    
        tools.GlobalEvent.off(this, 'mousewheel');
    
        tools.GlobalEvent.off(this, 'keydown');
    
        tools.GlobalEvent.off(this, 'resize');
    
        tools.GlobalEvent.off(this, 'contextmenu');
    
        this.preventEvent(null, 'destroyed', {
          $table: this
        });
      },
      render: function render(h) {
        var _class;
    
        var _e = this._e,
            id = this.id,
            tableData = this.tableData,
            tableColumn = this.tableColumn,
            visibleColumn = this.visibleColumn,
            collectColumn = this.collectColumn,
            isGroup = this.isGroup,
            hasFilter = this.hasFilter,
            isResizable = this.isResizable,
            isCtxMenu = this.isCtxMenu,
            loading = this.loading,
            _isLoading = this._isLoading,
            showHeader = this.showHeader,
            border = this.border,
            stripe = this.stripe,
            height = this.height,
            highlightHoverRow = this.highlightHoverRow,
            highlightHoverColumn = this.highlightHoverColumn,
            highlightCell = this.highlightCell,
            vSize = this.vSize,
            showOverflow = this.showOverflow,
            showHeaderOverflow = this.showHeaderOverflow,
            editConfig = this.editConfig,
            validOpts = this.validOpts,
            _this$mouseConfig = this.mouseConfig,
            mouseConfig = _this$mouseConfig === void 0 ? {} : _this$mouseConfig,
            editRules = this.editRules,
            showFooter = this.showFooter,
            footerMethod = this.footerMethod,
            overflowX = this.overflowX,
            overflowY = this.overflowY,
            scrollXLoad = this.scrollXLoad,
            scrollYLoad = this.scrollYLoad,
            scrollbarHeight = this.scrollbarHeight,
            optimizeOpts = this.optimizeOpts,
            vaildTipOpts = this.vaildTipOpts,
            tooltipConfig = this.tooltipConfig,
            columnStore = this.columnStore,
            filterStore = this.filterStore,
            ctxMenuStore = this.ctxMenuStore,
            footerData = this.footerData,
            hasTip = this.hasTip;
        var leftList = columnStore.leftList,
            rightList = columnStore.rightList;
        return h('div', {
          class: (_class = {
            'vue-xtable-table': 1
          }, tools.UtilTools.defineProperty(_class, 'size--'.concat(vSize), vSize), tools.UtilTools.defineProperty(_class, 'vue-xtable-editable', editConfig), tools.UtilTools.defineProperty(_class, 'show--head', showHeader), tools.UtilTools.defineProperty(_class, 'show--foot', showFooter), tools.UtilTools.defineProperty(_class, 'fixed--left', leftList.length), tools.UtilTools.defineProperty(_class, 'fixed--right', rightList.length), tools.UtilTools.defineProperty(_class, 'all-overflow', showOverflow), tools.UtilTools.defineProperty(_class, 'all-head-overflow', showHeaderOverflow), tools.UtilTools.defineProperty(_class, 'c--highlight', highlightCell), tools.UtilTools.defineProperty(_class, 't--animat', optimizeOpts.animat), tools.UtilTools.defineProperty(_class, 't--stripe', stripe), tools.UtilTools.defineProperty(_class, 't--border', border), tools.UtilTools.defineProperty(_class, 't--selected', mouseConfig.selected), tools.UtilTools.defineProperty(_class, 't--checked', mouseConfig.checked), tools.UtilTools.defineProperty(_class, 'row--highlight', highlightHoverRow), tools.UtilTools.defineProperty(_class, 'column--highlight', highlightHoverColumn), tools.UtilTools.defineProperty(_class, 'is--loading', loading), tools.UtilTools.defineProperty(_class, 'scroll--y', overflowY), tools.UtilTools.defineProperty(_class, 'scroll--x', overflowX), tools.UtilTools.defineProperty(_class, 'virtual--x', scrollXLoad), tools.UtilTools.defineProperty(_class, 'virtual--y', scrollYLoad), _class)
        }, [
        /**
         * 隐藏列
         */
        h('div', {
          class: 'vue-xtable-table-hidden-column',
          ref: 'hideColumn'
        }, this.$slots.default), h('div', {
          class: 'vue-xtable-table--main-wrapper'
        }, [
        /**
         * 主头部
         */
        showHeader ? h('vue-xtable-header', {
          ref: 'tableHeader',
          props: {
            tableData: tableData,
            tableColumn: tableColumn,
            visibleColumn: visibleColumn,
            collectColumn: collectColumn,
            size: vSize,
            isGroup: isGroup
          }
        }) : _e(),
        /**
         * 主内容
         */
        h('vue-xtable-body', {
          ref: 'tableBody',
          props: {
            tableData: tableData,
            tableColumn: tableColumn,
            visibleColumn: visibleColumn,
            collectColumn: collectColumn,
            size: vSize,
            isGroup: isGroup
          }
        }),
        /**
         * 底部汇总
         */
        showFooter ? h('vue-xtable-footer', {
          props: {
            footerData: footerData,
            footerMethod: footerMethod,
            tableColumn: tableColumn,
            visibleColumn: visibleColumn,
            size: vSize
          },
          ref: 'tableFooter'
        }) : null]),
        /**
         * 左侧固定列
         */
        leftList && leftList.length && overflowX ? renderFixed(h, this, 'left') : _e(),
        /**
         * 右侧固定列
         */
        rightList && rightList.length && overflowX ? renderFixed(h, this, 'right') : _e(),
        /**
         * 列宽线
         */
        isResizable ? h('div', {
          class: 'vue-xtable-table--resizable-bar',
          style: overflowX ? {
            'padding-bottom': ''.concat(scrollbarHeight, 'px')
          } : null,
          ref: 'resizeBar'
        }) : _e(),
        /**
         * 加载中
         */
        _isLoading ? h('vue-xtable-loading', {
          props: {
            visible: loading
          }
        }) : _e(), h('div', {
          class: 'vue-xtable-table'.concat(id, '-wrapper ').concat(this.$vnode.data.staticClass || ''),
          ref: 'tableWrapper'
        }, [
        /**
         * 筛选
         */
        hasFilter ? h('vue-xtable-filter', {
          props: {
            optimizeOpts: optimizeOpts,
            filterStore: filterStore
          },
          ref: 'filterWrapper'
        }) : _e(),
        /**
         * 快捷菜单
         */
        isCtxMenu ? h('vue-xtable-context-menu', {
          props: {
            ctxMenuStore: ctxMenuStore
          },
          ref: 'ctxWrapper'
        }) : _e(),
        /**
         * 单元格内容溢出的 tooltip
         */
        hasTip ? h('vue-xtable-tooltip', {
          ref: 'tooltip',
          props: tooltipConfig,
          on: tooltipConfig && tooltipConfig.enterable ? {
            leave: this.handleTooltipLeaveEvent
          } : null
        }) : _e(),
        /**
         * 校验不通过的 tooltip
         */
        hasTip && editRules && (validOpts.message === 'default' ? !height : validOpts.message === 'tooltip') ? h('vue-xtable-tooltip', {
          class: 'vue-xtable-table--valid-error',
          props: validOpts.message === 'tooltip' || tableData.length === 1 ? vaildTipOpts : null,
          ref: 'validTip'
        }) : _e()])]);
      },
      methods: mod.methods
    };
    
    return VueXtable;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableColumn = definition(context.tools, context.cell);
  }
})(this, function(tools, cell) {
  
  var props = {
    // 渲染类型 index,radio,checkbox,expand,drag
    type: String,
    // 在 v3.0 中废弃 prop
    prop: String,
    // 在 v3.0 中废弃 label
    label: String,
    // 列属性
	field: [String,Array],
    // 列标题
    title: String,
    // 列宽度
    width: [Number, String],
    // 列最小宽度，把剩余宽度按比例分配
    minWidth: [Number, String],
    // 是否允许拖动列宽调整大小
    resizable: {
      type: Boolean,
      default: null
    },
    // 将列固定在左侧或者右侧
    fixed: String,
    // 列对其方式
    align: String,
    // 表头对齐方式
    headerAlign: String,
    // 表尾列的对齐方式
    footerAlign: String,
    // 当内容过长时显示为省略号
    showOverflow: {
      type: [Boolean, String],
      default: null
    },
    // 当表头内容过长时显示为省略号
    showHeaderOverflow: {
      type: [Boolean, String],
      default: null
    },
    // 给单元格附加 className
    className: [String, Function],
    // 给表头单元格附加 className
    headerClassName: [String, Function],
    // 给表尾单元格附加 className
    footerClassName: [String, Function],
    // 格式化显示内容
    formatter: [Function, Array, String],
    // 自定义索引方法
    indexMethod: Function,
    // 是否允许排序
    sortable: Boolean,
    // 是否服务端排序
    remoteSort: {
      type: Boolean,
      default: null
    },
    // 自定义排序的属性
    sortBy: [String, Array],
    // 自定义排序方法
    sortMethod: Function,
    // 配置筛选条件数组
    filters: Array,
    // 筛选是否允许多选
    filterMultiple: {
      type: Boolean,
      default: true
    },
    // 自定义筛选方法
    filterMethod: Function,
    // 筛选模板配置项
    filterRender: Object,
    // 指定为树节点
    treeNode: Boolean,
    // 单元格渲染配置项
    cellRender: Object,
    // 单元格编辑渲染配置项
    editRender: Object,
    // 复制时值的格式化方法
    copyFormatter: [Function, Array, String],
    // 黏贴时值的格式化方法
    pasteFormatter: [Function, Array, String],
    // 额外的参数
    params: Object,
    visible: {
      type: Boolean,
      default: true
    }
  };
  var watch = {};
  VueUtil.keys(props).forEach(function (name) {
    watch[name] = function (value) {
      this.columnConfig.update(name, value);
      this.$table.refreshColumn();
    };
  });
  var VueXtableColumn = {
    name: 'VueXtableColumn',
    props: props,
    provide: function provide() {
      return {
        $column: this
      };
    },
    inject: {
      $table: {
        default: null
      },
      $column: {
        default: null
      }
    },
    watch: watch,
    created: function created() {
      this.columnConfig = this.createColumn(this.$table, this);
    },
    mounted: function mounted() {
      tools.UtilTools.assemColumn(this);
    },
    destroyed: function destroyed() {
      var self = this;
      VueUtil.remove(this.$table.sortingColumns, function(column) {
        return column.id && column.id === self.columnConfig.id;
      });

      tools.UtilTools.destroyColumn(this);
    },
    render: function render(h) {
      return h('div', this.$slots.default);
    },
    methods: cell
  };
  
  return VueXtableColumn;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableTooltip = definition(context.tools, context.baseTable);
  }
})(this, function(tools) {

  var VueXtableTooltip = {
    name: 'VueXtableTooltip',
    props: {
      value: Boolean,
      trigger: {
        type: String,
        default: function _default() {
          return GlobalConfig.tooltip.trigger;
        }
      },
      theme: {
        type: String,
        default: function _default() {
          return GlobalConfig.tooltip.theme;
        }
      },
      content: [String, Function],
      zIndex: [String, Number],
      isArrow: {
        type: Boolean,
        default: true
      },
      enterable: Boolean,
      leaveDelay: {
        type: Number,
        default: GlobalConfig.tooltip.leaveDelay
      }
    },
    data: function data() {
      return {
        isUpdate: false,
        isHover: false,
        visible: false,
        message: '',
        tipZindex: 0,
        tipStore: {
          style: {},
          placement: '',
          arrowStyle: null
        }
      };
    },
    watch: {
      content: function content(value) {
        this.message = value;
      },
      value: function value(_value) {
        if (!this.isUpdate) {
          this[_value ? 'show' : 'close']();
        }
  
        this.isUpdate = false;
      }
    },
    mounted: function mounted() {
      var $el = this.$el,
          trigger = this.trigger,
          content = this.content,
          value = this.value;
      var parentNode = $el.parentNode;
      var target;
      this.message = content;
      this.tipZindex = tools.UtilTools.nextZIndex();
      VueUtil.values($el.children).forEach(function (elem, index) {
        if (index > 1) {
          parentNode.insertBefore(elem, $el);
  
          if (!target) {
            target = elem;
          }
        }
      });
      parentNode.removeChild($el);
      this.target = target;
  
      if (target) {
        if (trigger === 'hover') {
          target.onmouseleave = this.targetMouseleaveEvent;
          target.onmouseenter = this.targetMouseenterEvent;
        } else if (trigger === 'click') {
          target.onclick = this.clickEvent;
        }
      }
  
      if (value) {
        this.show();
      }
    },
    beforeDestroy: function beforeDestroy() {
      var $el = this.$el,
          target = this.target,
          trigger = this.trigger;
      var parentNode = $el.parentNode;
  
      if (parentNode) {
        parentNode.removeChild($el);
      }
  
      if (target) {
        if (trigger === 'hover') {
          target.onmouseenter = null;
          target.onmouseleave = null;
        } else if (trigger === 'click') {
          target.onclick = null;
        }
      }
    },
    render: function render(h) {
      var theme = this.theme,
          message = this.message,
          isHover = this.isHover,
          isArrow = this.isArrow,
          visible = this.visible,
          tipStore = this.tipStore,
          enterable = this.enterable;
      var on = null;
  
      if (enterable) {
        on = {
          mouseenter: this.wrapperMouseenterEvent,
          mouseleave: this.wrapperMouseleaveEvent
        };
      }
  
      return h('div', {
        class: ['vue-xtable-table--tooltip-wrapper', 'theme--'.concat(theme), 'placement--'.concat(tipStore.placement), {
          'is--enterable': enterable,
          'is--visible': visible,
          'is--arrow': isArrow,
          'is--hover': isHover
        }],
        style: tipStore.style,
        ref: 'tipWrapper',
        on: on
      }, [h('div', {
        class: 'vue-xtable-table--tooltip-content'
      }, this.$slots.content || message), h('div', {
        class: 'vue-xtable-table--tooltip-arrow',
        style: tipStore.arrowStyle
      })].concat(this.$slots.default));
    },
    methods: {
      show: function show() {
        return this.toVisible(this.target);
      },
      close: function close() {
        VueUtil.assign(this.tipStore, {
          style: {},
          placement: '',
          arrowStyle: null
        });
        this.update(false);
        return this.$nextTick();
      },
      update: function update(value) {
        if (value !== this.visible) {
          this.visible = value;
          this.isUpdate = true;
  
          if (this.$listeners.input) {
            this.$emit('input', this.visible);
          }
        }
      },
      updateZindex: function updateZindex() {
        if (this.tipZindex < tools.UtilTools.getLastZIndex()) {
          this.tipZindex = tools.UtilTools.nextZIndex();
        }
      },
      toVisible: function toVisible(target, message) {
        var _this = this;
  
        this.targetActive = true;
  
        if (target) {
          var $el = this.$el,
              tipStore = this.tipStore,
              zIndex = this.zIndex;
  
          var _DomTools$getAbsolute = tools.DomTools.getAbsolutePos(target),
              top = _DomTools$getAbsolute.top,
              left = _DomTools$getAbsolute.left;
  
          var _DomTools$getDomNode = tools.DomTools.getDomNode(),
              scrollTop = _DomTools$getDomNode.scrollTop,
              scrollLeft = _DomTools$getDomNode.scrollLeft,
              visibleWidth = _DomTools$getDomNode.visibleWidth;
  
          var parentNode = $el.parentNode;
          var tipLeft = left;
          tipStore.placement = 'top';
          tipStore.style = {
            width: 'auto'
          };
          tipStore.arrowStyle = {
            left: '50%'
          };
  
          if (!parentNode) {
            document.body.appendChild($el);
          }
  
          if (message) {
            this.message = message;
          }
  
          this.update(true);
          this.updateZindex();
          return this.$nextTick().then(function () {
            var wrapperElem = $el;
  
            if (wrapperElem) {
              var clientHeight = wrapperElem.clientHeight;
              var clientWidth = (parseFloat(getComputedStyle(wrapperElem).width) || 0);
              tipLeft = left + Math.floor((target.offsetWidth - clientWidth) / 2);
              tipStore.style = {
                zIndex: zIndex || _this.tipZindex,
                width: ''.concat(clientWidth, 'px'),
                top: ''.concat(top - clientHeight - 6, 'px'),
                left: ''.concat(tipLeft, 'px')
              };
              return _this.$nextTick();
            }
          }).then(function () {
            var wrapperElem = $el;
  
            if (wrapperElem) {
              var clientHeight = wrapperElem.clientHeight;
              var clientWidth = wrapperElem.clientWidth;
              VueUtil.assign(tipStore.style, {
                top: ''.concat(top - clientHeight - 6, 'px'),
                left: ''.concat(tipLeft, 'px')
              });
  
              if (top - clientHeight < scrollTop + 6) {
                tipStore.placement = 'bottom';
                tipStore.style.top = ''.concat(top + target.offsetHeight + 6, 'px');
              }
  
              if (tipLeft < scrollLeft + 6) {
                // 超出左边界
                tipLeft = scrollLeft + 6;
                tipStore.arrowStyle.left = ''.concat(left > tipLeft + 16 ? left - tipLeft + 16 : 16, 'px');
                tipStore.style.left = ''.concat(tipLeft, 'px');
              } else if (tipLeft + clientWidth > scrollLeft + visibleWidth) {
                // 超出右边界
                tipLeft = scrollLeft + visibleWidth - clientWidth - 6;
                tipStore.arrowStyle.left = ''.concat(clientWidth - Math.max(Math.floor((tipLeft + clientWidth - left) / 2), 22), 'px');
                tipStore.style.left = ''.concat(tipLeft, 'px');
              }
            }
          });
        }
  
        return this.$nextTick();
      },
      clickEvent: function clickEvent(event) {
        this[this.visible ? 'close' : 'show']();
      },
      targetMouseenterEvent: function targetMouseenterEvent(evnt) {
        this.show();
      },
      targetMouseleaveEvent: function targetMouseleaveEvent(evnt) {
        var _this2 = this;
  
        var trigger = this.trigger,
            enterable = this.enterable,
            leaveDelay = this.leaveDelay;
        this.targetActive = false;
  
        if (enterable && trigger === 'hover') {
          setTimeout(function () {
            if (!_this2.isHover) {
              _this2.close();
            }
          }, leaveDelay);
        } else {
          this.close();
        }
      },
      wrapperMouseenterEvent: function wrapperMouseenterEvent(evnt) {
        this.isHover = true;
      },
      wrapperMouseleaveEvent: function wrapperMouseleaveEvent(evnt) {
        var _this3 = this;
  
        var $listeners = this.$listeners,
            trigger = this.trigger,
            enterable = this.enterable,
            leaveDelay = this.leaveDelay;
        this.isHover = false;
  
        if ($listeners.leave) {
          this.$emit('leave', evnt);
        } else if (enterable && trigger === 'hover') {
          setTimeout(function () {
            if (!_this3.targetActive) {
              _this3.close();
            }
          }, leaveDelay);
        }
      }
    }
  };
  return VueXtableTooltip;
});
(function (context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableToolbar = definition(context.tools, context.baseTable);
  }
})(this, function (tools, baseTable) {

  var vueFixedPanel = {
    template: '<div class="vue-xtable-toolbar-fixed-panel">\
    <vue-form label-width="100px"> \
      <vue-form-item :label="$t(\'vue.table.leftPin\')"> \
        <vue-select ref="left" clearable v-model="left" multiple @change="leftPin" > \
          <vue-option v-for="(column, index) in options" :key="index" :label="column.label" :value="column.value"></vue-option> \
        </vue-select> \
      </vue-form-item> \
      <vue-form-item :label="$t(\'vue.table.rightPin\')"> \
        <vue-select ref="right" clearable v-model="right" multiple @change="rightPin"> \
          <vue-option v-for="(column, index) in options" :key="index" :label="column.label" :value="column.value"></vue-option> \
        </vue-select> \
      </vue-form-item> \
      </vue-form>\
      </div>',
    props: ['toolbar','tableFullColumn', 'visible'],
    data: function(){
      return {
        left:[],
        right:[],
      };
    },
    computed: {
      comp: function() {
        var $grid = this.toolbar.$grid,
          $table = this.toolbar.$table;
        return $grid || $table;
      },
      cols: function() {
        var tableFullColumn = this.tableFullColumn;
        return tableFullColumn.filter(function(column) {
          var property = column.property,
            visible = column.visible,
            own = column.own;
          var headerTitle = tools.UtilTools.getFuncText(own.title || own.label);
          return visible && property && headerTitle;
        });
      },
      options: function() {
        return this.cols.map(function (column) {
          var property = column.property,
            own = column.own;
          var headerTitle = tools.UtilTools.getFuncText(own.title || own.label);
          return property && headerTitle ? {
            value: property,
            label: headerTitle
          } : null;
        });
      }
    },
    methods: {
      leftPin: function(columns) {
        var self = this;
        VueUtil.loop(this.cols, function(column) {
          if (column.fixed === 'left') {
            column.fixed = false;
          }
        });
        VueUtil.loop(columns, function(property) {
          var rightIndex = self.right.indexOf(property);
          if (rightIndex !== -1) self.right.splice(rightIndex, 1);
          self.comp.getColumnByField(property).fixed = 'left';
        });

        this.comp.refreshColumn();
      },
      rightPin: function(columns) {
        var self = this;
        VueUtil.loop(this.cols, function(column) {
          if (column.fixed === 'right') {
            column.fixed = false;
          }
        });
        VueUtil.loop(columns, function(property) {
          var leftIndex = self.left.indexOf(property);
          if (leftIndex !== -1) self.left.splice(leftIndex, 1);
          self.comp.getColumnByField(property).fixed = 'right';
        });

        this.comp.refreshColumn();
      },
      updateFixed: function(val) {
        this.left = val.filter(function(column) {
          return column.fixed == 'left';
        }).map(function(column) {
          return column.property;
        });

        this.right = val.filter(function(column) {
          return column.fixed == 'right';
        }).map(function(column) {
          return column.property;
        });
      }
    },
    watch: {
      visible: function(val) {
        if(!val) {
          this.$refs.left.handleClose();
          this.$refs.right.handleClose();
        }
      },
      cols: function(val) {
        this.updateFixed(val);
      }
    },
  };


  var _defineProperty = tools.UtilTools.defineProperty;
  var VueXtableToolbar = {
    name: 'VueToolbar',
    components: { 'vue-fixed-panel': vueFixedPanel },
    props: {
      id: String,
      loading: false,
      resizable: {
        type: [Boolean, Object],
        default: function _default() {
          return GlobalConfig.toolbar.resizable;
        }
      },
      addRow: {
        type: [Boolean, Object],
        default: function _default() {
          return GlobalConfig.toolbar.addRow;
        }
      },
      insertRow: {
        type: [Boolean, Object],
        default: function _default() {
          return GlobalConfig.toolbar.insertRow;
        }
      },
      delRow: {
        type: [Boolean, Object],
        default: function _default() {
          return GlobalConfig.toolbar.delRow;
        }
      },
      refresh: {
        type: [Boolean, Object],
        default: function _default() {
          return GlobalConfig.toolbar.refresh;
        }
      },
      import: {
        type: [Boolean, Object],
        default: function _default() {
          return GlobalConfig.toolbar.import;
        }
      },
      export: {
        type: [Boolean, Object],
        default: function _default() {
          return GlobalConfig.toolbar.export;
        }
      },
      setting: {
        type: [Boolean, Object],
        default: function _default() {
          return GlobalConfig.toolbar.setting;
        }
      },
      fixed: {
        type: [Boolean, Object],
        default: function _default() {
          return GlobalConfig.toolbar.fixed;
        }
      },
      buttons: {
        type: Array,
        default: function _default() {
          return GlobalConfig.toolbar.buttons;
        }
      },
      size: String,
      data: Array,
      customs: Array
    },
    inject: {
      $grid: {
        default: null
      }
    },
    data: function data() {
      return {
        $table: null,
        comp: null,
        isRefresh: false,
        tableFullColumn: [],
        importStore: {
          file: null,
          type: '',
          filename: '',
          visible: false
        },
        importParams: {
          mode: '',
          types: null,
          message: true
        },
        exportStore: {
          name: '',
          mode: '',
          columns: [],
          selectRecords: [],
          hasFooter: false,
          forceOriginal: false,
          visible: false
        },
        exportParams: {
          filename: '',
          sheetName: '',
          type: '',
          types: [],
          original: false,
          message: true,
          isHeader: false,
          isFooter: false,
          isPrint: true,
        },
        settingStore: {
          visible: false,
          fixedVisible: false,
        }
      };
    },
    computed: {
      vSize: function vSize() {
        return this.size || this.$parent.size || this.$parent.vSize;
      },
      refreshOpts: function refreshOpts() {
        return VueUtil.assign({}, GlobalConfig.toolbar.refresh, this.refresh);
      },
      importOpts: function importOpts() {
        return VueUtil.assign({}, GlobalConfig.toolbar.import, typeof this.import == 'object' ? this.import : {display: this.import});
      },
      exportOpts: function exportOpts() {
        return VueUtil.assign({}, GlobalConfig.toolbar.export, typeof this.export == 'object' ? this.export : {display: this.export});
      },
      resizableOpts: function resizableOpts() {
        return VueUtil.assign({
          storageKey: 'VUE_XTABLE_CUSTOM_COLUMN_WIDTH'
        }, GlobalConfig.toolbar.resizable, this.resizable);
      },
      settingOpts: function settingOpts() {
        return VueUtil.assign({
          storageKey: 'VUE_XTABLE_CUSTOM_COLUMN_HIDDEN'
        }, GlobalConfig.toolbar.setting, this.setting);
      },
      fixedOpts: function fixedOpts() {
        return VueUtil.assign({
          storageKey: 'VUE_XTABLE_CUSTOM_COLUMN_FIXED'
        }, GlobalConfig.toolbar.fixed, this.fixed);
      },
      disableDelRow: function() {
        var comp = this.comp;
        if(!this.comp) {
          return true;
        }

        var checkboxConfig = comp.checkboxConfig || comp.selectConfig || {};
        if ((comp.selection && comp.selection.length > 0) || comp.selectRow) {
          // checkbox选中或radio选中
          return false;
        } else if (checkboxConfig.checkField) {
          // 配置了checkField，判断选中项大于0
          return comp.getSelectRecords().length === 0;
        } else if (comp.highlightCurrentRow && comp.getCurrentRow()){
          // 单选，且有选中
          return false;
        }

        return true;
      }
    },
    created: function created() {
      var _this = this;

      var settingOpts = this.settingOpts,
        id = this.id,
        customs = this.customs;

      if (customs) {
        this.tableFullColumn = customs;
      }

      if (settingOpts.storage && !id) {
        return tools.UtilTools.error('vue.xtable.error.toolbarId');
      }

      if (!baseTable._export && (this.export || this.import)) {
        tools.UtilTools.error('vue.xtable.error.reqModule', ['Export']);
      }

      this.$nextTick(function () {
        _this.updateConf();

        _this.loadStorage();
      });

      tools.GlobalEvent.on(this, 'mousedown', this.handleGlobalMousedownEvent);

      tools.GlobalEvent.on(this, 'blur', this.handleGlobalBlurEvent);
    },
    destroyed: function destroyed() {
      tools.GlobalEvent.off(this, 'mousedown');

      tools.GlobalEvent.off(this, 'blur');
    },
    render: function render(h) {
      var _ref,
        _this2 = this;

      var _e = this._e,
        $scopedSlots = this.$scopedSlots,
        $grid = this.$grid,
        $table = this.$table,
        loading = this.loading,
        settingStore = this.settingStore,
        addRow = this.addRow,
        insertRow = this.insertRow,
        delRow = this.delRow,
        refresh = this.refresh,
        setting = this.setting,
        settingOpts = this.settingOpts,
        _this$buttons = this.buttons,
        buttons = _this$buttons === void 0 ? [] : _this$buttons,
        vSize = this.vSize,
        tableFullColumn = this.tableFullColumn,
        importStore = this.importStore,
        importParams = this.importParams,
        exportStore = this.exportStore,
        fixed = this.fixed,
        exportParams = this.exportParams;
      var customBtnOns = {};
      var customWrapperOns = {};
      var $buttons = $scopedSlots.buttons;
      var $tools = $scopedSlots.tools;

      if (setting || fixed) {
        if (settingOpts.trigger === 'manual') {// 手动触发
        } else if (settingOpts.trigger === 'hover') {
          // hover 触发
          customBtnOns.mouseenter = this.handleMouseenterSettingEvent;
          customBtnOns.mouseleave = this.handleMouseleaveSettingEvent;
          customWrapperOns.mouseenter = this.handleWrapperMouseenterEvent;
          customWrapperOns.mouseleave = this.handleWrapperMouseleaveEvent;
        } else {
          // 点击触发
          customBtnOns.click = this.handleClickSettingEvent;
        }
      }

      return h('div', {
        class: ['vue-xtable-toolbar', (_ref = {}, _defineProperty(_ref, 'size--'.concat(vSize), vSize), _defineProperty(_ref, 'is--loading', loading), _ref)]
      }, [h('div', {
        class: 'vue-xtable-button--wrapper'
      }, $buttons ? $buttons.call(this, {
        $grid: $grid,
        $table: $table
      }, h) : buttons.map(function (item) {
        return item.visible === false ? _e() : h(item.dropdowns && item.dropdowns.length ? 'vue-dropdown' : 'vue-button', {
          on: {
            click: function click(evnt) {
              return _this2.btnEvent(evnt, item);
            }
          },
          props: {
            disabled: item.disabled
          },
        }, item.dropdowns && item.dropdowns.length ? [
          h('vue-button', null, [tools.UtilTools.getFuncText(item.name),
          h('i', {
            class: 'vue-icon-arrow-down vue-icon--right'
          })
          ]),
          h('vue-dropdown-menu', {
            slot: 'dropdown'
          }, item.dropdowns.map(function (child) {
            return child.visible === false ? _e() : h('vue-dropdown-item', {
              nativeOn: {
                click: function click(evnt) {
                  return _this2.btnEvent(evnt, child);
                }
              },
              props: {
                disabled: child.disabled
              }
            }, tools.UtilTools.getFuncText(child.name));
          }))
        ] : tools.UtilTools.getFuncText(item.name));
      })), h('div', {
        class: 'vue-xtable-tools--operate'
      }, [
        
        addRow ? h('vue-button', {
          class: ['vue-xtable-add-row--btn', 'toolbar-right-btn'],
          props: {
            type: 'text',
            icon: GlobalConfig.icon.addRow,
          },
          attrs: {
            title: GlobalConfig.i18n('vue.xtable.toolbar.addRow')
          },
          on: {
            click: this.addRowEvent
          }
        }) : null,


        insertRow ? h('vue-button', {
          class: ['vue-xtable-insert-row--btn', 'toolbar-right-btn'],
          props: {
            type: 'text',
            icon: GlobalConfig.icon.insertRow,
          },
          attrs: {
            title: GlobalConfig.i18n('vue.xtable.toolbar.insertRow')
          },
          on: {
            click: this.insertRowEvent
          }
        }) : null,

        delRow ? h('vue-button', {
          class: ['vue-xtable-del-row--btn', 'toolbar-right-btn'],
          props: {
            type: 'text',
            icon: GlobalConfig.icon.delRow,
            disabled: this.disableDelRow
          },
          attrs: {
            title: GlobalConfig.i18n('vue.xtable.toolbar.delRow')
          },
          on: {
            click: this.delRowEvent
          }
        }) : null,
        
        
        
        this.importOpts.display ? h('vue-button', {
        class: ['vue-xtable-export--btn', 'toolbar-right-btn'],
        props: {
          type: 'text',
          icon: GlobalConfig.icon.import,
        },
        attrs: {
          title: GlobalConfig.i18n('vue.xtable.toolbar.impConfirm')
        },
        on: {
          click: this.importEvent
        }
      }) : null, this.exportOpts.display ? h('vue-button', {
        class: ['vue-xtable-export--btn', 'toolbar-right-btn'],
        props: {
          type: 'text',
          icon: GlobalConfig.icon.export
        },
        attrs: {
          title: GlobalConfig.i18n('vue.xtable.toolbar.expConfirm')
        },
        on: {
          click: this.exportEvent
        }
      }) : null, refresh ? h('vue-button', {
        class: ['vue-xtable-refresh--btn', 'toolbar-right-btn'],
        props: {
          type: 'text',
          icon: GlobalConfig.icon.refresh,
          loading: this.isRefresh
        },
        attrs: {
          title: GlobalConfig.i18n('vue.xtable.toolbar.refresh')
        },
        on: {
          click: this.refreshEvent
        }
      }) : null,

      setting ? h('div', {
        class: ['vue-xtable-custom--wrapper', 'toolbar-right-btn', {
          'is--active': settingStore.visible
        }],
        ref: 'customWrapper'
      }, [h('div', {
        class: 'vue-xtable-custom--setting-btn',
        on: customBtnOns
      }, [h('i', {
        class: GlobalConfig.icon.custom
      })]), h('div', {
        class: 'vue-xtable-custom--option-wrapper'
      }, [h('div', {
        class: 'vue-xtable-custom--option',
        on: customWrapperOns
      }, tableFullColumn.map(function (column) {
        var property = column.property,
          visible = column.visible,
          own = column.own;

        var headerTitle = tools.UtilTools.getFuncText(own.title || own.label);

        return property && headerTitle ? h('vue-checkbox', {
          props: {
            value: visible,
            disabled: settingOpts.checkMethod ? !settingOpts.checkMethod({
              column: column
            }) : false
          },
          attrs: {
            title: headerTitle
          },
          on: {
            input: function change(value) {
              column.visible = value;

              if (setting && settingOpts.immediate) {
                _this2.updateSetting();
              }
            },
          }
        }, headerTitle) : null;
      }))])]) : null

        , fixed ? h('div', {
          class: ['vue-xtable-custom--wrapper', 'vue-xtable-fixed--wrapper', 'toolbar-right-btn', {
            'is--active': settingStore.fixedVisible
          }],
          ref: 'fixedWrapper'
        }, [h('div', {
          class: 'vue-xtable-custom--setting-btn',
          on: customBtnOns
        }, [h('i', {
          class: GlobalConfig.icon.fixed
        })]), h('div', {
          class: 'vue-xtable-custom--option-wrapper'
        }, [h('div', {
          class: 'vue-xtable-custom--option',
          on: customWrapperOns
        },
          [h('vue-fixed-panel',  {
            props: {
              visible: settingStore.fixedVisible,
              tableFullColumn: tableFullColumn,
              toolbar: _this2
            }
          })]
          )
        ]
        )]) : null]),

      baseTable._export ? h('vue-xtable-import-panel', {
        props: {
          defaultOptions: importParams,
          storeData: importStore
        },
        on: {
          import: this.confirmImportEvent
        }
      }) : _e(),

      baseTable._export ? h('vue-xtable-export-panel', {
        props: {
          defaultOptions: exportParams,
          storeData: exportStore
        },
        on: {
          print: this.confirmPrintEvent,
          export: this.confirmExportEvent
        }
      }) : _e(),

      $tools ? h('div', {
        class: 'vue-xtable-tools--wrapper'
      }, $tools.call(this, {
        $grid: $grid,
        $table: $table
      }, h)) : null]);
    },
    methods: {
      updateConf: function updateConf() {
        var $parent = this.$parent,
          data = this.data;
        var $children = $parent.$children;
        var selfIndex = $children.indexOf(this);
        this.$table = VueUtil.find($children, function (comp, index) {
          return comp && comp.refreshColumn && index > selfIndex && (data ? comp.data === data : comp.$vnode.componentOptions.tag === 'vue-xtable');
        });

        this.comp = this.$table || this.$grid;
      },
      openSetting: function openSetting() {
        this.settingStore.visible = true;
      },
      openFixedSetting: function () {
        this.settingStore.fixedVisible = true;
      },
      closeSetting: function closeSetting() {
        var setting = this.setting,
          settingStore = this.settingStore;
        if (settingStore.visible) {
          settingStore.visible = false;

          if (setting && !settingStore.immediate) {
            this.updateSetting();
          }
        }
        if (settingStore.fixedVisible) {
          settingStore.fixedVisible = false;

          if (setting && !settingStore.immediate) {
            this.updateFixed();
          }
        }
      },
      loadStorage: function loadStorage() {
        var $grid = this.$grid,
          $table = this.$table,
          id = this.id,
          refresh = this.refresh,
          resizable = this.resizable,
          setting = this.setting,
          refreshOpts = this.refreshOpts,
          resizableOpts = this.resizableOpts,
          settingOpts = this.settingOpts,
          fixedOpts = this.fixedOpts;

        if (refresh && !$grid) {
          if (!refreshOpts.query) {
            tools.UtilTools.warn('vue.xtable.error.notFunc', ['query']);
          }
        }

        if ($grid || $table) {
          ($grid || $table).connect({
            toolbar: this
          });
        } else {
          if (resizable || setting) {
            throw new Error(tools.UtilTools.getLog('vue.xtable.error.barUnableLink'));
          }
        }

        if (resizable || setting) {
          var customMap = {};

          if (resizableOpts.storage) {
            var columnWidthStorage = this.getStorageMap(resizableOpts.storageKey)[id];

            if (columnWidthStorage) {
              VueUtil.forEach(columnWidthStorage, function (resizeWidth, field) {
                customMap[field] = {
                  field: field,
                  resizeWidth: resizeWidth
                };
              });
            }
          }

          if (settingOpts.storage) {
            var columnHideStorage = this.getStorageMap(settingOpts.storageKey)[id];

            if (columnHideStorage) {
              columnHideStorage.split(',').forEach(function (field) {
                if (customMap[field]) {
                  customMap[field].visible = false;
                } else {
                  customMap[field] = {
                    field: field,
                    visible: false
                  };
                }
              });
            }
          }

          if (fixedOpts.storage) {
            var columnFixedStorage = this.getStorageMap(fixedOpts.storageKey)[id];

            if (columnFixedStorage) {
              VueUtil.forEach(columnFixedStorage, function (fixed, field) {
                if (customMap[field]) {
                  customMap[field].fixed = fixed;
                } else {
                  customMap[field] = {
                    field: field,
                    fixed: fixed
                  };
                }
              });
            }
          }
          var customList = VueUtil.values(customMap);
          this.updateCustoms(customList.length ? customList : this.tableFullColumn);
        }
      },
      updateColumn: function updateColumn(fullColumn) {
        this.tableFullColumn = fullColumn;
      },
      updateCustoms: function updateCustoms(customs) {
        var _this3 = this;

        var $grid = this.$grid,
          $table = this.$table;
        var comp = $grid || $table;

        if (comp) {
          comp.reloadCustoms(customs).then(function (fullColumn) {
            _this3.tableFullColumn = fullColumn;
          });
        }
      },
      getStorageMap: function getStorageMap(key) {
        var version = GlobalConfig.version;
        var rest = JSON.parse(localStorage.getItem(key));
        return rest && rest._v === version ? rest : {
          _v: version
        };
      },
      saveColumnHide: function saveColumnHide() {
        var id = this.id,
          tableFullColumn = this.tableFullColumn,
          settingOpts = this.settingOpts;

        if (settingOpts.storage) {
          var columnHideStorageMap = this.getStorageMap(settingOpts.storageKey);
          var colHides = tableFullColumn.filter(function (column) {
            return column.property && !column.visible;
          });
          columnHideStorageMap[id] = colHides.length ? colHides.map(function (column) {
            return column.property;
          }).join(',') : undefined;
          localStorage.setItem(settingOpts.storageKey, JSON.stringify(columnHideStorageMap));
        }

        return this.$nextTick();
      },
      saveColumnWidth: function saveColumnWidth(isReset) {
        var id = this.id,
          tableFullColumn = this.tableFullColumn,
          resizableOpts = this.resizableOpts;

        if (resizableOpts.storage) {
          var columnWidthStorageMap = this.getStorageMap(resizableOpts.storageKey);
          var columnWidthStorage;

          if (!isReset) {
            columnWidthStorage = VueUtil.isObject(columnWidthStorageMap[id]) ? columnWidthStorageMap[id] : {};
            tableFullColumn.forEach(function (_ref2) {
              var property = _ref2.property,
                resizeWidth = _ref2.resizeWidth,
                renderWidth = _ref2.renderWidth;

              if (property && resizeWidth) {
                columnWidthStorage[property] = renderWidth;
              }
            });
          }

          columnWidthStorageMap[id] = VueUtil.isEmpty(columnWidthStorage) ? undefined : columnWidthStorage;
          localStorage.setItem(resizableOpts.storageKey, JSON.stringify(columnWidthStorageMap));
        }

        return this.$nextTick();
      },

      saveColumnFixed: function () {
        var id = this.id,
          tableFullColumn = this.tableFullColumn,
          fixedOpts = this.fixedOpts;

        if (fixedOpts.storage) {
          var columnFixedStorageMap = this.getStorageMap(fixedOpts.storageKey);
          var columnFixedStorage = {};
          var colFixed = tableFullColumn.filter(function (column) {
            return column.property && column.fixed;
          });

          colFixed.forEach(function (col) {
            columnFixedStorage[col.property] = col.fixed;
          });

          columnFixedStorageMap[id] = VueUtil.isEmpty(columnFixedStorage) ? undefined : columnFixedStorage;
          localStorage.setItem(fixedOpts.storageKey, JSON.stringify(columnFixedStorageMap));
        }
        return this.$nextTick();
      },

      hideColumn: function hideColumn(column) {
        tools.UtilTools.warn('vue.xtable.error.delFunc', ['hideColumn', 'table.hideColumn']);

        column.visible = false;
        return this.updateSetting();
      },
      showColumn: function showColumn(column) {
        tools.UtilTools.warn('vue.xtable.error.delFunc', ['showColumn', 'table.showColumn']);

        column.visible = true;
        return this.updateSetting();
      },
      resetCustoms: function resetCustoms() {
        return this.updateSetting();
      },
      resetResizable: function resetResizable() {
        this.updateResizable(this);
      },
      updateResizable: function updateResizable(isReset) {
        var $grid = this.$grid,
          $table = this.$table;
        var comp = $grid || $table;
        this.saveColumnWidth(isReset);
        comp.analyColumnWidth();
        return comp.recalculate(true);
      },
      updateSetting: function updateSetting() {
        (this.$grid || this.$table).refreshColumn();
        return this.saveColumnHide();
      },
      updateFixed: function updateFixed() {
        (this.$grid || this.$table).refreshColumn();
        return this.saveColumnFixed();
      },
      handleGlobalMousedownEvent: function handleGlobalMousedownEvent(evnt) {
        var warpper = this.isFixedEvent(evnt) ? this.$refs.fixedWrapper : this.$refs.customWrapper;
        if (!tools.DomTools.getEventTargetNode(evnt, warpper).flag) {
          this.closeSetting();
        }
      },
      handleGlobalBlurEvent: function handleGlobalBlurEvent(evnt) {
        this.closeSetting();
      },
      isFixedEvent: function(evnt) {
        return tools.DomTools.getEventTargetNode(evnt, this.$refs.fixedWrapper).flag;
      },
      handleClickSettingEvent: function handleClickSettingEvent(evnt) {
        var settingStore = this.settingStore;
        var isFixed = this.isFixedEvent(evnt);
        if (isFixed) {
          settingStore.fixedVisible = !settingStore.fixedVisible;
          settingStore.visible = false;
        } else {
          settingStore.fixedVisible = false;
          settingStore.visible = !settingStore.visible;
        }
      },
      handleMouseenterSettingEvent: function handleMouseenterSettingEvent(evnt) {
        this.settingStore.activeBtn = true;
        this.openSetting();
      },
      handleMouseleaveSettingEvent: function handleMouseleaveSettingEvent(evnt) {
        var _this4 = this;

        var settingStore = this.settingStore;
        settingStore.activeBtn = false;
        setTimeout(function () {
          if (!settingStore.activeBtn && !settingStore.activeWrapper) {
            _this4.closeSetting();
          }
        }, 300);
      },
      // fix列
      handleWrapperMouseenterEvent: function handleWrapperMouseenterEvent(evnt) {
        this.settingStore.activeWrapper = true;
        this.openSetting();
      },
      handleWrapperMouseleaveEvent: function handleWrapperMouseleaveEvent(evnt) {
        var _this5 = this;

        var settingStore = this.settingStore;
        settingStore.activeWrapper = false;
        setTimeout(function () {
          if (!settingStore.activeBtn && !settingStore.activeWrapper) {
            _this5.closeSetting();
          }
        }, 300);
      },
      addRowEvent: function() {
        var $grid = this.$grid,
            $table = this.$table;
        var comp = $grid || $table;

        if(this.addRow.handler) {
          return this.addRow.handler(comp, 'add');
        }

        return comp.insertRow(-1, this.addRow.record, this.addRow.callback);
      },

      insertRowEvent: function() {
        var $grid = this.$grid,
            $table = this.$table;
        var comp = $grid || $table;

        if(this.insertRow.handler) {
          return this.insertRow.handler(comp, 'insert');
        }

        return comp.insertRow(this.insertRow.position, this.insertRow.record, this.insertRow.callback);
      },

      delRowEvent: function() {
        var $grid = this.$grid,
            $table = this.$table;
        var comp = $grid || $table;
        
        if(this.delRow.handler) {
          return this.delRow.handler(comp, 'del');
        }

        return comp.delRow(this.delRow.callback);
      },

      refreshEvent: function refreshEvent() {
        var _this6 = this;

        var $grid = this.$grid,
          refreshOpts = this.refreshOpts,
          isRefresh = this.isRefresh;

        if (!isRefresh) {
          if (refreshOpts.query) {
            this.isRefresh = true;
            refreshOpts.query().catch(function (e) {
              return e;
            }).then(function () {
              _this6.isRefresh = false;
            });
          } else if ($grid) {
            this.isRefresh = true;
            $grid.commitProxy('reload').catch(function (e) {
              return e;
            }).then(function () {
              _this6.isRefresh = false;
            });
          }
        }
      },
      btnEvent: function btnEvent(evnt, item) {
        var $grid = this.$grid,
          $table = this.$table;
        var code = item.code;

        if (code) {
          if ($grid) {
            $grid.triggerToolbarBtnEvent(item, evnt);
          } else {
            var btnMethod = baseTable.Buttons.get(code);

            var params = {
              code: code,
              button: item,
              $grid: $grid,
              $table: $table
            };

            if (btnMethod) {
              btnMethod.call(this, params, evnt);
            }

            tools.UtilTools.emitEvent(this, 'button-click', [params, evnt]);
          }
        }
      },
      importEvent: function importEvent() {
        this.openImport();
      },
      openImport: function openImport(options) {
        var importParams = this.importParams,
          importStore = this.importStore,
          importOpts = this.importOpts;
        var defOpts = VueUtil.assign({
          mode: 'covering',
          message: true
        }, options, importOpts);
        VueUtil.assign(importStore, {
          file: null,
          type: '',
          filename: '',
          visible: true
        });
        VueUtil.assign(importParams, defOpts);
      },
      confirmImportEvent: function confirmImportEvent(options) {
        var $grid = this.$grid,
          $table = this.$table;
        var comp = $grid || $table;
        comp.importByFile(this.importStore.file, options);
      },
      exportEvent: function exportEvent() {
        this.openExport();
      },
      openExport: function openExport(options) {
        var $grid = this.$grid,
          $table = this.$table,
          exportOpts = this.exportOpts,
          exportStore = this.exportStore,
          exportParams = this.exportParams;
        var comp = $grid || $table;

        var _comp$getTableColumn = comp.getTableColumn(),
          fullColumn = _comp$getTableColumn.fullColumn;

        var _comp$getTableData = comp.getTableData(),
          footerData = _comp$getTableData.footerData;

        var selectRecords = comp.getSelectRecords();
        var exportColumns = fullColumn.filter(function (column) {
          return column.type === 'index' || column.property && ['checkbox', 'selection', 'radio'].indexOf(column.type) === -1;
        });
        var treeStatus = comp.getTreeStatus();
        var forceOriginal = !!treeStatus;
        var hasFooter = !!footerData.length;
        var defOpts = VueUtil.assign({
          original: true,
          message: true,
          isPrint: true,
        }, exportOpts, options);
        var types = defOpts.types || baseTable.exportTypes; // 处理类型

        defOpts.types = types.map(function (value) {
          return {
            value: value,
            label: 'vue.xtable.types.'.concat(value)
          };
        }); // 索引列默认不选中

        exportColumns.forEach(function (column) {
          column.checked = column.type !== 'index';
        }); // 更新条件

        VueUtil.assign(exportStore, {
          columns: exportColumns,
          selectRecords: selectRecords,
          mode: selectRecords.length ? 'selected' : 'all',
          forceOriginal: !!treeStatus,
          hasFooter: !!footerData.length,
          visible: true
        }); // 重置参数

        VueUtil.assign(exportParams, {
          filename: defOpts.filename || '',
          sheetName: defOpts.sheetName || '',
          type: defOpts.type || defOpts.types[0].value,
          types: defOpts.types,
          original: forceOriginal || defOpts.original,
          message: defOpts.message,
          isPrint: defOpts.isPrint,
          isHeader: true,
          isFooter: hasFooter
        });
        return this.$nextTick();
      },
      confirmPrintEvent: function confirmPrintEvent(options) {
        (this.$grid || this.$table).print(options);
      },
      confirmExportEvent: function confirmExportEvent(options) {
        (this.$grid || this.$table).exportData(options);
      }
    },
  };

  return VueXtableToolbar;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtablePager = definition(context.tools);
  }
})(this, function(tools) {
  var VueXtablePager = {
    name: 'VueXtablePager',
    props: {
      size: String,
      // 自定义布局
      layouts: {
        type: Array,
        default: function _default() {
          return GlobalConfig.pager.layouts || ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total'];
        }
      },
      // 当前页
      currentPage: {
        type: Number,
        default: 1
      },
      // 加载中
      loading: Boolean,
      // 每页大小
      pageSize: {
        type: Number,
        default: function _default() {
          return GlobalConfig.pager.pageSize || 10;
        }
      },
      // 总条数
      total: {
        type: Number,
        default: 0
      },
      // 显示页码按钮的数量
      pagerCount: {
        type: Number,
        default: function _default() {
          return GlobalConfig.pager.pagerCount || 7;
        }
      },
      // 每页大小选项列表
      pageSizes: {
        type: Array,
        default: function _default() {
          return GlobalConfig.pager.pageSizes || [10, 15, 20, 50, 100];
        }
      },
      // 列对其方式
      align: String,
      // 带边框
      border: {
        type: Boolean,
        default: function _default() {
          return GlobalConfig.pager.border;
        }
      },
      // 带背景颜色
      background: {
        type: Boolean,
        default: function _default() {
          return GlobalConfig.pager.background;
        }
      },
      // 默认的样式
      perfect: {
        type: Boolean,
        default: function _default() {
          return GlobalConfig.pager.perfect;
        }
      }
    },
    inject: {
      $grid: {
        default: null
      }
    },
    data: function data() {
      return {
        showSizes: false,
        panelStyle: null,
        panelIndex: 0
      };
    },
    computed: {
      vSize: function vSize() {
        return this.size || this.$parent.size || this.$parent.vSize;
      },
      isSizes: function isSizes() {
        return this.layouts.some(function (name) {
          return name === 'Sizes';
        });
      },
      pageCount: function pageCount() {
        return this.getPageCount(this.total, this.pageSize);
      },
      numList: function numList() {
        return VueUtil.values(new Array(this.pageCount > this.pagerCount ? this.pagerCount - 2 : this.pagerCount));
      },
      offsetNumber: function offsetNumber() {
        return Math.floor((this.pagerCount - 2) / 2);
      }
    },
    created: function created() {
      this.panelIndex = tools.UtilTools.nextZIndex();
  
      tools.GlobalEvent.on(this, 'mousedown', this.handleGlobalMousedownEvent);
    },
    destroyed: function destroyed() {
      tools.GlobalEvent.off(this, 'mousedown');
    },
    render: function render(h) {
      var _ref,
          _this = this;
  
      var layouts = this.layouts,
          loading = this.loading,
          vSize = this.vSize,
          align = this.align,
          border = this.border,
          background = this.background,
          perfect = this.perfect;
      return h('div', {
        class: ['vue-xtable-pager', (_ref = {}, tools.UtilTools.defineProperty(_ref, 'size--'.concat(vSize), vSize), tools.UtilTools.defineProperty(_ref, 'align--'.concat(align), align), tools.UtilTools.defineProperty(_ref, 'p--border', border), tools.UtilTools.defineProperty(_ref, 'p--background', background), tools.UtilTools.defineProperty(_ref, 'p--perfect', perfect), tools.UtilTools.defineProperty(_ref, 'is--loading', loading), _ref)]
      }, layouts.map(function (name) {
        return _this['render'.concat(name)](h);
      }));
    },
    methods: {
      // 上一页
      renderPrevPage: function renderPrevPage(h) {
        var currentPage = this.currentPage;
        return h('span', {
          class: ['vue-xtable-pager--prev-btn', {
            'is--disabled': currentPage <= 1
          }],
          on: {
            click: this.prevPage
          }
        }, [h('i', {
          class: ['vue-xtable-icon--page-icon', GlobalConfig.icon.prevPage]
        })]);
      },
      // 向上翻页
      renderPrevJump: function renderPrevJump(h, tagName) {
        return h(tagName || 'span', {
          class: ['vue-xtable-pager--jump-prev', {
            'is--fixed': !tagName,
            'is--disabled': this.currentPage <= 1
          }],
          on: {
            click: this.prevJump
          }
        }, [tagName ? h('i', {
          class: 'vue-xtable-pager--jump-more vue-xtable-icon--more'
        }) : null, h('i', {
          class: ['vue-xtable-pager--jump-icon', GlobalConfig.icon.jumpPrev]
        })]);
      },
      // number
      renderNumber: function renderNumber(h) {
        return h('ul', {
          class: 'vue-xtable-pager--btn-wrapper'
        }, this.renderPageBtn(h));
      },
      // jumpNumber
      renderJumpNumber: function renderJumpNumber(h) {
        return h('ul', {
          class: 'vue-xtable-pager--btn-wrapper'
        }, this.renderPageBtn(h, true));
      },
      // 向下翻页
      renderNextJump: function renderNextJump(h, tagName) {
        var currentPage = this.currentPage,
            pageCount = this.pageCount;
        return h(tagName || 'span', {
          class: ['vue-xtable-pager--jump-next', {
            'is--fixed': !tagName,
            'is--disabled': currentPage >= pageCount
          }],
          on: {
            click: this.nextJump
          }
        }, [tagName ? h('i', {
          class: 'vue-xtable-pager--jump-more vue-xtable-icon--more'
        }) : null, h('i', {
          class: ['vue-xtable-pager--jump-icon', GlobalConfig.icon.jumpNext]
        })]);
      },
      // 下一页
      renderNextPage: function renderNextPage(h) {
        var currentPage = this.currentPage,
            pageCount = this.pageCount;
        return h('span', {
          class: ['vue-xtable-pager--next-btn', {
            'is--disabled': currentPage >= pageCount
          }],
          on: {
            click: this.nextPage
          }
        }, [h('i', {
          class: ['vue-xtable-icon--page-icon', GlobalConfig.icon.nextPage]
        })]);
      },
      // sizes
      renderSizes: function renderSizes(h) {
        var _this2 = this;
  
        var pageSizes = this.pageSizes,
            showSizes = this.showSizes,
            pageSize = this.pageSize,
            panelStyle = this.panelStyle;
        return h('span', {
          class: ['vue-xtable-pager--sizes', {
            'is--active': showSizes
          }],
          ref: 'sizeBtn'
        }, [h('span', {
          class: 'size--content',
          on: {
            click: this.toggleSizePanel
          }
        }, [h('span', ''.concat(pageSize).concat(GlobalConfig.i18n('vue.xtable.pager.pagesize'))), h('i', {
          class: 'vue-xtable-pager--sizes-arrow '.concat(GlobalConfig.icon.caretBottom)
        })]), h('div', {
          class: 'vue-xtable-pager-size--select-wrapper',
          style: panelStyle,
          ref: 'sizePanel'
        }, [h('ul', {
          class: 'vue-xtable-pager-size--select'
        }, pageSizes.map(function (num) {
          return h('li', {
            class: ['size--option', {
              'is--active': num === pageSize
            }],
            on: {
              click: function click() {
                return _this2.changePageSize(num);
              }
            }
          }, ''.concat(num).concat(GlobalConfig.i18n('vue.xtable.pager.pagesize')));
        }))])]);
      },
      // FullJump
      renderFullJump: function renderFullJump(h) {
        return this.renderJump(h, true);
      },
      // Jump
      renderJump: function renderJump(h, isFull) {
        var _this3 = this;
  
        var currentPage = this.currentPage,
            pageCount = this.pageCount;
        return h('span', {
          class: 'vue-xtable-pager--jump'
        }, [isFull ? h('span', {
          class: 'vue-xtable-pager--goto-text'
        }, GlobalConfig.i18n('vue.xtable.pager.goto')) : null, h('input', {
          class: 'vue-xtable-pager--goto',
          domProps: {
            value: currentPage
          },
          attrs: {
            type: 'text',
            autocomplete: 'off'
          },
          on: {
            keydown: function keydown(evnt) {
              if (evnt.keyCode === 13) {
                var value = (parseFloat(evnt.target.value) || 0);
                var current = value <= 0 ? 1 : value >= pageCount ? pageCount : value;
                evnt.target.value = current;
  
                _this3.jumpPage(current);
              } else if (evnt.keyCode === 38) {
                evnt.preventDefault();
  
                _this3.nextPage();
              } else if (evnt.keyCode === 40) {
                evnt.preventDefault();
  
                _this3.prevPage();
              }
            }
          }
        }), isFull ? h('span', {
          class: 'vue-xtable-pager--classifier-text'
        }, GlobalConfig.i18n('vue.xtable.pager.pageClassifier')) : null]);
      },
      // PageCount
      renderPageCount: function renderPageCount(h) {
        var pageCount = this.pageCount;
        return h('span', {
          class: 'vue-xtable-pager--count'
        }, [h('span', {
          class: 'vue-xtable-pager--separator'
        }, '/'), h('span', pageCount)]);
      },
      // total
      renderTotal: function renderTotal(h) {
        var total = this.total;
        return h('span', {
          class: 'vue-xtable-pager--total'
        }, this.$t('vue.xtable.pager.total', {total: total}));
      },
      // number
      renderPageBtn: function renderPageBtn(h, showJump) {
        var _this4 = this;
  
        var numList = this.numList,
            currentPage = this.currentPage,
            pageCount = this.pageCount,
            pagerCount = this.pagerCount,
            offsetNumber = this.offsetNumber;
        var nums = [];
        var isOv = pageCount > pagerCount;
        var isLt = isOv && currentPage > offsetNumber + 1;
        var isGt = isOv && currentPage < pageCount - offsetNumber;
        var startNumber = 1;
  
        if (isOv) {
          if (currentPage >= pageCount - offsetNumber) {
            startNumber = Math.max(pageCount - numList.length + 1, 1);
          } else {
            startNumber = Math.max(currentPage - offsetNumber, 1);
          }
        }
  
        if (showJump && isLt) {
          nums.push(h('li', {
            class: 'vue-xtable-pager--num-btn',
            on: {
              click: function click() {
                return _this4.jumpPage(1);
              }
            }
          }, 1), this.renderPrevJump(h, 'li'));
        }
  
        numList.forEach(function (item, index) {
          var number = startNumber + index;
  
          if (number <= pageCount) {
            nums.push(h('li', {
              class: ['vue-xtable-pager--num-btn', {
                'is--active': currentPage === number
              }],
              on: {
                click: function click() {
                  return _this4.jumpPage(number);
                }
              },
              key: number
            }, number));
          }
        });
  
        if (showJump && isGt) {
          nums.push(this.renderNextJump(h, 'li'), h('li', {
            class: 'vue-xtable-pager--num-btn',
            on: {
              click: function click() {
                return _this4.jumpPage(pageCount);
              }
            }
          }, pageCount));
        }
  
        return nums;
      },
      getPageCount: function getPageCount(total, size) {
        return Math.max(Math.ceil(total / size), 1);
      },
      handleGlobalMousedownEvent: function handleGlobalMousedownEvent(evnt) {
        if (this.showSizes && !(tools.DomTools.getEventTargetNode(evnt, this.$refs.sizeBtn).flag || tools.DomTools.getEventTargetNode(evnt, this.$refs.sizePanel).flag)) {
          this.hideSizePanel();
        }
      },
      prevPage: function prevPage() {
        var currentPage = this.currentPage;
  
        if (currentPage > 1) {
          this.jumpPage(Math.max(currentPage - 1, 1));
        }
      },
      nextPage: function nextPage() {
        var currentPage = this.currentPage,
            pageCount = this.pageCount;
  
        if (currentPage < pageCount) {
          this.jumpPage(Math.min(currentPage + 1, pageCount));
        }
      },
      prevJump: function prevJump() {
        var numList = this.numList,
            currentPage = this.currentPage;
        this.jumpPage(Math.max(currentPage - numList.length, 1));
      },
      nextJump: function nextJump() {
        var numList = this.numList,
            currentPage = this.currentPage,
            pageCount = this.pageCount;
        this.jumpPage(Math.min(currentPage + numList.length, pageCount));
      },
      jumpPage: function jumpPage(currentPage) {
        var type = 'current-change';
  
        if (currentPage !== this.currentPage) {
          this.$emit('update:currentPage', currentPage);
  
          tools.UtilTools.emitEvent(this, type, [currentPage]);
  
          this.emitPageChange(type, this.pageSize, currentPage);
        }
      },
      changePageSize: function changePageSize(pageSize) {
        var type = 'size-change';
  
        if (pageSize !== this.pageSize) {
          this.$emit('update:pageSize', pageSize);
  
          tools.UtilTools.emitEvent(this, type, [pageSize]);
  
          this.emitPageChange(type, pageSize, Math.min(this.currentPage, this.getPageCount(this.total, pageSize)));
        }
  
        this.hideSizePanel();
      },
      emitPageChange: function emitPageChange(type, pageSize, currentPage) {
        tools.UtilTools.emitEvent(this, 'page-change', [{
          type: type,
          pageSize: pageSize,
          currentPage: currentPage
        }]);
      },
      toggleSizePanel: function toggleSizePanel() {
        this[this.showSizes ? 'hideSizePanel' : 'showSizePanel']();
      },
      updateZindex: function updateZindex() {
        if (this.panelIndex < tools.UtilTools.getLastZIndex()) {
          this.panelIndex = tools.UtilTools.nextZIndex();
        }
      },
      showSizePanel: function showSizePanel() {
        var _this5 = this;
  
        this.showSizes = true;
        this.updateZindex();
        this.$nextTick(function () {
          var $refs = _this5.$refs;
          var sizeBtn = $refs.sizeBtn,
              sizePanel = $refs.sizePanel;
          _this5.panelStyle = {
            zIndex: _this5.panelIndex,
            bottom: ''.concat(sizeBtn.clientHeight + 6, 'px'),
            left: '-'.concat(sizePanel.clientWidth / 2 - sizeBtn.clientWidth / 2, 'px')
          };
        });
      },
      hideSizePanel: function hideSizePanel() {
        this.showSizes = false;
      }
    }
  };
  return VueXtablePager;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableHeader = definition(context.tools);
  }
})(this, function(tools) {
  var _defineProperty = tools.UtilTools.defineProperty;
  
var getAllColumns = function getAllColumns(columns) {
  var result = [];
  columns.forEach(function (column) {
    if (column.visible) {
      if (column.children && column.children.length && column.children.some(function (column) {
        return column.visible;
      })) {
        result.push(column);
        result.push.apply(result, getAllColumns(column.children));
      } else {
        result.push(column);
      }
    }
  });
  return result;
};

var convertToRows = function convertToRows(originColumns) {
  var maxLevel = 1;

  var traverse = function traverse(column, parent) {
    if (parent && !column.fixed) {
      column.level = parent.level + 1;

      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }

    if(column.fixed) {
      column.level = 1;
    }
    if (column.children && column.children.length && column.children.some(function (column) {
      return column.visible;
    })) {
      var colSpan = 0;
      column.children.forEach(function (subColumn) {
        if (subColumn.visible) {
          traverse(subColumn, column);
          if(!subColumn.fixed) {
            colSpan += subColumn.colSpan;
          }
        }
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };

  originColumns.forEach(function (column) {
    column.level = 1;
    traverse(column);
  });
  var rows = [];

  for (var i = 0; i < maxLevel; i++) {
    rows.push([]);
  }

  var allColumns = getAllColumns(originColumns);
  allColumns.forEach(function (column) {
    if (column.children && column.children.length && column.children.some(function (column) {
      return column.visible;
    })) {
      column.rowSpan = 1;
    } else {
      column.rowSpan = maxLevel - column.level + 1;
    }

    rows[column.level - 1].push(column);
  });

  var firstRow = rows[0];
  rows[0] = fixedRow(firstRow, 'left').concat(fixedRow(firstRow)).concat(fixedRow(firstRow, 'right'));
  return rows;
};

function fixedRow (rows, fixed) {
  return rows.filter(function(row) {
    var fix = row.fixed || undefined;
    return fix == fixed ;
  });
}

var VueXtableHeader = {
  name: 'VueXtableHeader',
  props: {
    tableData: Array,
    tableColumn: Array,
    visibleColumn: Array,
    collectColumn: Array,
    fixedColumn: Array,
    size: String,
    fixedType: String,
    isGroup: Boolean
  },
  data: function data() {
    return {
      headerColumn: []
    };
  },
  watch: {
    tableColumn: function tableColumn() {
      this.uploadColumn();
    }
  },
  created: function created() {
    this.uploadColumn();
  },
  mounted: function mounted() {
    var $table = this.$parent,
        $el = this.$el,
        $refs = this.$refs,
        fixedType = this.fixedType;
    var elemStore = $table.elemStore;
    var prefix = ''.concat(fixedType || 'main', '-header-');
    elemStore[''.concat(prefix, 'wrapper')] = $el;
    elemStore[''.concat(prefix, 'table')] = $refs.table;
    elemStore[''.concat(prefix, 'colgroup')] = $refs.colgroup;
    elemStore[''.concat(prefix, 'list')] = $refs.thead;
    elemStore[''.concat(prefix, 'x-space')] = $refs.xSpace;
    elemStore[''.concat(prefix, 'repair')] = $refs.repair;
  },
  render: function render(h) {
    var _this = this;

    var _e = this._e,
        $table = this.$parent,
        fixedType = this.fixedType,
        headerColumn = this.headerColumn,
        tableColumn = this.tableColumn,
        fixedColumn = this.fixedColumn;
    var tableListeners = $table.$listeners,
        resizable = $table.resizable,
        border = $table.border,
        columnKey = $table.columnKey,
        headerRowClassName = $table.headerRowClassName,
        headerCellClassName = $table.headerCellClassName,
        headerRowStyle = $table.headerRowStyle,
        headerCellStyle = $table.headerCellStyle,
        allColumnHeaderOverflow = $table.showHeaderOverflow,
        allHeaderAlign = $table.headerAlign,
        allAlign = $table.align,
        highlightCurrentColumn = $table.highlightCurrentColumn,
        _$table$mouseConfig = $table.mouseConfig,
        mouseConfig = _$table$mouseConfig === void 0 ? {} : _$table$mouseConfig,
        scrollXLoad = $table.scrollXLoad,
        overflowX = $table.overflowX,
        getColumnIndex = $table.getColumnIndex,
        sortOpts = $table.sortOpts; // 横向滚动渲染

    if (scrollXLoad) {
      if (fixedType) {
        tableColumn = fixedColumn;
      }
    }

    return h('div', {
      class: ['vue-xtable-table--header-wrapper', fixedType ? 'fixed-'.concat(fixedType, '--wrapper') : 'body--wrapper']
    }, [fixedType ? _e() : h('div', {
      class: 'vue-xtable-body--x-space',
      ref: 'xSpace'
    }), h('table', {
      class: 'vue-xtable-table--header',
      attrs: {
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      },
      ref: 'table'
    }, [
    /**
     * 列宽
     */
    h('colgroup', {
      ref: 'colgroup'
    }, tableColumn.map(function (column, columnIndex) {
      return h('col', {
        attrs: {
          name: column.id
        },
        key: columnIndex
      });
    }).concat([h('col', {
      attrs: {
        name: 'col_gutter'
      }
    })])),
    /**
     * 头部
     */
    h('thead', {
      ref: 'thead'
    }, headerColumn.map(function (cols, $rowIndex) {
      return h('tr', {
        class: ['vue-xtable-header--row', headerRowClassName ? VueUtil.isFunction(headerRowClassName) ? headerRowClassName({
          $table: $table,
          $rowIndex: $rowIndex,
          fixed: fixedType
        }) : headerRowClassName : ''],
        style: headerRowStyle ? VueUtil.isFunction(headerRowStyle) ? headerRowStyle({
          $table: $table,
          $rowIndex: $rowIndex,
          fixed: fixedType
        }) : headerRowStyle : null
      }, cols.map(function (column, $columnIndex) {
        var _ref;

        var showHeaderOverflow = column.showHeaderOverflow,
            headerAlign = column.headerAlign,
            align = column.align,
            headerClassName = column.headerClassName;
        var isColGroup = column.children && column.children.length;
        var fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
        var headOverflow = VueUtil.isUndefined(showHeaderOverflow) || VueUtil.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
        var headAlign = headerAlign || align || allHeaderAlign || allAlign;
        var showEllipsis = headOverflow === 'ellipsis';
        var showTitle = headOverflow === 'title';
        var showTooltip = headOverflow === true || headOverflow === 'tooltip';
        var hasEllipsis = showTitle || showTooltip || showEllipsis;
        var thOns = {}; // 确保任何情况下 columnIndex 都精准指向真实列索引

        var columnIndex = getColumnIndex(column);
        var params = {
          $table: $table,
          $rowIndex: $rowIndex,
          column: column,
          columnIndex: columnIndex,
          $columnIndex: $columnIndex,
          fixed: fixedType
        };

        if (showTitle || showTooltip) {
          thOns.mouseenter = function (evnt) {
            if ($table._isResize) {
              return;
            }

            if (showTitle) {
              tools.DomTools.updateCellTitle(evnt);
            } else if (showTooltip) {
              $table.triggerHeaderTooltipEvent(evnt, {
                $table: $table,
                $rowIndex: $rowIndex,
                column: column,
                columnIndex: columnIndex,
                $columnIndex: $columnIndex,
                fixed: fixedType
              });
            }
          };
        }

        if (showTooltip) {
          thOns.mouseleave = function (evnt) {
            if ($table._isResize) {
              return;
            }

            if (showTooltip) {
              $table.handleTargetLeaveEvent(evnt);
            }
          };
        }

        if (highlightCurrentColumn || tableListeners['header-cell-click'] || mouseConfig.checked || sortOpts.trigger === 'cell') {
          thOns.click = function (evnt) {
            return $table.triggerHeaderCellClickEvent(evnt, {
              $table: $table,
              $rowIndex: $rowIndex,
              column: column,
              columnIndex: columnIndex,
              $columnIndex: $columnIndex,
              fixed: fixedType,
              cell: evnt.currentTarget
            });
          };
        }

        if (tableListeners['header-cell-dblclick']) {
          thOns.dblclick = function (evnt) {
            return tools.UtilTools.emitEvent($table, 'header-cell-dblclick', [{
              $table: $table,
              $rowIndex: $rowIndex,
              column: column,
              columnIndex: columnIndex,
              $columnIndex: $columnIndex,
              fixed: fixedType,
              cell: evnt.currentTarget
            }, evnt]);
          };
        } // 按下事件处理


        if (mouseConfig.checked && mouseConfig.colSelect) {
          thOns.mousedown = function (evnt) {
            return $table.triggerHeaderCellMousedownEvent(evnt, {
              $table: $table,
              $rowIndex: $rowIndex,
              column: column,
              columnIndex: columnIndex,
              $columnIndex: $columnIndex,
              fixed: fixedType,
              cell: evnt.currentTarget
            });
          };
        }
        return column.colSpan === 0 ? null : h('th', {
          class: ['vue-xtable-header--column', column.id, (_ref = {}, _defineProperty(_ref, 'col--'.concat(headAlign), headAlign), _defineProperty(_ref, 'col--fixed', column.fixed), _defineProperty(_ref, 'col--index', column.type === 'index'), _defineProperty(_ref, 'col--drag', column.type === 'drag'), _defineProperty(_ref, 'col--group', isColGroup), _defineProperty(_ref, 'col--ellipsis', hasEllipsis), _defineProperty(_ref, 'fixed--hidden', fixedHiddenColumn), _defineProperty(_ref, 'is--sortable', column.sortable), _defineProperty(_ref, 'is--filter', column.filters.length), _defineProperty(_ref, 'filter--active', column.filters.some(function (item) {
            return item.checked;
          })), _ref), tools.UtilTools.getClass(headerClassName, params), tools.UtilTools.getClass(headerCellClassName, params)],
          attrs: {
            'data-colid': column.id,
            colspan: column.colSpan,
            rowspan: column.rowSpan
          },
          style: headerCellStyle ? VueUtil.isFunction(headerCellStyle) ? headerCellStyle({
            $table: $table,
            $rowIndex: $rowIndex,
            column: column,
            columnIndex: columnIndex,
            $columnIndex: $columnIndex,
            fixed: fixedType,
            isHidden: fixedHiddenColumn
          }) : headerCellStyle : null,
          on: thOns,
          key: columnKey || isColGroup ? column.id : columnIndex
        }, [h('div', {
          class: ['vue-xtable-cell', {
            'c--title': showTitle,
            'c--tooltip': showTooltip,
            'c--ellipsis': showEllipsis
          }]
        }, column.renderHeader(h, {
          $table: $table,
          $rowIndex: $rowIndex,
          column: column,
          columnIndex: columnIndex,
          $columnIndex: $columnIndex,
          fixed: fixedType,
          isHidden: fixedHiddenColumn
        })),
        /**
         * 列宽拖动
         */
        !fixedHiddenColumn && !isColGroup && (VueUtil.isBoolean(column.resizable) ? column.resizable : resizable) ? h('div', {
          class: ['vue-xtable-resizable', {
            'is--line': !border
          }],
          on: {
            mousedown: function mousedown(evnt) {
              return _this.resizeMousedown(evnt, {
                $table: $table,
                $rowIndex: $rowIndex,
                column: column,
                columnIndex: columnIndex,
                $columnIndex: $columnIndex,
                fixed: fixedType,
                isHidden: fixedHiddenColumn
              });
            }
          }
        }) : null]);
      }).concat([h('th', {
        class: 'col--gutter'
      })]));
    }))]),
    /**
     * 其他
     */
    h('div', {
      class: 'vue-xtable-table--repair',
      ref: 'repair'
    })]);
  },
  methods: {
    uploadColumn: function uploadColumn() {
      this.headerColumn = this.isGroup ? convertToRows(this.collectColumn) : [this.$parent.scrollXLoad && this.fixedType ? this.fixedColumn : this.tableColumn];
    },
    resizeMousedown: function resizeMousedown(evnt, params) {
      var column = params.column;
      var $table = this.$parent,
          $el = this.$el,
          fixedType = this.fixedType;
      var _$table$$refs = $table.$refs,
          tableBody = _$table$$refs.tableBody,
          leftContainer = _$table$$refs.leftContainer,
          rightContainer = _$table$$refs.rightContainer,
          resizeBarElem = _$table$$refs.resizeBar;
      var dragBtnElem = evnt.target,
          dragClientX = evnt.clientX;
      var cell = dragBtnElem.parentNode;
      var dragLeft = 0;
      var minInterval = 36; // 列之间的最小间距

      var tableBodyElem = tableBody.$el;

      var pos = tools.DomTools.getOffsetPos(dragBtnElem, $el);

      var dragBtnWidth = dragBtnElem.clientWidth;
      var dragMinLeft = pos.left - cell.clientWidth + dragBtnWidth + minInterval;
      var dragPosLeft = pos.left + Math.floor(dragBtnWidth / 2);
      var domMousemove = document.onmousemove;
      var domMouseup = document.onmouseup;
      var isLeftFixed = fixedType === 'left';
      var isRightFixed = fixedType === 'right'; // 计算左右侧固定列偏移量

      var fixedOffsetWidth = 0;

      if (isLeftFixed || isRightFixed) {
        var siblingProp = isLeftFixed ? 'nextElementSibling' : 'previousElementSibling';
        var tempCellElem = cell[siblingProp];

        while (tempCellElem) {
          if (tools.DomTools.hasClass(tempCellElem, 'fixed--hidden')) {
            break;
          } else if (!tools.DomTools.hasClass(tempCellElem, 'col--group')) {
            fixedOffsetWidth += tempCellElem.offsetWidth;
          }

          tempCellElem = tempCellElem[siblingProp];
        }

        if (isRightFixed && rightContainer) {
          dragPosLeft = rightContainer.offsetLeft + fixedOffsetWidth;
        }
      } // 处理拖动事件


      var updateEvent = function updateEvent(evnt) {
        evnt.stopPropagation();
        evnt.preventDefault();
        var offsetX = evnt.clientX - dragClientX;
        var left = dragPosLeft + offsetX;
        var scrollLeft = fixedType ? 0 : tableBodyElem.scrollLeft;

        if (isLeftFixed) {
          // 左固定列（不允许超过右侧固定列、不允许超过右边距）
          left = Math.min(left, (rightContainer ? rightContainer.offsetLeft : tableBodyElem.clientWidth) - fixedOffsetWidth - minInterval);
        } else if (isRightFixed) {
          // 右侧固定列（不允许超过左侧固定列、不允许超过左边距）
          dragMinLeft = (leftContainer ? leftContainer.clientWidth : 0) + fixedOffsetWidth + minInterval;
          left = Math.min(left, dragPosLeft + cell.clientWidth - minInterval);
        }

        dragLeft = Math.max(left, dragMinLeft);
        resizeBarElem.style.left = ''.concat(dragLeft - scrollLeft, 'px');
      };

      $table._isResize = true;

      tools.DomTools.addClass($table.$el, 'c--resize');

      resizeBarElem.style.display = 'block';
      document.onmousemove = updateEvent;

      document.onmouseup = function (evnt) {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        column.resizeWidth = column.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);
        resizeBarElem.style.display = 'none';
        $table._isResize = false;
        $table._lastResizeTime = Date.now();
        $table.analyColumnWidth();
        $table.recalculate(true);

        tools.DomTools.removeClass($table.$el, 'c--resize');

        if ($table.$toolbar) {
          $table.$toolbar.updateResizable();
        }

        tools.UtilTools.emitEvent($table, 'resizable-change', [params]);
      };

      updateEvent(evnt);
    }
  }
};
  return VueXtableHeader;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableBody = definition(context.GlobalConfig, context.tools);
  }
})(this, function(GlobalConfig, tools) {

  var _defineProperty = tools.UtilTools.defineProperty;
  
  // 滚动、拖动过程中不需要触发
  function isOperateMouse ($table) {
    return $table._isResize || ($table.lastScrollTime && Date.now() < $table.lastScrollTime + $table.optimizeOpts.delayHover);
  }
  function renderBorder(h, type) {
    return h('div', {
      class: 'vue-xtable-table-'.concat(type, 'ed-borders'),
      ref: ''.concat(type, 'Borders')
    }, [h('span', {
      class: 'vue-xtable-table-border-top',
      ref: ''.concat(type, 'Top')
    }), h('span', {
      class: 'vue-xtable-table-border-right',
      ref: ''.concat(type, 'Right')
    }), h('span', {
      class: 'vue-xtable-table-border-bottom',
      ref: ''.concat(type, 'Bottom')
    }), h('span', {
      class: 'vue-xtable-table-border-left',
      ref: ''.concat(type, 'Left')
    })]);
  }
  /**
   * 渲染列
   */
  
  
  function renderColumn(h, _vm, $table, $seq, seq, fixedType, rowLevel, row, rowIndex, $rowIndex, column, columnIndex, $columnIndex) {
    var _ref2;
  
    var _e = $table._e,
        tableListeners = $table.$listeners,
        tableData = $table.tableData,
        height = $table.height,
        columnKey = $table.columnKey,
        overflowX = $table.overflowX,
        scrollXLoad = $table.scrollXLoad,
        scrollYLoad = $table.scrollYLoad,
        highlightCurrentRow = $table.highlightCurrentRow,
        allColumnOverflow = $table.showOverflow,
        allAlign = $table.align,
        cellClassName = $table.cellClassName,
        cellStyle = $table.cellStyle,
        spanMethod = $table.spanMethod,
        _$table$radioConfig = $table.radioConfig,
        radioConfig = _$table$radioConfig === void 0 ? {} : _$table$radioConfig,
        _$table$expandConfig = $table.expandConfig,
        expandConfig = _$table$expandConfig === void 0 ? {} : _$table$expandConfig,
        _$table$treeConfig = $table.treeConfig,
        treeConfig = _$table$treeConfig === void 0 ? {} : _$table$treeConfig,
        _$table$mouseConfig = $table.mouseConfig,
        mouseConfig = _$table$mouseConfig === void 0 ? {} : _$table$mouseConfig,
        editConfig = $table.editConfig,
        editRules = $table.editRules,
        validOpts = $table.validOpts,
        editStore = $table.editStore,
        validStore = $table.validStore,
        validResultsCell = $table.validResultsCell;
    var editRender = column.editRender,
        align = column.align,
        showOverflow = column.showOverflow,
        className = column.className;
    var actived = editStore.actived;
    var fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;
    var cellOverflow = VueUtil.isUndefined(showOverflow) || VueUtil.isNull(showOverflow) ? allColumnOverflow : showOverflow;
    var showEllipsis = cellOverflow === 'ellipsis';
    var showTitle = cellOverflow === 'title';
    var showTooltip = cellOverflow === true || cellOverflow === 'tooltip';
    var hasEllipsis = showTitle || showTooltip || showEllipsis;
    var isDirty;
    var tdOns = {};
    var cellAlign = align || allAlign;
    var validError = validStore.row === row && validStore.column === column;
    var rowId = tools.UtilTools.getRowid($table, row);
    var validResultCell = validResultsCell[rowId] ? validResultsCell[rowId][column.property] : undefined;
    var hasDefaultTip = editRules && (validOpts.message === 'default' ? height || tableData.length > 1 : validOpts.message === 'inline');
    var attrs = {
      'data-colid': column.id
    };
    var triggerDblclick = editRender && editConfig && editConfig.trigger === 'dblclick';
    var params = {
      $table: $table,
      $seq: $seq,
      seq: seq,
      row: row,
      rowIndex: rowIndex,
      $rowIndex: $rowIndex,
      column: column,
      columnIndex: columnIndex,
      $columnIndex: $columnIndex,
      fixed: fixedType,
      isHidden: fixedHiddenColumn,
      level: rowLevel,
      data: tableData
    }; // 在 v3.0 中废弃 selectConfig
  
    var checkboxConfig = $table.checkboxConfig || $table.selectConfig || {}; // 滚动的渲染不支持动态行高
  
    if ((scrollXLoad || scrollYLoad) && !hasEllipsis) {
      showEllipsis = hasEllipsis = true;
    } // hover 进入事件
  
  
    if (showTitle || showTooltip || tableListeners['cell-mouseenter']) {
      tdOns.mouseenter = function (evnt) {
        if (isOperateMouse($table)) {
          return;
        }
  
        var evntParams = {
          $table: $table,
          seq: seq,
          row: row,
          rowIndex: rowIndex,
          $rowIndex: $rowIndex,
          column: column,
          columnIndex: columnIndex,
          $columnIndex: $columnIndex,
          fixed: fixedType,
          isHidden: fixedHiddenColumn,
          level: rowLevel,
          cell: evnt.currentTarget
        };
  
        if (showTitle) {
          tools.DomTools.updateCellTitle(evnt);
        } else if (showTooltip) {
          // 如果配置了显示 tooltip
          $table.triggerTooltipEvent(evnt, evntParams);
        }
  
        tools.UtilTools.emitEvent($table, 'cell-mouseenter', [evntParams, evnt]);
      };
    } // hover 退出事件
  
  
    if (showTooltip || tableListeners['cell-mouseleave']) {
      tdOns.mouseleave = function (evnt) {
        if (isOperateMouse($table)) {
          return;
        }
  
        if (showTooltip) {
          $table.handleTargetLeaveEvent(evnt);
        }
  
        tools.UtilTools.emitEvent($table, 'cell-mouseleave', [{
          $table: $table,
          seq: seq,
          row: row,
          rowIndex: rowIndex,
          $rowIndex: $rowIndex,
          column: column,
          columnIndex: columnIndex,
          $columnIndex: $columnIndex,
          fixed: fixedType,
          isHidden: fixedHiddenColumn,
          level: rowLevel,
          cell: evnt.currentTarget
        }, evnt]);
      };
    } // 按下事件处理
  
  
    if (mouseConfig.checked || mouseConfig.selected || $table.highlightCurrentRow) {
      tdOns.mousedown = function (evnt) {
        if(evnt.currentTarget.className.indexOf('col--drag') > -1) {
          return;
        }
        if ($table.editStore && $table.editStore.actived &&  $table.editConfig) {
          if($table.editConfig.mode == 'row' && $table.editStore.actived.row == row) {
            return; 
          }
          if($table.editConfig.mode == 'cell' && $table.editStore.actived.row == row && $table.editStore.actived.column == column) {
            return;
          }
        }
        
        $table.triggerCellMousedownEvent(evnt, {
          $table: $table,
          seq: seq,
          row: row,
          rowIndex: rowIndex,
          $rowIndex: $rowIndex,
          column: column,
          columnIndex: columnIndex,
          $columnIndex: $columnIndex,
          fixed: fixedType,
          isHidden: fixedHiddenColumn,
          level: rowLevel,
          cell: evnt.currentTarget
        });
      };
    } // 点击事件处理
  
  
    if (highlightCurrentRow || tableListeners['cell-click'] || mouseConfig.checked || editRender && editConfig || expandConfig.trigger === 'row' || expandConfig.trigger === 'cell' || radioConfig.trigger === 'row' || column.type === 'radio' && radioConfig.trigger === 'cell' || // 在 v3.0 中废弃 type=selection
    checkboxConfig.trigger === 'row' || (column.type === 'checkbox' || column.type === 'selection') && checkboxConfig.trigger === 'cell' || treeConfig.trigger === 'row' || column.treeNode && treeConfig.trigger === 'cell') {
      tdOns.click = function (evnt) {
        if(evnt.currentTarget.className.indexOf('col--drag') > -1) {
          return;
        }
        $table.triggerCellClickEvent(evnt, {
          $table: $table,
          row: row,
          rowIndex: rowIndex,
          $rowIndex: $rowIndex,
          column: column,
          columnIndex: columnIndex,
          $columnIndex: $columnIndex,
          fixed: fixedType,
          isHidden: fixedHiddenColumn,
          level: rowLevel,
          cell: evnt.currentTarget
        });
      };
    } // 双击事件处理
  
  
    tdOns.dblclick = function (evnt) {
      $table.clearCopyed();
      if (triggerDblclick || tableListeners['cell-dblclick']) {
        $table.triggerCellDBLClickEvent(evnt, {
          $table: $table,
          seq: seq,
          row: row,
          rowIndex: rowIndex,
          $rowIndex: $rowIndex,
          column: column,
          columnIndex: columnIndex,
          $columnIndex: $columnIndex,
          fixed: fixedType,
          isHidden: fixedHiddenColumn,
          level: rowLevel,
          cell: evnt.currentTarget
        });
      } 
    };
  
  // 合并行或列
    if (spanMethod) {
      var _ref = spanMethod(params) || {},
          _ref$rowspan = _ref.rowspan,
          rowspan = _ref$rowspan === void 0 ? 1 : _ref$rowspan,
          _ref$colspan = _ref.colspan,
          colspan = _ref$colspan === void 0 ? 1 : _ref$colspan;
  
      if (!rowspan || !colspan) {
        return null;
      }
  
      attrs.rowspan = rowspan;
      attrs.colspan = colspan;
    } // 如果显示状态
  
  
    if (!fixedHiddenColumn && editConfig && editConfig.showStatus) {
      isDirty = $table.isUpdateByRow(row, column.property);
    }
  
    return h('td', {
      class: ['vue-xtable-body--column', column.id, (_ref2 = {}, _defineProperty(_ref2, 'col--'.concat(cellAlign), cellAlign),
      _defineProperty(_ref2, 'col--edit', editRender), _defineProperty(_ref2, 'col--index', column.type === 'index'),
      _defineProperty(_ref2, 'col--drag', column.type === 'drag'), _defineProperty(_ref2, 'col--ellipsis', hasEllipsis),
      _defineProperty(_ref2, 'edit--visible', editRender && editRender.type === 'visible'), _defineProperty(_ref2, 'fixed--hidden', fixedHiddenColumn),
      _defineProperty(_ref2, 'col--dirty', isDirty), _defineProperty(_ref2, 'col--actived', editConfig && editRender && actived.row === row && (actived.column === column || editConfig.mode === 'row')),
      _defineProperty(_ref2, 'col--valid-error', validError),
      _defineProperty(_ref2, 'col--valid-result-error', validResultCell),
       _ref2), tools.UtilTools.getClass(className, params),
       tools.UtilTools.getClass(cellClassName, params)],
      key: columnKey ? column.id : columnIndex,
      attrs: attrs,
      style: cellStyle ? VueUtil.isFunction(cellStyle) ? cellStyle(params) : cellStyle : null,
      on: tdOns
    }, allColumnOverflow && fixedHiddenColumn ? [] : [h('div', {
      class: ['vue-xtable-cell', {
        'c--title': showTitle,
        'c--tooltip': showTooltip,
        'c--ellipsis': showEllipsis
      }],
      attrs: {
        title: showTitle ? tools.UtilTools.getCellLabel(row, column, params) : null
      }
    }, column.renderCell(h, params)), hasDefaultTip ? validError ? h('div', {
      class: 'vue-xtable-cell--valid',
      style: validStore.rule && validStore.rule.width ? {
        width: ''.concat(validStore.rule.width, 'px')
      } : null
    }, [h('span', {
      class: 'vue-xtable-cell--valid-msg',
      domProps: {
        innerHTML: Array.isArray(validStore.content) ? validStore.content.join('<br>') :  validStore.content
      },
    })]) : _e() : null]);
  }
  
  function renderRows(h, _vm, $table, $seq, rowLevel, fixedType, tableData, tableColumn) {
    var stripe = $table.stripe,
        rowKey = $table.rowKey,
        highlightHoverRow = $table.highlightHoverRow,
        rowClassName = $table.rowClassName,
        rowStyle = $table.rowStyle,
        treeConfig = $table.treeConfig,
        treeExpandeds = $table.treeExpandeds,
        scrollYLoad = $table.scrollYLoad,
        scrollYStore = $table.scrollYStore,
        editStore = $table.editStore,
        expandeds = $table.expandeds,
        getColumnIndex = $table.getColumnIndex,
        validResultsCell = $table.validResultsCell;
    var rows = [];
    tableData.forEach(function (row, $rowIndex) {
      var _ref3;
  
      var trOn = {};
      var rowIndex = $rowIndex;
      var seq = rowIndex + 1;
  
      if (scrollYLoad) {
        seq += scrollYStore.startIndex;
      } // 确保任何情况下 rowIndex 都精准指向真实 data 索引
  
  
      rowIndex = $table.getRowIndex(row); // 事件绑定
  
      row.$rowIndex = $rowIndex;
      row.rowIndex = rowIndex;

      var rowid = tools.UtilTools.getRowid($table, row);

      var evntParams = {
        $table: $table,
        $seq: $seq,
        seq: seq,
        fixedType: fixedType,
        rowLevel: rowLevel,
        row: row,
        rowIndex: rowIndex,
        $rowIndex: $rowIndex
      };

      
      trOn.mouseenter = function (evnt) {
        if (isOperateMouse($table)) {
          return;
        }

        if (highlightHoverRow) {
          $table.triggerHoverEvent(evnt, {
            row: row,
            rowIndex: rowIndex
          });
        }

        tools.UtilTools.emitEvent($table, 'row-mouseenter', [evntParams, evnt]);
      };

      trOn.mouseleave = function (evnt) {
        if (isOperateMouse($table)) {
          return;
        }

        if (highlightHoverRow) {
          $table.clearHoverRow();
        }

        tools.UtilTools.emitEvent($table, 'row-mouseleave', [evntParams, evnt]);
      };
      
      trOn.mousedown = function (evnt) {
        if (isOperateMouse($table)) {
          return;
        }
        tools.UtilTools.emitEvent($table, 'row-mousedown', [evntParams, evnt]);
      };
      rows.push(h('tr', {
        class: ['vue-xtable-body--row', (_ref3 = {
          'row--stripe': stripe && $rowIndex > 0 && ($rowIndex + 1) % 2 === 0,
          'row--valid-result-error': validResultsCell[rowid] && Object.keys(validResultsCell[rowid]).length
        }, _defineProperty(_ref3, 'row--level-'.concat(rowLevel), treeConfig), _defineProperty(_ref3, 'row--new', editStore.insertList.indexOf(row) > -1), _ref3), rowClassName ? VueUtil.isFunction(rowClassName) ? rowClassName({
          $table: $table,
          $seq: $seq,
          seq: seq,
          fixedType: fixedType,
          rowLevel: rowLevel,
          row: row,
          rowIndex: rowIndex,
          $rowIndex: $rowIndex
        }) : rowClassName : ''],
        attrs: {
          'data-rowid': rowid
        },
        style: rowStyle ? VueUtil.isFunction(rowStyle) ? rowStyle({
          $table: $table,
          $seq: $seq,
          seq: seq,
          fixedType: fixedType,
          rowLevel: rowLevel,
          row: row,
          rowIndex: rowIndex,
          $rowIndex: $rowIndex
        }) : rowStyle : null,
        key: rowKey || treeConfig ? rowid : $rowIndex,
        on: trOn
      }, tableColumn.map(function (column, $columnIndex) {
        var columnIndex = getColumnIndex(column);
        return renderColumn(h, _vm, $table, $seq, seq, fixedType, rowLevel, row, rowIndex, $rowIndex, column, columnIndex, $columnIndex);
      }))); // 如果行被展开了
  
      if (expandeds.length && expandeds.indexOf(row) > -1) {
        var column = VueUtil.find(tableColumn, function (column) {
          return column.type === 'expand';
        });
        var columnIndex = getColumnIndex(column);
        var cellStyle;
  
        if (treeConfig) {
          cellStyle = {
            paddingLeft: ''.concat(rowLevel * (treeConfig.indent || 16) + 30, 'px')
          };
        }
  
        if (column) {
          rows.push(h('tr', {
            class: 'vue-xtable-body--expanded-row',
            key: 'expand_'.concat(rowid),
            style: rowStyle ? VueUtil.isFunction(rowStyle) ? rowStyle({
              $table: $table,
              $seq: $seq,
              seq: seq,
              fixedType: fixedType,
              rowLevel: rowLevel,
              row: row,
              rowIndex: rowIndex,
              $rowIndex: $rowIndex,
              isExpanded: true
            }) : rowStyle : null,
            on: trOn
          }, [h('td', {
            class: 'vue-xtable-body--expanded-column',
            attrs: {
              colspan: tableColumn.length
            }
          }, [h('div', {
            class: ['vue-xtable-body--expanded-cell', {
              'fixed--hidden': fixedType
            }],
            style: cellStyle
          }, [column.renderData(h, {
            $table: $table,
            seq: seq,
            row: row,
            rowIndex: rowIndex,
            column: column,
            columnIndex: columnIndex,
            fixed: fixedType,
            level: rowLevel
          })])])]));
        }
      } // 如果是树形表格
  
  
      if (treeConfig && treeExpandeds.length) {
        var rowChildren = row[treeConfig.children];
  
        if (rowChildren && rowChildren.length && treeExpandeds.indexOf(row) > -1) {
          rows.push.apply(rows, renderRows(h, _vm, $table, $seq ? ''.concat($seq, '.').concat(seq) : ''.concat(seq), rowLevel + 1, fixedType, rowChildren, tableColumn));
        }
      }
    });
    return rows;
  }
  /**
   * 同步滚动条
   * scroll 方式：可以使固定列与内容保持一致的滚动效果，处理相对麻烦
   * mousewheel 方式：对于同步滚动效果就略差了，左右滚动，内容跟随即可
   * css3 translate 方式：可以利用硬件加速，各方面较优，失去table布局能力
   */
  
  
  var scrollProcessTimeout;
  
  function syncBodyScroll(scrollTop, elem1, elem2) {
    if (elem1 || elem2) {
      if (elem1) {
        elem1.onscroll = null;
        elem1.scrollTop = scrollTop;
      }
  
      if (elem2) {
        elem2.onscroll = null;
        elem2.scrollTop = scrollTop;
      }
  
      clearTimeout(scrollProcessTimeout);
      scrollProcessTimeout = setTimeout(function () {
        if (elem1) {
          elem1.onscroll = elem1._onscroll;
        }
  
        if (elem2) {
          elem2.onscroll = elem2._onscroll;
        }
      }, 100);
    }
  }
  
  var VueXtableBody = {
    name: 'VueXtableBody',
    props: {
      tableData: Array,
      tableColumn: Array,
      visibleColumn: Array,
      collectColumn: Array,
      fixedColumn: Array,
      size: String,
      fixedType: String,
      isGroup: Boolean
    },
    mounted: function mounted() {
      var $table = this.$parent,
          $el = this.$el,
          $refs = this.$refs,
          fixedType = this.fixedType;
      var elemStore = $table.elemStore;
      var prefix = ''.concat(fixedType || 'main', '-body-');
      elemStore[''.concat(prefix, 'wrapper')] = $el;
      elemStore[''.concat(prefix, 'table')] = $refs.table;
      elemStore[''.concat(prefix, 'colgroup')] = $refs.colgroup;
      elemStore[''.concat(prefix, 'list')] = $refs.tbody;
      elemStore[''.concat(prefix, 'xSpace')] = $refs.xSpace;
      elemStore[''.concat(prefix, 'ySpace')] = $refs.ySpace;
      elemStore[''.concat(prefix, 'emptyBlock')] = $refs.emptyBlock;
      this.$el.onscroll = this.scrollEvent;
      this.$el._onscroll = this.scrollEvent;
    },
    beforeDestroy: function beforeDestroy() {
      this.$el._onscroll = null;
      this.$el.onscroll = null;
    },
    render: function render(h) {
      var _e = this._e,
          $table = this.$parent,
          fixedColumn = this.fixedColumn,
          fixedType = this.fixedType;
      var $scopedSlots = $table.$scopedSlots,
          tableData = $table.tableData,
          tableColumn = $table.tableColumn,
          allColumnOverflow = $table.showOverflow,
          scrollXLoad = $table.scrollXLoad,
          _$table$mouseConfig2 = $table.mouseConfig,
          mouseConfig = _$table$mouseConfig2 === void 0 ? {} : _$table$mouseConfig2,
          _$table$keyboardConfi = $table.keyboardConfig,
          keyboardConfig = _$table$keyboardConfi === void 0 ? {} : _$table$keyboardConfi; // 如果是固定列与设置了超出隐藏
  
      if (fixedType && allColumnOverflow) {
        tableColumn = fixedColumn;
      } else if (scrollXLoad) {
        if (fixedType) {
          tableColumn = fixedColumn;
        }
      }
  
      return h('div', {
        class: ['vue-xtable-table--body-wrapper', fixedType ? 'fixed-'.concat(fixedType, '--wrapper') : 'body--wrapper']
      }, [fixedType ? _e() : h('div', {
        class: 'vue-xtable-body--x-space',
        ref: 'xSpace'
      }), h('div', {
        class: 'vue-xtable-body--y-space',
        ref: 'ySpace'
      }), h('table', {
        class: 'vue-xtable-table--body',
        attrs: {
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        },
        ref: 'table'
      }, [
      /**
       * 列宽
       */
      h('colgroup', {
        ref: 'colgroup'
      }, tableColumn.map(function (column, columnIndex) {
        return h('col', {
          attrs: {
            name: column.id
          },
          key: columnIndex
        });
      })),
      /**
       * 内容
       */
      h('tbody', {
        ref: 'tbody'
      }, renderRows(h, this, $table, '', 0, fixedType, tableData, tableColumn))]),
      /**
       * 选中边框线
       */
      !fixedType && (mouseConfig.checked || keyboardConfig.isCut) ? h('div', {
        class: 'vue-xtable-table--borders'
      }, [mouseConfig.checked ? renderBorder(h, 'check') : null, keyboardConfig.isCut ? renderBorder(h, 'copy') : null]) : null, !fixedType ? h('div', {
        class: 'vue-xtable-table--empty-block'.concat(tableData.length ? '' : ' is--visible'),
        ref: 'emptyBlock'
      }, [h('span', {
        class: 'vue-xtable-table--empty-text'
      }, $scopedSlots.empty ? $scopedSlots.empty.call(this, {
        $table: $table
      }, h) : GlobalConfig.i18n('vue.xtable.table.emptyText'))]) : null]);
    },
    methods: {
      /**
       * 滚动处理
       * 如果存在列固定左侧，同步更新滚动状态
       * 如果存在列固定右侧，同步更新滚动状态
       */
      scrollEvent: function scrollEvent(evnt) {
        var $table = this.$parent,
            fixedType = this.fixedType;
        var $refs = $table.$refs,
            highlightHoverRow = $table.highlightHoverRow,
            scrollXLoad = $table.scrollXLoad,
            scrollYLoad = $table.scrollYLoad,
            lastScrollTop = $table.lastScrollTop,
            lastScrollLeft = $table.lastScrollLeft;
        var tableHeader = $refs.tableHeader,
            tableBody = $refs.tableBody,
            leftBody = $refs.leftBody,
            rightBody = $refs.rightBody,
            tableFooter = $refs.tableFooter;
        var headerElem = tableHeader ? tableHeader.$el : null;
        var footerElem = tableFooter ? tableFooter.$el : null;
        var bodyElem = tableBody.$el;
        var leftElem = leftBody ? leftBody.$el : null;
        var rightElem = rightBody ? rightBody.$el : null;
        var scrollTop = bodyElem.scrollTop;
        var scrollLeft = bodyElem.scrollLeft;
        var isX = scrollLeft !== lastScrollLeft;
        var isY = scrollTop !== lastScrollTop;
        $table.lastScrollTop = scrollTop;
        $table.lastScrollLeft = scrollLeft;
        $table.lastScrollTime = Date.now();
  
        if (highlightHoverRow) {
          $table.clearHoverRow();
        }
  
        if (leftElem && fixedType === 'left') {
          scrollTop = leftElem.scrollTop;
          syncBodyScroll(scrollTop, bodyElem, rightElem);
        } else if (rightElem && fixedType === 'right') {
          scrollTop = rightElem.scrollTop;
          syncBodyScroll(scrollTop, bodyElem, leftElem);
        } else {
          if (isX) {
            if (headerElem) {
              headerElem.scrollLeft = bodyElem.scrollLeft;
            }
  
            if (footerElem) {
              footerElem.scrollLeft = bodyElem.scrollLeft;
            }
          }
  
          if (leftElem || rightElem) {
            $table.checkScrolling();
  
            if (isY) {
              syncBodyScroll(scrollTop, leftElem, rightElem);
            }
          }
        }
  
        if (scrollXLoad && isX) {
          $table.triggerScrollXEvent(evnt);
  
          if (headerElem && scrollLeft + bodyElem.clientWidth >= bodyElem.scrollWidth - 80) {
            // 修复拖动滚动条时可能存在不同步问题
            this.$nextTick(function () {
              if (bodyElem.scrollLeft !== headerElem.scrollLeft) {
                headerElem.scrollLeft = bodyElem.scrollLeft;
              }
            });
          }
        }
  
        if (scrollYLoad && isY) {
          $table.triggerScrollYEvent(evnt);
        }
  
        tools.UtilTools.emitEvent($table, 'scroll', [{
          type: 'body',
          fixed: fixedType,
          scrollTop: scrollTop,
          scrollLeft: scrollLeft,
          isX: isX,
          isY: isY,
          $table: $table
        }, evnt]);
      }
    }
  };
  
  return VueXtableBody;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableFooter = definition(context.tools);
  }
})(this, function(tools) {

  var _defineProperty = tools.UtilTools.defineProperty;
  
  var VueXtableFooter = {
    name: 'VueXtableFooter',
    props: {
      footerData: Array,
      tableColumn: Array,
      visibleColumn: Array,
      fixedColumn: Array,
      size: String,
      fixedType: String
    },
    mounted: function mounted() {
      var $table = this.$parent,
          $el = this.$el,
          $refs = this.$refs,
          fixedType = this.fixedType;
      var elemStore = $table.elemStore;
      var prefix = ''.concat(fixedType || 'main', '-footer-');
      elemStore[''.concat(prefix, 'wrapper')] = $el;
      elemStore[''.concat(prefix, 'table')] = $refs.table;
      elemStore[''.concat(prefix, 'colgroup')] = $refs.colgroup;
      elemStore[''.concat(prefix, 'list')] = $refs.tfoot;
      elemStore[''.concat(prefix, 'x-space')] = $refs.xSpace;
    },
    render: function render(h) {
      var _e = this._e,
          $table = this.$parent,
          fixedType = this.fixedType,
          fixedColumn = this.fixedColumn,
          tableColumn = this.tableColumn,
          footerData = this.footerData;
      var tableListeners = $table.$listeners,
          footerRowClassName = $table.footerRowClassName,
          footerCellClassName = $table.footerCellClassName,
          footerRowStyle = $table.footerRowStyle,
          footerCellStyle = $table.footerCellStyle,
          allFooterAlign = $table.footerAlign,
          footerSpanMethod = $table.footerSpanMethod,
          allAlign = $table.align,
          scrollXLoad = $table.scrollXLoad,
          columnKey = $table.columnKey,
          allColumnOverflow = $table.showOverflow,
          overflowX = $table.overflowX,
          getColumnIndex = $table.getColumnIndex; // 如果是使用优化模式
  
      if (fixedType && allColumnOverflow) {
        tableColumn = fixedColumn;
      } else if (scrollXLoad) {
        if (fixedType) {
          tableColumn = fixedColumn;
        }
      }
  
      return h('div', {
        class: ['vue-xtable-table--footer-wrapper', fixedType ? 'fixed-'.concat(fixedType, '--wrapper') : 'body--wrapper'],
        on: {
          scroll: this.scrollEvent
        }
      }, [fixedType ? _e() : h('div', {
        class: 'vue-xtable-body--x-space',
        ref: 'xSpace'
      }), h('table', {
        class: 'vue-xtable-table--footer',
        attrs: {
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        },
        ref: 'table'
      }, [
      /**
       * 列宽
       */
      h('colgroup', {
        ref: 'colgroup'
      }, tableColumn.map(function (column, columnIndex) {
        return h('col', {
          attrs: {
            name: column.id
          },
          key: columnIndex
        });
      }).concat([h('col', {
        attrs: {
          name: 'col_gutter'
        }
      })])),
      /**
       * 底部
       */
      h('tfoot', {
        ref: 'tfoot'
      }, footerData.map(function (list, $rowIndex) {
        return h('tr', {
          class: ['vue-xtable-footer--row', footerRowClassName ? VueUtil.isFunction(footerRowClassName) ? footerRowClassName({
            $table: $table,
            $rowIndex: $rowIndex,
            fixed: fixedType
          }) : footerRowClassName : ''],
          style: footerRowStyle ? VueUtil.isFunction(footerRowStyle) ? footerRowStyle({
            $table: $table,
            $rowIndex: $rowIndex,
            fixed: fixedType
          }) : footerRowStyle : null
        }, tableColumn.map(function (column, $columnIndex) {
          var _ref2;
  
          var showOverflow = column.showOverflow,
              footerAlign = column.footerAlign,
              align = column.align,
              footerClassName = column.footerClassName;
          var isColGroup = column.children && column.children.length;
          var fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
          var cellOverflow = VueUtil.isUndefined(showOverflow) || VueUtil.isNull(showOverflow) ? allColumnOverflow : showOverflow;
          var footAlign = footerAlign || align || allFooterAlign || allAlign;
          var showEllipsis = cellOverflow === 'ellipsis';
          var showTitle = cellOverflow === 'title';
          var showTooltip = cellOverflow === true || cellOverflow === 'tooltip';
          var hasEllipsis = showTitle || showTooltip || showEllipsis;
          var attrs = {
            'data-colid': column.id
          };
          var tfOns = {}; // 确保任何情况下 columnIndex 都精准指向真实列索引
  
          var columnIndex = getColumnIndex(column);
          var params = {
            $table: $table,
            $rowIndex: $rowIndex,
            column: column,
            columnIndex: columnIndex,
            $columnIndex: $columnIndex,
            fixed: fixedType
          };
  
          if (showTitle || showTooltip) {
            tfOns.mouseenter = function (evnt) {
              if (showTitle) {
                tools.DomTools.updateCellTitle(evnt);
              } else if (showTooltip) {
                $table.triggerFooterTooltipEvent(evnt, {
                  $table: $table,
                  $rowIndex: $rowIndex,
                  column: column,
                  columnIndex: columnIndex,
                  $columnIndex: $columnIndex,
                  fixed: fixedType
                });
              }
            };
          }
  
          if (showTooltip) {
            tfOns.mouseleave = function (evnt) {
              if (showTooltip) {
                $table.handleTargetLeaveEvent(evnt);
              }
            };
          }
  
          if (tableListeners['header-cell-click']) {
            tfOns.click = function (evnt) {
              tools.UtilTools.emitEvent($table, 'header-cell-click', [{
                $table: $table,
                $rowIndex: $rowIndex,
                column: column,
                columnIndex: columnIndex,
                $columnIndex: $columnIndex,
                fixed: fixedType,
                cell: evnt.currentTarget
              }, evnt]);
            };
          }
  
          if (tableListeners['header-cell-dblclick']) {
            tfOns.dblclick = function (evnt) {
              tools.UtilTools.emitEvent($table, 'header-cell-dblclick', [{
                $table: $table,
                $rowIndex: $rowIndex,
                column: column,
                columnIndex: columnIndex,
                $columnIndex: $columnIndex,
                fixed: fixedType,
                cell: evnt.currentTarget
              }, evnt]);
            };
          } // 合并行或列
  
  
          if (footerSpanMethod) {
            var _ref = footerSpanMethod({
              $table: $table,
              $rowIndex: $rowIndex,
              column: column,
              columnIndex: columnIndex,
              $columnIndex: $columnIndex,
              fixed: fixedType,
              data: footerData
            }) || {},
                _ref$rowspan = _ref.rowspan,
                rowspan = _ref$rowspan === void 0 ? 1 : _ref$rowspan,
                _ref$colspan = _ref.colspan,
                colspan = _ref$colspan === void 0 ? 1 : _ref$colspan;
  
            if (!rowspan || !colspan) {
              return null;
            }
  
            attrs.rowspan = rowspan;
            attrs.colspan = colspan;
          }
  
          return h('td', {
            class: ['vue-xtable-footer--column', column.id, (_ref2 = {}, _defineProperty(_ref2, 'col--'.concat(footAlign), footAlign), _defineProperty(_ref2, 'fixed--hidden', fixedHiddenColumn), _defineProperty(_ref2, 'col--ellipsis', hasEllipsis), _defineProperty(_ref2, 'filter--active', column.filters.some(function (item) {
              return item.checked;
            })), _ref2), tools.UtilTools.getClass(footerClassName, params), tools.UtilTools.getClass(footerCellClassName, params)],
            attrs: attrs,
            style: footerCellStyle ? VueUtil.isFunction(footerCellStyle) ? footerCellStyle({
              $table: $table,
              $rowIndex: $rowIndex,
              column: column,
              columnIndex: columnIndex,
              $columnIndex: $columnIndex,
              fixed: fixedType
            }) : footerCellStyle : null,
            on: tfOns,
            key: columnKey ? column.id : columnIndex
          }, [h('div', {
            class: 'vue-xtable-cell'
          }, tools.UtilTools.formatText(list[$table.tableColumn.indexOf(column)], 1))]);
        }).concat([h('td', {
          class: 'col--gutter'
        })]));
      }))])]);
    },
    methods: {
      /**
       * 滚动处理
       * 如果存在列固定左侧，同步更新滚动状态
       * 如果存在列固定右侧，同步更新滚动状态
       */
      scrollEvent: function scrollEvent(evnt) {
        var $table = this.$parent,
            fixedType = this.fixedType;
        var $refs = $table.$refs,
            scrollXLoad = $table.scrollXLoad,
            triggerScrollXEvent = $table.triggerScrollXEvent,
            lastScrollLeft = $table.lastScrollLeft;
        var tableHeader = $refs.tableHeader;
        var headerElem = tableHeader ? tableHeader.$el : null;
        var bodyElem = $refs.tableBody.$el;
        var footerElem = $refs.tableFooter.$el;
        var scrollLeft = footerElem.scrollLeft;
        var isX = scrollLeft !== lastScrollLeft;
        $table.lastScrollLeft = scrollLeft;
        $table.lastScrollTime = Date.now();
  
        if (headerElem) {
          headerElem.scrollLeft = scrollLeft;
        }
  
        if (bodyElem) {
          bodyElem.scrollLeft = scrollLeft;
        }
  
        if (scrollXLoad && isX) {
          triggerScrollXEvent(evnt);
        }
  
        tools.UtilTools.emitEvent($table, 'scroll', [{
          type: 'footer',
          fixed: fixedType,
          scrollTop: bodyElem.scrollTop,
          scrollLeft: scrollLeft,
          isX: isX,
          isY: false,
          $table: $table
        }, evnt]);
      }
    }
  };
  return VueXtableFooter;
});
(function (context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    var result = definition(context.VueXtable, context.baseTable, context.tools);
    context.VueXtableFilter = result.component;
    context.VueXtableFilterMixin = result.mixin;
  }
})(this, function (Table, baseTable, tools) {
  var _defineProperty = tools.UtilTools.defineProperty;

  var mixin = {
    methods: {
      /**
       * 手动调用筛选的方法
       * 如果不传回调则返回一个选项列表的 Promise 对象
       * 如果传回调则通过回调返回的值更新选项列表，并返回一个新选项列表的 Promise 对象
       * @param {String} field 字段名
       * @param {Function} callback 重置列表的回调函数，返回新的选项列表
       */
      _filter: function filter(field, callback) {
        var column = this.getColumnByField(field);
        var filters = column.filters;

        if (callback) {
          var rest = callback(filters);

          if (VueUtil.isArray(rest)) {
            column.filters = tools.UtilTools.getFilters(rest);
          }
        }

        return this.$nextTick().then(function () {
          return filters;
        });
      },

      /**
       * 点击筛选事件
       * 当筛选图标被点击时触发
       * 更新选项是否全部状态
       * 打开筛选面板
       * @param {Event} evnt 事件
       * @param {ColumnConfig} column 列配置
       * @param {Object} params 参数
       */
      triggerFilterEvent: function triggerFilterEvent(evnt, column, params) {
        var $refs = this.$refs,
          filterStore = this.filterStore;

        if (filterStore.column === column && filterStore.visible) {
          filterStore.visible = false;
        } else {

          this.closeFilter();
          this.$nextTick(function () {

            var filterWrapper = $refs.filterWrapper;
            var targetElem = evnt.target,
              pageX = evnt.pageX;

            var _DomTools$getDomNode = tools.DomTools.getDomNode(),
              visibleWidth = _DomTools$getDomNode.visibleWidth;

            var _DomTools$getAbsolute = tools.DomTools.getAbsolutePos(targetElem),
              top = _DomTools$getAbsolute.top,
              left = _DomTools$getAbsolute.left;

            if (!filterStore.zIndex || filterStore.zIndex < tools.UtilTools.getLastZIndex()) {
              filterStore.zIndex = tools.UtilTools.nextZIndex(this);
            }

            VueUtil.assign(filterStore, {
              args: params,
              multiple: column.filterMultiple,
              options: column.filters,
              column: column,
              style: {
                zIndex: filterStore.zIndex,
                top: ''.concat(top + targetElem.clientHeight + 6, 'px'),
                left: ''.concat(left, 'px')
              },
              visible: true
            });
            filterStore.isAllSelected = filterStore.options.every(function (item) {
              return item.checked;
            });
            filterStore.isIndeterminate = !filterStore.isAllSelected && filterStore.options.some(function (item) {
              return item.checked;
            });
            this.$nextTick(function () {
              var filterWrapperElem = filterWrapper.$el;
              var clientWidth = filterWrapperElem.clientWidth;
              var wrapperLeft = left - clientWidth / 2 + 10;

              if (pageX + clientWidth > visibleWidth) {
                wrapperLeft = left - clientWidth;
              }

              filterStore.style.left = ''.concat(Math.max(20, wrapperLeft + 20), 'px');
              filterStore.style.top = ''.concat(top + targetElem.clientHeight + 6, 'px');
            });
          });

        }
      },

      /**
       * 确认筛选
       * 当筛选面板中的确定按钮被按下时触发
       * @param {Event} evnt 事件
       */
      confirmFilterEvent: function confirmFilterEvent(evnt) {
        var visibleColumn = this.visibleColumn,
          filterStore = this.filterStore,
          remoteFilter = this.remoteFilter,
          scrollXLoad = this.scrollXLoad,
          scrollYLoad = this.scrollYLoad;
        var column = filterStore.column;
        var property = column.property;
        var values = [];
        var datas = [];
        column.filters.forEach(function (item) {
          if (item.checked) {
            values.push(item.value);
            datas.push(item.data);
          }
        });
        filterStore.visible = false; // 如果是服务端筛选，则跳过本地筛选处理

        if (!remoteFilter) {
          this.handleTableData(true);
        }

        var filterList = [];
        visibleColumn.filter(function (column) {
          var property = column.property,
            filters = column.filters;
          var valueList = [];
          var dataList = [];

          if (filters && filters.length) {
            filters.forEach(function (item) {
              if (item.checked) {
                valueList.push(item.value);
                dataList.push(item.data);
              }
            }); // 在 v3.0 中废弃 prop

            filterList.push({
              column: column,
              property: property,
              field: property,
              prop: property,
              values: valueList,
              datas: dataList
            });
          }
        }); // 在 v3.0 中废弃 prop

        tools.UtilTools.emitEvent(this, 'filter-change', [{
          column: column,
          property: property,
          field: property,
          prop: property,
          values: values,
          datas: datas,
          filters: filterList,
          $table: this
        }]);

        this.updateFooter();

        if (scrollXLoad || scrollYLoad) {
          this.clearScroll();

          if (scrollYLoad) {
            this.updateScrollYSpace();
          }
        }

        this.closeFilter();
        this.$nextTick(this.recalculate);
      },

      /**
       * 重置筛选
       * 当筛选面板中的重置按钮被按下时触发
       * @param {Event} evnt 事件
       */
      resetFilterEvent: function resetFilterEvent(evnt) {
        this.filterStore.options.forEach(function (item) {
          item.checked = false;
          item.data = item._data;
        });
        this.confirmFilterEvent(evnt);
      },

      /**
       * 清空指定列的筛选条件
       * 如果为空则清空所有列的筛选条件
       * @param {String} field 字段名
       */
      _clearFilter: function (field) {
        var column = arguments.length ? this.getColumnByField(field) : null;
        var filterStore = this.filterStore;

        var handleClear = function handleClear(column) {
          var filters = column.filters;

          if (filters && filters.length) {
            filters.forEach(function (item) {
              item.checked = false;
              item.data = item._data;
            });
          }
        };

        if (column) {
          handleClear(column);
        } else {
          this.visibleColumn.forEach(handleClear);
        }

        if (!column || column !== filterStore.column) {
          VueUtil.assign(filterStore, {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          });
        }

        return this.updateData();
      }
    }
  };

  var VueXtableFilter = {
    name: 'VueXtableFilter',
    props: {
      filterStore: Object,
      optimizeOpts: Object
    },
    render: function render(h) {
      var filterStore = this.filterStore,
        optimizeOpts = this.optimizeOpts;
      return h('div', {
        class: ['vue-xtable-table--filter-wrapper', 'filter--prevent-default', {
          't--animat': optimizeOpts.animat,
          'filter--active': filterStore.visible
        }],
        style: filterStore.style
      }, filterStore.visible ? [h('ul', {
        class: 'vue-xtable-table--filter-body'
      }, this.renderOptions(h)), this.renderFooter(h)] : []);
    },
    methods: {
      renderOptions: function renderOptions(h) {
        var _ref,
          _this = this;

        var $table = this.$parent,
          filterStore = this.filterStore;
        var vSize = $table.vSize;
        var args = filterStore.args,
          column = filterStore.column,
          multiple = filterStore.multiple;
        var slots = column.slots,
          own = column.own;
        var filterRender = own.filterRender;
        var compConf = filterRender ? baseTable.Renderer.get(filterRender.name) : null;

        if (slots && slots.filter) {
          return slots.filter.call($table, VueUtil.assign({
            $table: $table,
            context: this
          }, args), h);
        } else if (compConf && compConf.renderFilter) {
          return compConf.renderFilter.call($table, h, filterRender, args, this);
        }

        var filterRens = [h('li', {
          class: ['vue-xtable-table--filter-option', {
            'is--active': !filterStore.options.some(function (item) {
              return item.checked;
            })
          }]
        }, [multiple ? h('label', {
          class: ['vue-xtable-checkbox', (_ref = {}, _defineProperty(_ref, 'size--'.concat(vSize), vSize), _defineProperty(_ref, 'is--indeterminate', filterStore.isIndeterminate), _ref)]
        }, [h('input', {
          attrs: {
            type: 'checkbox'
          },
          domProps: {
            checked: filterStore.isAllSelected
          },
          on: {
            change: function change(evnt) {
              return _this.filterCheckAllEvent(evnt, evnt.target.checked);
            }
          }
        }), h('span', {
          class: 'vue-xtable-checkbox--icon'
        }), h('span', {
          class: 'vue-xtable-checkbox--label'
        }, GlobalConfig.i18n('vue.xtable.table.allFilter'))]) : h('span', {
          class: 'vue-xtable-table--filter-label',
          on: {
            click: $table.resetFilterEvent
          }
        }, GlobalConfig.i18n('vue.xtable.table.allFilter'))])];
        filterStore.options.forEach(function (item, index) {
          filterRens.push(h('li', {
            class: ['vue-xtable-table--filter-option', {
              'is--active': item.checked
            }],
            key: index
          }, [multiple ? h('label', {
            class: ['vue-xtable-checkbox', _defineProperty({}, 'size--'.concat(vSize), vSize)]
          }, [h('input', {
            attrs: {
              type: 'checkbox'
            },
            domProps: {
              checked: item.checked
            },
            on: {
              change: function change(evnt) {
                return _this.changeMultipleOption(evnt, evnt.target.checked, item);
              }
            }
          }), h('span', {
            class: 'vue-xtable-checkbox--icon'
          }), h('span', {
            class: 'vue-xtable-checkbox--label'
          }, item.label)]) : h('span', {
            class: 'vue-xtable-table--filter-label',
            on: {
              click: function click(evnt) {
                return _this.changeRadioOption(evnt, !item.checked, item);
              }
            }
          }, item.label)]));
        });
        return filterRens;
      },
      renderFooter: function renderFooter(h) {
        var filterStore = this.filterStore;
        var multiple = filterStore.multiple;
        return multiple ? h('div', {
          class: 'vue-xtable-table--filter-footer'
        }, [h('vue-button', {
          attrs: {
            type: 'primary',
            size: 'mini',
            disabled: !filterStore.isAllSelected && !filterStore.isIndeterminate
          },
          on: {
            click: this.confirmFilter
          }
        }, GlobalConfig.i18n('vue.xtable.table.confirmFilter')), h('vue-button', {
          attrs: {
            size: 'mini'
          },
          on: {
            click: this.resetFilter
          }
        }, GlobalConfig.i18n('vue.xtable.table.resetFilter'))]) : null;
      },
      // 全部筛选事件
      filterCheckAllEvent: function filterCheckAllEvent(evnt, value) {
        var filterStore = this.filterStore;
        filterStore.options.forEach(function (item) {
          item.checked = value;
        });
        filterStore.isAllSelected = value;
        filterStore.isIndeterminate = false;
      },
      checkOptions: function checkOptions() {
        var filterStore = this.filterStore;
        filterStore.isAllSelected = filterStore.options.every(function (item) {
          return item.checked;
        });
        filterStore.isIndeterminate = !filterStore.isAllSelected && filterStore.options.some(function (item) {
          return item.checked;
        });
      },

      /*************************
       * Publish methods
       *************************/
      // （单选）筛选发生改变
      changeRadioOption: function changeRadioOption(evnt, checked, item) {
        this.filterStore.options.forEach(function (item) {
          item.checked = false;
        });
        item.checked = checked;
        this.checkOptions();
        this.$parent.confirmFilterEvent();
      },
      // （多选）筛选发生改变
      changeMultipleOption: function changeMultipleOption(evnt, checked, item) {
        item.checked = checked;
        this.checkOptions();
      },
      // 筛选发生改变
      changeOption: function changeOption(evnt, checked, item) {
        if (this.filterStore.multiple) {
          this.changeMultipleOption(evnt, checked, item);
        } else {
          this.changeRadioOption(evnt, checked, item);
        }
      },
      // 确认筛选
      confirmFilter: function confirmFilter() {
        this.$parent.confirmFilterEvent();
      },
      // 重置筛选
      resetFilter: function resetFilter() {
        this.$parent.resetFilterEvent();
      }
      /*************************
       * Publish methods
       *************************/

    }
  };

  return {
    component: VueXtableFilter,
    mixin: mixin
  };
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableContextMenu = definition(context.tools, context.baseTable).component;
    context.VueXtableContextMenuMixin = definition(context.tools, context.baseTable).mixin;
  }
})(this, function(tools, baseTable) {

  var Mixin = {
    methods: {
      /**
      * 关闭快捷菜单
      */
      _closeMenu: function _closeMenu() {
        VueUtil.assign(this.ctxMenuStore, {
          visible: false,
          selected: null,
          selectChild: null,
          showChild: false
        });
        return this.$nextTick();
      },
      // 处理菜单的移动
      moveCtxMenu: function moveCtxMenu(evnt, keyCode, ctxMenuStore, property, operKey, operRest, menuList) {
        var selectItem;
        var selectIndex = VueUtil.findIndexOf(menuList, function (item) {
          return ctxMenuStore[property] === item;
        });
  
        if (keyCode === operKey) {
          if (operRest && tools.UtilTools.hasChildrenList(ctxMenuStore.selected)) {
            ctxMenuStore.showChild = true;
          } else {
            ctxMenuStore.showChild = false;
            ctxMenuStore.selectChild = null;
          }
        } else if (keyCode === 38) {
          for (var len = selectIndex - 1; len >= 0; len--) {
            if (menuList[len].visible !== false) {
              selectItem = menuList[len];
              break;
            }
          }
  
          ctxMenuStore[property] = selectItem || menuList[menuList.length - 1];
        } else if (keyCode === 40) {
          for (var index = selectIndex + 1; index < menuList.length; index++) {
            if (menuList[index].visible !== false) {
              selectItem = menuList[index];
              break;
            }
          }
  
          ctxMenuStore[property] = selectItem || menuList[0];
        } else if (ctxMenuStore[property] && (keyCode === 13 || keyCode === 32)) {
          this.ctxMenuLinkEvent(evnt, ctxMenuStore[property]);
        }
      },
  
      /**
      * 快捷菜单事件处理
      */
      handleGlobalContextmenuEvent: function handleGlobalContextmenuEvent(evnt) {
        var isCtxMenu = this.isCtxMenu,
            ctxMenuStore = this.ctxMenuStore,
            ctxMenuOpts = this.ctxMenuOpts;
        var layoutList = ['header', 'body', 'footer'];
  
        if (isCtxMenu) {
          if (ctxMenuStore.visible) {
            if (ctxMenuStore.visible && this.$refs.ctxWrapper && this.getEventTargetNode(evnt, this.$refs.ctxWrapper.$el).flag) {
              evnt.preventDefault();
              return;
            }
          }
  
          for (var index = 0; index < layoutList.length; index++) {
            var layout = layoutList[index];
            var columnTargetNode = this.getEventTargetNode(evnt, this.$el, 'vue-xtable-'.concat(layout, '--column'));
            var params = {
              type: layout,
              $table: this,
              columns: this.visibleColumn.slice(0)
            };
  
            if (columnTargetNode.flag) {
              var cell = columnTargetNode.targetElem;
              var column = this.getColumnNode(cell).item;
              var typePrefix = ''.concat(layout, '-');
              VueUtil.assign(params, {
                column: column,
                columnIndex: this.getColumnIndex(column),
                cell: cell
              });
  
              if (layout === 'body') {
                var row = this.getRowNode(cell.parentNode).item;
                typePrefix = '';
                params.row = row;
                params.rowIndex = this.getRowIndex(row);
              }
  
              this.openContextMenu(evnt, layout, params);
  
              tools.UtilTools.emitEvent(this, ''.concat(typePrefix, 'cell-context-menu'), [params, evnt]);
  
              return;
            } else if (this.getEventTargetNode(evnt, this.$el, 'vue-xtable-table--'.concat(layout, '-wrapper')).flag) {
              if (ctxMenuOpts.trigger === 'cell') {
                evnt.preventDefault();
              } else {
                this.openContextMenu(evnt, layout, params);
              }
  
              return;
            }
          }
        }
  
        this.closeMenu();
        this.closeFilter();
      },
  
      /**
      * 显示快捷菜单
      */
      openContextMenu: function openContextMenu(evnt, type, params) {
        var _this = this;
  
        var ctxMenuStore = this.ctxMenuStore,
            ctxMenuOpts = this.ctxMenuOpts;
        var config = ctxMenuOpts[type];
        var visibleMethod = ctxMenuOpts.visibleMethod;
  
        if (config) {
          var options = config.options,
              disabled = config.disabled;
  
          if (disabled) {
            evnt.preventDefault();
          } else if (options && options.length) {
            params.options = options;
            this.preventEvent(evnt, 'event.show_menu', params, null, function () {
              if (!visibleMethod || visibleMethod(params, evnt)) {
                evnt.preventDefault();
  
                _this.updateZindex();
  
                var _DomTools$getDomNode = tools.DomTools.getDomNode(),
                    scrollTop = _DomTools$getDomNode.scrollTop,
                    scrollLeft = _DomTools$getDomNode.scrollLeft,
                    visibleHeight = _DomTools$getDomNode.visibleHeight,
                    visibleWidth = _DomTools$getDomNode.visibleWidth;
  
                var top = evnt.clientY + scrollTop;
                var left = evnt.clientX + scrollLeft;
                VueUtil.assign(ctxMenuStore, {
                  args: params,
                  visible: true,
                  list: options,
                  selected: null,
                  selectChild: null,
                  showChild: false,
                  style: {
                    zIndex: _this.tZindex,
                    top: ''.concat(top, 'px'),
                    left: ''.concat(left, 'px')
                  }
                });
  
                _this.$nextTick(function () {
                  var ctxElem = _this.$refs.ctxWrapper.$el;
                  var clientHeight = ctxElem.clientHeight;
                  var clientWidth = ctxElem.clientWidth;
                  var offsetTop = evnt.clientY + clientHeight - visibleHeight;
                  var offsetLeft = evnt.clientX + clientWidth - visibleWidth;
  
                  if (offsetTop > -10) {
                    ctxMenuStore.style.top = ''.concat(top - clientHeight, 'px');
                  }
  
                  if (offsetLeft > -10) {
                    ctxMenuStore.style.left = ''.concat(left - clientWidth, 'px');
                  }
                });
              } else {
                _this.closeMenu();
              }
            });
          }
        }
  
        this.closeFilter();
      },
      ctxMenuMouseoverEvent: function ctxMenuMouseoverEvent(evnt, item, child) {
        var ctxMenuStore = this.ctxMenuStore;
        evnt.preventDefault();
        evnt.stopPropagation();
        ctxMenuStore.selected = item;
        ctxMenuStore.selectChild = child;
  
        if (!child) {
          ctxMenuStore.showChild = tools.UtilTools.hasChildrenList(item);
        }
      },
      ctxMenuMouseoutEvent: function ctxMenuMouseoutEvent(evnt, item, child) {
        var ctxMenuStore = this.ctxMenuStore;
  
        if (!item.children) {
          ctxMenuStore.selected = null;
        }
  
        ctxMenuStore.selectChild = null;
      },
  
      /**
      * 快捷菜单点击事件
      */
      ctxMenuLinkEvent: function ctxMenuLinkEvent(evnt, menu) {
        if (!menu.disabled && (!menu.children || !menu.children.length)) {
          var ctxMenuMethod = baseTable.Menus.get(menu.code);
  
          var params = VueUtil.assign({
            menu: menu,
            $table: this
          }, this.ctxMenuStore.args);
  
          if (ctxMenuMethod) {
            ctxMenuMethod.call(this, params, evnt);
          }
  
          tools.UtilTools.emitEvent(this, 'context-menu-click', [params, evnt]);
  
          this.closeMenu();
        }
      }
    }
  };
  var VueXtableContextMenu = {
    name: 'VueXtableContextMenu',
    props: {
      ctxMenuStore: Object
    },
    render: function render(h) {
      var $table = this.$parent;
      var _e = this._e,
          ctxMenuStore = this.ctxMenuStore;
      return h('div', {
        class: ['vue-xtable-table--ctxmenu-wrapper', {
          show: ctxMenuStore.visible
        }],
        style: ctxMenuStore.style
      }, ctxMenuStore.list.map(function (options, gIndex) {
        return h('ul', {
          class: 'vue-xtable-ctxmenu--option-wrapper',
          key: gIndex
        }, options.map(function (item, index) {
          var hasChild = item.children && item.children.length;
          return item.visible === false ? _e() : h('li', {
            class: {
              'link--disabled': item.disabled,
              'link--active': item === ctxMenuStore.selected
            },
            key: ''.concat(gIndex, '_').concat(index)
          }, [h('a', {
            class: 'vue-xtable-ctxmenu--link',
            on: {
              click: function click(evnt) {
                $table.ctxMenuLinkEvent(evnt, item);
              },
              mouseover: function mouseover(evnt) {
                $table.ctxMenuMouseoverEvent(evnt, item);
              },
              mouseout: function mouseout(evnt) {
                $table.ctxMenuMouseoutEvent(evnt, item);
              }
            }
          }, [h('i', {
            class: ['vue-xtable-ctxmenu--link-prefix', item.prefixIcon]
          }), h('span', {
            class: 'vue-xtable-ctxmenu--link-content'
          }, tools.UtilTools.getFuncText(item.name)), h('i', {
            class: ['vue-xtable-ctxmenu--link-suffix', hasChild ? item.suffixIcon || 'suffix--haschild' : item.suffixIcon]
          })]), hasChild ? h('ul', {
            class: ['vue-xtable-table--ctxmenu-clild-wrapper', {
              show: item === ctxMenuStore.selected && ctxMenuStore.showChild
            }]
          }, item.children.map(function (child, cIndex) {
            return child.visible === false ? _e() : h('li', {
              class: {
                'link--disabled': child.disabled,
                'link--active': child === ctxMenuStore.selectChild
              },
              key: ''.concat(gIndex, '_').concat(index, '_').concat(cIndex)
            }, [h('a', {
              class: 'vue-xtable-ctxmenu--link',
              on: {
                click: function click(evnt) {
                  $table.ctxMenuLinkEvent(evnt, child);
                },
                mouseover: function mouseover(evnt) {
                  $table.ctxMenuMouseoverEvent(evnt, item, child);
                },
                mouseout: function mouseout(evnt) {
                  $table.ctxMenuMouseoutEvent(evnt, item, child);
                }
              }
            }, [h('i', {
              class: ['vue-xtable-ctxmenu--link-prefix', child.prefixIcon]
            }), h('span', {
              class: 'vue-xtable-ctxmenu--link-content'
            }, tools.UtilTools.getFuncText(child.name))])]);
          })) : _e()]);
        }));
      }));
    }
  };
  return {
    component: VueXtableContextMenu,
    mixin: Mixin
  };
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableEditMixin = definition(context.tools, context.baseTable);
  }
})(this, function(tools, baseTable) {
  var VueXtableEditMixin = {
    data: function() {
      return {
        currentActiveRowOldValue: null,
      };
    },
    methods: {
      /**
       * 往表格中插入临时数据
       *
       * @param {*} records
       */
      _insert: function _insert(records) {
        return this.insertAt(records);
      },

      /**
       * 往表格指定行中插入临时数据
       * 如果 row 为空则从插入到顶部
       * 如果 row 为 -1 则从插入到底部
       * 如果 row 为有效行则插入到该行的位置
       * @param {Object/Array} records 新的数据
       * @param {Row} row 指定行
       */
      _insertAt: function _insertAt(records, row) {
        var _this = this;

        var afterFullData = this.afterFullData,
            editStore = this.editStore,
            scrollYLoad = this.scrollYLoad,
            tableFullData = this.tableFullData,
            treeConfig = this.treeConfig;

        if (treeConfig) {
          throw new Error(tools.UtilTools.getLog('vue.xtable.error.noTree', ['insert']));
        }

        if (!VueUtil.isArray(records)) {
          records = [records];
        }

        var nowData = afterFullData;
        var newRecords = records.map(function (record) {
          return _this.defineField(VueUtil.assign({}, record));
        });

        if (!row) {
          nowData.unshift.apply(nowData, newRecords);
          tableFullData.unshift.apply(tableFullData, newRecords);
        } else {
          if (row === -1) {
            nowData.push.apply(nowData, newRecords);
            tableFullData.push.apply(tableFullData, newRecords);
          } else {
            var targetIndex = nowData.indexOf(row);

            if (targetIndex === -1) {
              throw new Error(tools.UtilTools.error('vue.xtable.error.unableInsert'));
            }

            nowData.splice.apply(nowData, [targetIndex, 0].concat(newRecords));
            tableFullData.splice.apply(tableFullData, [tableFullData.indexOf(row), 0].concat(newRecords));
          }
        }

        [].unshift.apply(editStore.insertList, newRecords);
        this.handleTableData();
        this.updateCache();
        this.checkSelectionStatus();

        if (scrollYLoad) {
          this.updateScrollYSpace();
        }

        return this.$nextTick().then(function () {
          _this.recalculate();

          return {
            row: newRecords.length ? newRecords[newRecords.length - 1] : null,
            rows: newRecords
          };
        });
      },

      /**
       * 删除指定行数据
       * 如果传 row 则删除一行
       * 如果传 rows 则删除多行
       * 如果为空则删除所有
       */
      _remove: function _remove(rows) {
        var _this2 = this;

        var afterFullData = this.afterFullData,
            tableFullData = this.tableFullData,
            editStore = this.editStore,
            treeConfig = this.treeConfig,
            selection = this.selection,
            isInsertByRow = this.isInsertByRow,
            scrollYLoad = this.scrollYLoad;
        var removeList = editStore.removeList,
            insertList = editStore.insertList; // 在 v3.0 中废弃 selectConfig

        var checkboxConfig = this.checkboxConfig || this.selectConfig || {};
        var property = checkboxConfig.checkField;
        var rest = [];
        var nowData = afterFullData;

        if (treeConfig) {
          throw new Error(tools.UtilTools.getLog('vue.xtable.error.noTree', ['remove']));
        }

        if (!rows) {
          rows = tableFullData;
        } else if (!VueUtil.isArray(rows)) {
          rows = [rows];
        } // 如果是新增，则保存记录


        rows.forEach(function (row) {
          if (!isInsertByRow(row)) {
            removeList.push(row);
          }
        }); // 如果绑定了多选属性，则更新状态

        if (!property) {
          VueUtil.remove(selection, function (row) {
            return rows.indexOf(row) > -1;
          });
        } // 从数据源中移除


        if (tableFullData === rows) {
          rows = tableFullData.slice(0);
          tableFullData.length = 0;
          nowData.length = 0;
        } else {
          rest = VueUtil.remove(tableFullData, function (row) {
            return rows.indexOf(row) > -1;
          });
          VueUtil.remove(nowData, function (row) {
            return rows.indexOf(row) > -1;
          });
        } // 从新增中移除已删除的数据


        VueUtil.remove(insertList, function (row) {
          return rows.indexOf(row) > -1;
        });
        this.handleTableData();
        this.updateCache();
        this.checkSelectionStatus();

        if (scrollYLoad) {
          this.updateScrollYSpace();
        }

        return this.$nextTick().then(function () {
          _this2.recalculate();

          return {
            row: rows && rows.length ? rows[rows.length - 1] : null,
            rows: rest
          };
        });
      },

      _insertRow: function(position, record, callback) {
        var self = this;
        var addPosition;
        //参数position为0第一行插入，-1最后一行
        if (position === 0 || position === -1) {
          addPosition = position;
        //其他数字放回对应的row对象，在该row上面插入
        } else if (position) {
          addPosition = self.afterFullData[position];
        //未定义，并且当前选中行存在，返回选中行的下一行，并在该行上面插入
        } else if (self.highlightCurrentRow && self.getCurrentRow()) {
          addPosition = self.afterFullData[self.afterFullData.indexOf(self.getCurrentRow()) + 1] || -1;
        //其他情况，在最后插入
        } else {
          addPosition = -1;
        }

        record = record || {};

        return self.insertAt(record, addPosition).then(function(added) {
          var newRow = added.row;
          self.setCurrentRow(newRow);
          self.setActiveRow(newRow).then(function() {
            callback && callback(added, self);
          });
        });
      },

      _delRow: function(callback) {
        var self = this;
        if(this.getSelectRecords().length > 0){
            this.removeSelecteds().then(function() {
              callback && callback();
            });
        } else if (this.highlightCurrentRow && this.getCurrentRow()) {
          var index = this.afterFullData.indexOf(this.getCurrentRow());
          this.remove(this.getCurrentRow()).then(function(row) {
            if (index >= self.afterFullData.length) index = self.afterFullData.length -1;
            self.setCurrentRow(self.afterFullData[index]);
            callback && callback(row);
          });
        }
      },

      /**
       * 删除选中数据
       */
      _removeSelecteds: function _removeSelecteds() {
        var _this3 = this;

        return this.remove(this.getSelectRecords()).then(function (params) {
          _this3.clearSelection();

          return params;
        });
      },
      _revert: function _revert() {
        tools.UtilTools.warn('vue.xtable.error.delFunc', ['revert', 'revertData']);

        return this.revertData.apply(this, arguments);
      },

      /**
       * 还原数据
       * 如果不传任何参数，则还原整个表格
       * 如果传 row 则还原一行
       * 如果传 rows 则还原多行
       * 如果还额外传了 field 则还原指定的单元格数据
       */
      _revertData: function _revertData(rows, field) {
        var tableSourceData = this.tableSourceData,
            getRowIndex = this.getRowIndex;

        if (arguments.length) {
          if (rows && !VueUtil.isArray(rows)) {
            rows = [rows];
          }

          rows.forEach(function (row) {
            var rowIndex = getRowIndex(row);
            var oRow = tableSourceData[rowIndex];

            if (oRow && row) {
              if (field) {
                VueUtil.set(row, field, VueUtil.get(oRow, field));
              } else {
                VueUtil.destructuring(row, oRow);
              }
            }
          });
          return this.$nextTick();
        }

        return this.reloadData(tableSourceData);
      },

      /**
       * 获取表格数据集，包含新增、删除、修改
       */
      _getRecordset: function _getRecordset() {
        return {
          insertRecords: this.getInsertRecords(),
          removeRecords: this.getRemoveRecords(),
          updateRecords: this.getUpdateRecords()
        };
      },

      /**
       * 获取新增的临时数据
       */
      _getInsertRecords: function _getInsertRecords() {
        return this.editStore.insertList;
      },

      /**
       * 获取已删除的数据
       */
      _getRemoveRecords: function _getRemoveRecords() {
        return this.editStore.removeList;
      },

      /**
       * 获取更新数据
       * 只精准匹配 row 的更改
       * 如果是树表格，子节点更改状态不会影响父节点的更新状态
       */
      _getUpdateRecords: function _getUpdateRecords() {
        var tableFullData = this.tableFullData,
            isUpdateByRow = this.isUpdateByRow,
            treeConfig = this.treeConfig;

        if (treeConfig) {
          return VueUtil.filterTree(tableFullData, function (row) {
            return isUpdateByRow(row);
          }, treeConfig);
        }

        return tableFullData.filter(function (row) {
          return isUpdateByRow(row);
        });
      },

      isCellEditable: function(params) {
        if (params.column && params.column.editRender) {
          var cell = tools.DomTools.getCell(this, {
            row: params.row,
            column: params.column
          });

          var newParams = {
            row: params.row,
            rowIndex: this.getRowIndex(params.row),
            column: params.column,
            columnIndex: this.getColumnIndex(params.column),
            $table: this
          };

          params.cell = cell;
          var activeMethod = this.editConfig && this.editConfig.activeMethod;

          if (!activeMethod || activeMethod(newParams)) {
            return true;
          }
        }
        return false;
      },
      /**
       * 处理激活编辑
       */
      handleActived: function handleActived(params, evnt, clearColumn) {
        var _this4 = this;

        var editStore = this.editStore,
            editConfig = this.editConfig,
            tableColumn = this.tableColumn;
        var activeMethod = editConfig.activeMethod;
        var actived = editStore.actived;
        var row = params.row,
            column = params.column,
            cell = params.cell;
        var editRender = column.editRender;

        if (editRender && cell) {
          if (actived.row !== row || (editConfig.mode === 'cell' ? actived.column !== column : false)) {
            // 判断是否禁用编辑
            var type = 'edit-disabled';

            if (!activeMethod || activeMethod(params)) {
              if (this.keyboardConfig || this.mouseConfig) {
                this.clearCopyed(evnt);
                this.clearChecked();
                this.clearSelected(evnt);
              }

              this.clostTooltip();
              this.clearActived(evnt);
              type = 'edit-actived';
              column.renderHeight = cell.offsetHeight;
              actived.args = params;
              actived.row = row;
              actived.column = column;

              this.currentActiveRowOldValue = VueUtil.cloneDeep(row);
              if (clearColumn) tools.UtilTools.setCellValue(row, clearColumn, null);
              if (editConfig.mode === 'row') {
                tableColumn.forEach(function (column) {
                  return _this4._getColumnModel(row, column);
                });
              } else {
                this._getColumnModel(row, column);
              }

              this.$nextTick(function () {
                _this4.handleFocus(params, evnt);
              });
            }

            tools.UtilTools.emitEvent(this, type, [params, evnt]);
          } else {
            var oldColumn = actived.column;

            if (oldColumn !== column) {
              var oldModel = oldColumn.model;

              if (oldModel.update) {
                tools.UtilTools.setCellValue(row, oldColumn, oldModel.value);
              }

              this.clearValidate();
            }

            column.renderHeight = cell.offsetHeight;
            actived.args = params;
            actived.column = column;
            setTimeout(function () {
              _this4.handleFocus(params, evnt);
            });
          }
        }
        _this4.isActivated = true;
        return this.$nextTick();
      },
      _getColumnModel: function _getColumnModel(row, column) {
        var model = column.model,
            editRender = column.editRender;

        if (editRender) {
          model.value = tools.UtilTools.getCellValue(row, column);
          model.update = false;
        }
      },
      _setColumnModel: function _setColumnModel(row, column) {
        var model = column.model,
            editRender = column.editRender;

        if (editRender && model.update) {
          tools.UtilTools.setCellValue(row, column, model.value);

          model.update = false;
          model.value = null;
        }
      },

      /**
       * 清除激活的编辑
       */
      _clearActived: function _clearActived(evnt) {
        var _this5 = this;

        var tableColumn = this.tableColumn,
            editStore = this.editStore,
            _this$editConfig = this.editConfig,
            editConfig = _this$editConfig === void 0 ? {} : _this$editConfig;
        var actived = editStore.actived;
        var args = actived.args,
            row = actived.row,
            column = actived.column;

        if (row || column) {
          if (editConfig.mode === 'row') {
            tableColumn.forEach(function (column) {
              return _this5._setColumnModel(row, column);
            });
          } else {
            this._setColumnModel(row, column);
          }

          this.updateFooter();

          tools.UtilTools.emitEvent(this, 'edit-closed', [args, evnt]);
        }

        actived.args = null;
        actived.row = null;
        actived.column = null;
        return (baseTable._valid ? this.clearValidate() : this.$nextTick()).then(this.recalculate);
      },
      _getActiveRow: function _getActiveRow() {
        var $el = this.$el,
            editStore = this.editStore,
            tableData = this.tableData;
        var _editStore$actived = editStore.actived,
            args = _editStore$actived.args,
            row = _editStore$actived.row;

        if (args && tableData.indexOf(row) > -1 && $el.querySelectorAll('.vue-xtable-body--column.col--actived').length) {
          return VueUtil.assign({}, args);
        }

        return null;
      },
      // 在 v3.0 中废弃 hasActiveRow
      _hasActiveRow: function _hasActiveRow(row) {
        tools.UtilTools.warn('vue.xtable.error.delFunc', ['hasActiveRow', 'isActiveByRow']);

        return this.isActiveByRow(row);
      },

      /**
       * 判断行是否为激活编辑状态
       * @param {Row} row 行对象
       */
      _isActiveByRow: function _isActiveByRow(row) {
        return this.editStore.actived.row === row;
      },

      /**
       * 处理聚焦
       */
      handleFocus: function handleFocus(params, evnt) {
        var row = params.row,
            column = params.column,
            cell = params.cell;
        var editRender = column.editRender;

        if (editRender) {
          var compRender = baseTable.Renderer.get(editRender.name);

          var autofocus = editRender.autofocus,
              autoselect = editRender.autoselect;
          var inputElem; // 如果指定了聚焦 class

          if (autofocus) {
            inputElem = cell.querySelector(autofocus);
          } // 渲染器的聚焦处理


          if (!inputElem && compRender && compRender.autofocus) {
            inputElem = cell.querySelector(compRender.autofocus);
          }

          if (inputElem) {
            inputElem[autoselect ? 'select' : 'focus']();

            if (VueUtil.isIE) {
              var textRange = inputElem.createTextRange();
              textRange.collapse(false);
              textRange.select();
            }
          } else {
            // 显示到可视区中
            this.scrollToRow(row, column);
          }
        }
      },

      /**
       * 激活行编辑
       */
      _setActiveRow: function _setActiveRow(row) {
        var column = VueUtil.find(this.visibleColumn, function (column) {
          return column.editRender;
        });
        // 没有可编辑列时, 强制focus第一可见列
        if(!column) {
          column = VueUtil.find(this.visibleColumn, function (column) {
            return column.property;
          });
        }

        return this.setActiveCell(row, column.property);
      },

      /**
       * 激活单元格编辑
       */
      _setActiveCell: function _setActiveCell(row, field) {
        var _this6 = this;

        return this.scrollToRow(row, true).then(function () {
          if (row && field) {
            var column = VueUtil.find(_this6.visibleColumn, function (column) {
              return column.property === field;
            });

            if (column && column.editRender) {
              var cell = tools.DomTools.getCell(_this6, {
                row: row,
                column: column
              });

              if (cell) {
                _this6.handleActived({
                  row: row,
                  rowIndex: _this6.getRowIndex(row),
                  column: column,
                  columnIndex: _this6.getColumnIndex(column),
                  $columnIndex: _this6.tableColumn.indexOf(column),
                  cell: cell,
                  $table: _this6
                });

                _this6.lastCallTime = Date.now();
              }
            }
          }

          return _this6.$nextTick();
        });
      },

      /**
       * 只对 trigger=dblclick 有效，选中单元格
       */
      _setSelectCell: function _setSelectCell(row, field) {
        var tableData = this.tableData,
            editConfig = this.editConfig,
            visibleColumn = this.visibleColumn;

        if (!VueUtil.isDef(field)) field = 0;
        if (row && (!editConfig || editConfig.trigger === 'dblclick')) {
          var column;
          if(typeof field === 'number') {
            column = visibleColumn[field];
          } else {
            column = VueUtil.find(visibleColumn, function (column) {
              return column.property === field;
            });
          }
          var rowIndex = tableData.indexOf(row);

          if (rowIndex > -1 && column) {
            var cell = tools.DomTools.getCell(this, {
              row: row,
              rowIndex: rowIndex,
              column: column
            });

            var params = {
              row: row,
              rowIndex: rowIndex,
              column: column,
              columnIndex: visibleColumn.indexOf(column),
              cell: cell
            };

            this.setCurrentRow(row, column);
            this.isActivated = true;
            this.handleSelected(params, {});
          }
        }

        return this.$nextTick();
      },

      /**
       * 处理选中源
       */
      handleSelected: function handleSelected(params, evnt) {
        var _this7 = this;

        var _this$mouseConfig = this.mouseConfig,
            mouseConfig = _this$mouseConfig === void 0 ? {} : _this$mouseConfig,
            editConfig = this.editConfig,
            editStore = this.editStore,
            elemStore = this.elemStore;
        var actived = editStore.actived,
            selected = editStore.selected;
        var row = params.row,
            column = params.column,
            cell = params.cell;

        var selectMethod = function selectMethod() {
          if ((mouseConfig.selected || mouseConfig.checked) && (selected.row !== row || selected.column !== column)) {
            if (actived.row !== row || (editConfig.mode === 'cell' ? actived.column !== column : false)) {
              if (_this7.keyboardConfig) {
                _this7.clearChecked(evnt);

                _this7.clearIndexChecked();

                _this7.clearHeaderChecked();

                _this7.clearSelected(evnt);
              }

              _this7.clearActived(evnt);

              selected.args = params;
              selected.row = row;
              selected.column = column;

              if (mouseConfig.selected) {
                _this7.addColSdCls();
              } // 如果配置了批量选中功能，则为批量选中状态


              if (mouseConfig.checked) {
                var headerElem = elemStore['main-header-list'];

                _this7.handleChecked([[cell]]);

                if (headerElem) {
                  _this7.handleHeaderChecked([[headerElem.querySelector('.'.concat(column.id))]]);
                }

                _this7.handleIndexChecked([[cell.parentNode.querySelector('.col--index')]]);
              }
            }
          }

          return _this7.$nextTick();
        };

        return selectMethod();
      },

      /**
       * 清除所选中源状态
       */
      _clearSelected: function _clearSelected(evnt) {
        var selected = this.editStore.selected;
        selected.row = null;
        selected.column = null;
        this.reColTitleSdCls();
        this.reColSdCls();
        return this.$nextTick();
      },
      reColTitleSdCls: function reColTitleSdCls() {
        var headerElem = this.elemStore['main-header-list'];

        if (headerElem) {
          VueUtil.loop(headerElem.querySelectorAll('.col--title-selected'), function (elem) {
            return tools.DomTools.removeClass(elem, 'col--title-selected');
          });
        }
      },
      reColSdCls: function reColSdCls() {
        var cell = this.$el.querySelector('.col--selected');

        if (cell) {
          tools.DomTools.removeClass(cell, 'col--selected');
        }
      },
      addColSdCls: function addColSdCls() {
        var selected = this.editStore.selected;
        var row = selected.row,
            column = selected.column;
        this.reColSdCls();

        if (row && column) {
          var cell = tools.DomTools.getCell(this, {
            row: row,
            column: column
          });

          if (cell) {
            tools.DomTools.addClass(cell, 'col--selected');
          }
        }
      }
    }
  };

  return VueXtableEditMixin;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableValidatorMixin = definition(context.tools);
  }
})(this, function(tools) {
  var _defineProperty = tools.UtilTools.defineProperty;
  var _createClass = tools.UtilTools.createClass;
  var _classCallCheck = tools.UtilTools.classCallCheck;

  var Rule =
  /*#__PURE__*/
  function () {
    function Rule(rule) {
      _classCallCheck(this, Rule);

      VueUtil.assign(this, {
        $options: rule,
        required: rule.required,
        min: rule.min,
        max: rule.min,
        type: rule.type,
        pattern: rule.pattern,
        validator: rule.validator,
        trigger: rule.trigger,
        maxWidth: rule.maxWidth
      });
    }

    _createClass(Rule, [{
      key: 'message',
      get: function get() {
        return tools.UtilTools.getFuncText(this.$options.message);
      }
    }]);

    return Rule;
  }();

  var VueXtableValidatorMixin = {
    methods: {
      /**
      * 与 validate 一致行为，区别就是会校验所有并返回所有不通过的所有列
      */
      _fullValidate: function _fullValidate(rows, cb) {
        return this.beginValidate(rows, cb, true);
      },

      /**
      * 对表格数据进行校验
      */
      _validate: function _validate(rows, cb) {
        return this.beginValidate(rows, cb);
      },

      /**
      * 聚焦到校验通过的单元格并弹出校验错误提示
      */
      handleValidError: function handleValidError(params) {
        var _this = this;

        this.handleActived(params, {
          type: 'valid-error',
          trigger: 'call'
        }).then(function () {
          return _this.showValidTooltip(params);
        });
      },

      /**
      * 对表格数据进行校验
      * 如果传 row 指定行记录，则只验证传入的行
      * 如果传 rows 为多行记录，则只验证传入的行
      * 如果只传 callback 否则默认验证整个表格数据
      * 返回 Promise 对象，或者使用回调方式
      */
      beginValidate: function beginValidate(rows, cb, isAll) {
        var _this2 = this;

        var validRest = {};
        var status = true;
        var editRules = this.editRules,
            afterFullData = this.afterFullData,
            treeConfig = this.treeConfig;
        var vaildDatas = afterFullData;

        if (rows) {
          if (VueUtil.isFunction(rows)) {
            cb = rows;
          } else {
            vaildDatas = VueUtil.isArray(rows) ? rows : [rows];
          }
        }

        var rowValids = [];
        this.lastCallTime = Date.now();
        this.clearValidate();

        if (editRules) {
          var columns = this.getColumns();

          var handleVaild = function handleVaild(row) {
            var colVailds = [];
            columns.forEach(function (column, columnIndex) {
               function validOne(property){
                  if (VueUtil.hasIn(editRules, property)) {
                    colVailds.push(new Promise(function (resolve, reject) {
                      _this2.validCellRules('all', row, column).then(resolve).catch(function (_ref) {
                        var _rest;

                        var rule = _ref.rule,
                            rules = _ref.rules,
                            errorPropertys = _ref.propertys;
                        rule=rules[errorPropertys.indexOf(property)];
                        if(!rule){
                           return resolve();
                        }
                        var rest = (_rest = {
                          rule: rule,
                          rules: rules
                        }, _defineProperty(_rest, ''.concat(treeConfig ? '$' : '', 'rowIndex'), _this2.getRowIndex(row)), _defineProperty(_rest, 'row', row), _defineProperty(_rest, 'columnIndex', columnIndex), _defineProperty(_rest, '$columnIndex', _this2.tableColumn.indexOf(column)), _defineProperty(_rest, 'column', column), _defineProperty(_rest, '$table', _this2), _rest);

                        if (isAll) {
                          if (!validRest[property]) {
                            validRest[property] = [];
                          }

                          validRest[property].push(rest);
                          return resolve();
                        }

                        return reject(rest);
                      });
                    }));
                  }
              }
              if(VueUtil.isArray(column.property)){
                column.property.forEach(function(property){
                    validOne(property);
                });
              }else{
                validOne(column.property);
              }
            });
            rowValids.push(Promise.all(colVailds));
          };

          if (treeConfig) {
            VueUtil.eachTree(vaildDatas, handleVaild, treeConfig);
          } else {
            vaildDatas.forEach(handleVaild);
          }

          return Promise.all(rowValids).then(function () {
            var ruleProps = VueUtil.keys(validRest);

            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }

            if (cb) {
              cb(status);
            }
          }).catch(function (params) {
            var args = isAll ? validRest : _defineProperty({}, params.column.property, params);
            return new Promise(function (resolve, reject) {
              var finish = function finish() {
                params.cell = tools.DomTools.getCell(_this2, params);

                _this2.handleValidError(params);

                if (cb) {
                  status = false;
                  resolve(cb(status, args));
                } else {
                  reject(args);
                }
              };
              /**
               * 当校验不通过时
               * 将表格滚动到可视区
               * 由于提示信息至少需要占一行，定位向上偏移一行
               */


              var row = params.row;
              var rowIndex = afterFullData.indexOf(row);
              var locatRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;

              tools.DomTools.toView(_this2.$el);

              if (treeConfig) {
                _this2.scrollToTreeRow(locatRow).then(finish);
              } else {
                _this2.scrollToRow(locatRow).then(finish);
              }
            });
          });
        } else {
          if (cb) {
            cb(status);
          }
        }

        return Promise.resolve(true);
      },
      hasCellRules: function hasCellRules(type, row, column) {
        var editRules = this.editRules;
        var property = column.property;
        function hasRulesByOne(itemProperty){
           if (itemProperty && editRules) {
             var rules = VueUtil.get(editRules, itemProperty);
             return rules && VueUtil.find(rules, function (rule) {
               return type === 'all' || !rule.trigger || type === rule.trigger;
             });
           }
           return false;
       }
		if(VueUtil.isArray(property)){
			return property.some(function(item){
				return hasRulesByOne(item);
			});
		}else{
			return hasRulesByOne(property);
		}
      },
      hasValidResultCell: function (validResult, row, column) {
        var result;
        var rowResult = validResult[tools.UtilTools.getRowid(this,row)];
        if (rowResult) {
          result = rowResult[column.property];
        }
        return result;
      },

      /**
      * 校验数据
      * 按表格行、列顺序依次校验（同步或异步）
      * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
      * 如果校验失败则，触发回调或者Promise，结果返回一个 Boolean 值
      * 如果是传回调方式这返回一个 Boolean 值和校验不通过列的错误消息
      *
      * rule 配置：
      *  required=Boolean 是否必填
      *  min=Number 最小长度
      *  max=Number 最大长度
      *  validator=Function(rule, value, callback, {rules, row, column, rowIndex, columnIndex}) 自定义校验
      *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）
      */
      validCellRules: function validCellRules(type, row, column, val) {
        var _this3 = this;

        var editRules = this.editRules,
            treeConfig = this.treeConfig;
        var property = column.property;
        var errorRules = [];
        var errorPropertys = [];
        var cellVailds = [];

        if (property && editRules) {
//if prop is Array
		  function validOne(propertyItem){
              var rules = VueUtil.get(editRules, propertyItem);
              var cellValue = VueUtil.isUndefined(val) ? VueUtil.get(row, propertyItem) : val;

              if (rules) {
                 rules.forEach(function (rule) {
                 cellVailds.push(new Promise(function (resolve) {
                     var isRequired = rule.required === true;

                     if (type === 'all' || !rule.trigger || type === rule.trigger) {
                          if (VueUtil.isFunction(rule.validator)) {
                          var _rule$validator;

                        rule.validator(rule, cellValue, function (e) {
                          if (Object.prototype.toString.call(e) === '[object Error]') {
                            var cusRule = {
                              type: 'custom',
                              trigger: rule.trigger,
                              message: e.message,
                              rule: new Rule(rule)
                            };
                            errorRules.push(new Rule(cusRule));
                            errorPropertys.push(propertyItem);
                          }

                          return resolve();
                        }, (_rule$validator = {
                          rules: rules,
                          row: row,
                          column: column
                        }, _defineProperty(_rule$validator, ''.concat(treeConfig ? '$' : '', 'rowIndex'), _this3.getRowIndex(row)), _defineProperty(_rule$validator, 'columnIndex', _this3.getColumnIndex(column)), _rule$validator));
                      } else {
                        var len;
                        var restVal = cellValue;
                        var isNumber = rule.type === 'number';
                        var isEmpty = cellValue === null || cellValue === undefined || cellValue === '';
                        if (isNumber) {
                          restVal = (parseFloat(cellValue) || 0);
                        } else {
                          len = restVal ? VueUtil.keys(restVal).length : 0;
                        }
                        if (isRequired && isEmpty) {
                          errorRules.push(new Rule(rule));
                          errorPropertys.push(propertyItem);
                        } else if (isNumber && isNaN(cellValue) || VueUtil.isRegExp(rule.pattern) && !rule.pattern.test(cellValue) || VueUtil.isNumber(rule.min) && (isNumber ? restVal < rule.min : len < rule.min) || VueUtil.isNumber(rule.max) && (isNumber ? restVal > rule.max : len > rule.max)) {
                          errorRules.push(new Rule(rule));
                          errorPropertys.push(propertyItem);
                        }
                        resolve();
                      }
                    } else {
                      resolve();
                    }
                  }));
                });
			  }
			}
            if(VueUtil.isArray(property)){
                property.forEach(function(propertyItem){
                    validOne(propertyItem);
                 });
            }else{
                validOne(property);
            }
        }

        return Promise.all(cellVailds).then(function () {
          if (errorRules.length) {
            var rest = {
              rules: errorRules,
              rule: errorRules[0],
              propertys: errorPropertys
            };
            return Promise.reject(rest);
          }
        });
      },
      _clearValidate: function _clearValidate() {
        var validTip = this.$refs.validTip;
        VueUtil.assign(this.validStore, {
          visible: false,
          row: null,
          column: null,
          content: '',
          rule: null
        });

        if (validTip && validTip.visible) {
          validTip.close();
        }

        return this.$nextTick();
      },

      /**
      * 触发校验
      */
      triggerValidate: function triggerValidate(type) {
        var _this4 = this;
        var editConfig = this.editConfig,
            editStore = this.editStore,
            editRules = this.editRules,
            validStore = this.validStore,
            validResultCell = this.validResultsCell;
        var actived = editStore.actived;

        if (actived.row && editRules) {
          var _actived$args = actived.args,
              row = _actived$args.row,
              column = _actived$args.column,
              cell = _actived$args.cell;

          if (this.hasCellRules(type, row, column)) {
            return this.validCellRules(type, row, column).then(function () {
              if (editConfig.mode === 'row') {
                if (validStore.visible && validStore.row === row && validStore.column === column) {
                  _this4.clearValidate();
                }
              }
              return _this4.doValidateResult(validResultCell, row, column, cell);
            }).catch(function (_ref3) {
              var rule = _ref3.rule;

              // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理
              if (!rule.trigger || type === rule.trigger) {
                var rest = {
                  rule: rule,
                  row: row,
                  column: column,
                  cell: cell
                };

                _this4.showValidTooltip(rest);

                return Promise.reject(rest);
              }

              return Promise.resolve();
            });
          } else if(validResultCell) {
            return this.doValidateResult(validResultCell, row, column, cell);
          }
        }

        return Promise.resolve();
      },

      doValidateResult: function(validResultCell, row, column, cell) {
        var validResult = this.hasValidResultCell(validResultCell, row, column);
        if (validResult) {
          var rest = {
            rule: {message: validResult.map(function(res) {return res.message;})},
            row: row,
            column: column,
            cell: cell
          };

          this.showValidTooltip(rest);

          return Promise.reject(rest);
        }
        return Promise.resolve();
      },

      /**
      * 弹出校验错误提示
      */
      showValidTooltip: function showValidTooltip(params) {
        var _this5 = this;
        var $refs = this.$refs,
            height = this.height,
            tableData = this.tableData,
            validOpts = this.validOpts;
        var rule = params.rule,
            row = params.row,
            column = params.column,
            cell = params.cell;
        var validTip = $refs.validTip;
        var content = rule.message;
        this.$nextTick(function () {
          VueUtil.assign(_this5.validStore, {
            row: row,
            column: column,
            rule: rule,
            content: content,
            visible: true
          });

          if (validTip && (validOpts.message === 'tooltip' || validOpts.message === 'default' && !height && tableData.length < 2)) {
            validTip.toVisible(cell, content);
          }

          tools.UtilTools.emitEvent(_this5, 'valid-error', [params]);
        });
      }
    }
  };

  return VueXtableValidatorMixin;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    var mod = definition(context.tools, context.baseTable);
    context.VueXtableExportPanel = mod.VueXtableExportPanel;
    context.VueXtableImportPanel = mod.VueXtableImportPanel;
    context.VueXtableExportMixin = mod.VueXtableExportMixin;
  }
})(this, function(tools, baseTable) {

  var mod = {};

  (function() {
    var VueXtableExportPanel = {
      name: 'VueXtableExportPanel',
      props: {
        defaultOptions: Object,
        storeData: Object
      },
      data: function data() {
        return {
          isAll: false,
          isIndeterminate: false,
          modeList: [{
            value: 'all',
            label: 'vue.xtable.toolbar.expAll'
          }, {
            value: 'selected',
            label: 'vue.xtable.toolbar.expSelected'
          }]
        };
      },
      computed: {
        vSize: function vSize() {
          return this.size || this.$parent.size || this.$parent.vSize;
        },
        showSheet: function showSheet() {
          return VueUtil.includes(['html', 'xml', 'xlsx'], this.defaultOptions.type);
        }
      },
      render: function render(h) {
        var _this = this;
    
        var _e = this._e,
            isAll = this.isAll,
            isIndeterminate = this.isIndeterminate,
            showSheet = this.showSheet,
            defaultOptions = this.defaultOptions,
            storeData = this.storeData,
            modeList = this.modeList;
        return h('vue-dialog', {
          res: 'modal',
          model: {
            value: storeData.visible,
            callback: function callback(value) {
              storeData.visible = value;
            }
          },
          props: {
            title: GlobalConfig.i18n('vue.xtable.toolbar.expTitle'),
            showClose: true,
            // width: 660,
            // mask: true,
            // lockView: true,
            // showFooter: false,
            // maskClosable: true
          },
          on: {
            open: this.showEvent
          }
        }, [h('div', {
          class: 'vue-xtable-export--panel'
        }, [h('table', {
          attrs: {
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }
        }, [h('tr', [h('td', GlobalConfig.i18n('vue.xtable.toolbar.expName')), h('td', [h('input', {
          ref: 'filename',
          attrs: {
            type: 'text',
            placeholder: GlobalConfig.i18n('vue.xtable.toolbar.expNamePlaceholder')
          },
          domProps: {
            value: defaultOptions.filename
          },
          on: {
            input: function input(evnt) {
              defaultOptions.filename = evnt.target.value;
            }
          }
        })])]), h('tr', [h('td', GlobalConfig.i18n('vue.xtable.toolbar.expType')), h('td', [h('select', {
          on: {
            change: function change(evnt) {
              defaultOptions.type = evnt.target.value;
            }
          }
        }, defaultOptions.types.map(function (item) {
          return h('option', {
            attrs: {
              value: item.value
            },
            domProps: {
              selected: defaultOptions.type === item.value
            }
          }, GlobalConfig.i18n(item.label));
        }))])]), showSheet ? h('tr', [h('td', GlobalConfig.i18n('vue.xtable.toolbar.expSheetName')), h('td', [h('input', {
          attrs: {
            type: 'text',
            placeholder: GlobalConfig.i18n('vue.xtable.toolbar.expSheetNamePlaceholder')
          },
          domProps: {
            value: defaultOptions.sheetName
          },
          on: {
            input: function input(evnt) {
              defaultOptions.sheetName = evnt.target.value;
            }
          }
        })])]) : _e(), h('tr', [h('td', GlobalConfig.i18n('vue.xtable.toolbar.expMode')), h('td', [h('select', {
          on: {
            change: function change(evnt) {
              storeData.mode = evnt.target.value;
            }
          }
        }, modeList.map(function (item) {
          return h('option', {
            attrs: {
              value: item.value
            },
            domProps: {
              selected: storeData.mode === item.value
            }
          }, GlobalConfig.i18n(item.label));
        }))])]), h('tr', [h('td', [GlobalConfig.i18n('vue.xtable.toolbar.expColumn')]), h('td', [h('div', {
          class: 'vue-xtable-export--panel-column'
        }, [h('vue-checkbox', {
          props: {
            indeterminate: isIndeterminate
          },
          model: {
            value: isAll,
            callback: function callback(value) {
              _this.isAll = value;
            }
          },
          on: {
            change: this.allColumnEvent
          }
        }, GlobalConfig.i18n('vue.xtable.toolbar.expAllColumn')), h('ul', storeData.columns.map(function (column) {
          var own = column.own,
              checked = column.checked,
              type = column.type;
          return h('li', {
            class: {
              active: checked
            },
            on: {
              click: function click() {
                column.checked = !checked;
    
                _this.checkStatus();
              }
            }
          }, tools.UtilTools.getFuncText(own.title || own.label || (type === 'index' ? GlobalConfig.i18n('vue.xtable.column.indexTitle') : '')));
        }))])])]), h('tr', [h('td', GlobalConfig.i18n('vue.xtable.toolbar.expOpts')), h('td', [h('vue-checkbox', {
          model: {
            value: defaultOptions.isHeader,
            callback: function callback(value) {
              defaultOptions.isHeader = value;
            }
          }
        }, GlobalConfig.i18n('vue.xtable.toolbar.expOptHeader')), h('vue-checkbox', {
          props: {
            disabled: !storeData.hasFooter
          },
          model: {
            value: defaultOptions.isFooter,
            callback: function callback(value) {
              defaultOptions.isFooter = value;
            }
          }
        }, GlobalConfig.i18n('vue.xtable.toolbar.expOptFooter')), h('vue-checkbox', {
          props: {
            disabled: storeData.forceOriginal
          },
          model: {
            value: defaultOptions.original,
            callback: function callback(value) {
              defaultOptions.original = value;
            }
          }
        }, GlobalConfig.i18n('vue.xtable.toolbar.expOptOriginal'))])])]), h('div', {
          class: 'vue-xtable-export--panel-btns'
        }, [defaultOptions.isPrint ? h('vue-button', {
          on: {
            click: this.printEvent
          }
        }, GlobalConfig.i18n('vue.xtable.toolbar.expPrint')) : null, h('vue-button', {
          props: {
            type: 'primary'
          },
          on: {
            click: this.exportEvent
          }
        }, GlobalConfig.i18n('vue.xtable.toolbar.expConfirm'))])])]);
      },
      methods: {
        checkStatus: function checkStatus() {
          var columns = this.storeData.columns;
          this.isAll = this.storeData.columns.every(function (column) {
            return column.checked;
          });
          this.isIndeterminate = !this.isAll && columns.some(function (column) {
            return column.checked;
          });
        },
        allColumnEvent: function allColumnEvent() {
          var isAll = this.isAll;
          this.storeData.columns.forEach(function (column) {
            column.checked = isAll;
          });
          this.checkStatus();
        },
        showEvent: function showEvent() {
          var _this2 = this;
    
          this.$nextTick(function () {
            _this2.$refs.filename.focus();
          });
          this.checkStatus();
        },
        getExportOption: function getExportOption() {
          var storeData = this.storeData,
              defaultOptions = this.defaultOptions;
          var _this$$parent = this.$parent,
              $grid = _this$$parent.$grid,
              $table = _this$$parent.$table;
          var comp = $grid || $table;
          var selectRecords = storeData.selectRecords;
          var opts = VueUtil.assign({
            columns: storeData.columns.filter(function (column) {
              return column.checked;
            })
          }, defaultOptions);
    
          if (storeData.mode === 'selected') {
            if (VueUtil.includes(['html', 'pdf'], defaultOptions.type) && comp.treeConfig) {
              opts.data = VueUtil.searchTree(comp.tableFullData, function (item) {
                return selectRecords.indexOf(item) > -1;
              }, comp.treeConfig);
            } else {
              opts.data = selectRecords;
            }
          }
    
          return opts;
        },
        printEvent: function printEvent() {
          this.storeData.visible = false;
          this.$emit('print', this.getExportOption());
        },
        exportEvent: function exportEvent() {
          this.storeData.visible = false;
          this.$emit('export', this.getExportOption());
        }
      }
    };
    mod.VueXtableExportPanel = VueXtableExportPanel;
  })();

  (function() {
    var VueXtableImportPanel = {
      name: 'VueXtableImportPanel',
      props: {
        defaultOptions: Object,
        storeData: Object
      },
      computed: {
        vSize: function vSize() {
          return this.size || this.$parent.size || this.$parent.vSize;
        },
        selectName: function selectName() {
          return ''.concat(this.storeData.filename, '.').concat(this.storeData.type);
        },
        hasFile: function hasFile() {
          return this.storeData.file && this.storeData.type;
        },
        parseTypeLabel: function parseTypeLabel() {
          var storeData = this.storeData;
    
          if (storeData.type) {
            return GlobalConfig.i18n('vue.xtable.types.'.concat(storeData.type));
          }
    
          return '*.'.concat((this.defaultOptions.types || baseTable.importTypes).join(', *.'));
        }
      },
      render: function render(h) {
        var hasFile = this.hasFile,
            parseTypeLabel = this.parseTypeLabel,
            defaultOptions = this.defaultOptions,
            storeData = this.storeData,
            selectName = this.selectName;
        return h('vue-dialog', {
          res: 'modal',
          model: {
            value: storeData.visible,
            callback: function callback(value) {
              storeData.visible = value;
            }
          },
          props: {
            title: GlobalConfig.i18n('vue.xtable.toolbar.impTitle'),
            showClose: true,
            // width: 440,
            // mask: true,
            // lockView: true,
            // showFooter: false,
            // maskClosable: true
          }
        }, [h('div', {
          class: 'vue-xtable-export--panel'
        }, [h('table', {
          attrs: {
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }
        }, [h('tr', [h('td', GlobalConfig.i18n('vue.xtable.toolbar.impFile')), h('td', [hasFile ? h('div', {
          class: 'vue-xtable-import-selected--file',
          attrs: {
            title: selectName
          }
        }, [h('span', selectName), h('i', {
          class: GlobalConfig.icon.importRemove,
          on: {
            click: this.clearFileEvent
          }
        })]) : h('span', {
          class: 'vue-xtable-import-select--file',
          on: {
            click: this.selectFileEvent
          }
        }, GlobalConfig.i18n('vue.xtable.toolbar.impSelect'))])]), h('tr', [h('td', GlobalConfig.i18n('vue.xtable.toolbar.impType')), h('td', parseTypeLabel)]), h('tr', [h('td', GlobalConfig.i18n('vue.xtable.toolbar.impOpts')), h('td', [h('vue-radio', {
          props: {
            name: 'mode',
            label: 'covering'
          },
          model: {
            value: defaultOptions.mode,
            callback: function callback(value) {
              defaultOptions.mode = value;
            }
          }
        }, GlobalConfig.i18n('vue.xtable.toolbar.impModeCovering')), h('vue-radio', {
          props: {
            name: 'mode',
            label: 'append'
          },
          model: {
            value: defaultOptions.mode,
            callback: function callback(value) {
              defaultOptions.mode = value;
            }
          }
        }, GlobalConfig.i18n('vue.xtable.toolbar.impModeAppend'))])])]), h('div', {
          class: 'vue-xtable-export--panel-btns'
        }, [h('vue-button', {
          props: {
            type: 'primary',
            disabled: !hasFile
          },
          on: {
            click: this.importEvent
          }
        }, GlobalConfig.i18n('vue.xtable.toolbar.impConfirm'))])])]);
      },
      methods: {
        clearFileEvent: function clearFileEvent() {
          VueUtil.assign(this.storeData, {
            filename: '',
            sheetName: '',
            type: ''
          });
        },
        selectFileEvent: function selectFileEvent() {
          var _this = this;
    
          var _this$$parent = this.$parent,
              $grid = _this$$parent.$grid,
              $table = _this$$parent.$table;
          var comp = $grid || $table;
    
          if (comp) {
            comp.readFile(this.defaultOptions).then(function (evnt) {
              var file = evnt.target.files[0];
              VueUtil.assign(_this.storeData, tools.UtilTools.parseFile(file), {
                file: file
              });
            }).catch(function (e) {
              return e;
            });
          }
        },
        importEvent: function importEvent() {
          var storeData = this.storeData,
              defaultOptions = this.defaultOptions;
          var opts = VueUtil.assign({}, defaultOptions);
          storeData.visible = false;
          this.$emit('import', opts);
        }
      }
    };
    mod.VueXtableImportPanel = VueXtableImportPanel;
  })();


  (function() {
    var defaultHtmlStyle = 'body{margin:0;font-size:14px}table{text-align:left;border-width:1px 0 0 1px}table,td,th{border-style:solid;border-color:#e8eaec}tfoot,thead{background-color:#f8f8f9}td,th{padding:6px;border-width:0 1px 1px 0}.tree-icon-wrapper{position:relative;display:inline-block;width:18px}.tree-icon{position:absolute;top:-9px;left:0;width:0;height:0;border-style:solid;border-width:6px;border-top-color:#939599;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent}.tree-node{text-align:left}.tree-indent{display:inline-block}'; // 导入

    var impForm = document.createElement('form');
    var impInput = document.createElement('input');
    impForm.className = 'vue-xtable-table--import-form';
    impInput.name = 'file';
    impInput.type = 'file';
    impForm.appendChild(impInput); // 打印
    
    var printFrame;
    
    function createFrame() {
      var frame = document.createElement('iframe');
      frame.className = 'vue-xtable-table--print-frame';
      return frame;
    }
    
    function hasTreeChildren($table, row) {
      var treeConfig = $table.treeConfig;
      return row[treeConfig.children] && row[treeConfig.children].length;
    }
    
    function handleExport($table, opts, oColumns, fullData) {
      var _getExportData = getExportData($table, opts, fullData, oColumns),
          columns = _getExportData.columns,
          datas = _getExportData.datas;

      return $table.preventEvent(null, 'event.export', {
        $table: $table,
        options: opts,
        columns: columns,
        datas: datas
      }, function () {
        return downloadFile($table, opts, getContent($table, opts, columns, datas));
      });
    }
    
    function getContent($table, opts, columns, datas) {
      switch (opts.type) {
        case 'csv':
          return toCsv($table, opts, columns, datas);
    
        case 'txt':
          return toTxt($table, opts, columns, datas);
    
        case 'html':
          return toHtml($table, opts, columns, datas);
    
        case 'xml':
          return toXML($table, opts, columns, datas);

        case 'xlsx':
          return toXlsx($table, opts, columns, datas);
      }
    
      return '';
    }
    
    function getHeaderTitle(opts, column) {
      return (opts.original ? column.property : column.getTitle()) || '';
    }
    
    function toCsv($table, opts, columns, datas) {
      var isOriginal = opts.original;
      var content = '\uFEFF';
      
      if (opts.isHeader) {
        content += columns.map(function (column) {
          return '"'.concat(getHeaderTitle(opts, column), '"');
        }).join(',') + '\n';
      }
    
      datas.forEach(function (row, rowIndex) {
        if (isOriginal) {
          content += columns.map(function (column, columnIndex) {
            if (column.type === 'index') {
              return '"'.concat(column.indexMethod ? column.indexMethod({
                row: row,
                rowIndex: rowIndex,
                column: column,
                columnIndex: columnIndex
              }) : rowIndex + 1, '"');
            }
    
            var cellValue = tools.UtilTools.getCellValue(row, column);
            cellValue = cellValue!='undefined'?cellValue:'';
            if(VueUtil.isString(cellValue)) cellValue = cellValue.replace('"', '\\"');
            return '"'.concat(cellValue, '"');
          }).join(',') + '\n';
        } else {
          content += columns.map(function (column) {
            var value = row[column.id];
            if(VueUtil.isString(value)) value = value.replace('"', '\\"');
            return '"'.concat(value, '"');
          }).join(',') + '\n';
        }
      });
    
      if (opts.isFooter) {
        var footerData = $table.footerData;
        var footers = opts.footerFilterMethod ? footerData.filter(opts.footerFilterMethod) : footerData;
        footers.forEach(function (rows) {
          content += columns.map(function (column) {
            return '"'.concat(rows[$table.getColumnIndex(column)] || '', '"');
          }).join(',') + '\n';
        });
      }
    
      return content;
    }

    function toXlsx($table, opts, columns, datas) {
      var isOriginal = opts.original;
      var sheetName = opts.sheetName;

      var indexKey = 'xtable-column-index';
      var exportDatas = [];
      var fields = columns.map(function(column) {
        if (column.type === 'index') {
          return indexKey;
        } else {
          return column.property;
        }
      });

      if (opts.isHeader) {
        var header = {};
        columns.map(function (column) {
          var title = getHeaderTitle(opts, column);
          var field = column.type === 'index'? indexKey :column.property;
          header[field] = title;
        });
        exportDatas.push(header);
      }
      
      datas.forEach(function (row, rowIndex) {
        var data = {};
        if (isOriginal) {
          columns.map(function (column, columnIndex) {
            if (column.type === 'index') {
              var value = column.indexMethod ? column.indexMethod({
                row: row,
                rowIndex: rowIndex,
                column: column,
                columnIndex: columnIndex
              }) : rowIndex + 1;

              data[indexKey] = value;

            } else {
              var cellValue = tools.UtilTools.getCellValue(row, column);
              cellValue = cellValue!='undefined'?cellValue:'';
              data[column.property] = cellValue;
            }
          });
        } else {
          columns.map(function (column) {
            var value = row[column.id];
            data[column.type === 'index'? indexKey :column.property] = value;
          });
        }

        exportDatas.push(data);
      });
      if (opts.isFooter) {
        var footerData = $table.footerData;
        var footers = opts.footerFilterMethod ? footerData.filter(opts.footerFilterMethod) : footerData;
        footers.forEach(function (rows) {
          var data = {};
          columns.map(function (column) {
            var content = rows[$table.getColumnIndex(column)] || '';
            data[column.type === 'index'? indexKey : column.property] = content;
          });
          exportDatas.push(data);
        });
      }
      var data = VueUtil.Excel.filterExportData(exportDatas, fields);

      var exportDataSheet = {};
      exportDataSheet[sheetName] = data;
      return VueUtil.Excel.exportExcel( exportDataSheet, 'export.xlsx', 'xlsx', {download: false});
    }
    
    function toTxt($table, opts, columns, datas) {
      var isOriginal = opts.original;
      var content = '';
      if (opts.isHeader) {
        content += columns.map(function (column) {
          return ''.concat(getHeaderTitle(opts, column));
        }).join('\t') + '\n';
      }
    
      datas.forEach(function (row, rowIndex) {
        if (isOriginal) {
          content += columns.map(function (column, columnIndex) {
            if (column.type === 'index') {
              return ''.concat(column.indexMethod ? column.indexMethod({
                row: row,
                rowIndex: rowIndex,
                column: column,
                columnIndex: columnIndex
              }) : rowIndex + 1);
            }
    
            var cellValue = tools.UtilTools.getCellValue(row, column);
			cellValue = cellValue!='undefined'?cellValue:'';
            return '"'.concat(cellValue, '"');
          }).join('\t') + '\n';
        } else {
          content += columns.map(function (column) {
            return ''.concat(row[column.id]);
          }).join('\t') + '\n';
        }
      });
    
      if (opts.isFooter) {
        var footerData = $table.footerData;
        var footers = opts.footerFilterMethod ? footerData.filter(opts.footerFilterMethod) : footerData;
        footers.forEach(function (rows) {
          content += columns.map(function (column) {
            return ''.concat(rows[$table.getColumnIndex(column)] || '');
          }).join(',') + '\n';
        });
      }
    
      return content;
    }
    
    function toHtml($table, opts, columns, datas) {
      var treeConfig = $table.treeConfig,
          tableFullData = $table.tableFullData;
      var isOriginal = opts.original;
      var html = ['<html>', '<head>', '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui"><title>'.concat(opts.sheetName, '</title>'), '<style>'.concat(opts.style || defaultHtmlStyle, '</style>'), '</head>', '<body>', '<table border="1" cellspacing="0" cellpadding="0">', '<colgroup>'.concat(columns.map(function (column) {
        return '<col width="'.concat(column.renderWidth, '">');
      }).join(''), '</colgroup>')].join('');
    
      if (opts.isHeader) {
        html += '<thead><tr>'.concat(columns.map(function (column) {
          return '<th>'.concat(getHeaderTitle(opts, column), '</th>');
        }).join(''), '</tr></thead>');
      }
    
      if (datas.length) {
        html += '<tbody>';
    
        if (treeConfig) {
          VueUtil.eachTree(opts.data ? datas : tableFullData, function (row, rowIndex, items, path, parent, nodes) {
            html += '<tr>';
    
            if (isOriginal) {
              html += columns.map(function (column, columnIndex) {
                var cellValue = '';
    
                if (column.type === 'index') {
                  cellValue = column.indexMethod ? column.indexMethod({
                    row: row,
                    rowIndex: rowIndex,
                    column: column,
                    columnIndex: columnIndex
                  }) : rowIndex + 1;
                } else {
					var cellValue = tools.UtilTools.getCellValue(row, column);
					cellValue = cellValue!='undefined'?cellValue:'';
                }
    
                if (treeConfig && column.treeNode) {
                  var treeIcon = '';
    
                  if (hasTreeChildren($table, row)) {
                    treeIcon = '<i class="tree-icon"></i>';
                  }
    
                  return '<td class="tree-node"><span class="tree-indent" style="width: '.concat((nodes.length - 1) * (treeConfig.indent || 16), 'px"></span><span class="tree-icon-wrapper">').concat(treeIcon, '</span>').concat(cellValue, '</td>');
                }
    
                return '<td>'.concat(cellValue, '</td>');
              }).join('');
            } else {
              html += columns.map(function (column) {
                if (treeConfig && column.treeNode) {
                  var treeIcon = '';
    
                  if (row.hasChild) {
                    treeIcon = '<i class="tree-icon"></i>';
                  }
    
                  return '<td class="tree-node"><span class="tree-indent" style="width: '.concat((nodes.length - 1) * (treeConfig.indent || 16), 'px"></span><span class="tree-icon-wrapper">').concat(treeIcon, '</span>').concat(row[column.id], '</td>');
                }
    
                return '<td>'.concat(row[column.id], '</td>');
              }).join('');
            }
    
            html += '</tr>';
          }, treeConfig);
        } else {
          datas.forEach(function (row, rowIndex) {
            html += '<tr>';
    
            if (isOriginal) {
              html += columns.map(function (column, columnIndex) {
                var cellValue = '';
    
                if (column.type === 'index') {
                  cellValue = column.indexMethod ? column.indexMethod({
                    row: row,
                    rowIndex: rowIndex,
                    column: column,
                    columnIndex: columnIndex
                  }) : rowIndex + 1;
                } else {
                  cellValue = tools.UtilTools.getCellValue(row, column) || '';
                }
    
                return '<td>'.concat(cellValue, '</td>');
              }).join('');
            } else {
              html += columns.map(function (column) {
                return '<td>'.concat(row[column.id], '</td>');
              }).join('');
            }
    
            html += '</tr>';
          });
        }
    
        html += '</tbody>';
      }
    
      if (opts.isFooter) {
        var footerData = $table.footerData;
        var footers = opts.footerFilterMethod ? footerData.filter(opts.footerFilterMethod) : footerData;
    
        if (footers.length) {
          html += '<tfoot>';
          footers.forEach(function (rows) {
            html += '<tr>'.concat(columns.map(function (column) {
              return '<td>'.concat(rows[$table.getColumnIndex(column)] || '', '</td>');
            }).join(''), '</tr>');
          });
          html += '</tfoot>';
        }
      }
    
      return html + '</table></body></html>';
    }
    
    function toXML($table, opts, columns, datas) {
      var isOriginal = opts.original;
      var xml = ['<?xml version="1.0"?>', '<?mso-application progid="Excel.Sheet"?>', '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">', '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">', '<Version>16.00</Version>', '</DocumentProperties>', '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">', '<WindowHeight>7920</WindowHeight>', '<WindowWidth>21570</WindowWidth>', '<WindowTopX>32767</WindowTopX>', '<WindowTopY>32767</WindowTopY>', '<ProtectStructure>False</ProtectStructure>', '<ProtectWindows>False</ProtectWindows>', '</ExcelWorkbook>', '<Worksheet ss:Name="'.concat(opts.sheetName, '">'), '<Table>', columns.map(function (column) {
        return '<Column ss:Width="'.concat(column.renderWidth, '"/>');
      }).join('')].join('');
    
      if (opts.isHeader) {
        xml += '<Row>'.concat(columns.map(function (column) {
          return '<Cell><Data ss:Type="String">'.concat(getHeaderTitle(opts, column), '</Data></Cell>');
        }).join(''), '</Row>');
      }
    
      datas.forEach(function (row, rowIndex) {
        xml += '<Row>';
    
        if (isOriginal) {
          xml += columns.map(function (column, columnIndex) {
            if (column.type === 'index') {
              return '<Cell><Data ss:Type="String">'.concat(column.indexMethod ? column.indexMethod({
                row: row,
                rowIndex: rowIndex,
                column: column,
                columnIndex: columnIndex
              }) : rowIndex + 1, '</Data></Cell>');
            }
    
			var cellValue = tools.UtilTools.getCellValue(row, column);
			cellValue = cellValue!='undefined'?cellValue:'';
            return '<Cell><Data ss:Type="String">'.concat(cellValue, '</Data></Cell>');
          }).join('');
        } else {
          xml += columns.map(function (column) {
            return '<Cell><Data ss:Type="String">'.concat(row[column.id], '</Data></Cell>');
          }).join('');
        }
    
        xml += '</Row>';
      });
    
      if (opts.isFooter) {
        var footerData = $table.footerData;
        var footers = opts.footerFilterMethod ? footerData.filter(opts.footerFilterMethod) : footerData;
        footers.forEach(function (rows) {
          xml += '<Row>'.concat(columns.map(function (column) {
            return '<Cell><Data ss:Type="String">'.concat(rows[$table.getColumnIndex(column) || ''], '</Data></Cell>');
          }).join(''), '</Row>');
        });
      }
    
      return ''.concat(xml, '</Table></Worksheet></Workbook>');
    }
    
    function downloadFile($table, opts, content) {
      var filename = opts.filename,
          type = opts.type,
          download = opts.download;
      var name = ''.concat(filename, '.').concat(type);
    
      if (window.Blob) {
        var blob;
        if (type == 'xlsx') {
          blob = content;
        } else {
          blob = new Blob([content], {
            type: 'text/'.concat(type)
          });
        }
    
        if (!download) {
          return Promise.resolve({
            type: type,
            content: content,
            blob: blob
          });
        }
    
        if (navigator.msSaveBlob) {
          navigator.msSaveBlob(blob, name);
        } else {
          var linkElem = document.createElement('a');
          linkElem.target = '_blank';
          linkElem.download = name;
          linkElem.href = URL.createObjectURL(blob);
          document.body.appendChild(linkElem);
          linkElem.click();
          document.body.removeChild(linkElem);
        }
    
        if (opts.message !== false) {
          $table.$notify({
            message: GlobalConfig.i18n('vue.xtable.table.expSuccess'),
            type: 'success'
          });
        }
      } else {
        tools.UtilTools.error('vue.xtable.error.notExp');
      }
    }
    
    function getLabelData($table, columns, datas) {
      var treeConfig = $table.treeConfig;
      var virtualScroller = $table.getVirtualScroller();
      return datas.map(function (row) {
        var item = {
          hasChild: treeConfig && hasTreeChildren($table, row)
        };
        columns.forEach(function (column) {
          if (virtualScroller.scrollX || virtualScroller.scrollY) {
            var params = {
              $table:$table,
              column:column,
              row:row
            };
            var cellLabel = tools.UtilTools.formatText(tools.UtilTools.getCellLabel(row, column, params), 1);
            item[column.id] = cellLabel || '';
          } else {
            var cell = tools.DomTools.getCell($table, {
              row: row,
              column: column
            });
            item[column.id] = cell ? cell.innerText.trim() : '';
          }
        });
        return item;
      });
    }
    
    function getExportData($table, opts, fullData, oColumns) {
      var columns = opts.columns ? opts.columns : oColumns;
      var datas = opts.data || fullData;
    
      if (opts.columnFilterMethod) {
        columns = columns.filter(opts.columnFilterMethod);
      }
    
      if (opts.dataFilterMethod) {
        datas = datas.filter(opts.dataFilterMethod);
      }
    
      return {
        columns: columns,
        datas: opts.original ? datas : getLabelData($table, columns, datas)
      };
    }
    
    function replaceDoubleQuotation(val) {
      return val.replace(/^"/, '').replace(/"$/, '');
    }
    function formateValue(value, field,item, table) {
      var col = table.getColumnByField(field);
      if(table.getFormattedVal) {
        value = table.getFormattedVal(value, item, col, 'paste');
      }
      return value;
    }

    function CSVtoArray(text) {
      var re_valid = /^\s*(?:'[^'\\]*(?:\\[\S\s][^'\\]*)*'|"[^"\\]*(?:\\[\S\s][^"\\]*)*"|[^,'"\s\\]*(?:\s+[^,'"\s\\]+)*)\s*(?:,\s*(?:'[^'\\]*(?:\\[\S\s][^'\\]*)*'|"[^"\\]*(?:\\[\S\s][^"\\]*)*"|[^,'"\s\\]*(?:\s+[^,'"\s\\]+)*)\s*)*$/;
      var re_value = /(?!\s*$)\s*(?:'([^'\\]*(?:\\[\S\s][^'\\]*)*)'|"([^"\\]*(?:\\[\S\s][^"\\]*)*)"|([^,'"\s\\]*(?:\s+[^,'"\s\\]+)*))\s*(?:,|$)/g;
      if (!re_valid.test(text)) return [];
      var a = []; 
      text.replace(re_value,
          function(m0, m1, m2, m3) {
              if      (m1 !== undefined) a.push(m1.replace(/\\'/g, '\''));
              else if (m2 !== undefined) a.push(m2.replace(/\\"/g, '"'));
              else if (m3 !== undefined) a.push(m3);
              return ''; // Return empty string.
          });
      // Handle special case of empty last value.
      if (/,\s*$/.test(text)) a.push('');
      return a;
    }

    function parseCsv(columns, content, table) {
      var list = content.split('\n');
      var fields = [];
      var rows = [];
    
      if (list.length) {
        var rList = list.slice(1);
        CSVtoArray(list[0]).forEach(function (val) {
          // var field = replaceDoubleQuotation(val);
            fields.push(val);
        });
        rList.forEach(function (r) {
          if (r) {
            var item = {};
            CSVtoArray(r).forEach(function (val, colIndex) {

              // val = replaceDoubleQuotation(val);
              val = formateValue(val, fields[colIndex], item, table);
              if(fields[colIndex]) {
                item[fields[colIndex]] = val;
              }
            });
            rows.push(item);
          }
        });
      }
      return {
        fields: fields,
        rows: rows
      };
    }

    function parseXlsx(columns, content, table, book) {
      var fields = [];
      var rows = [];
      var firstSheetName = book[0].SheetNames[0];
      var rawData = content[0][firstSheetName];

      if (rawData.length) {
        var header = rawData[0];
        var fieldMap = VueUtil.keys(header).reduce(function(obj, key) {
          fields.push(header[key]);
          obj[header[key]] = key;
          return obj; 
        }, {});
        
        VueUtil.Excel.filterImportData(content, fieldMap);

        rows = content[0][firstSheetName].slice(1);
      }
    
      return {
        fields: fields,
        rows: rows
      };
    }
    
    function parseTxt(columns, content, table) {
      var list = content.split('\n');
      var fields = [];
      var rows = [];
    
      if (list.length) {
        var rList = list.slice(1);
        list[0].split('\t').forEach(function (field) {
            fields.push(field);
        });
        rList.forEach(function (r) {
          if (r) {
            var item = {};
            r.split('\t').forEach(function (val, colIndex) {
              if(fields[colIndex]) {
                val = replaceDoubleQuotation(val);
                val = formateValue(val, fields[colIndex], item, table);

                item[fields[colIndex]] = val;
              }
            });
            rows.push(item);
          }
        });
      }
    
      return {
        fields: fields,
        rows: rows
      };
    }
    
    function parseHTML(columns, content, table) {
      var domParser = new DOMParser();
      var xmlDoc = domParser.parseFromString(content, 'text/html');
      var bodyNodes = getElementsByTagName(xmlDoc, 'body');
      var fields = [];
      var rows = [];
    
      if (bodyNodes.length) {
        var tableNodes = getElementsByTagName(bodyNodes[0], 'table');
    
        if (tableNodes.length) {
          var theadNodes = getElementsByTagName(tableNodes[0], 'thead');
    
          if (theadNodes.length) {
            VueUtil.forEach(getElementsByTagName(theadNodes[0], 'tr'), function (rowNode) {
              VueUtil.forEach(getElementsByTagName(rowNode, 'th'), function (cellNode) {
                var field = cellNode.textContent;
    
                  fields.push(field);
              });
            });
            var tbodyNodes = getElementsByTagName(tableNodes[0], 'tbody');
    
            if (tbodyNodes.length) {
              VueUtil.forEach(getElementsByTagName(tbodyNodes[0], 'tr'), function (rowNode) {
                var item = {};
                VueUtil.forEach(getElementsByTagName(rowNode, 'td'), function (cellNode, colIndex) {
                  var val = formateValue(cellNode.textContent || '', fields[colIndex], item, table);

                  if(fields[colIndex]) {
                    item[fields[colIndex]] = val;
                  }
                });
                rows.push(item);
              });
            }
          }
        }
      }
    
      return {
        fields: fields,
        rows: rows
      };
    }
    
    function parseXML(columns, content, table) {
      var domParser = new DOMParser();
      var xmlDoc = domParser.parseFromString(content, 'application/xml');
      var sheetNodes = getElementsByTagName(xmlDoc, 'Worksheet');
      var fields = [];
      var rows = [];
    
      if (sheetNodes.length) {
        var tableNodes = getElementsByTagName(sheetNodes[0], 'Table');
    
        if (tableNodes.length) {
          var rowNodes = getElementsByTagName(tableNodes[0], 'Row');
    
          if (rowNodes.length) {
            VueUtil.forEach(getElementsByTagName(rowNodes[0], 'Cell'), function (cellNode) {
              var field = cellNode.textContent;
    
                fields.push(field);
            });
            VueUtil.forEach(rowNodes, function (rowNode, index) {
              if (index) {
                var item = {};
                var cellNodes = getElementsByTagName(rowNode, 'Cell');
                VueUtil.forEach(cellNodes, function (cellNode, colIndex) {
                  var val = formateValue(cellNode.textContent, fields[colIndex], item, table);
                  if(fields[colIndex])  {
                    item[fields[colIndex]] = val;
                  }
                });
                rows.push(item);
              }
            });
          }
        }
      }
    
      return {
        fields: fields,
        rows: rows
      };
    }
    
    function getElementsByTagName(elem, qualifiedName) {
      return elem.getElementsByTagName(qualifiedName);
    }
    /**
     * 检查导入的列是否完整
     * @param {Array} fields 字段名列表
     * @param {Array} rows 数据列表
     */
    
    
    function checkImportData(columns, fields, rows) {
      var tableFields = [];
      columns.forEach(function (column) {
        var field = column.property;
    
        if (field) {
            var fields = [].concat(field);
            fields.forEach(function(item){
                tableFields.push(item);
            });
        }
      });
      return tableFields.every(function (field) {
        return VueUtil.includes(fields, field);
      });
    }
    
    function handleImport($table, content, opts, book) {
      var tableFullColumn = $table.tableFullColumn,
          _importResolve = $table._importResolve;
      var rest = {
        fields: [],
        rows: []
      };
      
      switch (opts.type) {
        case 'csv':
          rest = parseCsv(tableFullColumn, content, $table);
          break;

        case 'xlsx':
          rest = parseXlsx(tableFullColumn, content, $table, book);
          break;
    
        case 'txt':
          rest = parseTxt(tableFullColumn, content, $table);
          break;
    
        case 'html':
          rest = parseHTML(tableFullColumn, content, $table);
          break;
    
        case 'xml':
          rest = parseXML(tableFullColumn, content, $table);
          break;
      }
    
      var _rest = rest,
          fields = _rest.fields,
          rows = _rest.rows;
      var status = checkImportData(tableFullColumn, fields, rows);
    
      if (status) {
        $table.createData(rows).then(function (data) {
          if (opts.mode === 'append') {
            $table.insertAt(data, -1);
          } else {
            $table.reloadData(data);
          }
        });
    
        if (opts.message !== false) {
          $table.$notify({
            message: GlobalConfig.i18n('vue.xtable.table.impSuccess'),
            type: 'success'
          });
        }
      } else if (opts.message !== false) {
        $table.$notify({
          message: GlobalConfig.i18n('vue.xtable.error.impFields'),
          type: 'error'
        });
      }
    
      if (_importResolve) {
        _importResolve(status);
    
        $table._importResolve = null;
      }
    }
    
    var VueXtableExportMixin = {
      methods: {
        // 在 v3.0 中废弃 exportCsv 方法
        _exportCsv: function _exportCsv(options) {
          tools.UtilTools.warn('vue.xtable.error.delFunc', ['exportCsv', 'exportData']);
    
          return this.exportData(options);
        },
        _openExport: function _openExport(options) {
          if (this.$toolbar) {
            return this.$toolbar.openExport(options);
          }
    
          throw new Error(tools.UtilTools.getLog('vue.xtable.error.barUnableLink'));
        },
    
        /**
         * 导出文件，支持 csv/html/xml
         * 如果是树表格，则默认是导出所有节点
         * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数自行转换数据
         * @param {Object} options 参数
         */
        _exportData: function _exportData(options) {
          var visibleColumn = this.visibleColumn,
              scrollXLoad = this.scrollXLoad,
              scrollYLoad = this.scrollYLoad,
              treeConfig = this.treeConfig;
          var opts = VueUtil.assign({
            filename: '',
            sheetName: '',
            original: !!treeConfig,
            message: false,
            isHeader: true,
            isFooter: true,
            download: true,
            type: 'csv',
            data: null,
            columns: null,
            columnFilterMethod: null,
            dataFilterMethod: null,
            footerFilterMethod: null
          }, GlobalConfig.export, options);
    
          if (!opts.filename) {
            opts.filename = 'export';
          }
    
          if (!opts.sheetName) {
            opts.sheetName = 'Sheet1';
          }
    
          if (!VueUtil.includes(baseTable.exportTypes, opts.type)) {
            throw new Error(tools.UtilTools.getLog('vue.xtable.error.notType', [opts.type]));
          }
    
          if (!options || !options.columns) {
            // 在 v3.0 中废弃 type=selection
            opts.columnFilterMethod = function (column) {
              return column.property && ['index', 'checkbox', 'selection', 'radio'].indexOf(column.type) === -1;
            };
          }
    
          var columns = visibleColumn;
          var fullData = this.tableFullData;
    
          if (treeConfig) {
            fullData = VueUtil.toTreeArray(fullData, treeConfig);
          }
    
          return handleExport(this, opts, columns, fullData);
        },
        _openImport: function _openImport(options) {
          if (this.$toolbar) {
            return this.$toolbar.openImport(options);
          }
    
          throw new Error(tools.UtilTools.getLog('vue.xtable.error.barUnableLink'));
        },
        _importByFile: function _importByFile(file, opts) {
          var _this = this;
    
          if (window.FileReader) {
            var _UtilTools$parseFile = tools.UtilTools.parseFile(file),
                type = _UtilTools$parseFile.type,
                filename = _UtilTools$parseFile.filename;
    
            var options = VueUtil.assign({
              mode: 'covering'
            }, opts, {
              type: type,
              filename: filename
            });
            var types = options.types || baseTable.importTypes;
    
            if (VueUtil.includes(types, type)) {
              this.preventEvent(null, 'event.import', {
                $table: this,
                file: file,
                options: options,
                columns: this.tableFullColumn
              }, function () {

                if(type == 'xlsx') {
                  VueUtil.Excel.importExcel([file], {cellDates: true}, function(data, book) {
                    handleImport(_this, data, options, book);
                  });

                  return;
                }

                var reader = new FileReader();
    
                reader.onerror = function (e) {
                  tools.UtilTools.error('vue.xtable.error.notType', [type]);
                };
    
                reader.onload = function (e) {
                  var result = e.target.result;
                  // txt类型被trim后，由于index列没有标题，field会少掉一列，导致列数据错位,所以去掉trim。
                  handleImport(_this, type != 'txt' ? result.trim() : result, options);
                };
    
                reader.readAsText(file, 'UTF-8');
              });
            } else {
              tools.UtilTools.error('vue.xtable.error.notType', [type]);
            }
          } else {
            tools.UtilTools.error('vue.xtable.error.notExp');
          }
        },
        _importData: function _importData(options) {
          var _this2 = this;
    
          var opts = VueUtil.assign({}, GlobalConfig.import, options);
          var rest = new Promise(function (resolve, reject) {
            _this2._importResolve = resolve;
            _this2._importReject = reject;
          });
          this.readFile(opts).then(function (evnt) {
            return _this2.importByFile(evnt.target.files[0], opts);
          }).catch(function (evnt) {
            _this2._importReject(evnt);
    
            _this2._importReject = null;
          });
          return rest;
        },
        _readFile: function _readFile() {
          var _this3 = this;
    
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    
          if (!impForm.parentNode) {
            document.body.appendChild(impForm);
          }
    
          var types = options.types || baseTable.importTypes;
          impInput.accept = '.'.concat(types.join(', .'));
    
          impInput.onchange = function (evnt) {
            var _UtilTools$parseFile2 = tools.UtilTools.parseFile(evnt.target.files[0]),
                type = _UtilTools$parseFile2.type;
    
            if (VueUtil.includes(types, type)) {
              _this3._fileResolve(evnt);
            } else {
              if (options.message !== false) {
                _this3.$notify({
                  message: _this3.t('vue.xtable.error.notType', [type]),
                  type: 'error'
                });
              }
    
              _this3._fileReject(evnt);
            }
    
            _this3._fileResolve = null;
          };
    
          impForm.reset();
          impInput.click();
          return new Promise(function (resolve, reject) {
            _this3._fileResolve = resolve;
            _this3._fileReject = reject;
          });
        },
        _print: function _print(options) {
          this.exportData(VueUtil.assign({
            original: this.scrollXLoad || this.scrollYLoad
          }, options, {
            type: 'html',
            download: false
          })).then(function (_ref) {
            var content = _ref.content,
                blob = _ref.blob;
    
            if (VueUtil.isIE) {
              if (printFrame) {
                try {
                  printFrame.contentDocument.write('');
                  printFrame.contentDocument.clear();
                } catch (e) {}
    
                document.body.removeChild(printFrame);
              }
    
              printFrame = createFrame();
              document.body.appendChild(printFrame);
              printFrame.contentDocument.write(content);
              printFrame.contentDocument.execCommand('print');
            } else {
              if (!printFrame) {
                printFrame = createFrame();
    
                printFrame.onload = function (evnt) {
                  if (evnt.target.src) {
                    evnt.target.contentWindow.print();
                  }
                };
    
                document.body.appendChild(printFrame);
              }
    
              printFrame.src = URL.createObjectURL(blob);
            }
          });
        }
      }
    };
    mod.VueXtableExportMixin = VueXtableExportMixin;
  })();

  return mod;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableKeyboardMixin = definition(context.tools);
  }
})(this, function(tools) {
  var VueXtableKeyboardMixin = {
    methods: {
      // 处理 Tab 键移动
      moveTabSelected: function moveTabSelected(args, isLeft, evnt) {
        var _this = this;
  
        var afterFullData = this.afterFullData,
            visibleColumn = this.visibleColumn,
            editConfig = this.editConfig,
            hasIndexColumn = this.hasIndexColumn;
        var targetRow;
        var targetRowIndex;
        var targetColumn;
        var targetColumnIndex;
        var params = VueUtil.assign({}, args);
        var rowIndex = afterFullData.indexOf(params.row);
        var columnIndex = visibleColumn.indexOf(params.column);
        evnt.preventDefault();

        if (params.column.editRender && params.column.editRender.name && params.column.editRender.name.indexOf('checkbox') > -1) {

          var allChecks = params.cell.querySelectorAll('input[type=checkbox]:not(:disabled)');
          var focusCheck = params.cell.querySelector('input[type=checkbox]:focus');

          var index = [].indexOf.call(allChecks, focusCheck);

          if (!evnt.shiftKey && index > -1 && index < allChecks.length -1) {
            allChecks[index + 1].focus();
            return;
          }

          if (evnt.shiftKey && index > 0) {
            allChecks[index - 1].focus();
            return;
          }
        }
  
        if (isLeft) {
          // 向左
          for (var len = columnIndex - 1; len >= 0; len--) {
            if (!hasIndexColumn(visibleColumn[len])) {
              if (visibleColumn[len].editRender) {
                targetColumnIndex = len;
                targetColumn = visibleColumn[len];
                break;
              }
            }
          }
  
          if (!targetColumn && rowIndex > 0) {
            // 如果找不到从上一行开始找，如果一行都找不到就不需要继续找了，可能不存在可编辑的列
            targetRowIndex = rowIndex - 1;
            targetRow = afterFullData[targetRowIndex];
  
            for (var _len = visibleColumn.length - 1; _len >= 0; _len--) {
              if (!hasIndexColumn(visibleColumn[_len])) {
                targetColumnIndex = _len;
                targetColumn = visibleColumn[_len];
                break;
              }
            }
          }
        } else {
          // 向右
          for (var index = columnIndex + 1; index < visibleColumn.length; index++) {
            if (!hasIndexColumn(visibleColumn[index])) {
              if (visibleColumn[index].editRender) {
                targetColumnIndex = index;
                targetColumn = visibleColumn[index];
                break;
              }
            }
          }
  
          if (!targetColumn && rowIndex < afterFullData.length - 1) {
            // 如果找不到从下一行开始找，如果一行都找不到就不需要继续找了，可能不存在可编辑的列
            targetRowIndex = rowIndex + 1;
            targetRow = afterFullData[targetRowIndex];
  
            for (var _index = 0; _index < visibleColumn.length; _index++) {
              if (!hasIndexColumn(visibleColumn[_index])) {
                targetColumnIndex = _index;
                targetColumn = visibleColumn[_index];
                break;
              }
            }
          }
        }
  
        if (targetColumn) {
          if (targetRow) {
            params.rowIndex = targetRowIndex;
            params.row = targetRow;
          } else {
            params.rowIndex = rowIndex;
          }
  
          params.columnIndex = targetColumnIndex;
          params.column = targetColumn;

          params.$columnIndex = this.tableColumn.indexOf(targetColumn);
          targetRow && (params.$rowIndex = targetRow.$rowIndex);

          params.cell = tools.DomTools.getCell(this, params);
  
          if (editConfig) {
            if (editConfig.trigger === 'click' || editConfig.trigger === 'dblclick') {
              if (editConfig.mode === 'row') {
                this.handleActived(params, evnt);
              } else {
                this.scrollToRow(params.row, params.column).then(function () {
                  return _this.handleSelected(params, evnt);
                });
              }
            }
          }
        }
      },
      // 处理当前行方向键移动
      moveCurrentRow: function moveCurrentRow(isUpArrow, isDwArrow, evnt) {
        var _this2 = this;
  
        var currentRow = this.currentRow,
            treeConfig = this.treeConfig,
            afterFullData = this.afterFullData;
        var targetRow;
        evnt.preventDefault();
  
        if (treeConfig) {
          var findTreeData = VueUtil.findTree(afterFullData, function (item) {
            return item === currentRow;
          }, treeConfig),
              index = findTreeData.index,
              items = findTreeData.items;
  
          if (isUpArrow && index > 0) {
            targetRow = items[index - 1];
          } else if (isDwArrow && index < items.length - 1) {
            targetRow = items[index + 1];
          }
        } else {
          var rowIndex = afterFullData.indexOf(currentRow);
  
          if (isUpArrow && rowIndex > 0) {
            targetRow = afterFullData[rowIndex - 1];
          } else if (isDwArrow && rowIndex < afterFullData.length - 1) {
            targetRow = afterFullData[rowIndex + 1];
          }
        }
  
        if (targetRow) {
          var params = {
            $table: this,
            row: targetRow
          };
          this.scrollToRow(targetRow).then(function () {
            return _this2.triggerCurrentRowEvent(evnt, params);
          });
        }
      },
      // 处理可编辑方向键移动
      moveSelected: function moveSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        var _this3 = this;
        var params = VueUtil.assign({}, args);

        function _getRowIndex (row) {
          return _this3.afterFullData.indexOf(row);
        }

        var _rowIndex = _getRowIndex(params.row);

        params.rowIndex = _rowIndex;
        var offsetRow = params.offset && params.offset[0];
        var offsetCol = params.offset && params.offset[1];

        var afterFullData = this.afterFullData,
            visibleColumn = this.tableColumn,
            hasIndexColumn = this.hasIndexColumn;
        
        var visibleIndex = this.getVisibleIndexFromColumnIndex(params.columnIndex);
        evnt.preventDefault();
  
        if (isUpArrow && params.rowIndex) {
          params.rowIndex -= 1;
          params.row = afterFullData[params.rowIndex];
          params.$rowIndex = params.row.$rowIndex;
        } else if (isDwArrow && params.rowIndex < afterFullData.length - 1) {
          params.rowIndex += params.cell.rowSpan;
          params.row = afterFullData[params.rowIndex];
          params.$rowIndex = params.row.$rowIndex;
        } else if (isLeftArrow && visibleIndex) {
          for (var len = visibleIndex - 1; len >= 0; len--) {
            if (!hasIndexColumn(visibleColumn[len])) {
              params.columnIndex = this.getColumnIndexFromVisibleIndex(len);
              params.column = visibleColumn[len];
              params.$columnIndex = visibleColumn.indexOf(params.column);
              break;
            }
          }
        } else if (isRightArrow) {
          for (var index = visibleIndex + params.cell.colSpan; index < visibleColumn.length; index++) {
            if (!hasIndexColumn(visibleColumn[index])) {
              params.columnIndex = this.getColumnIndexFromVisibleIndex(index);
              params.column = visibleColumn[index];
              params.$columnIndex = visibleColumn.indexOf(params.column);
              break;
            }
          }
        }

        if(offsetRow && (isLeftArrow || isRightArrow)) {
          params.rowIndex = _this3.getRowIndex(offsetRow);
          params.row = offsetRow;
          params.$rowIndex = params.row.$rowIndex;
        }
        if(offsetCol && (isUpArrow || isDwArrow)) {
          params.columnIndex = _this3.getColumnIndex(offsetCol);
          params.column = offsetCol;
          params.$columnIndex = visibleColumn.indexOf(offsetCol);
        }
  
        this.scrollToRow(params.row, params.column).then(function () {
          params.cell = tools.DomTools.getCell(_this3, params);
  
          _this3.handleSelected(params, evnt);
        });
      },
  
      /**
       * 表头按下事件
       */
      triggerHeaderCellMousedownEvent: function triggerHeaderCellMousedownEvent(evnt, params) {
        var $el = this.$el,
            tableData = this.tableData,
            _this$mouseConfig = this.mouseConfig,
            mouseConfig = _this$mouseConfig === void 0 ? {} : _this$mouseConfig,
            elemStore = this.elemStore,
            handleChecked = this.handleChecked,
            handleHeaderChecked = this.handleHeaderChecked;
        var button = evnt.button;
        var column = params.column,
            cell = params.cell;
        var isLeftBtn = button === 0;
        var isIndex = column.type === 'index';
  
        if (isLeftBtn && mouseConfig.checked) {
          var headerList = elemStore['main-header-list'].children;
          var bodyList = elemStore['main-body-list'].children;
  
          if (isIndex) {
            this.handleAllChecked(evnt);
          } else {
            evnt.preventDefault();
            evnt.stopPropagation();
            this.clearSelected(evnt);
            this.clearHeaderChecked();
            this.clearIndexChecked();
            var domMousemove = document.onmousemove;
            var domMouseup = document.onmouseup;
            var startCell = bodyList[0].querySelector('.'.concat(column.id));
            var updateEvent = VueUtil._throttle(function (evnt) {
              evnt.preventDefault();
  
              var _DomTools$getEventTar = tools.DomTools.getEventTargetNode(evnt, $el, 'vue-xtable-header--column'),
                  flag = _DomTools$getEventTar.flag,
                  targetElem = _DomTools$getEventTar.targetElem;
  
              if (!flag) {
                var a = tools.DomTools.getEventTargetNode(evnt, $el, 'vue-xtable-body--column');
  
                flag = a.flag;
                targetElem = a.targetElem;
              }
  
              if (flag && !tools.DomTools.hasClass(targetElem, 'col--index')) {
                var colIndex = [].indexOf.call(targetElem.parentNode.children, targetElem);
                var endCell = bodyList[bodyList.length - 1].children[colIndex];
                var head = headerList[0].children[colIndex];
                handleHeaderChecked(tools.DomTools.getRowNodes(headerList, tools.DomTools.getCellNodeIndex(head), tools.DomTools.getCellNodeIndex(cell)));
                handleChecked(tools.DomTools.getRowNodes(bodyList, tools.DomTools.getCellNodeIndex(startCell), tools.DomTools.getCellNodeIndex(endCell)));
              }
            }, 80, {
              leading: true,
              trailing: true
            });
  
            tools.DomTools.addClass($el, 'c--checked');
  
            document.onmousemove = updateEvent;
  
            document.onmouseup = function () {
              tools.DomTools.removeClass($el, 'c--checked');
  
              document.onmousemove = domMousemove;
              document.onmouseup = domMouseup;
            };
  
            handleHeaderChecked([[cell]]);
  
            if (bodyList.length) {
              var endCell = bodyList[bodyList.length - 1].querySelector('.'.concat(column.id));
              var firstTrElem = bodyList[0];
              var lastTrElem = bodyList[bodyList.length - 1];
              var firstCell = firstTrElem.querySelector('.col--index');
              params.rowIndex = 0;
              params.row = tableData[0];
              params.cell = tools.DomTools.getCell(this, params);
              this.handleSelected(params, evnt);
              this.handleIndexChecked(tools.DomTools.getRowNodes(bodyList, tools.DomTools.getCellNodeIndex(firstCell), tools.DomTools.getCellNodeIndex(lastTrElem.querySelector('.col--index'))));
              this.handleChecked(tools.DomTools.getRowNodes(bodyList, tools.DomTools.getCellNodeIndex(startCell), tools.DomTools.getCellNodeIndex(endCell)));
            }
          }
  
          this.closeMenu();
        }
  
        this.isActivated = true;
      },
  
      /**
       * 单元格按下事件
       */
      triggerCellMousedownEvent: function triggerCellMousedownEvent(evnt, params) {
        var $el = this.$el,
            visibleColumn = this.visibleColumn,
            highlightCurrentRow = this.highlightCurrentRow,
            _this$radioConfig3 = this.radioConfig,
            radioConfig = _this$radioConfig3 === void 0 ? {} : _this$radioConfig3,
            editStore = this.editStore,
            editConfig = this.editConfig,
            handleSelected = this.handleSelected,
            _this$mouseConfig2 = this.mouseConfig,
            mouseConfig = _this$mouseConfig2 === void 0 ? {} : _this$mouseConfig2,
            handleChecked = this.handleChecked,
            handleIndexChecked = this.handleIndexChecked,
            handleHeaderChecked = this.handleHeaderChecked,
            elemStore = this.elemStore;
        var checked = editStore.checked,
            actived = editStore.actived;
        var row = params.row,
            column = params.column,
            cell = params.cell;
        var button = evnt.button;
        var isLeftBtn = button === 0;
  
        if ((!column.treeNode || !this.getEventTargetNode(evnt, $el, 'vue-xtable-tree-wrapper').flag) && (column.type !== 'expand' || !this.getEventTargetNode(evnt, $el, 'vue-xtable-table--expanded').flag)) {
          // 如果是高亮行
          if (highlightCurrentRow) {
            if (radioConfig.trigger === 'row' || !this.getEventTargetNode(evnt, $el, 'vue-xtable-checkbox').flag && !this.getEventTargetNode(evnt, $el, 'vue-xtable-radio').flag) {
              this.triggerCurrentRowEvent(evnt, params);
            }
          }
        }
        if (editConfig) {
          if (actived.row !== row || !(editConfig.mode === 'cell' && actived.column === column)) {
            if (isLeftBtn && mouseConfig.checked) {
              evnt.preventDefault();
              evnt.stopPropagation();
              this.clearHeaderChecked();
              this.clearIndexChecked();
              var domMousemove = document.onmousemove;
              var domMouseup = document.onmouseup;
  
              var startCellNode = tools.DomTools.getCellNodeIndex(cell);
  
              var isIndex = column.type === 'index';
              var bodyList = elemStore['main-body-list'].children;
              var headerList = elemStore['main-header-list'].children;
              var cellLastElementChild = cell.parentNode.lastElementChild;
              var cellFirstElementChild = cell.parentNode.firstElementChild;
              var colIndex = [].indexOf.call(cell.parentNode.children, cell);
              var headStart = headerList[0].children[colIndex];
              var updateEvent = VueUtil._throttle(function (evnt) {
                evnt.preventDefault();
  
                var _DomTools$getEventTar2 = tools.DomTools.getEventTargetNode(evnt, $el, 'vue-xtable-body--column'),
                    flag = _DomTools$getEventTar2.flag,
                    targetElem = _DomTools$getEventTar2.targetElem;
  
                if (flag) {
                  var indexCells = Array.prototype.filter.call(targetElem.parentNode.children, function(cell) {
                    return VueUtil.hasClass(cell, 'col--index');
                  });
                  
                  var firstCell = indexCells.length ? indexCells[0] : targetElem.parentNode.firstElementChild;
                  
                  if (isIndex) {
                    handleChecked(tools.DomTools.getRowNodes(bodyList, tools.DomTools.getCellNodeIndex(firstCell.nextElementSibling), tools.DomTools.getCellNodeIndex(cellLastElementChild)));
                    handleIndexChecked(tools.DomTools.getRowNodes(bodyList, tools.DomTools.getCellNodeIndex(firstCell), tools.DomTools.getCellNodeIndex(cell)));
                  } else if (!tools.DomTools.hasClass(targetElem, 'col--index')) {
  
                    var _colIndex = [].indexOf.call(targetElem.parentNode.children, targetElem);
  
                    if(headerList.length == 1) {
                      var head = headerList[0].children[_colIndex];
                      handleHeaderChecked(tools.DomTools.getRowNodes(headerList, tools.DomTools.getCellNodeIndex(head), tools.DomTools.getCellNodeIndex(headStart)));
                    } else if(headerList.length > 1) {
                      
                      var startRect = cell.getBoundingClientRect();
                      var targetRect = targetElem.getBoundingClientRect();
                      var offs = 5;
                      var left = Math.min(startRect.left, targetRect.left) - offs;
                      var right = Math.max(startRect.right, targetRect.right) + offs;
                      var rows = [];

                      VueUtil.loop(headerList, function(header) {
                        var row = Array.prototype.filter.call(header.children, function(td) {
                          var tdRect = td.getBoundingClientRect();
                          return tdRect.left > left && tdRect.right < right;
                        });
                        rows.push(row);
                      });

                      handleHeaderChecked(rows);
                    }
                    handleIndexChecked(tools.DomTools.getRowNodes(bodyList, tools.DomTools.getCellNodeIndex(firstCell), tools.DomTools.getCellNodeIndex(cellFirstElementChild)));
                    handleChecked(tools.DomTools.getRowNodes(bodyList, startCellNode, tools.DomTools.getCellNodeIndex(targetElem)));
                  }
                }
              }, 80, {
                leading: true,
                trailing: true
              });
              document.onmousemove = updateEvent;
  
              document.onmouseup = function (evnt) {
                document.onmousemove = domMousemove;
                document.onmouseup = domMouseup;
              };
  
              if (isIndex) {
                var firstCell = cell.parentNode.firstElementChild;
                params.columnIndex++;
                params.column = visibleColumn[params.columnIndex];
                params.cell = cell.nextElementSibling;
                handleSelected(params, evnt);
                handleChecked(tools.DomTools.getRowNodes(bodyList, tools.DomTools.getCellNodeIndex(firstCell.nextElementSibling), tools.DomTools.getCellNodeIndex(cellLastElementChild)));
                handleHeaderChecked([headerList[0].querySelectorAll('.vue-xtable-header--column:not(.col--index):not(.col--drag)')]);
                handleIndexChecked(tools.DomTools.getRowNodes(bodyList, tools.DomTools.getCellNodeIndex(firstCell), tools.DomTools.getCellNodeIndex(cell)));
              } else {
                
                var indexCells = Array.prototype.filter.call(cell.parentNode.children, function(cell) {
                  return VueUtil.hasClass(cell, 'col--index');
                });
                
                var _firstCell2 = indexCells.length ? indexCells[0] : cell.parentNode.firstElementChild;
                
                handleSelected(params, evnt);
                handleHeaderChecked([[headerList[0].querySelector('.'.concat(column.id))]]);
                handleIndexChecked([[_firstCell2]]);
              }
  
              this.closeFilter();
              this.closeMenu();
            } else if (mouseConfig.selected) {
              // 除了双击其他都没有选中状态
              if (editConfig.trigger === 'dblclick') {
                // 如果不在所有选中的范围之内则重新选中
                if (!checked.rowNodes || !checked.rowNodes.some(function (list) {
                  return VueUtil.includes(list, cell);
                })) {
                  handleSelected(params, evnt);
                }
              }
            }
          }
        } else if (mouseConfig.selected) {
          handleSelected(params, evnt);
        }
  
        this.isActivated = true;
      },
  
      /**
       * 边角事件
       */
      // triggerCornerMousedownEvent (params, evnt) {
      //   evnt.preventDefault()
      //   evnt.stopPropagation()
      //   let { $el, tableData, visibleColumn, editStore, editConfig, handleTempChecked } = this
      //   let { checked } = editStore
      //   let { button } = evnt
      //   let isLeftBtn = button === 0
      //   let isRightBtn = button === 2
      //   if (isLeftBtn || isRightBtn) {
      //     if (editConfig && checked.rows.length && editConfig.trigger === 'dblclick') {
      //       let domMousemove = document.onmousemove
      //       let domMouseup = document.onmouseup
      //       let start = {
      //         rowIndex: tableData.indexOf(checked.rows[0]),
      //         columnIndex: visibleColumn.indexOf(checked.columns[0])
      //       }
      //       let updateEvent = VueUtil._throttle(function (evnt) {
      //         evnt.preventDefault()
      //         let { flag, targetElem } = DomTools.getEventTargetNode(evnt, $el, 'vue-xtable-body--column')
      //         if (flag) {
      //           handleTempChecked(start, DomTools.getCellIndexs(targetElem), evnt)
      //         }
      //       }, VueUtil.isIE ? 80 : 40, { leading: true, trailing: true })
      //       document.onmousemove = updateEvent
      //       document.onmouseup = function (evnt) {
      //         document.onmousemove = domMousemove
      //         document.onmouseup = domMouseup
      //         checked.rows = checked.tRows
      //         checked.columns = checked.tColumns
      //       }
      //     }
      //   }
      // },
  
      /**
       * 清除所有选中状态
       */
      _clearChecked: function _clearChecked(evnt) {
        var $refs = this.$refs,
            editStore = this.editStore,
            mouseConfig = this.mouseConfig;
        var checked = editStore.checked;
  
        if (mouseConfig && mouseConfig.checked) {
          var tableBody = $refs.tableBody;
          checked.rows = [];
          checked.columns = [];
          checked.tRows = [];
          checked.tColumns = [];
          var checkBorders = tableBody.$refs.checkBorders;
          checkBorders.style.display = 'none';
          VueUtil.loop(this.$el.querySelectorAll('.col--checked'), function (elem) {
            return tools.DomTools.removeClass(elem, 'col--checked');
          });
        }
  
        return this.$nextTick();
      },
      _getMouseSelecteds: function _getMouseSelecteds() {
        var _this$editStore$selec = this.editStore.selected,
            args = _this$editStore$selec.args,
            column = _this$editStore$selec.column;
  
        if (args && column) {
          return VueUtil.assign({}, args);
        }
  
        return null;
      },
      _getMouseCheckeds: function _getMouseCheckeds() {
        var _this4 = this;
  
        var checked = this.editStore.checked;
        var _checked$rowNodes = checked.rowNodes,
            rowNodes = _checked$rowNodes === void 0 ? [] : _checked$rowNodes;
        var columns = [];
        var rows = [];
  
        if (rowNodes && rowNodes.length) {
          rows = rowNodes.map(function (list) {
            return _this4.getRowNode(list[0].parentNode).item;
          });
          columns = rowNodes[0].map(function (cell) {
            return _this4.getColumnNode(cell).item;
          });
        }
  
        return {
          columns: columns,
          rows: rows,
          rowNodes: rowNodes
        };
      },
  
      /**
       * 处理所有选中
       */
      handleChecked: function handleChecked(rowNodes) {
        var checked = this.editStore.checked;
        this.clearChecked();
        var cWidth = -2;
        var cHeight = -2;
        var offsetTop = 0;
        var offsetLeft = 0;
        VueUtil.loop(rowNodes, function (rows, rowIndex) {
          var isTop = rowIndex === 0;
          VueUtil.loop(rows, function (elem, colIndex) {
            var isLeft = colIndex === 0;
  
            if (isLeft && isTop) {
              offsetTop = elem.offsetTop;
              offsetLeft = elem.offsetLeft;
            }
  
            if (isTop) {
              cWidth += elem.offsetWidth;
            }
  
            if (isLeft) {
              cHeight += elem.offsetHeight;
            }
  
            tools.DomTools.addClass(elem, 'col--checked');
          });
        });
        var _this$$refs$tableBody = this.$refs.tableBody.$refs,
            checkBorders = _this$$refs$tableBody.checkBorders,
            checkTop = _this$$refs$tableBody.checkTop,
            checkRight = _this$$refs$tableBody.checkRight,
            checkBottom = _this$$refs$tableBody.checkBottom,
            checkLeft = _this$$refs$tableBody.checkLeft;
        checkBorders.style.display = 'block';
        VueUtil.assign(checkTop.style, {
          top: ''.concat(offsetTop, 'px'),
          left: ''.concat(offsetLeft, 'px'),
          width: ''.concat(cWidth, 'px')
        });
        VueUtil.assign(checkRight.style, {
          top: ''.concat(offsetTop, 'px'),
          left: ''.concat(offsetLeft + cWidth, 'px'),
          height: ''.concat(cHeight, 'px')
        });
        VueUtil.assign(checkBottom.style, {
          top: ''.concat(offsetTop + cHeight, 'px'),
          left: ''.concat(offsetLeft, 'px'),
          width: ''.concat(cWidth, 'px')
        });
        VueUtil.assign(checkLeft.style, {
          top: ''.concat(offsetTop, 'px'),
          left: ''.concat(offsetLeft, 'px'),
          height: ''.concat(cHeight, 'px')
        });
        checked.rowNodes = rowNodes;
      },
      handleAllChecked: function handleAllChecked(evnt) {
        var tableData = this.tableData,
            visibleColumn = this.visibleColumn,
            _this$mouseConfig3 = this.mouseConfig,
            mouseConfig = _this$mouseConfig3 === void 0 ? {} : _this$mouseConfig3,
            elemStore = this.elemStore;
  
        if (mouseConfig.checked) {
          evnt.preventDefault();
          var headerListElem = elemStore['main-header-list'];
          var headerList = headerListElem.children;
          var bodyList = elemStore['main-body-list'].children;
          var column = VueUtil.find(visibleColumn, function (column) {
            return column.type === 'index';
          }) || visibleColumn[0];
          var cell = headerListElem.querySelector('.'.concat(column.id));
          var firstTrElem = bodyList[0];
          var lastTrElem = bodyList[bodyList.length - 1];
          var firstCell = firstTrElem.querySelector('.'.concat(column.id));
          var params = {
            $table: this,
            rowIndex: 0,
            row: tableData[0],
            column: VueUtil.find(visibleColumn, function (column) {
              return column.property;
            })
          };
          params.columnIndex = this.getColumnIndex(params.column);
          params.cell = tools.DomTools.getCell(this, params);
          this.handleSelected(params, evnt);
          this.handleHeaderChecked(tools.DomTools.getRowNodes(headerList, tools.DomTools.getCellNodeIndex(cell.nextElementSibling), tools.DomTools.getCellNodeIndex(cell.parentNode.lastElementChild)));
          this.handleIndexChecked(tools.DomTools.getRowNodes(bodyList, tools.DomTools.getCellNodeIndex(firstCell), tools.DomTools.getCellNodeIndex(lastTrElem.querySelector('.'.concat(column.id)))));
          this.handleChecked(tools.DomTools.getRowNodes(bodyList, tools.DomTools.getCellNodeIndex(firstCell.nextElementSibling), tools.DomTools.getCellNodeIndex(lastTrElem.lastElementChild)));
        }
      },
      handleIndexChecked: function handleIndexChecked(rowNodes) {
        var indexs = this.editStore.indexs;
        this.clearIndexChecked();
        VueUtil.loop(rowNodes, function (rows) {
          VueUtil.loop(rows, function (elem) {
            tools.DomTools.addClass(elem, 'col--index-checked');
          });
        });
        indexs.rowNodes = rowNodes;
      },
      _clearIndexChecked: function _clearIndexChecked() {
        var elemStore = this.elemStore;
        var bodyElem = elemStore['main-body-list'];
        VueUtil.loop(bodyElem.querySelectorAll('.col--index-checked'), function (elem) {
          return tools.DomTools.removeClass(elem, 'col--index-checked');
        });
        return this.$nextTick();
      },
      handleHeaderChecked: function handleHeaderChecked(rowNodes) {
        var titles = this.editStore.titles;
        this.clearHeaderChecked();
        VueUtil.loop(rowNodes, function (rows) {
          VueUtil.loop(rows, function (elem) {
            tools.DomTools.addClass(elem, 'col--title-checked');
          });
        });
        titles.rowNodes = rowNodes;
      },
      _clearHeaderChecked: function _clearHeaderChecked() {
        var elemStore = this.elemStore;
        var headerElem = elemStore['main-header-list'];
  
        if (headerElem) {
          VueUtil.loop(headerElem.querySelectorAll('.col--title-checked'), function (elem) {
            return tools.DomTools.removeClass(elem, 'col--title-checked');
          });
        }
  
        return this.$nextTick();
      },
  
      /**
       * 处理所有选中的临时选中
       */
      // handleTempChecked (start, end, evnt) {
      //   let { tableData, visibleColumn, editStore } = this
      //   let { checked } = editStore
      //   let { rows, tRows, columns, tColumns } = checked
      //   let { rowIndex: sRowIndex, columnIndex: sColumnIndex } = start
      //   let { rowIndex: eRowIndex, columnIndex: eColumnIndex } = end
      //   if (tRows.length > rows.length) {
      //     eColumnIndex = visibleColumn.indexOf(columns[columns.length - 1])
      //   } else if (tColumns.length > columns.length) {
      //     eRowIndex = tableData.indexOf(rows[rows.length - 1])
      //   }
      //   if (sRowIndex < eRowIndex) {
      //     // 向下
      //     checked.tRows = tableData.slice(sRowIndex, eRowIndex + 1)
      //   } else {
      //     // 向上
      //     sRowIndex += rows.length
      //     checked.tRows = tableData.slice(eRowIndex, sRowIndex)
      //   }
      //   if (sColumnIndex < eColumnIndex) {
      //     // 向右
      //     checked.tColumns = visibleColumn.slice(Math.max(sColumnIndex, 1), eColumnIndex + 1)
      //   } else {
      //     // 向左
      //     sColumnIndex += columns.length
      //     checked.tColumns = visibleColumn.slice(Math.max(eColumnIndex, 1), sColumnIndex)
      //   }
      // },
  
      /**
       * 清空已复制的内容
       */
      _clearCopyed: function _clearCopyed() {
        var $refs = this.$refs,
            editStore = this.editStore,
            keyboardConfig = this.keyboardConfig;
        var copyed = editStore.copyed;
  
        if (keyboardConfig && keyboardConfig.isCut) {
          var tableBody = $refs.tableBody;
          var copyBorders = $refs.tableBody.$refs.copyBorders;
          copyed.cut = false;
          copyed.rows = [];
          copyed.columns = [];
          copyBorders.style.display = 'none';
          VueUtil.loop(tableBody.$el.querySelectorAll('.col--copyed'), function (elem) {
            return tools.DomTools.removeClass(elem, 'col--copyed');
          });
        }
  
        return this.$nextTick();
      },
  
      /**
       * 处理复制
       */
      handleCopyed: function handleCopyed(cut, evnt) {
        var tableData = this.tableData,
            tableColumn = this.tableColumn,
            editStore = this.editStore;
        var copyed = editStore.copyed,
            checked = editStore.checked;
        var rowNodes;

        if (this.mouseConfig.checked) {
          rowNodes = checked.rowNodes;
        } else if(this.mouseConfig.selected) {
          rowNodes = editStore.selected.args && [[editStore.selected.args.cell]] ;
        }

        if (!rowNodes) {
          return;
        }

        this.clearCopyed();
        var cWidth = -3;
        var cHeight = -3;
        var offsetTop = 0;
        var offsetLeft = 0;
        var columns = [];
        var rows = [];
  
        if (rowNodes.length) {
          var firstRows = rowNodes[0];
  
          var _DomTools$getCellNode = tools.DomTools.getCellNodeIndex(firstRows[0]),
              rowIndex = _DomTools$getCellNode.rowIndex,
              columnIndex = _DomTools$getCellNode.columnIndex;
  
          columns = tableColumn.slice(columnIndex, columnIndex + firstRows.length);
          rows = tableData.slice(rowIndex, rowIndex + rowNodes.length);
        }
  
        VueUtil.loop(rowNodes, function (rows, rowIndex) {
          var isTop = rowIndex === 0;
          VueUtil.loop(rows, function (elem, colIndex) {
            var isLeft = colIndex === 0;
  
            if (isLeft && isTop) {
              offsetTop = elem.offsetTop;
              offsetLeft = elem.offsetLeft;
            }
  
            if (isTop) {
              cWidth += elem.offsetWidth;
            }
  
            if (isLeft) {
              cHeight += elem.offsetHeight;
            }
  
            tools.DomTools.addClass(elem, 'col--copyed');
          });
        });
        var _this$$refs$tableBody2 = this.$refs.tableBody.$refs,
            copyBorders = _this$$refs$tableBody2.copyBorders,
            copyTop = _this$$refs$tableBody2.copyTop,
            copyRight = _this$$refs$tableBody2.copyRight,
            copyBottom = _this$$refs$tableBody2.copyBottom,
            copyLeft = _this$$refs$tableBody2.copyLeft;
        copyBorders.style.display = 'block';
        VueUtil.assign(copyTop.style, {
          top: ''.concat(offsetTop, 'px'),
          left: ''.concat(offsetLeft, 'px'),
          width: ''.concat(cWidth, 'px')
        });
        VueUtil.assign(copyRight.style, {
          top: ''.concat(offsetTop, 'px'),
          left: ''.concat(offsetLeft + cWidth, 'px'),
          height: ''.concat(cHeight, 'px')
        });
        VueUtil.assign(copyBottom.style, {
          top: ''.concat(offsetTop + cHeight, 'px'),
          left: ''.concat(offsetLeft, 'px'),
          width: ''.concat(cWidth, 'px')
        });
        VueUtil.assign(copyLeft.style, {
          top: ''.concat(offsetTop, 'px'),
          left: ''.concat(offsetLeft, 'px'),
          height: ''.concat(cHeight, 'px')
        });
        copyed.cut = cut;
        copyed.rows = rows;
        copyed.columns = columns;
        copyed.rowNodes = rowNodes;

        VueUtil.clipboard(this.getHandleCopyStr());
      },
  
      /**
       * 处理粘贴
       */
      handlePaste: function handlePaste(evnt) {
        var table = this;
        var data = this.getClipboardData(evnt);
        var tableData = this.tableData,
            visibleColumn = this.visibleColumn,
            editStore = this.editStore,
            elemStore = this.elemStore;
        var copyed = editStore.copyed,
            selected = editStore.selected;
        var cut = copyed.cut,
            rows = data.rows,
            columns = data.columns;
  
        if (rows.length && columns.length && selected.row && selected.column) {
          var _selected$args = selected.args,
              rowIndex = _selected$args.$rowIndex,
              columnIndex = _selected$args.columnIndex;
          VueUtil.loop(rows, function (row, rIndex) {
            var offsetRow = tableData[rowIndex + rIndex];
  
            if (offsetRow) {
              VueUtil.loop(columns, function (column, cIndex) {
                var offsetColumn = visibleColumn[columnIndex + cIndex];

                if (offsetColumn) {

                  if (table.isCellEditable({row: offsetRow, column: offsetColumn})) {
                    var val = tools.UtilTools.getCellValue(row, column);
                    var formattedVal = table.getFormattedVal(val, offsetRow, offsetColumn, 'paste');
                    tools.UtilTools.setCellValue(offsetRow, offsetColumn, formattedVal);
                  }
                }
  
                if (cut) {
                  var oldRow = copyed.rows[rIndex];
                  var oldCol = copyed.columns[cIndex];
                  if (table.isCellEditable({row: oldRow, column: oldCol})) {
                    tools.UtilTools.setCellValue(oldRow, oldCol, null);
                  }
                }
              });
            }
          });
  
          if (cut) {
            this.clearCopyed();
          }
  
          var bodyList = elemStore['main-body-list'].children;
          var cell = selected.args.cell;
          var trElem = cell.parentNode;
          var colIndex = VueUtil.arrayIndexOfVal(trElem.children, cell);
          var rIndex = VueUtil.arrayIndexOfVal(bodyList, trElem);
          var targetTrElem = bodyList[rIndex + rows.length - 1];
          var targetCell = targetTrElem.children[colIndex + columns.length - 1];
          this.handleChecked(tools.DomTools.getRowNodes(bodyList, tools.DomTools.getCellNodeIndex(cell), tools.DomTools.getCellNodeIndex(targetCell)));
        }
      },

      getFormattedVal: function(val, offsetRow, offsetColumn, type) {
        if (!offsetColumn) return val;
        var formatter;
        if (type === 'paste') {
          formatter = offsetColumn.pasteFormatter;
        } else if (type === 'copy') {
          formatter = offsetColumn.copyFormatter || offsetColumn.formatter;
        }
        if(!formatter) return  val;

        var formattedVal = '';

        if (VueUtil.isString(formatter)) {
          formattedVal = VueUtil.get(VueUtil, formatter)(val);
        } else if (VueUtil.isArray(formatter)) {
          formattedVal = VueUtil.get(VueUtil, formatter[0]).apply(VueUtil, [val].concat(formatter.slice(1)));
        } else {
          formattedVal = formatter({
            cellValue: val,
            row: offsetRow,
            rowIndex: this.getRowIndex(offsetRow),
            column: offsetColumn,
            columnIndex: this.getColumnIndex(offsetColumn),
          });
        }

        return formattedVal;
      },

      // 复制的行列数据转化为内容数据
      getHandleCopyStr: function getHandleCopyStr() {
        var temp = '';
        var copy = this.editStore.copyed;
        for (var j = 0; j < copy.rows.length; j++) {
          if (j > 0) {
            temp += '\n';
          }
          for (var i = 0; i < copy.columns.length; i++) {
            if (i > 0) {
              temp += '\t';
            }
            // temp += tools.UtilTools.getCellValue(copy.rows[j], copy.columns[i]);
            var val = tools.UtilTools.getCellValue(copy.rows[j], copy.columns[i]);
            var formattedVal = this.getFormattedVal(val, copy.rows[j], copy.columns[i], 'copy');
            temp += (formattedVal || '');
          }
        }
        return temp;
      },
      // 获取剪贴板文字
      getClipboardText: function getClipboardText(e) {
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
          if (typeof e != 'undefined' && typeof e.clipboardData != 'undefined') {
            clipboardData = e.clipboardData;
          }
        }
        if (clipboardData) {
          data = clipboardData.getData('text');
        }
        return data;
      },
      /**
        return "{\"rows\": [{\"1\": \"抢钱cx\",\"2\": \"前端cx\"}, {\"1\": \"蕾蕾cx\",\"2\": \"后端cx\"}],
          \"columns\": [{\"property\": 1}, {\"property\": 2}]}"
      */
     getClipboardData: function getClipboardData(event) {

      function uniqueColumns(columns) {
        var map = {};
        var newList = [];
        for (var i = 0; i < columns.length; i++) {
          if (!map[columns[i].property]) {
            map[columns[i].property] = 1;
            newList.push(columns[i]);
          }
        }
        return newList;
      }

        var rows = this.getClipboardText(event).split(/\r?\n/);
        var dataObj = { rows: [], columns: [] };
        for (var i = 0; i < rows.length; i++) {
          var rowitems = rows[i].split('\t');
          if (rowitems.length == 1 && '' == rowitems[0]) {
            continue;
          }
          var rowitem = {};
          for (var j = 0; j < rowitems.length; j++) {
            rowitem[j + 1] = rowitems[j];
            dataObj.columns.push({ 'property': j + 1 });
          }
          dataObj.rows.push(rowitem);
        }
        dataObj.columns = uniqueColumns(dataObj.columns);
        return dataObj;
      },
    }
  };

  return VueXtableKeyboardMixin;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableLoading = definition(context.tools);
  }
})(this, function(tools) {
  var VueXtableLoading = {
    name: 'VueXtableLoading',
    props: {
      visible: Boolean
    },
    render: function render(h) {
      return h('div', {
        class: 'vue-xtable-table--loading',
        style: {
          display: this.visible ? 'block' : 'none'
        }
      }, [h('div', {
        class: 'vue-xtable-table--spinner'
      })]);
    }
  };
  return VueXtableLoading;
});
(function (context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueXtableChart = definition(context.tools);
  }
})(this, function () {
  'use strict';

  var modal = Vue.extend(({
    name: 'VueChartModal',
    data: function () {
      return { visible: false };
    },
    props: {
      title: String,
      showClose: Boolean,
      size: String,
      slots: Object,
      events: Object,
      width: [Number, String],
      height: [Number, String]
    },
    methods: {
      open: function () {
        var self = this,
          events = self.events === void 0 ? {} : self.events,
          listeners = this.$listeners;
        var params = {
          type: 'show',
          $modal: self
        };
        setTimeout(function () {
          self.visible = true;
          self.$nextTick(function () {
            if (!events.show) {
              self.$emit('input', true);
              self.$emit('show', params);
            }
            if (!listeners.show && events.show) {
              events.show.call(self, params);
            }
          });
        }, 10);
      },
      close: function (visible) {
        var self = this,
          events = self.events === void 0 ? {} : self.events;
        self.visible = visible;
        self.$el.parentNode.removeChild(self.$el);
        setTimeout(function () {
          var params = {
            type: 'hide',
            $modal: self
          };
          if (events.hide) {
            events.hide.call(self, params);
          } else {
            self.$emit('input', false);
            self.$emit('hide', params);
          }
        }, 200);
      },
      getBox: function getBox() {
        return this.$refs.modalBox;
      }
    },
    mounted: function () {
      document.body.appendChild(this.$el); // 触发 inserted 事件
      var modalElem = this.getBox(),
        width = this.width,
        height = this.height;
      VueUtil.assign(modalElem.style, {
        /* width: width ? isNaN(width) ? width : "".concat(width, "px") : null, */
        height: height ? isNaN(height) ? height : ''.concat(height, 'px') : null,
        width: '100%',
        overflow: 'auto'
      });
    },
    render: function render(h) {
      var self = this;
      var $scopedSlots = this.$scopedSlots;
      var defaultSlot = $scopedSlots.default || self.slots.default;
      return h('vue-dialog', {
        res: 'modal',
        model: {
          value: self.visible,
          callback: function callback(value) {
            if (!value) { self.close(value); }
          }
        },
        props: {
          title: self.title,
          showClose: self.showClose,
          widht: self.width,
          height: self.height
        }
      }, [h('div', {
        ref: 'modalBox'
      }, [defaultSlot ? defaultSlot.call(this, {
        $modal: this
      }, h) : null])]);
    }
  }));

  function createChartModal(getOptions) {
    return function (params) {
      var menu = params.menu;
      var dialogdiv = document.createElement('div');

      var options = {
        width: 600,
        height: 400,
        title: menu.name,
        showClose: true,
        slots: {
          'default': function _default(params, h) {
            return [h('div', {
              'class': 'vue-xtable-chart--wrapper'
            }, [h('div', {
              'class': 'vue-xtable-chart--panel'
            })])];
          }
        },
        events: {
          show: function show() {
            var $chart = echarts.init(this.$el.querySelector('.vue-xtable-chart--wrapper'));

            $chart.setOption(getOptions(params));
            this.$chart = $chart;
          },
          close: function close() {
            // 旧版本，即将废弃
            this.$chart.dispose();
            this.$chart = null;
          },
          hide: function hide() {
            this.$chart.dispose();
            this.$chart = null;
          },
          zoom: function zoom() {
            this.$chart.resize();
          }
        }
      };
      var chart = new modal({
        el: dialogdiv,//document.createElement('div'),
        propsData: options
      });
      setTimeout(function () {
        return chart.open();
      }, 10);
    };
  }

  var menuMap = {
    CHART_BAR_X_AXIS: createChartModal(function (params) {
      var $table = params.$table,
        menu = params.menu;

      var _$table$getMouseCheck = $table.getMouseCheckeds(),
        rows = _$table$getMouseCheck.rows,
        columns = _$table$getMouseCheck.columns;

      var _menu$params = menu.params,
        chartParams = _menu$params === void 0 ? {} : _menu$params;
      var category = chartParams.category;
      var categoryColumn = $table.getColumnByField(category || columns[0].property);
      var serieColumns = columns.filter(function (column) {
        return column.property !== categoryColumn.property;
      });
      var legendOpts = {
        data: []
      };
      var seriesOpts = [];
      var xAxisOpts = {
        type: 'category',
        data: rows.map(function (row) {
          return VueUtil.get(row, categoryColumn.property);
        })
      };
      serieColumns.forEach(function (column) {
        legendOpts.data.push(column.title);
        seriesOpts.push({
          name: column.title,
          type: 'bar',
          data: rows.map(function (row) {
            return VueUtil.get(row, column.property);
          })
        });
      });
      var option = {
        tooltip: {
          trigger: 'axis',
          axisPointer: {
            type: 'shadow'
          }
        },
        legend: legendOpts,
        xAxis: xAxisOpts,
        yAxis: {
          type: 'value'
        },
        series: seriesOpts
      };
      return option;
    }),
    CHART_BAR_Y_AXIS: createChartModal(function (params) {
      var $table = params.$table,
        menu = params.menu;

      var _$table$getMouseCheck2 = $table.getMouseCheckeds(),
        rows = _$table$getMouseCheck2.rows,
        columns = _$table$getMouseCheck2.columns;

      var _menu$params2 = menu.params,
        chartParams = _menu$params2 === void 0 ? {} : _menu$params2;
      var category = chartParams.category;
      var categoryColumn = $table.getColumnByField(category || columns[0].property);
      var serieColumns = columns.filter(function (column) {
        return column.property !== categoryColumn.property;
      });
      var legendOpts = {
        data: []
      };
      var seriesOpts = [];
      var xAxisOpts = {
        type: 'category',
        data: rows.map(function (row) {
          return VueUtil.get(row, categoryColumn.property);
        })
      };
      serieColumns.forEach(function (column) {
        legendOpts.data.push(column.title);
        seriesOpts.push({
          name: column.title,
          type: 'bar',
          data: rows.map(function (row) {
            return VueUtil.get(row, column.property);
          })
        });
      });
      var option = {
        tooltip: {
          trigger: 'axis',
          axisPointer: {
            type: 'shadow'
          }
        },
        legend: legendOpts,
        xAxis: xAxisOpts,
        yAxis: {
          type: 'value'
        },
        series: seriesOpts
      };
      return option;
    }),
    CHART_LINE: createChartModal(function (params) {
      var $table = params.$table,
        menu = params.menu;

      var _$table$getMouseCheck3 = $table.getMouseCheckeds(),
        rows = _$table$getMouseCheck3.rows,
        columns = _$table$getMouseCheck3.columns;

      var _menu$params3 = menu.params,
        chartParams = _menu$params3 === void 0 ? {} : _menu$params3;
      var category = chartParams.category;
      var categoryColumn = $table.getColumnByField(category || columns[0].property);
      var serieColumns = columns.filter(function (column) {
        return column.property !== categoryColumn.property;
      });
      var legendOpts = {
        data: []
      };
      var seriesOpts = [];
      var xAxisOpts = {
        type: 'category',
        data: rows.map(function (row) {
          return VueUtil.get(row, categoryColumn.property);
        })
      };
      serieColumns.forEach(function (column) {
        legendOpts.data.push(column.title);
        seriesOpts.push({
          name: column.title,
          type: 'line',
          data: rows.map(function (row) {
            return VueUtil.get(row, column.property);
          })
        });
      });
      var option = {
        tooltip: {
          trigger: 'axis'
        },
        legend: legendOpts,
        toolbox: {
          feature: {
            saveAsImage: {}
          }
        },
        xAxis: xAxisOpts,
        yAxis: {
          type: 'value'
        },
        series: seriesOpts
      };
      return option;
    }),
    CHART_PIE: createChartModal(function (params) {
      var $table = params.$table,
        menu = params.menu;

      var _$table$getMouseCheck4 = $table.getMouseCheckeds(),
        rows = _$table$getMouseCheck4.rows,
        columns = _$table$getMouseCheck4.columns;

      var _menu$params4 = menu.params,
        chartParams = _menu$params4 === void 0 ? {} : _menu$params4;
      var category = chartParams.category;
      var categoryColumn = $table.getColumnByField(category || columns[0].property);
      var serieColumns = columns.filter(function (column) {
        return column.property !== categoryColumn.property;
      });
      var serieColumn = serieColumns[0];
      var legendData = rows.map(function (row) {
        return VueUtil.get(row, categoryColumn.property);
      });
      var seriesData = [];
      rows.forEach(function (row) {
        seriesData.push({
          name: VueUtil.get(row, categoryColumn.property),
          value: VueUtil.get(row, serieColumn.property)
        });
      });
      var option = {
        tooltip: {
          trigger: 'item',
          formatter: '{a} <br/>{b} : {c} ({d}%)'
        },
        legend: {
          type: 'scroll',
          orient: 'vertical',
          right: 10,
          top: 20,
          bottom: 20,
          data: legendData // selected: data.selected

        },
        series: [{
          name: serieColumn.title,
          type: 'pie',
          radius: '50%',
          center: ['40%', '50%'],
          data: seriesData
        }]
      };
      return option;
    })
  };

  function checkPrivilege(item, params) {
    var $table = params.$table;
    var code = item.code,
      _item$params = item.params,
      chartParams = _item$params === void 0 ? {} : _item$params;

    switch (code) {
      case 'CHART_BAR_X_AXIS':
      case 'CHART_BAR_Y_AXIS':
      case 'CHART_LINE':
        {
          var _$table$getMouseCheck5 = $table.getMouseCheckeds(),
            rows = _$table$getMouseCheck5.rows,
            columns = _$table$getMouseCheck5.columns;

          var category = chartParams.category;

          if (category) {
            var serieColumns = columns.filter(function (column) {
              return column.property !== category;
            });
            item.disabled = !rows.length || serieColumns.length < 1;
          } else {
            item.disabled = !rows.length || columns.length < 2;
          }
        }
        break;

      case 'CHART_PIE':
        {
          var _$table$getMouseCheck6 = $table.getMouseCheckeds(),
            _rows = _$table$getMouseCheck6.rows,
            _columns = _$table$getMouseCheck6.columns;

          var _category = chartParams.category;

          if (_category) {
            var _serieColumns = _columns.filter(function (column) {
              return column.property !== _category;
            });

            item.disabled = !_rows.length || _serieColumns.length !== 1;
          } else {
            item.disabled = !_rows.length || _columns.length !== 2;
          }
        }
        break;
    }
  }

  function handlePrivilegeEvent(params) {
    params.options.forEach(function (list) {
      list.forEach(function (item) {
        checkPrivilege(item, params);

        if (item.children) {
          item.children.forEach(function (child) {
            checkPrivilege(child, params);
          });
        }
      });
    });
  }

  var VueXtableChart = {
    install: function install(baseTable) {
      var interceptor = baseTable.interceptor,
        menus = baseTable.menus;

      interceptor.add('event.show_menu', handlePrivilegeEvent);
      menus.mixin(menuMap);
    }
  };

  return VueXtableChart;
});
(function (context, definition) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define([], definition);
    } else {
        context.VueXgrid = definition(context.VueXtable, context.tools, context.baseTable);
    }
})(this, function (Table, tools, baseTable) {

    function ownKeys(object, enumerableOnly) { var keys = VueUtil.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { tools.UtilTools.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    var methods = {};
    var propKeys = VueUtil.keys(Table.props);
    VueUtil.keys(Table.methods).forEach(function (name) {
        methods[name] = function () {
            return this.$refs.xTable[name].apply(this.$refs.xTable[name], arguments);
        };
    });
    var VueXgrid = {
        name: 'VueXgrid',
        props: _objectSpread({
            columns: Array,
            pagerConfig: Object,
            proxyConfig: Object,
            toolbar: Object
        }, Table.props),
        provide: function provide() {
            return {
                $grid: this
            };
        },
        data: function data() {
            return {
                tableLoading: false,
                tableData: [],
                tableCustoms: [],
                pendingRecords: [],
                filterData: [],
                sortData: {},
                tablePage: {
                    total: 0,
                    pageSize: 10,
                    currentPage: 1
                }
            };
        },
        computed: {
            vSize: function vSize() {
                return this.size || this.$parent.size || this.$parent.vSize;
            },
            isMsg: function isMsg() {
                return this.proxyOpts.message !== false;
            },
            proxyOpts: function proxyOpts() {
                return VueUtil.assign({}, GlobalConfig.grid.proxyConfig, this.proxyConfig);
            },
            tableProps: function tableProps() {
                var _this = this;

                var rest = {};
                propKeys.forEach(function (key) {
                    rest[key] = _this[key];
                });
                return rest;
            }
        },
        watch: {
            columns: function columns(value) {
                this.loadColumn(value);
            },
            tableCustoms: function tableCustoms() {
                var $refs = this.$refs,
                    toolbar = this.toolbar;

                if (toolbar && $refs.toolbar) {
                    $refs.toolbar.loadStorage();
                }
            }
        },
        created: function created() {
            var customs = this.customs,
                data = this.data,
                proxyConfig = this.proxyConfig,
                proxyOpts = this.proxyOpts,
                pagerConfig = this.pagerConfig;
            var props = proxyOpts.props;

            if (customs) {
                this.tableCustoms = customs;
            }

            if (pagerConfig && pagerConfig.pageSize) {
                this.tablePage.pageSize = pagerConfig.pageSize;
            }

            if (data && proxyConfig) {
                console.warn('[vue-xgrid] There is a conflict between the props proxy-config and data.');
            } // （v3.0 中废弃 proxyConfig.props.data）


            if (props && props.data) {
                tools.UtilTools.warn('vue.xtable.error.delProp', ['proxy-config.props.data', 'proxy-config.props.result']);
            }
        },
        mounted: function mounted() {
            var columns = this.columns,
                proxyConfig = this.proxyConfig,
                proxyOpts = this.proxyOpts;

            if (columns && columns.length) {
                this.loadColumn(this.columns);
            }

            if (proxyConfig && proxyOpts.autoLoad !== false) {
                this.commitProxy('query');
            }
        },
        render: function render(h) {
            var _this2 = this,
                _ref;

            var $slots = this.$slots,
                $scopedSlots = this.$scopedSlots,
                $listeners = this.$listeners,
                pagerConfig = this.pagerConfig,
                vSize = this.vSize,
                loading = this.loading,
                toolbar = this.toolbar,
                editConfig = this.editConfig,
                proxyConfig = this.proxyConfig,
                proxyOpts = this.proxyOpts,
                tableProps = this.tableProps,
                tableLoading = this.tableLoading,
                tablePage = this.tablePage,
                tableData = this.tableData,
                tableCustoms = this.tableCustoms,
                optimization = this.optimization;
            var props = VueUtil.assign({}, tableProps, {
                optimization: VueUtil.assign({}, GlobalConfig.optimization, optimization)
            });
            var tableOns = VueUtil.assign({}, $listeners);
            var $buttons = $scopedSlots.buttons;
            var $tools = $scopedSlots.tools;

            if (proxyConfig) {
                VueUtil.assign(props, {
                    loading: loading || tableLoading,
                    data: tableData,
                    rowClassName: this.handleRowClassName
                });

                if (proxyOpts.index && pagerConfig) {
                    props.startIndex = (tablePage.currentPage - 1) * tablePage.pageSize;
                }

                if (proxyOpts.sort) {
                    tableOns['sort-change'] = this.sortChangeEvent;
                }

                if (proxyOpts.filter) {
                    tableOns['filter-change'] = this.filterChangeEvent;
                }
            }

            if (toolbar) {
                if (toolbar.slots) {
                    $buttons = toolbar.slots.buttons || $buttons;
                    $tools = toolbar.slots.tools || $tools;
                }

                if (!(toolbar.setting && toolbar.setting.storage)) {
                    props.customs = tableCustoms;
                }

                tableOns['update:customs'] = function (value) {
                    _this2.tableCustoms = value;
                };
            }

            if (editConfig) {
                props.editConfig = VueUtil.assign({}, editConfig, {
                    activeMethod: this.handleActiveMethod
                });
            }

            var toolbarScopedSlots = {};

            if ($buttons) {
                toolbarScopedSlots.buttons = $buttons;
            }

            if ($tools) {
                toolbarScopedSlots.tools = $tools;
            }

            return h('div', {
                class: ['vue-xtable-grid', (_ref = {}, tools.UtilTools.defineProperty(_ref, 'size--'.concat(vSize), vSize), tools.UtilTools.defineProperty(_ref, 't--animat', props.optimization.animat), _ref)]
            }, [toolbar ? h('vue-toolbar', {
                ref: 'toolbar',
                props: VueUtil.assign({
                    loading: loading || tableLoading
                }, toolbar),
                scopedSlots: toolbarScopedSlots
            }) : null, h('vue-xtable', {
                props: props,
                on: tableOns,
                scopedSlots: $scopedSlots,
                ref: 'xTable'
            }, $slots.default), pagerConfig ? h('vue-xtable-pager', {
                props: VueUtil.assign({
                    size: vSize,
                    loading: loading || tableLoading
                }, pagerConfig, proxyConfig ? tablePage : {}),
                on: {
                    'page-change': this.pageChangeEvent
                },
                ref: 'pager'
            }) : null]);
        },
        methods: _objectSpread({}, methods, {
            getParentHeight: function getParentHeight() {
                return this.$el.parentNode.clientHeight - this.getExcludeHeight();
            },

            /**
             * 获取需要排除的高度
             */
            getExcludeHeight: function getExcludeHeight() {
                var _this$$refs = this.$refs,
                    toolbar = _this$$refs.toolbar,
                    pager = _this$$refs.pager;
                return (toolbar && toolbar.$el ? toolbar.$el.offsetHeight : 0) + (pager && pager.$el ? pager.$el.offsetHeight : 0);
            },
            handleRowClassName: function handleRowClassName(params) {
                var rowClassName = this.rowClassName;
                var clss = [];

                if (this.pendingRecords.some(function (item) {
                    return item === params.row;
                })) {
                    clss.push('row--pending');
                }

                return clss.concat(rowClassName ? rowClassName(params) : []);
            },
            handleActiveMethod: function handleActiveMethod(params) {
                var activeMethod = this.editConfig.activeMethod;
                return this.pendingRecords.indexOf(params.row) === -1 && (!activeMethod || activeMethod(params));
            },

            /**
             * 提交指令，支持 code 或 button
             * @param {String/Object} code 字符串或对象
             */
            commitProxy: function commitProxy(code) {
                var _this3 = this;

                var toolbar = this.toolbar,
                    proxyOpts = this.proxyOpts,
                    tablePage = this.tablePage,
                    pagerConfig = this.pagerConfig,
                    sortData = this.sortData,
                    filterData = this.filterData,
                    isMsg = this.isMsg;
                var _proxyOpts$ajax = proxyOpts.ajax,
                    ajax = _proxyOpts$ajax === void 0 ? {} : _proxyOpts$ajax,
                    _proxyOpts$props = proxyOpts.props,
                    props = _proxyOpts$props === void 0 ? {} : _proxyOpts$props;
                var args = VueUtil.slice(arguments, 1);
                var button;

                if (VueUtil.isString(code)) {
                    var matchObj = toolbar ? VueUtil.findTree(toolbar.buttons, function (item) {
                        return item.code === code;
                    }, {
                        children: 'dropdowns'
                    }) : null;
                    button = matchObj ? matchObj.item : null;
                } else {
                    button = code;
                    code = button.code;
                }

                var btnParams = button ? button.params : null;

                switch (code) {
                    case 'insert':
                        this.insert();
                        break;

                    case 'insert_actived':
                        this.insert().then(function (_ref2) {
                            var row = _ref2.row;
                            return _this3.setActiveRow(row);
                        });
                        break;

                    case 'mark_cancel':
                        this.triggerPendingEvent(code);
                        break;

                    case 'delete_selection':
                        this.handleDeleteRow(code, 'vue.xtable.grid.deleteSelectRecord', function () {
                            return _this3.commitProxy.apply(_this3, ['delete'].concat(args));
                        });
                        break;

                    case 'remove_selection':
                        this.handleDeleteRow(code, 'vue.xtable.grid.removeSelectRecord', function () {
                            return _this3.removeSelecteds();
                        });
                        break;

                    case 'import':
                        this.importData(btnParams);
                        break;

                    case 'open_import':
                        this.openImport(btnParams);
                        break;

                    case 'export':
                        this.exportData(btnParams);
                        break;

                    case 'open_export':
                        this.openExport(btnParams);
                        break;

                    case 'reset_custom':
                        this.resetAll();
                        break;

                    case 'reload':
                    case 'query':
                        {
                            if (ajax.query) {
                                var params = {
                                    $grid: this,
                                    sort: sortData,
                                    filters: filterData
                                };
                                this.tableLoading = true;

                                if (pagerConfig) {
                                    params.page = tablePage;
                                }

                                if (code === 'reload') {
                                    if (pagerConfig) {
                                        tablePage.currentPage = 1;
                                    }

                                    this.sortData = params.sort = {};
                                    this.filterData = params.filters = [];
                                    this.pendingRecords = [];
                                    this.clearAll();
                                }

                                return ajax.query.apply(this, [params].concat(args)).then(function (rest) {
                                    if (rest) {
                                        if (pagerConfig) {
                                            tablePage.total = VueUtil.get(rest, props.total || 'page.total') || 0;
                                            _this3.tableData = VueUtil.get(rest, props.result || props.data || 'result') || [];
                                        } else {
                                            _this3.tableData = (props.list ? VueUtil.get(rest, props.list) : rest) || [];
                                        }
                                    } else {
                                        _this3.tableData = [];
                                    }

                                    _this3.tableLoading = false;
                                }).catch(function (e) {
                                    _this3.tableLoading = false;
                                });
                            } else {
                                tools.UtilTools.error('vue.xtable.error.notFunc', [code]);
                            }

                            break;
                        }

                    case 'delete':
                        {
                            if (ajax.delete) {
                                var selectRecords = this.getSelectRecords();
                                this.remove(selectRecords).then(function () {
                                    var removeRecords = _this3.getRemoveRecords();

                                    var body = {
                                        removeRecords: removeRecords
                                    };

                                    if (removeRecords.length) {
                                        _this3.tableLoading = true;
                                        return ajax.delete.apply(_this3, [{
                                            $grid: _this3,
                                            body: body
                                        }].concat(args)).then(function (result) {
                                            _this3.tableLoading = false;
                                        }).catch(function (e) {
                                            _this3.tableLoading = false;
                                        }).then(function () {
                                            return _this3.commitProxy('reload');
                                        });
                                    } else {
                                        if (isMsg && !selectRecords.length) {
                                            _this3.$notify.warning({
                                                message: GlobalConfig.i18n('vue.xtable.grid.selectOneRecord'),
                                            });
                                        }
                                    }
                                });
                            } else {
                                tools.UtilTools.error('vue.xtable.error.notFunc', [code]);
                            }

                            break;
                        }

                    case 'save':
                        {
                            if (ajax.save) {
                                var body = VueUtil.assign({
                                    pendingRecords: this.pendingRecords
                                }, this.getRecordset());
                                var insertRecords = body.insertRecords,
                                    removeRecords = body.removeRecords,
                                    updateRecords = body.updateRecords,
                                    pendingRecords = body.pendingRecords; // 排除掉新增且标记为删除的数据

                                if (insertRecords.length) {
                                    body.pendingRecords = pendingRecords.filter(function (row) {
                                        return insertRecords.indexOf(row) === -1;
                                    });
                                } // 排除已标记为删除的数据


                                if (pendingRecords.length) {
                                    body.insertRecords = insertRecords.filter(function (row) {
                                        return pendingRecords.indexOf(row) === -1;
                                    });
                                } // 只校验新增和修改的数据


                                return new Promise(function (resolve) {
                                    _this3.validate(body.insertRecords.concat(updateRecords), function (vaild) {
                                        if (vaild) {
                                            if (body.insertRecords.length || removeRecords.length || updateRecords.length || body.pendingRecords.length) {
                                                _this3.tableLoading = true;
                                                resolve(ajax.save.apply(_this3, [{
                                                    $grid: _this3,
                                                    body: body
                                                }].concat(args)).then(function () {
                                                    _this3.$notify.success({
                                                        message: GlobalConfig.i18n('vue.xtable.grid.saveSuccess'),
                                                    });

                                                    _this3.tableLoading = false;
                                                }).catch(function (e) {
                                                    _this3.tableLoading = false;
                                                }).then(function () {
                                                    return _this3.commitProxy('reload');
                                                }));
                                            } else {
                                                if (isMsg) {
                                                    // 直接移除未保存且标记为删除的数据
                                                    if (pendingRecords.length) {
                                                        _this3.remove(pendingRecords);
                                                    } else {
                                                        _this3.$notify.info({
                                                            message: GlobalConfig.i18n('vue.xtable.grid.dataUnchanged'),
                                                        });
                                                    }
                                                }

                                                resolve();
                                            }
                                        } else {
                                            resolve(vaild);
                                        }
                                    });
                                });
                            } else {
                                tools.UtilTools.error('vue.xtable.error.notFunc', [code]);
                            }

                            break;
                        }

                    default:
                        var btnMethod = baseTable.Buttons.get(code);

                        if (btnMethod) {
                            btnMethod.apply(this, [{
                                code: code,
                                button: button,
                                $grid: this,
                                $table: this.$refs.xTable
                            }].concat(args));
                        }

                }

                return this.$nextTick();
            },
            handleDeleteRow: function handleDeleteRow(code, alertKey, callback) {
                var selectRecords = this.getSelectRecords();

                if (this.isMsg) {
                    if (selectRecords.length) {
                        this.$confirm({
                            message: GlobalConfig.i18n(alertKey),
                        }).then(function (type) {
                            if (type === 'confirm') {
                                callback();
                            }
                        });
                    } else {
                        this.$notify.warning({
                            message: GlobalConfig.i18n('vue.xtable.grid.selectOneRecord'),
                        });
                    }
                } else {
                    if (selectRecords.length) {
                        callback();
                    }
                }
            },
            getPendingRecords: function getPendingRecords() {
                return this.pendingRecords;
            },
            triggerToolbarBtnEvent: function triggerToolbarBtnEvent(button, evnt) {
                this.commitProxy(button, evnt);

                tools.UtilTools.emitEvent(this, 'toolbar-button-click', [{
                    code: button.code,
                    button: button,
                    $grid: this
                }, evnt]);
            },
            triggerPendingEvent: function triggerPendingEvent(code) {
                var pendingRecords = this.pendingRecords,
                    isMsg = this.isMsg;
                var selectRecords = this.getSelectRecords();

                if (selectRecords.length) {
                    var plus = [];
                    var minus = [];
                    selectRecords.forEach(function (data) {
                        if (pendingRecords.some(function (item) {
                            return data === item;
                        })) {
                            minus.push(data);
                        } else {
                            plus.push(data);
                        }
                    });

                    if (minus.length) {
                        this.pendingRecords = pendingRecords.filter(function (item) {
                            return minus.indexOf(item) === -1;
                        }).concat(plus);
                    } else if (plus.length) {
                        this.pendingRecords = pendingRecords.concat(plus);
                    }

                    this.clearSelection();
                } else {
                    if (isMsg) {
                        this.$notify.warning({
                            message: GlobalConfig.i18n('vue.xtable.grid.selectOneRecord'),
                        });
                    }
                }
            },
            pageChangeEvent: function pageChangeEvent(params) {
                var proxyConfig = this.proxyConfig,
                    tablePage = this.tablePage;
                var currentPage = params.currentPage,
                    pageSize = params.pageSize;
                tablePage.currentPage = currentPage;
                tablePage.pageSize = pageSize;

                if (params.type === 'current-change') {
                    tools.UtilTools.emitEvent(this, 'current-page-change', [currentPage]);
                } else {
                    tools.UtilTools.emitEvent(this, 'page-size-change', [pageSize]);
                }

                tools.UtilTools.emitEvent(this, 'page-change', [VueUtil.assign({
                    $grid: this
                }, params)]);

                if (proxyConfig) {
                    this.commitProxy('query');
                }
            },
            sortChangeEvent: function sortChangeEvent(params) {
                var proxyConfig = this.proxyConfig,
                    remoteSort = this.remoteSort;
                var column = params.column;
                var isRemote = VueUtil.isBoolean(column.remoteSort) ? column.remoteSort : remoteSort; // 如果是服务端排序

                if (isRemote) {
                    this.sortData = params;

                    if (proxyConfig) {
                        this.commitProxy('query');
                    }
                }

                tools.UtilTools.emitEvent(this, 'sort-change', [VueUtil.assign({
                    $grid: this
                }, params)]);
            },
            filterChangeEvent: function filterChangeEvent(params) {
                var remoteFilter = this.remoteFilter;
                var filters = params.filters; // 如果是服务端过滤

                if (remoteFilter) {
                    this.filterData = filters;
                    this.commitProxy('query');
                }

                tools.UtilTools.emitEvent(this, 'filter-change', [VueUtil.assign({
                    $grid: this
                }, params)]);
            }
        })
    };

    return VueXgrid;
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    definition(context);
  }
})(this, function(context) {
  var baseTable = context.baseTable;
  // 暴露配置用变量到vueutil
  VueUtil.config.baseTable = baseTable;
  VueUtil.config.xtable = GlobalConfig;

  Vue.component(context.VueXtableColumn.name, context.VueXtableColumn);

  Vue.component(context.VueXtableHeader.name, context.VueXtableHeader);

  Vue.component(context.VueXtableBody.name, context.VueXtableBody);

  Vue.component(context.VueXtableFooter.name, context.VueXtableFooter);

  context.baseTable.reg('filter');
  context.VueXtable.mixins.push(context.VueXtableFilterMixin);
  Vue.component(context.VueXtableFilter.name, context.VueXtableFilter);

  Vue.component(context.VueXtableLoading.name, context.VueXtableLoading);

  Vue.component(context.VueXgrid.name, context.VueXgrid);

  context.baseTable.reg('menu');
  context.VueXtable.mixins.push(context.VueXtableContextMenuMixin);
  Vue.component(context.VueXtableContextMenu.name, context.VueXtableContextMenu);

  Vue.component(context.VueXtableToolbar.name, context.VueXtableToolbar);

  Vue.component(context.VueXtablePager.name, context.VueXtablePager);

  context.baseTable._tooltip = 1;
  Vue.component(context.VueXtableTooltip.name, context.VueXtableTooltip);

  context.baseTable.reg('edit');
  context.VueXtable.mixins.push(context.VueXtableEditMixin);

  context.baseTable.reg('export');
  VueUtil.assign(context.baseTable.types, {
    csv: 1,
    html: 1,
    xml: 1,
    txt: 1
  });

  document.addEventListener('DOMContentLoaded', function() {
    if(VueUtil.Excel) {
      VueUtil.assign(baseTable.types, {
        xlsx: 1
      });
    }
  });

  context.VueXtable.mixins.push(context.VueXtableExportMixin);
  Vue.component(context.VueXtableExportPanel.name, context.VueXtableExportPanel);
  Vue.component(context.VueXtableImportPanel.name, context.VueXtableImportPanel);

  
  context.baseTable.reg('keyboard');
  context.VueXtable.mixins.push(context.VueXtableKeyboardMixin);

  context.baseTable.reg('valid');
  context.VueXtable.mixins.push(context.VueXtableValidatorMixin);

  context.baseTable.use(context.VueXtableChart);

  context.baseTable.Vue = context.Vue;
  context.baseTable.Table = context.VueXtable;
  Vue.component(context.VueXtable.name, context.VueXtable);


  var allGlobalVars = 'baseTable,tools,VueXtableColumn,VueXtableHeader,VueXtableBody,VueXtableFooter,VueXtableFilterMixin,VueXtableFilter,VueXtableLoading,'
  +'VueXgrid,VueXtableContextMenuMixin,VueXtableContextMenu,VueXtableToolbar,VueXtablePager,VueXtableTooltip,VueXtableEditMixin,VueXtableExportMixin,'
  +'VueXtableExportPanel,VueXtableImportPanel,VueXtableKeyboardMixin,VueXtableValidatorMixin,VueXtableChart,VueXtable';

  allGlobalVars.split(',').forEach(function(name) {
    context[name] && delete context[name];
  });
});