(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(definition);
  } else {
    context.SystemInfo = definition();
  }
})(this, function() {
  'use strict';
  var win = window || {};
  var nav = navigator || {};
  var ua = nav.userAgent;
  var self = {};
  var match = {
    'Trident': ua.indexOf('Trident') !== -1 || ua.indexOf('NET CLR') !== -1,
    'Presto': ua.indexOf('Presto') !== -1,
    'WebKit': ua.indexOf('AppleWebKit') !== -1,
    'Gecko': ua.indexOf('Gecko/') !== -1,
    'Safari': ua.indexOf('Safari') !== -1 || ua.indexOf('iPhone') !== -1,
    'Chrome': ua.indexOf('Chrome') !== -1 || ua.indexOf('CriOS') !== -1,
    'IE': ua.indexOf('MSIE') !== -1 || ua.indexOf('Trident') !== -1,
    'Edge': ua.indexOf('Edge') !== -1,
    'Firefox': ua.indexOf('Firefox') !== -1 || ua.indexOf('FxiOS') !== -1,
    'Firefox Focus': ua.indexOf('Focus') !== -1,
    'Chromium': ua.indexOf('Chromium') !== -1,
    'Opera': ua.indexOf('Opera') !== -1 || ua.indexOf('OPR') !== -1,
    'Vivaldi': ua.indexOf('Vivaldi') !== -1,
    'Yandex': ua.indexOf('YaBrowser') !== -1,
    'Kindle': ua.indexOf('Kindle') !== -1 || ua.indexOf('Silk/') !== -1,
    '360': ua.indexOf('360EE') !== -1 || ua.indexOf('360SE') !== -1,
    'UC': ua.indexOf('UC') !== -1 || ua.indexOf(' UBrowser') !== -1,
    'QQBrowser': ua.indexOf('QQBrowser') !== -1,
    'QQ': ua.indexOf('QQ/') !== -1,
    'Baidu': ua.indexOf('Baidu') !== -1 || ua.indexOf('BIDUBrowser') !== -1,
    'Maxthon': ua.indexOf('Maxthon') !== -1,
    'Sogou': ua.indexOf('MetaSr') !== -1 || ua.indexOf('Sogou') !== -1,
    'LBBROWSER': ua.indexOf('LBBROWSER') !== -1,
    '2345Explorer': ua.indexOf('2345Explorer') !== -1,
    'TheWorld': ua.indexOf('TheWorld') !== -1,
    'XiaoMi': ua.indexOf('MiuiBrowser') !== -1,
    'Quark': ua.indexOf('Quark') !== -1,
    'Qiyu': ua.indexOf('Qiyu') !== -1,
    'Wechat': ua.indexOf('MicroMessenger') !== -1,
    'Taobao': ua.indexOf('AliApp(TB') !== -1,
    'Alipay': ua.indexOf('AliApp(AP') !== -1,
    'Weibo': ua.indexOf('Weibo') !== -1,
    'Douban': ua.indexOf('com.douban.frodo') !== -1,
    'Suning': ua.indexOf('SNEBUY-APP') !== -1,
    'iQiYi': ua.indexOf('IqiyiApp') !== -1,
    'Windows': ua.indexOf('Windows') !== -1,
    'Linux': ua.indexOf('Linux') !== -1 || ua.indexOf('X11') !== -1,
    'Mac OS': ua.indexOf('Macintosh') !== -1,
    'Android': ua.indexOf('Android') !== -1 || ua.indexOf('Adr') !== -1,
    'Ubuntu': ua.indexOf('Ubuntu') !== -1,
    'FreeBSD': ua.indexOf('FreeBSD') !== -1,
    'Debian': ua.indexOf('Debian') !== -1,
    'Windows Phone': ua.indexOf('IEMobile') !== -1 || ua.indexOf('Windows Phone') !== -1,
    'BlackBerry': ua.indexOf('BlackBerry') !== -1 || ua.indexOf('RIM') !== -1,
    'MeeGo': ua.indexOf('MeeGo') !== -1,
    'Symbian': ua.indexOf('Symbian') !== -1,
    'iOS': ua.indexOf('like Mac OS X') !== -1,
    'Chrome OS': ua.indexOf('CrOS') !== -1,
    'WebOS': ua.indexOf('hpwOS') !== -1,
    'Mobile': ua.indexOf('Mobi') !== -1 || ua.indexOf('iPh') !== -1 || ua.indexOf('480') !== -1,
    'Tablet': ua.indexOf('Tablet') !== -1 || ua.indexOf('Pad') !== -1 || ua.indexOf('Nexus 7') !== -1
  };
  if (match['Mobile']) {
    match['Mobile'] = !(ua.indexOf('iPad') !== -1);
  } else if (win.showModalDialog && win.chrome) {
    match['360'] = true;
  }
  var hash = {
    engine: ['WebKit', 'Trident', 'Gecko', 'Presto'],
    browser: ['Safari', 'Chrome', 'Edge', 'IE', 'Firefox', 'Firefox Focus', 'Chromium', 'Opera', 'Vivaldi', 'Yandex', 'Kindle', '360', 'UC', 'QQBrowser', 'QQ', 'Baidu', 'Maxthon', 'Sogou', 'LBBROWSER', '2345Explorer', 'TheWorld', 'XiaoMi', 'Quark', 'Qiyu', 'Wechat', 'Taobao', 'Alipay', 'Weibo', 'Douban', 'Suning', 'iQiYi'],
    os: ['Windows', 'Linux', 'Mac OS', 'Android', 'Ubuntu', 'FreeBSD', 'Debian', 'iOS', 'Windows Phone', 'BlackBerry', 'MeeGo', 'Symbian', 'Chrome OS', 'WebOS'],
    device: ['Mobile', 'Tablet']
  };
  self.device = 'PC';
  self.language = (function() {
    var g = (nav.browserLanguage || nav.language);
    var arr = g.split('-');
    if (arr[1]) {
      arr[1] = arr[1].toUpperCase();
    }
    return arr.join('_');
  })();
  for (var s in hash) {
    for (var i = 0; i < hash[s].length; i++) {
      var value = hash[s][i];
      if (match[value]) {
        self[s] = value;
      }
    }
  }
  var osVersion = {
    'Windows': function() {
      var v = ua.replace(/^.*Windows NT ([\d.]+);.*$/, '$1');
      var hash = {
        '6.4': '10',
        '6.3': '8.1',
        '6.2': '8',
        '6.1': '7',
        '6.0': 'Vista',
        '5.2': 'XP',
        '5.1': 'XP',
        '5.0': '2000'
      };
      return hash[v] || v;
    },
    'Android': function() {
      return ua.replace(/^.*Android ([\d.]+);.*$/, '$1');
    },
    'iOS': function() {
      return ua.replace(/^.*OS ([\d_]+) like.*$/, '$1').replace(/_/g, '.');
    },
    'Debian': function() {
      return ua.replace(/^.*Debian\/([\d.]+).*$/, '$1');
    },
    'Windows Phone': function() {
      return ua.replace(/^.*Windows Phone( OS)? ([\d.]+);.*$/, '$2');
    },
    'Mac OS': function() {
      return ua.replace(/^.*Mac OS X ([\d_]+).*$/, '$1').replace(/_/g, '.');
    },
    'WebOS': function() {
      return ua.replace(/^.*hpwOS\/([\d.]+);.*$/, '$1');
    }
  };
  self.osVersion = '';
  if (osVersion[self.os]) {
    self.osVersion = osVersion[self.os]();
    if (self.osVersion == ua) {
      self.osVersion = '';
    }
  }
  var version = {
    'Safari': function() {
      return ua.replace(/^.*Version\/([\d.]+).*$/, '$1');
    },
    'Chrome': function() {
      return ua.replace(/^.*Chrome\/([\d.]+).*$/, '$1').replace(/^.*CriOS\/([\d.]+).*$/, '$1');
    },
    'IE': function() {
      return ua.replace(/^.*MSIE ([\d.]+).*$/, '$1').replace(/^.*rv:([\d.]+).*$/, '$1');
    },
    'Edge': function() {
      return ua.replace(/^.*Edge\/([\d.]+).*$/, '$1');
    },
    'Firefox': function() {
      return ua.replace(/^.*Firefox\/([\d.]+).*$/, '$1').replace(/^.*FxiOS\/([\d.]+).*$/, '$1');
    },
    'Firefox Focus': function() {
      return ua.replace(/^.*Focus\/([\d.]+).*$/, '$1');
    },
    'Chromium': function() {
      return ua.replace(/^.*Chromium\/([\d.]+).*$/, '$1');
    },
    'Opera': function() {
      return ua.replace(/^.*Opera\/([\d.]+).*$/, '$1').replace(/^.*OPR\/([\d.]+).*$/, '$1');
    },
    'Vivaldi': function() {
      return ua.replace(/^.*Vivaldi\/([\d.]+).*$/, '$1');
    },
    'Yandex': function() {
      return ua.replace(/^.*YaBrowser\/([\d.]+).*$/, '$1');
    },
    'Kindle': function() {
      return ua.replace(/^.*Version\/([\d.]+).*$/, '$1');
    },
    'Maxthon': function() {
      return ua.replace(/^.*Maxthon\/([\d.]+).*$/, '$1');
    },
    'QQBrowser': function() {
      return ua.replace(/^.*QQBrowser\/([\d.]+).*$/, '$1');
    },
    'QQ': function() {
      return ua.replace(/^.*QQ\/([\d.]+).*$/, '$1');
    },
    'Baidu': function() {
      return ua.replace(/^.*BIDUBrowser[\s\/]([\d.]+).*$/, '$1');
    },
    'UC': function() {
      return ua.replace(/^.*UC?Browser\/([\d.]+).*$/, '$1');
    },
    'Sogou': function() {
      return ua.replace(/^.*SE ([\d.X]+).*$/, '$1').replace(/^.*SogouMobileBrowser\/([\d.]+).*$/, '$1');
    },
    '2345Explorer': function() {
      return ua.replace(/^.*2345Explorer\/([\d.]+).*$/, '$1');
    },
    'TheWorld': function() {
      return ua.replace(/^.*TheWorld ([\d.]+).*$/, '$1');
    },
    'XiaoMi': function() {
      return ua.replace(/^.*MiuiBrowser\/([\d.]+).*$/, '$1');
    },
    'Quark': function() {
      return ua.replace(/^.*Quark\/([\d.]+).*$/, '$1');
    },
    'Qiyu': function() {
      return ua.replace(/^.*Qiyu\/([\d.]+).*$/, '$1');
    },
    'Wechat': function() {
      return ua.replace(/^.*MicroMessenger\/([\d.]+).*$/, '$1');
    },
    'Taobao': function() {
      return ua.replace(/^.*AliApp\(TB\/([\d.]+).*$/, '$1');
    },
    'Alipay': function() {
      return ua.replace(/^.*AliApp\(AP\/([\d.]+).*$/, '$1');
    },
    'Weibo': function() {
      return ua.replace(/^.*weibo__([\d.]+).*$/, '$1');
    },
    'Douban': function() {
      return ua.replace(/^.*com.douban.frodo\/([\d.]+).*$/, '$1');
    },
    'Suning': function() {
      return ua.replace(/^.*SNEBUY-APP([\d.]+).*$/, '$1');
    },
    'iQiYi': function() {
      return ua.replace(/^.*IqiyiVersion\/([\d.]+).*$/, '$1');
    }
  };
  self.version = '';
  if (version[self.browser]) {
    self.version = version[self.browser]();
    if (self.version == ua) {
      self.version = '';
    }
  }
  return {
    device: self.device,
    os: self.os,
    osVersion: self.osVersion,
    browser: self.browser,
    version: self.version,
    language: self.language,
  };
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(definition);
  } else {
    context.DateUtil = definition();
  }
})(this, function() {
  'use strict';
  var fecha = {};
  var token = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = /\d\d?/;
  var threeDigits = /\d{3}/;
  var fourDigits = /\d{4}/;
  var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var noop = function() {};
  var shorten = function(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  };
  var monthUpdate = function(arrName) {
    return function(d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
      if (~index) {
        d.month = index;
      }
    };
  };
  var pad = function(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = '0' + val;
    }
    return val;
  };
  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  var formatFlags = {
    D: function(dateObj) {
      return dateObj.getDay();
    },
    DD: function(dateObj) {
      return pad(dateObj.getDay());
    },
    Do: function(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function(dateObj) {
      return dateObj.getDate();
    },
    dd: function(dateObj) {
      return pad(dateObj.getDate());
    },
    ddd: function(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function(dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    yy: function(dateObj) {
      return String(dateObj.getFullYear()).substr(2);
    },
    yyyy: function(dateObj) {
      return dateObj.getFullYear();
    },
    h: function(dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function(dateObj) {
      return dateObj.getHours();
    },
    HH: function(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function(dateObj) {
      return dateObj.getMinutes();
    },
    mm: function(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function(dateObj) {
      return dateObj.getSeconds();
    },
    ss: function(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function(dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function(dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };
  var parseFlags = {
    d: [twoDigits, function(d, v) {
      d.day = v;
    }],
    M: [twoDigits, function(d, v) {
      d.month = v - 1;
    }],
    yy: [twoDigits, function(d, v) {
      var da = new Date()
        , cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function(d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function(d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function(d, v) {
      d.second = v;
    }],
    yyyy: [fourDigits, function(d, v) {
      d.year = v;
    }],
    S: [/\d/, function(d, v) {
      d.millisecond = v * 100;
    }],
    SS: [/\d{2}/, function(d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function(d, v) {
      d.millisecond = v;
    }],
    D: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function(d, v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: [/[\+\-]\d\d:?\d\d/, function(d, v) {
      var parts = (v + '').match(/([\+\-]|\d\d)/gi), minutes;
      if (parts) {
        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.DD = parseFlags.D;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.Do = parseFlags.dd = parseFlags.d;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a;
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };
  fecha.masks = {
    'default': 'ddd MMM dd yyyy HH:mm:ss',
    shortDate: 'M/D/yy',
    mediumDate: 'MMM d, yyyy',
    longDate: 'MMMM d, yyyy',
    fullDate: 'dddd, MMMM d, yyyy',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };
  fecha.format = function(dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;
    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }
    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw 'Invalid Date in fecha.format';
    }
    mask = fecha.masks[mask] || mask || fecha.masks['default'];
    return mask.replace(token, function($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    });
  };
  fecha.parse = function(dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;
    if (typeof format !== 'string') {
      throw 'Invalid format in fecha.parse';
    }
    format = fecha.masks[format] || format;
    if (dateStr.length > 1000) {
      return null;
    }
    var isValid = true;
    var dateInfo = {};
    format.replace(token, function($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        var index = dateStr.search(info[0]);
        if (!~index) {
          isValid = false;
        } else {
          dateStr.replace(info[0], function(result) {
            info[1](dateInfo, result, i18n);
            dateStr = dateStr.substr(index + result.length);
            return result;
          });
        }
      }
      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
    });
    if (!isValid) {
      return null;
    }
    var today = new Date();
    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }
    var date;
    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }
    return date;
  };
  return fecha;
});

/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash category="math" include="pad,padEnd,padStart,parseInt,trim,trimEnd,trimStart,clone,cloneDeep,debounce,throttle,countBy,filter,remove,find,findLast,includes,groupBy,map,reduce,orderBy,sortBy,some,every,compact,concat,difference,differenceBy,differenceWith,dropWhile,findIndex,findLastIndex,indexOf,intersection,intersectionBy,intersectionWith,join,last,head,pull,pullAll,pullAt,remove,reverse,slice,tail,initial,take,takeRight,takeWhile,union,unionBy,unionWith,uniq,uniqBy,uniqWith,without,xor,xorBy,xorWith"`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.5';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsAstral = '[' + rsAstralRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /*--------------------------------------------------------------------------*/

  /** Used for built-in method references. */
  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined,
      Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice,
      spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
      symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  var defineProperty = (function() {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeCeil = Math.ceil,
      nativeFloor = Math.floor,
      nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeJoin = arrayProto.join,
      nativeKeys = overArg(Object.keys, Object),
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeNow = Date.now,
      nativeParseInt = root.parseInt,
      nativeReverse = arrayProto.reverse;

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');

  /** Used to lookup unminified function names. */
  var realNames = {};

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps `value` to enable implicit method
   * chain sequences. Methods that operate on and return arrays, collections,
   * and functions can be chained together. Methods that retrieve a single value
   * or may return a primitive value will automatically end the chain sequence
   * and return the unwrapped value. Otherwise, the value must be unwrapped
   * with `_#value`.
   *
   * Explicit chain sequences, which must be unwrapped with `_#value`, may be
   * enabled using `_.chain`.
   *
   * The execution of chained methods is lazy, that is, it's deferred until
   * `_#value` is implicitly or explicitly called.
   *
   * Lazy evaluation allows several methods to support shortcut fusion.
   * Shortcut fusion is an optimization to merge iteratee calls; this avoids
   * the creation of intermediate arrays and can greatly reduce the number of
   * iteratee executions. Sections of a chain sequence qualify for shortcut
   * fusion if the section is applied to an array and iteratees accept only
   * one argument. The heuristic for whether a section qualifies for shortcut
   * fusion is subject to change.
   *
   * Chaining is supported in custom builds as long as the `_#value` method is
   * directly or indirectly included in the build.
   *
   * In addition to lodash methods, wrappers have `Array` and `String` methods.
   *
   * The wrapper `Array` methods are:
   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
   *
   * The wrapper `String` methods are:
   * `replace` and `split`
   *
   * The wrapper methods that support shortcut fusion are:
   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
   *
   * The chainable wrapper methods are:
   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
   * `zipObject`, `zipObjectDeep`, and `zipWith`
   *
   * The wrapper methods that are **not** chainable by default are:
   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
   * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
   * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
   * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
   * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
   * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
   * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
   * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
   * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
   * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
   * `upperFirst`, `value`, and `words`
   *
   * @name _
   * @constructor
   * @category Seq
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // Returns an unwrapped value.
   * wrapped.reduce(_.add);
   * // => 6
   *
   * // Returns a wrapped value.
   * var squares = wrapped.map(square);
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash() {
    // No operation performed.
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  /*------------------------------------------------------------------------*/

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
  }

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map || ListCache),
      'string': new Hash
    };
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /*------------------------------------------------------------------------*/

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /**
   * Aggregates elements of `collection` on `accumulator` with keys transformed
   * by `iteratee` and values set by `setter`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function baseAggregator(collection, setter, iteratee, accumulator) {
    baseEach(collection, function(value, key, collection) {
      setter(accumulator, value, iteratee(value), collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  /**
   * The base implementation of `_.assignIn` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * The base implementation of `_.at` without support for individual paths.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {string[]} paths The property paths to pick.
   * @returns {Array} Returns the picked elements.
   */
  function baseAt(object, paths) {
    var index = -1,
        length = paths.length,
        result = Array(length),
        skip = object == null;

    while (++index < length) {
      result[index] = skip ? undefined : get(object, paths[index]);
    }
    return result;
  }

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
        result = (isFlat || isFunc) ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat
            ? copySymbolsIn(value, baseAssignIn(result, value))
            : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });

      return result;
    }

    if (isMap(value)) {
      value.forEach(function(subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });

      return result;
    }

    var keysFunc = isFull
      ? (isFlat ? getAllKeysIn : getAllKeys)
      : (isFlat ? keysIn : keys);

    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function(subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  /**
   * The base implementation of methods like `_.difference` without support
   * for excluding multiple arrays or iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Array} values The values to exclude.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   */
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1,
        includes = arrayIncludes,
        isCommon = true,
        length = array.length,
        result = [],
        valuesLength = values.length;

    if (!length) {
      return result;
    }
    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    }
    else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }
    outer:
    while (++index < length) {
      var value = array[index],
          computed = iteratee == null ? value : iteratee(value);

      value = (comparator || value !== 0) ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values[valuesIndex] === computed) {
            continue outer;
          }
        }
        result.push(value);
      }
      else if (!includes(values, computed, comparator)) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = createBaseEach(baseForOwn);

  /**
   * The base implementation of `_.every` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`
   */
  function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function(value, index, collection) {
      result = !!predicate(value, index, collection);
      return result;
    });
    return result;
  }

  /**
   * The base implementation of methods like `_.max` and `_.min` which accepts a
   * `comparator` to determine the extremum value.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The iteratee invoked per iteration.
   * @param {Function} comparator The comparator used to compare values.
   * @returns {*} Returns the extremum value.
   */
  function baseExtremum(array, iteratee, comparator) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      var value = array[index],
          current = iteratee(value);

      if (current != null && (computed === undefined
            ? (current === current && !isSymbol(current))
            : comparator(current, computed)
          )) {
        var computed = current,
            result = value;
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.filter` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value, index, collection) {
      if (predicate(value, index, collection)) {
        result.push(value);
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;

    predicate || (predicate = isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * The base implementation of `_.gt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   */
  function baseGt(value, other) {
    return value > other;
  }

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  /**
   * The base implementation of methods like `_.intersection`, without support
   * for iteratee shorthands, that accepts an array of arrays to inspect.
   *
   * @private
   * @param {Array} arrays The arrays to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of shared values.
   */
  function baseIntersection(arrays, iteratee, comparator) {
    var includes = comparator ? arrayIncludesWith : arrayIncludes,
        length = arrays[0].length,
        othLength = arrays.length,
        othIndex = othLength,
        caches = Array(othLength),
        maxLength = Infinity,
        result = [];

    while (othIndex--) {
      var array = arrays[othIndex];
      if (othIndex && iteratee) {
        array = arrayMap(array, baseUnary(iteratee));
      }
      maxLength = nativeMin(array.length, maxLength);
      caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
        ? new SetCache(othIndex && array)
        : undefined;
    }
    array = arrays[0];

    var index = -1,
        seen = caches[0];

    outer:
    while (++index < length && result.length < maxLength) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;

      value = (comparator || value !== 0) ? value : 0;
      if (!(seen
            ? cacheHas(seen, computed)
            : includes(result, computed, comparator)
          )) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache
                ? cacheHas(cache, computed)
                : includes(arrays[othIndex], computed, comparator))
              ) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : getTag(object),
        othTag = othIsArr ? arrayTag : getTag(other);

    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;

    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack);
      return (objIsArr || isTypedArray(object))
        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)
          ) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined
              ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
              : result
            )) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == 'object') {
      return isArray(value)
        ? baseMatchesProperty(value[0], value[1])
        : baseMatches(value);
    }
    return property(value);
  }

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.lt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   */
  function baseLt(value, other) {
    return value < other;
  }

  /**
   * The base implementation of `_.map` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike(collection) ? Array(collection.length) : [];

    baseEach(collection, function(value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return (objValue === undefined && objValue === srcValue)
        ? hasIn(object, path)
        : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }

  /**
   * The base implementation of `_.orderBy` without param guards.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
   * @param {string[]} orders The sort orders of `iteratees`.
   * @returns {Array} Returns the new sorted array.
   */
  function baseOrderBy(collection, iteratees, orders) {
    var index = -1;
    iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

    var result = baseMap(collection, function(value, key, collection) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { 'criteria': criteria, 'index': ++index, 'value': value };
    });

    return baseSortBy(result, function(object, other) {
      return compareMultiple(object, other, orders);
    });
  }

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }

  /**
   * The base implementation of `_.pullAllBy` without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to remove.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns `array`.
   */
  function basePullAll(array, values, iteratee, comparator) {
    var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
        index = -1,
        length = values.length,
        seen = array;

    if (array === values) {
      values = copyArray(values);
    }
    if (iteratee) {
      seen = arrayMap(array, baseUnary(iteratee));
    }
    while (++index < length) {
      var fromIndex = 0,
          value = values[index],
          computed = iteratee ? iteratee(value) : value;

      while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
        if (seen !== array) {
          splice.call(seen, fromIndex, 1);
        }
        splice.call(array, fromIndex, 1);
      }
    }
    return array;
  }

  /**
   * The base implementation of `_.pullAt` without support for individual
   * indexes or capturing the removed elements.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {number[]} indexes The indexes of elements to remove.
   * @returns {Array} Returns `array`.
   */
  function basePullAt(array, indexes) {
    var length = array ? indexes.length : 0,
        lastIndex = length - 1;

    while (length--) {
      var index = indexes[length];
      if (length == lastIndex || index !== previous) {
        var previous = index;
        if (isIndex(index)) {
          splice.call(array, index, 1);
        } else {
          baseUnset(array, index);
        }
      }
    }
    return array;
  }

  /**
   * The base implementation of `_.repeat` which doesn't coerce arguments.
   *
   * @private
   * @param {string} string The string to repeat.
   * @param {number} n The number of times to repeat the string.
   * @returns {string} Returns the repeated string.
   */
  function baseRepeat(string, n) {
    var result = '';
    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
      return result;
    }
    // Leverage the exponentiation by squaring algorithm for a faster repeat.
    // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
    do {
      if (n % 2) {
        result += string;
      }
      n = nativeFloor(n / 2);
      if (n) {
        string += string;
      }
    } while (n);

    return result;
  }

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + '');
  }

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * The base implementation of `_.some` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function baseSome(collection, predicate) {
    var result;

    baseEach(collection, function(value, index, collection) {
      result = predicate(value, index, collection);
      return !result;
    });
    return !!result;
  }

  /**
   * The base implementation of `_.toNumber` which doesn't ensure correct
   * conversions of binary, hexadecimal, or octal string values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   */
  function baseToNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    return +value;
  }

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  /**
   * The base implementation of `_.uniqBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   */
  function baseUniq(array, iteratee, comparator) {
    var index = -1,
        includes = arrayIncludes,
        length = array.length,
        isCommon = true,
        result = [],
        seen = result;

    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    }
    else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache;
    }
    else {
      seen = iteratee ? [] : result;
    }
    outer:
    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;

      value = (comparator || value !== 0) ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      }
      else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.unset`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The property path to unset.
   * @returns {boolean} Returns `true` if the property is deleted, else `false`.
   */
  function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent(object, path);
    return object == null || delete object[toKey(last(path))];
  }

  /**
   * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
   * without support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to query.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseWhile(array, predicate, isDrop, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length) &&
      predicate(array[index], index, array)) {}

    return isDrop
      ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
      : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
  }

  /**
   * The base implementation of methods like `_.xor`, without support for
   * iteratee shorthands, that accepts an array of arrays to inspect.
   *
   * @private
   * @param {Array} arrays The arrays to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of values.
   */
  function baseXor(arrays, iteratee, comparator) {
    var length = arrays.length;
    if (length < 2) {
      return length ? baseUniq(arrays[0]) : [];
    }
    var index = -1,
        result = Array(length);

    while (++index < length) {
      var array = arrays[index],
          othIndex = -1;

      while (++othIndex < length) {
        if (othIndex != index) {
          result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
        }
      }
    }
    return baseUniq(baseFlatten(result, 1), iteratee, comparator);
  }

  /**
   * Casts `value` to an empty array if it's not an array like object.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Array|Object} Returns the cast array-like object.
   */
  function castArrayLikeObject(value) {
    return isArrayLikeObject(value) ? value : [];
  }

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return (!start && end >= length) ? array : baseSlice(array, start, end);
  }

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Compares values to sort them in ascending order.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined,
          valIsNull = value === null,
          valIsReflexive = value === value,
          valIsSymbol = isSymbol(value);

      var othIsDefined = other !== undefined,
          othIsNull = other === null,
          othIsReflexive = other === other,
          othIsSymbol = isSymbol(other);

      if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
          (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
          (valIsNull && othIsDefined && othIsReflexive) ||
          (!valIsDefined && othIsReflexive) ||
          !valIsReflexive) {
        return 1;
      }
      if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
          (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
          (othIsNull && valIsDefined && valIsReflexive) ||
          (!othIsDefined && valIsReflexive) ||
          !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * Used by `_.orderBy` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
   * specify an order of "desc" for descending or "asc" for ascending sort order
   * of corresponding values.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]|string[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = compareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * (order == 'desc' ? -1 : 1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * Copies own symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  /**
   * Copies own and inherited symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }

  /**
   * Creates a function like `_.groupBy`.
   *
   * @private
   * @param {Function} setter The function to set accumulator values.
   * @param {Function} [initializer] The accumulator object initializer.
   * @returns {Function} Returns the new aggregator function.
   */
  function createAggregator(setter, initializer) {
    return function(collection, iteratee) {
      var func = isArray(collection) ? arrayAggregator : baseAggregator,
          accumulator = initializer ? initializer() : {};

      return func(collection, setter, getIteratee(iteratee, 2), accumulator);
    };
  }

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * Creates a `_.find` or `_.findLast` function.
   *
   * @private
   * @param {Function} findIndexFunc The function to find the collection index.
   * @returns {Function} Returns the new find function.
   */
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = getIteratee(predicate, 3);
        collection = keys(collection);
        predicate = function(key) { return iteratee(iterable[key], key, iterable); };
      }
      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
    };
  }

  /**
   * Creates a function that performs a mathematical operation on two values.
   *
   * @private
   * @param {Function} operator The function to perform the operation.
   * @param {number} [defaultValue] The value used for `undefined` arguments.
   * @returns {Function} Returns the new mathematical operation function.
   */
  function createMathOperation(operator, defaultValue) {
    return function(value, other) {
      var result;
      if (value === undefined && other === undefined) {
        return defaultValue;
      }
      if (value !== undefined) {
        result = value;
      }
      if (other !== undefined) {
        if (result === undefined) {
          return other;
        }
        if (typeof value == 'string' || typeof other == 'string') {
          value = baseToString(value);
          other = baseToString(other);
        } else {
          value = baseToNumber(value);
          other = baseToNumber(other);
        }
        result = operator(value, other);
      }
      return result;
    };
  }

  /**
   * Creates the padding for `string` based on `length`. The `chars` string
   * is truncated if the number of characters exceeds `length`.
   *
   * @private
   * @param {number} length The padding length.
   * @param {string} [chars=' '] The string used as padding.
   * @returns {string} Returns the padding for `string`.
   */
  function createPadding(length, chars) {
    chars = chars === undefined ? ' ' : baseToString(chars);

    var charsLength = chars.length;
    if (charsLength < 2) {
      return charsLength ? baseRepeat(chars, length) : chars;
    }
    var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
    return hasUnicode(chars)
      ? castSlice(stringToArray(result), 0, length).join('')
      : result.slice(0, length);
  }

  /**
   * Creates a function like `_.round`.
   *
   * @private
   * @param {string} methodName The name of the `Math` method to use when rounding.
   * @returns {Function} Returns the new round function.
   */
  function createRound(methodName) {
    var func = Math[methodName];
    return function(number, precision) {
      number = toNumber(number);
      precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
      if (precision) {
        // Shift with exponential notation to avoid floating-point issues.
        // See [MDN](https://mdn.io/round#Examples) for more details.
        var pair = (toString(number) + 'e').split('e'),
            value = func(pair[0] + 'e' + (+pair[1] + precision));

        pair = (toString(value) + 'e').split('e');
        return +(pair[0] + 'e' + (+pair[1] - precision));
      }
      return func(number);
    };
  }

  /**
   * Creates a set object of `values`.
   *
   * @private
   * @param {Array} values The values to add to the set.
   * @returns {Object} Returns the new set.
   */
  var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
    return new Set(values);
  };

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!arraySome(other, function(othValue, othIndex) {
              if (!cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  /**
   * A specialized version of `baseRest` which flattens the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @returns {Function} Returns the new function.
   */
  function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + '');
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }

  /**
   * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
   * this function returns the custom method, otherwise it returns `baseIteratee`.
   * If arguments are provided, the chosen function is invoked with them and
   * its result is returned.
   *
   * @private
   * @param {*} [value] The value to convert to an iteratee.
   * @param {number} [arity] The arity of the created iteratee.
   * @returns {Function} Returns the chosen function or its result.
   */
  function getIteratee() {
    var result = lodash.iteratee || iteratee;
    result = result === iteratee ? baseIteratee : result;
    return arguments.length ? result(arguments[0], arguments[1]) : result;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];

      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
      (Map && getTag(new Map) != mapTag) ||
      (Promise && getTag(Promise.resolve()) != promiseTag) ||
      (Set && getTag(new Set) != setTag) ||
      (WeakMap && getTag(new WeakMap) != weakMapTag)) {
    getTag = function(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag;
          case mapCtorString: return mapTag;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag;
          case weakMapCtorString: return weakMapTag;
        }
      }
      return result;
    };
  }

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) &&
      (isArray(object) || isArguments(object));
  }

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate(getPrototype(object))
      : {};
  }

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag: case float64Tag:
      case int8Tag: case int16Tag: case int32Tag:
      case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return new Ctor;

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return new Ctor;

      case symbolTag:
        return cloneSymbol(object);
    }
  }

  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) ||
      !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq(object[index], value);
    }
    return false;
  }

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

    return value === proto;
  }

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue &&
        (srcValue !== undefined || (key in Object(object)));
    };
  }

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }

  /**
   * Gets the parent value at `path` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} path The path to get the parent value of.
   * @returns {*} Returns the parent value.
   */
  function parent(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  }

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = shortOut(baseSetToString);

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates an array with all falsey values removed. The values `false`, `null`,
   * `0`, `""`, `undefined`, and `NaN` are falsey.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to compact.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.compact([0, 1, false, 2, '', 3]);
   * // => [1, 2, 3]
   */
  function compact(array) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * Creates a new array concatenating `array` with any additional arrays
   * and/or values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to concatenate.
   * @param {...*} [values] The values to concatenate.
   * @returns {Array} Returns the new concatenated array.
   * @example
   *
   * var array = [1];
   * var other = _.concat(array, 2, [3], [[4]]);
   *
   * console.log(other);
   * // => [1, 2, 3, [4]]
   *
   * console.log(array);
   * // => [1]
   */
  function concat() {
    var length = arguments.length;
    if (!length) {
      return [];
    }
    var args = Array(length - 1),
        array = arguments[0],
        index = length;

    while (index--) {
      args[index - 1] = arguments[index];
    }
    return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
  }

  /**
   * Creates an array of `array` values not included in the other given arrays
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. The order and references of result values are
   * determined by the first array.
   *
   * **Note:** Unlike `_.pullAll`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...Array} [values] The values to exclude.
   * @returns {Array} Returns the new array of filtered values.
   * @see _.without, _.xor
   * @example
   *
   * _.difference([2, 1], [2, 3]);
   * // => [1]
   */
  var difference = baseRest(function(array, values) {
    return isArrayLikeObject(array)
      ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
      : [];
  });

  /**
   * This method is like `_.difference` except that it accepts `iteratee` which
   * is invoked for each element of `array` and `values` to generate the criterion
   * by which they're compared. The order and references of result values are
   * determined by the first array. The iteratee is invoked with one argument:
   * (value).
   *
   * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...Array} [values] The values to exclude.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
   * // => [1.2]
   *
   * // The `_.property` iteratee shorthand.
   * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
   * // => [{ 'x': 2 }]
   */
  var differenceBy = baseRest(function(array, values) {
    var iteratee = last(values);
    if (isArrayLikeObject(iteratee)) {
      iteratee = undefined;
    }
    return isArrayLikeObject(array)
      ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
      : [];
  });

  /**
   * This method is like `_.difference` except that it accepts `comparator`
   * which is invoked to compare elements of `array` to `values`. The order and
   * references of result values are determined by the first array. The comparator
   * is invoked with two arguments: (arrVal, othVal).
   *
   * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...Array} [values] The values to exclude.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
   *
   * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
   * // => [{ 'x': 2, 'y': 1 }]
   */
  var differenceWith = baseRest(function(array, values) {
    var comparator = last(values);
    if (isArrayLikeObject(comparator)) {
      comparator = undefined;
    }
    return isArrayLikeObject(array)
      ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
      : [];
  });

  /**
   * Creates a slice of `array` excluding elements dropped from the beginning.
   * Elements are dropped until `predicate` returns falsey. The predicate is
   * invoked with three arguments: (value, index, array).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to query.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.dropWhile(users, function(o) { return !o.active; });
   * // => objects for ['pebbles']
   *
   * // The `_.matches` iteratee shorthand.
   * _.dropWhile(users, { 'user': 'barney', 'active': false });
   * // => objects for ['fred', 'pebbles']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.dropWhile(users, ['active', false]);
   * // => objects for ['pebbles']
   *
   * // The `_.property` iteratee shorthand.
   * _.dropWhile(users, 'active');
   * // => objects for ['barney', 'fred', 'pebbles']
   */
  function dropWhile(array, predicate) {
    return (array && array.length)
      ? baseWhile(array, getIteratee(predicate, 3), true)
      : [];
  }

  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseFindIndex(array, getIteratee(predicate, 3), index);
  }

  /**
   * This method is like `_.findIndex` except that it iterates over elements
   * of `collection` from right to left.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=array.length-1] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': true },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': false }
   * ];
   *
   * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
   * // => 2
   *
   * // The `_.matches` iteratee shorthand.
   * _.findLastIndex(users, { 'user': 'barney', 'active': true });
   * // => 0
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findLastIndex(users, ['active', false]);
   * // => 2
   *
   * // The `_.property` iteratee shorthand.
   * _.findLastIndex(users, 'active');
   * // => 0
   */
  function findLastIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = length - 1;
    if (fromIndex !== undefined) {
      index = toInteger(fromIndex);
      index = fromIndex < 0
        ? nativeMax(length + index, 0)
        : nativeMin(index, length - 1);
    }
    return baseFindIndex(array, getIteratee(predicate, 3), index, true);
  }

  /**
   * Flattens `array` a single level deep.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flatten([1, [2, [3, [4]], 5]]);
   * // => [1, 2, [3, [4]], 5]
   */
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }

  /**
   * Gets the first element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias first
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the first element of `array`.
   * @example
   *
   * _.head([1, 2, 3]);
   * // => 1
   *
   * _.head([]);
   * // => undefined
   */
  function head(array) {
    return (array && array.length) ? array[0] : undefined;
  }

  /**
   * Gets the index at which the first occurrence of `value` is found in `array`
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. If `fromIndex` is negative, it's used as the
   * offset from the end of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   * @example
   *
   * _.indexOf([1, 2, 1, 2], 2);
   * // => 1
   *
   * // Search from the `fromIndex`.
   * _.indexOf([1, 2, 1, 2], 2, 2);
   * // => 3
   */
  function indexOf(array, value, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseIndexOf(array, value, index);
  }

  /**
   * Gets all but the last element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * _.initial([1, 2, 3]);
   * // => [1, 2]
   */
  function initial(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseSlice(array, 0, -1) : [];
  }

  /**
   * Creates an array of unique values that are included in all given arrays
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. The order and references of result values are
   * determined by the first array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of intersecting values.
   * @example
   *
   * _.intersection([2, 1], [2, 3]);
   * // => [2]
   */
  var intersection = baseRest(function(arrays) {
    var mapped = arrayMap(arrays, castArrayLikeObject);
    return (mapped.length && mapped[0] === arrays[0])
      ? baseIntersection(mapped)
      : [];
  });

  /**
   * This method is like `_.intersection` except that it accepts `iteratee`
   * which is invoked for each element of each `arrays` to generate the criterion
   * by which they're compared. The order and references of result values are
   * determined by the first array. The iteratee is invoked with one argument:
   * (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {Array} Returns the new array of intersecting values.
   * @example
   *
   * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
   * // => [2.1]
   *
   * // The `_.property` iteratee shorthand.
   * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 1 }]
   */
  var intersectionBy = baseRest(function(arrays) {
    var iteratee = last(arrays),
        mapped = arrayMap(arrays, castArrayLikeObject);

    if (iteratee === last(mapped)) {
      iteratee = undefined;
    } else {
      mapped.pop();
    }
    return (mapped.length && mapped[0] === arrays[0])
      ? baseIntersection(mapped, getIteratee(iteratee, 2))
      : [];
  });

  /**
   * This method is like `_.intersection` except that it accepts `comparator`
   * which is invoked to compare elements of `arrays`. The order and references
   * of result values are determined by the first array. The comparator is
   * invoked with two arguments: (arrVal, othVal).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of intersecting values.
   * @example
   *
   * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
   * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
   *
   * _.intersectionWith(objects, others, _.isEqual);
   * // => [{ 'x': 1, 'y': 2 }]
   */
  var intersectionWith = baseRest(function(arrays) {
    var comparator = last(arrays),
        mapped = arrayMap(arrays, castArrayLikeObject);

    comparator = typeof comparator == 'function' ? comparator : undefined;
    if (comparator) {
      mapped.pop();
    }
    return (mapped.length && mapped[0] === arrays[0])
      ? baseIntersection(mapped, undefined, comparator)
      : [];
  });

  /**
   * Converts all elements in `array` into a string separated by `separator`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to convert.
   * @param {string} [separator=','] The element separator.
   * @returns {string} Returns the joined string.
   * @example
   *
   * _.join(['a', 'b', 'c'], '~');
   * // => 'a~b~c'
   */
  function join(array, separator) {
    return array == null ? '' : nativeJoin.call(array, separator);
  }

  /**
   * Gets the last element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the last element of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   */
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
  }

  /**
   * Removes all given values from `array` using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
   * to remove elements from an array by predicate.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @param {...*} [values] The values to remove.
   * @returns {Array} Returns `array`.
   * @example
   *
   * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
   *
   * _.pull(array, 'a', 'c');
   * console.log(array);
   * // => ['b', 'b']
   */
  var pull = baseRest(pullAll);

  /**
   * This method is like `_.pull` except that it accepts an array of values to remove.
   *
   * **Note:** Unlike `_.difference`, this method mutates `array`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @param {Array} values The values to remove.
   * @returns {Array} Returns `array`.
   * @example
   *
   * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
   *
   * _.pullAll(array, ['a', 'c']);
   * console.log(array);
   * // => ['b', 'b']
   */
  function pullAll(array, values) {
    return (array && array.length && values && values.length)
      ? basePullAll(array, values)
      : array;
  }

  /**
   * Removes elements from `array` corresponding to `indexes` and returns an
   * array of removed elements.
   *
   * **Note:** Unlike `_.at`, this method mutates `array`.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @param {...(number|number[])} [indexes] The indexes of elements to remove.
   * @returns {Array} Returns the new array of removed elements.
   * @example
   *
   * var array = ['a', 'b', 'c', 'd'];
   * var pulled = _.pullAt(array, [1, 3]);
   *
   * console.log(array);
   * // => ['a', 'c']
   *
   * console.log(pulled);
   * // => ['b', 'd']
   */
  var pullAt = flatRest(function(array, indexes) {
    var length = array == null ? 0 : array.length,
        result = baseAt(array, indexes);

    basePullAt(array, arrayMap(indexes, function(index) {
      return isIndex(index, length) ? +index : index;
    }).sort(compareAscending));

    return result;
  });

  /**
   * Removes all elements from `array` that `predicate` returns truthy for
   * and returns an array of the removed elements. The predicate is invoked
   * with three arguments: (value, index, array).
   *
   * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
   * to pull elements from an array by value.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new array of removed elements.
   * @example
   *
   * var array = [1, 2, 3, 4];
   * var evens = _.remove(array, function(n) {
   *   return n % 2 == 0;
   * });
   *
   * console.log(array);
   * // => [1, 3]
   *
   * console.log(evens);
   * // => [2, 4]
   */
  function remove(array, predicate) {
    var result = [];
    if (!(array && array.length)) {
      return result;
    }
    var index = -1,
        indexes = [],
        length = array.length;

    predicate = getIteratee(predicate, 3);
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result.push(value);
        indexes.push(index);
      }
    }
    basePullAt(array, indexes);
    return result;
  }

  /**
   * Reverses `array` so that the first element becomes the last, the second
   * element becomes the second to last, and so on.
   *
   * **Note:** This method mutates `array` and is based on
   * [`Array#reverse`](https://mdn.io/Array/reverse).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @returns {Array} Returns `array`.
   * @example
   *
   * var array = [1, 2, 3];
   *
   * _.reverse(array);
   * // => [3, 2, 1]
   *
   * console.log(array);
   * // => [3, 2, 1]
   */
  function reverse(array) {
    return array == null ? array : nativeReverse.call(array);
  }

  /**
   * Creates a slice of `array` from `start` up to, but not including, `end`.
   *
   * **Note:** This method is used instead of
   * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
   * returned.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function slice(array, start, end) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
      start = 0;
      end = length;
    }
    else {
      start = start == null ? 0 : toInteger(start);
      end = end === undefined ? length : toInteger(end);
    }
    return baseSlice(array, start, end);
  }

  /**
   * Gets all but the first element of `array`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * _.tail([1, 2, 3]);
   * // => [2, 3]
   */
  function tail(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseSlice(array, 1, length) : [];
  }

  /**
   * Creates a slice of `array` with `n` elements taken from the beginning.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @param {number} [n=1] The number of elements to take.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * _.take([1, 2, 3]);
   * // => [1]
   *
   * _.take([1, 2, 3], 2);
   * // => [1, 2]
   *
   * _.take([1, 2, 3], 5);
   * // => [1, 2, 3]
   *
   * _.take([1, 2, 3], 0);
   * // => []
   */
  function take(array, n, guard) {
    if (!(array && array.length)) {
      return [];
    }
    n = (guard || n === undefined) ? 1 : toInteger(n);
    return baseSlice(array, 0, n < 0 ? 0 : n);
  }

  /**
   * Creates a slice of `array` with `n` elements taken from the end.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to query.
   * @param {number} [n=1] The number of elements to take.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * _.takeRight([1, 2, 3]);
   * // => [3]
   *
   * _.takeRight([1, 2, 3], 2);
   * // => [2, 3]
   *
   * _.takeRight([1, 2, 3], 5);
   * // => [1, 2, 3]
   *
   * _.takeRight([1, 2, 3], 0);
   * // => []
   */
  function takeRight(array, n, guard) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    n = (guard || n === undefined) ? 1 : toInteger(n);
    n = length - n;
    return baseSlice(array, n < 0 ? 0 : n, length);
  }

  /**
   * Creates a slice of `array` with elements taken from the beginning. Elements
   * are taken until `predicate` returns falsey. The predicate is invoked with
   * three arguments: (value, index, array).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to query.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.takeWhile(users, function(o) { return !o.active; });
   * // => objects for ['barney', 'fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.takeWhile(users, { 'user': 'barney', 'active': false });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.takeWhile(users, ['active', false]);
   * // => objects for ['barney', 'fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.takeWhile(users, 'active');
   * // => []
   */
  function takeWhile(array, predicate) {
    return (array && array.length)
      ? baseWhile(array, getIteratee(predicate, 3))
      : [];
  }

  /**
   * Creates an array of unique values, in order, from all given arrays using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of combined values.
   * @example
   *
   * _.union([2], [1, 2]);
   * // => [2, 1]
   */
  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });

  /**
   * This method is like `_.union` except that it accepts `iteratee` which is
   * invoked for each element of each `arrays` to generate the criterion by
   * which uniqueness is computed. Result values are chosen from the first
   * array in which the value occurs. The iteratee is invoked with one argument:
   * (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {Array} Returns the new array of combined values.
   * @example
   *
   * _.unionBy([2.1], [1.2, 2.3], Math.floor);
   * // => [2.1, 1.2]
   *
   * // The `_.property` iteratee shorthand.
   * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 1 }, { 'x': 2 }]
   */
  var unionBy = baseRest(function(arrays) {
    var iteratee = last(arrays);
    if (isArrayLikeObject(iteratee)) {
      iteratee = undefined;
    }
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
  });

  /**
   * This method is like `_.union` except that it accepts `comparator` which
   * is invoked to compare elements of `arrays`. Result values are chosen from
   * the first array in which the value occurs. The comparator is invoked
   * with two arguments: (arrVal, othVal).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of combined values.
   * @example
   *
   * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
   * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
   *
   * _.unionWith(objects, others, _.isEqual);
   * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
   */
  var unionWith = baseRest(function(arrays) {
    var comparator = last(arrays);
    comparator = typeof comparator == 'function' ? comparator : undefined;
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
  });

  /**
   * Creates a duplicate-free version of an array, using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons, in which only the first occurrence of each element
   * is kept. The order of result values is determined by the order they occur
   * in the array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @returns {Array} Returns the new duplicate free array.
   * @example
   *
   * _.uniq([2, 1, 2]);
   * // => [2, 1]
   */
  function uniq(array) {
    return (array && array.length) ? baseUniq(array) : [];
  }

  /**
   * This method is like `_.uniq` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the criterion by which
   * uniqueness is computed. The order of result values is determined by the
   * order they occur in the array. The iteratee is invoked with one argument:
   * (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   * @example
   *
   * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
   * // => [2.1, 1.2]
   *
   * // The `_.property` iteratee shorthand.
   * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 1 }, { 'x': 2 }]
   */
  function uniqBy(array, iteratee) {
    return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
  }

  /**
   * This method is like `_.uniq` except that it accepts `comparator` which
   * is invoked to compare elements of `array`. The order of result values is
   * determined by the order they occur in the array.The comparator is invoked
   * with two arguments: (arrVal, othVal).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   * @example
   *
   * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
   *
   * _.uniqWith(objects, _.isEqual);
   * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
   */
  function uniqWith(array, comparator) {
    comparator = typeof comparator == 'function' ? comparator : undefined;
    return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
  }

  /**
   * Creates an array excluding all given values using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * **Note:** Unlike `_.pull`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...*} [values] The values to exclude.
   * @returns {Array} Returns the new array of filtered values.
   * @see _.difference, _.xor
   * @example
   *
   * _.without([2, 1, 2, 3], 1, 2);
   * // => [3]
   */
  var without = baseRest(function(array, values) {
    return isArrayLikeObject(array)
      ? baseDifference(array, values)
      : [];
  });

  /**
   * Creates an array of unique values that is the
   * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
   * of the given arrays. The order of result values is determined by the order
   * they occur in the arrays.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of filtered values.
   * @see _.difference, _.without
   * @example
   *
   * _.xor([2, 1], [2, 3]);
   * // => [1, 3]
   */
  var xor = baseRest(function(arrays) {
    return baseXor(arrayFilter(arrays, isArrayLikeObject));
  });

  /**
   * This method is like `_.xor` except that it accepts `iteratee` which is
   * invoked for each element of each `arrays` to generate the criterion by
   * which by which they're compared. The order of result values is determined
   * by the order they occur in the arrays. The iteratee is invoked with one
   * argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
   * // => [1.2, 3.4]
   *
   * // The `_.property` iteratee shorthand.
   * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
   * // => [{ 'x': 2 }]
   */
  var xorBy = baseRest(function(arrays) {
    var iteratee = last(arrays);
    if (isArrayLikeObject(iteratee)) {
      iteratee = undefined;
    }
    return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
  });

  /**
   * This method is like `_.xor` except that it accepts `comparator` which is
   * invoked to compare elements of `arrays`. The order of result values is
   * determined by the order they occur in the arrays. The comparator is invoked
   * with two arguments: (arrVal, othVal).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
   * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
   *
   * _.xorWith(objects, others, _.isEqual);
   * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
   */
  var xorWith = baseRest(function(arrays) {
    var comparator = last(arrays);
    comparator = typeof comparator == 'function' ? comparator : undefined;
    return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
  });

  /*------------------------------------------------------------------------*/

  /**
   * Creates an object composed of keys generated from the results of running
   * each element of `collection` thru `iteratee`. The corresponding value of
   * each key is the number of times the key was returned by `iteratee`. The
   * iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.countBy([6.1, 4.2, 6.3], Math.floor);
   * // => { '4': 1, '6': 2 }
   *
   * // The `_.property` iteratee shorthand.
   * _.countBy(['one', 'two', 'three'], 'length');
   * // => { '3': 2, '5': 1 }
   */
  var countBy = createAggregator(function(result, value, key) {
    if (hasOwnProperty.call(result, key)) {
      ++result[key];
    } else {
      baseAssignValue(result, key, 1);
    }
  });

  /**
   * Checks if `predicate` returns truthy for **all** elements of `collection`.
   * Iteration is stopped once `predicate` returns falsey. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * **Note:** This method returns `true` for
   * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
   * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
   * elements of empty collections.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes'], Boolean);
   * // => false
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': false },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.every(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.every(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.every(users, 'active');
   * // => false
   */
  function every(collection, predicate, guard) {
    var func = isArray(collection) ? arrayEvery : baseEvery;
    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = undefined;
    }
    return func(collection, getIteratee(predicate, 3));
  }

  /**
   * Iterates over elements of `collection`, returning an array of all elements
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * **Note:** Unlike `_.remove`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   * @see _.reject
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * _.filter(users, function(o) { return !o.active; });
   * // => objects for ['fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, { 'age': 36, 'active': true });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, ['active', false]);
   * // => objects for ['fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.filter(users, 'active');
   * // => objects for ['barney']
   */
  function filter(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, getIteratee(predicate, 3));
  }

  /**
   * Iterates over elements of `collection`, returning the first element
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36, 'active': true },
   *   { 'user': 'fred',    'age': 40, 'active': false },
   *   { 'user': 'pebbles', 'age': 1,  'active': true }
   * ];
   *
   * _.find(users, function(o) { return o.age < 40; });
   * // => object for 'barney'
   *
   * // The `_.matches` iteratee shorthand.
   * _.find(users, { 'age': 1, 'active': true });
   * // => object for 'pebbles'
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.find(users, ['active', false]);
   * // => object for 'fred'
   *
   * // The `_.property` iteratee shorthand.
   * _.find(users, 'active');
   * // => object for 'barney'
   */
  var find = createFind(findIndex);

  /**
   * This method is like `_.find` except that it iterates over elements of
   * `collection` from right to left.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=collection.length-1] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * _.findLast([1, 2, 3, 4], function(n) {
   *   return n % 2 == 1;
   * });
   * // => 3
   */
  var findLast = createFind(findLastIndex);

  /**
   * Creates an object composed of keys generated from the results of running
   * each element of `collection` thru `iteratee`. The order of grouped values
   * is determined by the order they occur in `collection`. The corresponding
   * value of each key is an array of elements responsible for generating the
   * key. The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.groupBy([6.1, 4.2, 6.3], Math.floor);
   * // => { '4': [4.2], '6': [6.1, 6.3] }
   *
   * // The `_.property` iteratee shorthand.
   * _.groupBy(['one', 'two', 'three'], 'length');
   * // => { '3': ['one', 'two'], '5': ['three'] }
   */
  var groupBy = createAggregator(function(result, value, key) {
    if (hasOwnProperty.call(result, key)) {
      result[key].push(value);
    } else {
      baseAssignValue(result, key, [value]);
    }
  });

  /**
   * Checks if `value` is in `collection`. If `collection` is a string, it's
   * checked for a substring of `value`, otherwise
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * is used for equality comparisons. If `fromIndex` is negative, it's used as
   * the offset from the end of `collection`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {boolean} Returns `true` if `value` is found, else `false`.
   * @example
   *
   * _.includes([1, 2, 3], 1);
   * // => true
   *
   * _.includes([1, 2, 3], 1, 2);
   * // => false
   *
   * _.includes({ 'a': 1, 'b': 2 }, 1);
   * // => true
   *
   * _.includes('abcd', 'bc');
   * // => true
   */
  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection)
      ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
      : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
  }

  /**
   * Creates an array of values by running each element in `collection` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
   *
   * The guarded methods are:
   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * _.map([4, 8], square);
   * // => [16, 64]
   *
   * _.map({ 'a': 4, 'b': 8 }, square);
   * // => [16, 64] (iteration order is not guaranteed)
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, 'user');
   * // => ['barney', 'fred']
   */
  function map(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, getIteratee(iteratee, 3));
  }

  /**
   * This method is like `_.sortBy` except that it allows specifying the sort
   * orders of the iteratees to sort by. If `orders` is unspecified, all values
   * are sorted in ascending order. Otherwise, specify an order of "desc" for
   * descending or "asc" for ascending sort order of corresponding values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @param {string[]} [orders] The sort orders of `iteratees`.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 34 },
   *   { 'user': 'fred',   'age': 40 },
   *   { 'user': 'barney', 'age': 36 }
   * ];
   *
   * // Sort by `user` in ascending order and by `age` in descending order.
   * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
   */
  function orderBy(collection, iteratees, orders, guard) {
    if (collection == null) {
      return [];
    }
    if (!isArray(iteratees)) {
      iteratees = iteratees == null ? [] : [iteratees];
    }
    orders = guard ? undefined : orders;
    if (!isArray(orders)) {
      orders = orders == null ? [] : [orders];
    }
    return baseOrderBy(collection, iteratees, orders);
  }

  /**
   * Reduces `collection` to a value which is the accumulated result of running
   * each element in `collection` thru `iteratee`, where each successive
   * invocation is supplied the return value of the previous. If `accumulator`
   * is not given, the first element of `collection` is used as the initial
   * value. The iteratee is invoked with four arguments:
   * (accumulator, value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.reduce`, `_.reduceRight`, and `_.transform`.
   *
   * The guarded methods are:
   * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
   * and `sortBy`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @returns {*} Returns the accumulated value.
   * @see _.reduceRight
   * @example
   *
   * _.reduce([1, 2], function(sum, n) {
   *   return sum + n;
   * }, 0);
   * // => 3
   *
   * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
   *   (result[value] || (result[value] = [])).push(key);
   *   return result;
   * }, {});
   * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
   */
  function reduce(collection, iteratee, accumulator) {
    var func = isArray(collection) ? arrayReduce : baseReduce,
        initAccum = arguments.length < 3;

    return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
  }

  /**
   * Checks if `predicate` returns truthy for **any** element of `collection`.
   * Iteration is stopped once `predicate` returns truthy. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, 'yes', false], Boolean);
   * // => true
   *
   * var users = [
   *   { 'user': 'barney', 'active': true },
   *   { 'user': 'fred',   'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.some(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.some(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.some(users, 'active');
   * // => true
   */
  function some(collection, predicate, guard) {
    var func = isArray(collection) ? arraySome : baseSome;
    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = undefined;
    }
    return func(collection, getIteratee(predicate, 3));
  }

  /**
   * Creates an array of elements, sorted in ascending order by the results of
   * running each element in a collection thru each iteratee. This method
   * performs a stable sort, that is, it preserves the original sort order of
   * equal elements. The iteratees are invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {...(Function|Function[])} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 40 },
   *   { 'user': 'barney', 'age': 34 }
   * ];
   *
   * _.sortBy(users, [function(o) { return o.user; }]);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
   *
   * _.sortBy(users, ['user', 'age']);
   * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
   */
  var sortBy = baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length = iteratees.length;
    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });

  /*------------------------------------------------------------------------*/

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root.Date.now();
  };

  /*------------------------------------------------------------------------*/

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;

  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a shallow clone of `value`.
   *
   * **Note:** This method is loosely based on the
   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
   * and supports cloning arrays, array buffers, booleans, date objects, maps,
   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
   * arrays. The own enumerable properties of `arguments` objects are cloned
   * as plain objects. An empty object is returned for uncloneable values such
   * as error objects, functions, DOM nodes, and WeakMaps.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to clone.
   * @returns {*} Returns the cloned value.
   * @see _.cloneDeep
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var shallow = _.clone(objects);
   * console.log(shallow[0] === objects[0]);
   * // => true
   */
  function clone(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG);
  }

  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */
  function isString(value) {
    return typeof value == 'string' ||
      (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
  }

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag);
  }

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = (value < 0 ? -1 : 1);
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  function toInteger(value) {
    var result = toFinite(value),
        remainder = result % 1;

    return result === result ? (remainder ? result - remainder : result) : 0;
  }

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */
  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }

  /*------------------------------------------------------------------------*/

  /**
   * Pads `string` on the left and right sides if it's shorter than `length`.
   * Padding characters are truncated if they can't be evenly divided by `length`.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to pad.
   * @param {number} [length=0] The padding length.
   * @param {string} [chars=' '] The string used as padding.
   * @returns {string} Returns the padded string.
   * @example
   *
   * _.pad('abc', 8);
   * // => '  abc   '
   *
   * _.pad('abc', 8, '_-');
   * // => '_-abc_-_'
   *
   * _.pad('abc', 3);
   * // => 'abc'
   */
  function pad(string, length, chars) {
    string = toString(string);
    length = toInteger(length);

    var strLength = length ? stringSize(string) : 0;
    if (!length || strLength >= length) {
      return string;
    }
    var mid = (length - strLength) / 2;
    return (
      createPadding(nativeFloor(mid), chars) +
      string +
      createPadding(nativeCeil(mid), chars)
    );
  }

  /**
   * Pads `string` on the right side if it's shorter than `length`. Padding
   * characters are truncated if they exceed `length`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to pad.
   * @param {number} [length=0] The padding length.
   * @param {string} [chars=' '] The string used as padding.
   * @returns {string} Returns the padded string.
   * @example
   *
   * _.padEnd('abc', 6);
   * // => 'abc   '
   *
   * _.padEnd('abc', 6, '_-');
   * // => 'abc_-_'
   *
   * _.padEnd('abc', 3);
   * // => 'abc'
   */
  function padEnd(string, length, chars) {
    string = toString(string);
    length = toInteger(length);

    var strLength = length ? stringSize(string) : 0;
    return (length && strLength < length)
      ? (string + createPadding(length - strLength, chars))
      : string;
  }

  /**
   * Pads `string` on the left side if it's shorter than `length`. Padding
   * characters are truncated if they exceed `length`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to pad.
   * @param {number} [length=0] The padding length.
   * @param {string} [chars=' '] The string used as padding.
   * @returns {string} Returns the padded string.
   * @example
   *
   * _.padStart('abc', 6);
   * // => '   abc'
   *
   * _.padStart('abc', 6, '_-');
   * // => '_-_abc'
   *
   * _.padStart('abc', 3);
   * // => 'abc'
   */
  function padStart(string, length, chars) {
    string = toString(string);
    length = toInteger(length);

    var strLength = length ? stringSize(string) : 0;
    return (length && strLength < length)
      ? (createPadding(length - strLength, chars) + string)
      : string;
  }

  /**
   * Converts `string` to an integer of the specified radix. If `radix` is
   * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
   * hexadecimal, in which case a `radix` of `16` is used.
   *
   * **Note:** This method aligns with the
   * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category String
   * @param {string} string The string to convert.
   * @param {number} [radix=10] The radix to interpret `value` by.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.parseInt('08');
   * // => 8
   *
   * _.map(['6', '08', '10'], _.parseInt);
   * // => [6, 8, 10]
   */
  function parseInt(string, radix, guard) {
    if (guard || radix == null) {
      radix = 0;
    } else if (radix) {
      radix = +radix;
    }
    return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
  }

  /**
   * Removes leading and trailing whitespace or specified characters from `string`.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to trim.
   * @param {string} [chars=whitespace] The characters to trim.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {string} Returns the trimmed string.
   * @example
   *
   * _.trim('  abc  ');
   * // => 'abc'
   *
   * _.trim('-_-abc-_-', '_-');
   * // => 'abc'
   *
   * _.map(['  foo  ', '  bar  '], _.trim);
   * // => ['foo', 'bar']
   */
  function trim(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === undefined)) {
      return string.replace(reTrim, '');
    }
    if (!string || !(chars = baseToString(chars))) {
      return string;
    }
    var strSymbols = stringToArray(string),
        chrSymbols = stringToArray(chars),
        start = charsStartIndex(strSymbols, chrSymbols),
        end = charsEndIndex(strSymbols, chrSymbols) + 1;

    return castSlice(strSymbols, start, end).join('');
  }

  /**
   * Removes trailing whitespace or specified characters from `string`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to trim.
   * @param {string} [chars=whitespace] The characters to trim.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {string} Returns the trimmed string.
   * @example
   *
   * _.trimEnd('  abc  ');
   * // => '  abc'
   *
   * _.trimEnd('-_-abc-_-', '_-');
   * // => '-_-abc'
   */
  function trimEnd(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === undefined)) {
      return string.replace(reTrimEnd, '');
    }
    if (!string || !(chars = baseToString(chars))) {
      return string;
    }
    var strSymbols = stringToArray(string),
        end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

    return castSlice(strSymbols, 0, end).join('');
  }

  /**
   * Removes leading whitespace or specified characters from `string`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to trim.
   * @param {string} [chars=whitespace] The characters to trim.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {string} Returns the trimmed string.
   * @example
   *
   * _.trimStart('  abc  ');
   * // => 'abc  '
   *
   * _.trimStart('-_-abc-_-', '_-');
   * // => 'abc-_-'
   */
  function trimStart(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === undefined)) {
      return string.replace(reTrimStart, '');
    }
    if (!string || !(chars = baseToString(chars))) {
      return string;
    }
    var strSymbols = stringToArray(string),
        start = charsStartIndex(strSymbols, stringToArray(chars));

    return castSlice(strSymbols, start).join('');
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * Creates a function that invokes `func` with the arguments of the created
   * function. If `func` is a property name, the created function returns the
   * property value for a given element. If `func` is an array or object, the
   * created function returns `true` for elements that contain the equivalent
   * source properties, otherwise it returns `false`.
   *
   * @static
   * @since 4.0.0
   * @memberOf _
   * @category Util
   * @param {*} [func=_.identity] The value to convert to a callback.
   * @returns {Function} Returns the callback.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
   * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, _.iteratee(['user', 'fred']));
   * // => [{ 'user': 'fred', 'age': 40 }]
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, _.iteratee('user'));
   * // => ['barney', 'fred']
   *
   * // Create custom iteratee shorthands.
   * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
   *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
   *     return func.test(string);
   *   };
   * });
   *
   * _.filter(['abc', 'def'], /ef/);
   * // => ['def']
   */
  function iteratee(func) {
    return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
  }

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /*------------------------------------------------------------------------*/

  /**
   * Adds two numbers.
   *
   * @static
   * @memberOf _
   * @since 3.4.0
   * @category Math
   * @param {number} augend The first number in an addition.
   * @param {number} addend The second number in an addition.
   * @returns {number} Returns the total.
   * @example
   *
   * _.add(6, 4);
   * // => 10
   */
  var add = createMathOperation(function(augend, addend) {
    return augend + addend;
  }, 0);

  /**
   * Computes `number` rounded up to `precision`.
   *
   * @static
   * @memberOf _
   * @since 3.10.0
   * @category Math
   * @param {number} number The number to round up.
   * @param {number} [precision=0] The precision to round up to.
   * @returns {number} Returns the rounded up number.
   * @example
   *
   * _.ceil(4.006);
   * // => 5
   *
   * _.ceil(6.004, 2);
   * // => 6.01
   *
   * _.ceil(6040, -2);
   * // => 6100
   */
  var ceil = createRound('ceil');

  /**
   * Divide two numbers.
   *
   * @static
   * @memberOf _
   * @since 4.7.0
   * @category Math
   * @param {number} dividend The first number in a division.
   * @param {number} divisor The second number in a division.
   * @returns {number} Returns the quotient.
   * @example
   *
   * _.divide(6, 4);
   * // => 1.5
   */
  var divide = createMathOperation(function(dividend, divisor) {
    return dividend / divisor;
  }, 1);

  /**
   * Computes `number` rounded down to `precision`.
   *
   * @static
   * @memberOf _
   * @since 3.10.0
   * @category Math
   * @param {number} number The number to round down.
   * @param {number} [precision=0] The precision to round down to.
   * @returns {number} Returns the rounded down number.
   * @example
   *
   * _.floor(4.006);
   * // => 4
   *
   * _.floor(0.046, 2);
   * // => 0.04
   *
   * _.floor(4060, -2);
   * // => 4000
   */
  var floor = createRound('floor');

  /**
   * Computes the maximum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the maximum value.
   * @example
   *
   * _.max([4, 2, 8, 6]);
   * // => 8
   *
   * _.max([]);
   * // => undefined
   */
  function max(array) {
    return (array && array.length)
      ? baseExtremum(array, identity, baseGt)
      : undefined;
  }

  /**
   * This method is like `_.max` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the criterion by which
   * the value is ranked. The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {*} Returns the maximum value.
   * @example
   *
   * var objects = [{ 'n': 1 }, { 'n': 2 }];
   *
   * _.maxBy(objects, function(o) { return o.n; });
   * // => { 'n': 2 }
   *
   * // The `_.property` iteratee shorthand.
   * _.maxBy(objects, 'n');
   * // => { 'n': 2 }
   */
  function maxBy(array, iteratee) {
    return (array && array.length)
      ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
      : undefined;
  }

  /**
   * Computes the mean of the values in `array`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {number} Returns the mean.
   * @example
   *
   * _.mean([4, 2, 8, 6]);
   * // => 5
   */
  function mean(array) {
    return baseMean(array, identity);
  }

  /**
   * This method is like `_.mean` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the value to be averaged.
   * The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.7.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {number} Returns the mean.
   * @example
   *
   * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
   *
   * _.meanBy(objects, function(o) { return o.n; });
   * // => 5
   *
   * // The `_.property` iteratee shorthand.
   * _.meanBy(objects, 'n');
   * // => 5
   */
  function meanBy(array, iteratee) {
    return baseMean(array, getIteratee(iteratee, 2));
  }

  /**
   * Computes the minimum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * _.min([4, 2, 8, 6]);
   * // => 2
   *
   * _.min([]);
   * // => undefined
   */
  function min(array) {
    return (array && array.length)
      ? baseExtremum(array, identity, baseLt)
      : undefined;
  }

  /**
   * This method is like `_.min` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the criterion by which
   * the value is ranked. The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * var objects = [{ 'n': 1 }, { 'n': 2 }];
   *
   * _.minBy(objects, function(o) { return o.n; });
   * // => { 'n': 1 }
   *
   * // The `_.property` iteratee shorthand.
   * _.minBy(objects, 'n');
   * // => { 'n': 1 }
   */
  function minBy(array, iteratee) {
    return (array && array.length)
      ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
      : undefined;
  }

  /**
   * Multiply two numbers.
   *
   * @static
   * @memberOf _
   * @since 4.7.0
   * @category Math
   * @param {number} multiplier The first number in a multiplication.
   * @param {number} multiplicand The second number in a multiplication.
   * @returns {number} Returns the product.
   * @example
   *
   * _.multiply(6, 4);
   * // => 24
   */
  var multiply = createMathOperation(function(multiplier, multiplicand) {
    return multiplier * multiplicand;
  }, 1);

  /**
   * Computes `number` rounded to `precision`.
   *
   * @static
   * @memberOf _
   * @since 3.10.0
   * @category Math
   * @param {number} number The number to round.
   * @param {number} [precision=0] The precision to round to.
   * @returns {number} Returns the rounded number.
   * @example
   *
   * _.round(4.006);
   * // => 4
   *
   * _.round(4.006, 2);
   * // => 4.01
   *
   * _.round(4060, -2);
   * // => 4100
   */
  var round = createRound('round');

  /**
   * Subtract two numbers.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {number} minuend The first number in a subtraction.
   * @param {number} subtrahend The second number in a subtraction.
   * @returns {number} Returns the difference.
   * @example
   *
   * _.subtract(6, 4);
   * // => 2
   */
  var subtract = createMathOperation(function(minuend, subtrahend) {
    return minuend - subtrahend;
  }, 0);

  /**
   * Computes the sum of the values in `array`.
   *
   * @static
   * @memberOf _
   * @since 3.4.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {number} Returns the sum.
   * @example
   *
   * _.sum([4, 2, 8, 6]);
   * // => 20
   */
  function sum(array) {
    return (array && array.length)
      ? baseSum(array, identity)
      : 0;
  }

  /**
   * This method is like `_.sum` except that it accepts `iteratee` which is
   * invoked for each element in `array` to generate the value to be summed.
   * The iteratee is invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Math
   * @param {Array} array The array to iterate over.
   * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
   * @returns {number} Returns the sum.
   * @example
   *
   * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
   *
   * _.sumBy(objects, function(o) { return o.n; });
   * // => 20
   *
   * // The `_.property` iteratee shorthand.
   * _.sumBy(objects, 'n');
   * // => 20
   */
  function sumBy(array, iteratee) {
    return (array && array.length)
      ? baseSum(array, getIteratee(iteratee, 2))
      : 0;
  }

  /*------------------------------------------------------------------------*/

  // Add methods that return wrapped values in chain sequences.
  lodash.compact = compact;
  lodash.concat = concat;
  lodash.constant = constant;
  lodash.countBy = countBy;
  lodash.debounce = debounce;
  lodash.difference = difference;
  lodash.differenceBy = differenceBy;
  lodash.differenceWith = differenceWith;
  lodash.dropWhile = dropWhile;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.groupBy = groupBy;
  lodash.initial = initial;
  lodash.intersection = intersection;
  lodash.intersectionBy = intersectionBy;
  lodash.intersectionWith = intersectionWith;
  lodash.iteratee = iteratee;
  lodash.keys = keys;
  lodash.keysIn = keysIn;
  lodash.map = map;
  lodash.memoize = memoize;
  lodash.orderBy = orderBy;
  lodash.property = property;
  lodash.pull = pull;
  lodash.pullAll = pullAll;
  lodash.pullAt = pullAt;
  lodash.remove = remove;
  lodash.reverse = reverse;
  lodash.slice = slice;
  lodash.sortBy = sortBy;
  lodash.tail = tail;
  lodash.take = take;
  lodash.takeRight = takeRight;
  lodash.takeWhile = takeWhile;
  lodash.throttle = throttle;
  lodash.union = union;
  lodash.unionBy = unionBy;
  lodash.unionWith = unionWith;
  lodash.uniq = uniq;
  lodash.uniqBy = uniqBy;
  lodash.uniqWith = uniqWith;
  lodash.values = values;
  lodash.without = without;
  lodash.xor = xor;
  lodash.xorBy = xorBy;
  lodash.xorWith = xorWith;

  /*------------------------------------------------------------------------*/

  // Add methods that return unwrapped values in chain sequences.
  lodash.add = add;
  lodash.ceil = ceil;
  lodash.clone = clone;
  lodash.cloneDeep = cloneDeep;
  lodash.divide = divide;
  lodash.eq = eq;
  lodash.every = every;
  lodash.find = find;
  lodash.findIndex = findIndex;
  lodash.findLast = findLast;
  lodash.findLastIndex = findLastIndex;
  lodash.floor = floor;
  lodash.get = get;
  lodash.hasIn = hasIn;
  lodash.head = head;
  lodash.identity = identity;
  lodash.includes = includes;
  lodash.indexOf = indexOf;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isArrayLike = isArrayLike;
  lodash.isArrayLikeObject = isArrayLikeObject;
  lodash.isBuffer = isBuffer;
  lodash.isFunction = isFunction;
  lodash.isLength = isLength;
  lodash.isMap = isMap;
  lodash.isObject = isObject;
  lodash.isObjectLike = isObjectLike;
  lodash.isSet = isSet;
  lodash.isString = isString;
  lodash.isSymbol = isSymbol;
  lodash.isTypedArray = isTypedArray;
  lodash.join = join;
  lodash.last = last;
  lodash.max = max;
  lodash.maxBy = maxBy;
  lodash.mean = mean;
  lodash.meanBy = meanBy;
  lodash.min = min;
  lodash.minBy = minBy;
  lodash.stubArray = stubArray;
  lodash.stubFalse = stubFalse;
  lodash.multiply = multiply;
  lodash.noop = noop;
  lodash.now = now;
  lodash.pad = pad;
  lodash.padEnd = padEnd;
  lodash.padStart = padStart;
  lodash.parseInt = parseInt;
  lodash.reduce = reduce;
  lodash.round = round;
  lodash.some = some;
  lodash.subtract = subtract;
  lodash.sum = sum;
  lodash.sumBy = sumBy;
  lodash.toFinite = toFinite;
  lodash.toInteger = toInteger;
  lodash.toNumber = toNumber;
  lodash.toString = toString;
  lodash.trim = trim;
  lodash.trimEnd = trimEnd;
  lodash.trimStart = trimStart;

  // Add aliases.
  lodash.first = head;

  /*------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type {string}
   */
  lodash.VERSION = VERSION;

  /*--------------------------------------------------------------------------*/

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = lodash;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return lodash;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = lodash)._ = lodash;
    // Export for CommonJS support.
    freeExports._ = lodash;
  }
  else {
    // Export to the global object.
    root._ = lodash;
  }
}.call(this));

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'SystemInfo', 'DateUtil', 'VueI18n', 'VueResource'], definition);
  } else {
    context.VueUtil = definition(context.Vue, context.SystemInfo, context.DateUtil);
    delete context.SystemInfo;
    delete context.DateUtil;
    delete context.VueResource;
    delete context.VueI18n;
  }
})(this, function(Vue, SystemInfo, DateUtil) {
  'use strict';
  var version = '1.1.4';
  var _toString = Object.prototype.toString;
  var _map = Array.prototype.map;
  var _filter = Array.prototype.filter;
  var isDef = function(v) {
    return v !== undefined && v !== null;
  };
  var objType = function(obj) {
    return _toString.call(obj).slice(8, -1);
  };
  var isString = function(obj) {
    return objType(obj) === 'String';
  };
  var isNumber = function(obj) {
    return objType(obj) === 'Number' && obj === obj;
  };
  var isNumberStr = function(num) {
    if (typeof num === 'number') {
      return num - num === 0;
    }
    if (typeof num === 'string' && num.trim() !== '') {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };
  var newArray = function (start, end) {
    var result = [];
  
    for (var i = start; i <= end; i++) {
      result.push(i);
    }
  
    return result;
  };
  var isBoolean = function(obj) {
    return objType(obj) === 'Boolean';
  };
  var isFile = function(obj) {
    return objType(obj) === 'File';
  };
  var isObject = function(obj) {
    return objType(obj) === 'Object';
  };
  var isArray = function(obj) {
    return objType(obj) === 'Array';
  };
  var isFunction = function(obj) {
    return objType(obj) === 'Function';
  };
  var isDate = function(obj) {
    return objType(obj) === 'Date';
  };
  var isDateObject = function(val) {
    return val instanceof Date;
  };
  var isNodeList = function(obj) {
    return objType(obj) === 'NodeList';
  };
  var isElement = function(obj) {
    return objType(obj).indexOf('Element') !== -1;
  };
  var isVNode = function(node) {
    return isObject(node) && node.hasOwnProperty('componentOptions');
  };
  var isVueComponent = function(node) {
    return isObject(node) && node.hasOwnProperty('$root');
  };
  var toString = function(val) {
    return !isDef(val) ? '' : typeof val === 'object' ? JSON.stringify(val) : String(val);
  };
  var toDate = function(date) {
    return (!isDef(date) || isNaN(new Date(date).getTime())) ? null : new Date(date);
  };
  var formatNumber = function(number, dec, dsep, tsep) {
    isDef(number) && (number = number*1);
    if (!isNumber(number)) return null;
    isDef(dec) && (dec = dec*1);
    if (!isNumber(dec)) dec = 2;
    number = number.toFixed(dec);
    if (!isString(dsep)) dsep = '.';
    if (!isString(tsep)) tsep = ',';
    var parts = number.split('.');
    var fnums = parts[0];
    var decimals = parts[1] ? dsep + parts[1] : '';
    return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + tsep) + decimals;
  };
  var formatDate = function(date, format) {
    date = toDate(date);
    if (!isDef(date)) return null;
    return DateUtil.format(date, format || 'yyyy-MM-dd');
  };
  var range = function a(n) {
    // see https://stackoverflow.com/questions/3746725/create-a-javascript-array-containing-1-n
    return Array.apply(null, {
      length: n
    }).map(function (_, n) {
      return n;
    });
  };

  var modifyDate = function (date, y, m, d) {
    return new Date(y, m, d, date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
  };
  
  var modifyTime = function (date, h, m, s) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), h, m, s, date.getMilliseconds());
  };
  
  var modifyWithTimeString = function (date, time) {
    if (date == null || !time) {
      return date;
    }
  
    time = parseDate(time, 'HH:mm:ss');
    return modifyTime(date, time.getHours(), time.getMinutes(), time.getSeconds());
  };
  
  var clearTime = function (date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate());
  };
  
  var clearMilliseconds = function (date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0);
  };
  
  var limitTimeRange = function (date, ranges) {
    var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'HH:mm:ss';
    if (ranges.length === 0) return date;
  
    var normalizeDate = function (date) {
      return DateUtil.parse(DateUtil.format(date, format), format);
    };
  
    var ndate = normalizeDate(date);
    var nranges = ranges.map(function (range) {
      return range.map(normalizeDate);
    });
    if (nranges.some(function (nrange) {
      return ndate >= nrange[0] && ndate <= nrange[1];
    })) return date;
    var minDate = nranges[0][0];
    var maxDate = nranges[0][0];
    nranges.forEach(function (nrange) {
      minDate = new Date(Math.min(nrange[0], minDate));
      maxDate = new Date(Math.max(nrange[1], minDate));
    });
    var ret = ndate < minDate ? minDate : maxDate; // preserve Year/Month/Date
  
    return modifyDate(ret, date.getFullYear(), date.getMonth(), date.getDate());
  };
  var parseDate = function(string, format) {
    var str = formatDate(string, format);
    if (!isDef(str)) str = string;
    return DateUtil.parse(str, format || 'yyyy-MM-dd');
  };
  var getDayCountOfMonth = function(year, month) {
    isDef(year) && (year = year*1);
    isDef(month) && (month = month*1);
    if (!isNumber(year) || !isNumber(month)) return null;
    if (month === 3 || month === 5 || month === 8 || month === 10) {
      return 30;
    }
    if (month === 1) {
      if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
        return 29;
      } else {
        return 28;
      }
    }
    return 31;
  };
  var getDayCountOfYear = function(year) {
    var isLeapYear = year % 400 === 0 || (year % 100 !== 0 && year % 4 === 0);
    return isLeapYear ? 366 : 365;
  };
  var getFirstDayOfMonth = function(date) {
    var temp = toDate(date);
    if (!isDate(temp)) return null;
    temp.setDate(1);
    return temp.getDay();
  };
  var getStartDateOfMonth = function (year, month) {
    var result = new Date(year, month, 1);
    var day = result.getDay();
  
    if (day === 0) {
      return prevDate(result, 7);
    } else {
      return prevDate(result, day);
    }
  };
  
  var prevDate = function (date) {
    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return new Date(date.getFullYear(), date.getMonth(), date.getDate() - amount);
  };
  
  var nextDate = function (date) {
    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return new Date(date.getFullYear(), date.getMonth(), date.getDate() + amount);
  };
  
  var timeWithinRange = function (date, selectableRange, format) {
    var limitedDate = limitTimeRange(date, selectableRange, format);
    return limitedDate.getTime() === date.getTime();
  };
  
  var changeYearMonthAndClampDate = function (date, year, month) {
    var monthDate = Math.min(date.getDate(), getDayCountOfMonth(year, month));
    return modifyDate(date, year, month, monthDate);
  };
  
  var prevMonth = function (date) {
    var year = date.getFullYear();
    var month = date.getMonth();
    return month === 0 ? changeYearMonthAndClampDate(date, year - 1, 11) : changeYearMonthAndClampDate(date, year, month - 1);
  };
  
  var nextMonth = function (date) {
    var year = date.getFullYear();
    var month = date.getMonth();
    return month === 11 ? changeYearMonthAndClampDate(date, year + 1, 0) : changeYearMonthAndClampDate(date, year, month + 1);
  };
  
  var prevYear = function (date) {
    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var year = date.getFullYear();
    var month = date.getMonth();
    return changeYearMonthAndClampDate(date, year - amount, month);
  };
  
  var nextYear = function (date) {
    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var year = date.getFullYear();
    var month = date.getMonth();
    return changeYearMonthAndClampDate(date, year + amount, month);
  };
  var getWeekNumber = function(date) {
    date = toDate(date);
    if (!isDate(date)) return null;
    date.setHours(0, 0, 0, 0);
    date.setTime((date.getTime() + (6 - date.getDay()) * 86400000));
    var firstDate = new Date(date.getFullYear(), 0, 1);
    return Math.ceil(((date.getTime() - firstDate.getTime()) / 86400000) / 7);
  };

  var getRangeHours = function (ranges) {
    var hours = [];
    var disabledHours = [];
    (ranges || []).forEach(function (range) {
      var value = range.map(function (date) {
        return date.getHours();
      });
      disabledHours = disabledHours.concat(newArray(value[0], value[1]));
    });
  
    if (disabledHours.length) {
      for (var i = 0; i < 24; i++) {
        hours[i] = disabledHours.indexOf(i) === -1;
      }
    } else {
      for (var _i = 0; _i < 24; _i++) {
        hours[_i] = false;
      }
    }
  
    return hours;
  };
  
  var setRangeData = function (arr, start, end, value) {
    for (var i = start; i < end; i++) {
      arr[i] = value;
    }
  };
  
  var getRangeMinutes = function (ranges, hour) {
    var minutes = new Array(60);
  
    if (ranges.length > 0) {
      ranges.forEach(function (range) {
        var start = range[0];
        var end = range[1];
        var startHour = start.getHours();
        var startMinute = start.getMinutes();
        var endHour = end.getHours();
        var endMinute = end.getMinutes();
  
        if (startHour === hour && endHour !== hour) {
          setRangeData(minutes, startMinute, 60, true);
        } else if (startHour === hour && endHour === hour) {
          setRangeData(minutes, startMinute, endMinute + 1, true);
        } else if (startHour !== hour && endHour === hour) {
          setRangeData(minutes, 0, endMinute + 1, true);
        } else if (startHour < hour && endHour > hour) {
          setRangeData(minutes, 0, 60, true);
        }
      });
    } else {
      setRangeData(minutes, 0, 60, true);
    }
  
    return minutes;
  };
  var addDate = function(src, num, type) {
    src = toDate(src);
    isDef(num) && (num = num*1);
    if (!isDate(src) || !isNumber(num)) return null;
    if (type !== 'week' && type !== 'day' && type !== 'month' && type !== 'year') type = 'day';
    var result = new Date();
    switch (type.toLowerCase()) {
      case 'week':
        var week = 7;
        result.setTime(src.getTime() + 86400000 * num * (week || 1));
        break;
      case 'day':
        result.setTime(src.getTime() + 86400000 * num * (week || 1));
        break;
      case 'month':
        var year = src.getFullYear();
        var month = src.getMonth();
        var date = src.getDate();
        var addMonth = 1;
        if (num < 0) {
          addMonth = -1;
          num = -num;
        }
        while (num--) {
          if (addMonth > 0) {
            year = month === 11 ? year + addMonth : year;
            month = month === 11 ? 0 : month + addMonth;
          } else {
            year = month === 0 ? year + addMonth : year;
            month = month === 0 ? 11 : month + addMonth;
          }
        }
        var newMonthDayCount = getDayCountOfMonth(year, month);
        if (newMonthDayCount < date) {
          src.setDate(newMonthDayCount);
        }
        src.setMonth(month);
        src.setFullYear(year);
        result.setTime(src.getTime());
        break;
      case 'year':
        src.setFullYear(src.getFullYear() + num);
        result.setTime(src.getTime());
        break;
    }
    return result;
  };

  var extractDateFormat = function (format) {
    return format.replace(/\W?m{1,2}|\W?ZZ/g, '').replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, '').trim();
  };

  var extractTimeFormat = function (format) {
    return format.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?y{2,4}/g, '').trim();
  };

  var loop = function(arr, fn) {
    if (isDef(arr) && isNumber(arr.length) && isFunction(fn)) {
      for (var i=0, j=arr.length; i<j; i++) {
        if (fn(arr[i], i) === false) break;
      }
    }
  };
  var ownPropertyLoop = function (obj, fn) {
    isDef(obj) && loop(Object.keys(obj), fn);
  };
  var map = function(arr, fn) {
    if (isArray(arr) && isFunction(fn)) {
      return _map.call(arr, fn);
    }
    return [];
  };
  var filter = function(arr, fn) {
    if (isArray(arr) && isFunction(fn)) {
      return _filter.call(arr, fn);
    }
    return [];
  };
  var trim = function(str) {
    if (!isString(str)) str = '';
    return str.replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
  };
  var deepCopy = function(obj, parent) {
    if (!isDef(parent)) parent = null;
    var result = {};
    if (isArray(obj)) result = [];
    var _parent = parent;
    while (_parent) {
      if (_parent.originalParent === obj) {
        return _parent.currentParent;
      }
      _parent = _parent.parent;
    }
    ownPropertyLoop(obj, function(key) {
      var temp = obj[key];
      if (temp && typeof temp === 'object') {
        result[key] = deepCopy(temp, {
          originalParent: obj,
          currentParent: result,
          parent: parent
        });
      } else {
        result[key] = temp;
      }
    });
    return result;
  };
  var merge = function(target) {
    loop(arguments, function(source, index) {
      if (index === 0) return;
      ownPropertyLoop(source, function(prop) {
        if (isObject(target[prop]) && isObject(source[prop])) {
          target[prop] = merge({}, target[prop], source[prop]);
        } else {
          isDef(source[prop]) && (target[prop] = source[prop]);
        }
      });
    });
    return target;
  };
  var mergeArray = function(target) {
    if (!isArray(target)) target = [];
    loop(arguments, function(array, index) {
      if (index === 0 || !isDef(array)) return;
      if (!isArray(array)) {
        target.push(array);
      } else {
        loop(array, function(item) {
          if (isArray(item)) item = mergeArray([], item);
          target.push(item);
        });
      }
    });
    return target;
  };
  var arrayFindIndex = function (arr, pred) {
    for (var i = 0; i !== arr.length; ++i) {
      if (pred(arr[i])) {
        return i;
      }
    }
  
    return -1;
  };
  
  var arrayFind = function (arr, pred) {
    var idx = arrayFindIndex(arr, pred);
    return idx !== -1 ? arr[idx] : undefined;
  }; // coerce truthy value to array
  
  
  var coerceTruthyValueToArray = function (val) {
    if (Array.isArray(val)) {
      return val;
    } else if (val) {
      return [val];
    } else {
      return [];
    }
  };
  var createUuid = function() {
    var s4 = function() {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    };
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
  };
  var on = function(el, event, handler, options) {
    if (el && event && handler) {
      if (!isDef(options)) options = {passive: false};
      el.addEventListener(event, handler, options);
    }
  };
  var off = function(el, event, handler, options) {
    if (el && event) {
      if (!isDef(options)) options = {passive: false};
      el.removeEventListener(event, handler, options);
    }
  };
  var once = function(el, event, handler, options) {
    var listener = function() {
      isFunction(handler) && handler.apply(this, arguments);
      off(el, event, listener, options);
    };
    on(el, event, listener, options);
  };
  var removeNode = function(node) {
    node && node.parentElement && node.parentElement.removeChild(node);
  };
  var insertNodeAt = function(fatherNode, node, position) {
    isDef(position) && (position = position*1);
    if (!isNumber(position)) position = 0;
    var refNode = (position === 0) ? fatherNode.firstElementChild : fatherNode.children[position - 1].nextElementSibling;
    fatherNode.insertBefore(node, refNode);
  };
  var scrollBarWidth = function() {
    if (!isNumber(document.__scrollBarWidth__)) {
      var inner = document.createElement('div');
      inner.style.width = '100%';
      var outer = document.createElement('div');
      outer.style.visibility = 'hidden';
      outer.style.width = '100px';
      outer.style.overflow = 'scroll';
      outer.appendChild(inner);
      document.body.appendChild(outer);
      document.__scrollBarWidth__ = outer.offsetWidth - inner.offsetWidth;
      removeNode(inner);
      removeNode(outer);
    }
    return document.__scrollBarWidth__;
  };
  var hasClass = function(el, clazz) {
    if (!isElement(el) || !isString(clazz)) return false;
    return el.classList.contains(clazz);
  };
  var addClass = function(el, clazz) {
    if (isElement(el) && isString(clazz)) el.classList.add(clazz);
  };
  var removeClass = function(el, clazz) {
    if (isElement(el) && isString(clazz)) el.classList.remove(clazz);
  };
  var getStyle = function(el, styleName) {
    if (!isElement(el) || !isString(styleName)) return null;
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    return el.style[styleName] || getComputedStyle(el, null)[styleName];
  };
  var setStyle = function(el, styleName, value) {
    if (!isElement(el) || !isString(styleName)) return;
    el.style[styleName] = value;
  };
  var getCookie = function(name) {
    var arr = document.cookie.replace(/\s/g, '').split(';');
    for (var i = 0, j = arr.length; i < j; i++) {
      var tempArr = arr[i].split('=');
      if (tempArr[0] === name) return decodeURIComponent(tempArr[1]);
    }
    return null;
  };
  var setCookie = function(name, value, days) {
    isDef(days) && (days = days*1);
    if (!isNumber(days)) days = 1;
    var date = addDate((new Date), days);
    document.cookie = name + '=' + encodeURIComponent(value) + ';expires=' + date;
  };
  var removeCookie = function(name) {
    var val = getCookie(name);
    setCookie(name, val, -1);
  };
  var performance = function(delay, callback, throttleflg) {
    if (!isFunction(callback)) {
      callback = delay;
      delay = null;
    }
    if (!isFunction(callback)) return function() {};
    var defaultTimer = Object.create(null);
    var setTimer = requestAnimationFrame;
    var clearTimer = cancelAnimationFrame;
    if (isNumber(delay)) {
      setTimer = setTimeout;
      clearTimer = clearTimeout;
    }
    return function() {
      var self = this;
      var timer = null;
      if (!isDef(self)) {
        timer = defaultTimer;
      } else {
        if (!isDef(self[callback])) self[callback] = Object.create(null);
        timer = self[callback];
      }
      var args = arguments;
      if (throttleflg) {
        if (isDef(timer.__timer__)) return false;
      } else {
        clearTimer(timer.__timer__);
      }
      timer.__timer__ = setTimer(function() {
        callback.apply(self, args);
        clearTimer(timer.__timer__);
        timer.__timer__ = null;
      }, delay);
    };
  };
  var throttle = function(delay, callback) {
    return performance(delay, callback, true);
  };
  var debounce = function(delay, callback) {
    return performance(delay, callback);
  };
  var resizeListener = function(el, fn, removeFlg) {
    if (!isFunction(fn)) {
      fn = el;
      el = document.body;
    }
    if (!isArray(el.__resizeListeners__)) {
      var resetTrigger = function(el) {
        var trigger = el.__resizeTrigger__;
        var expand = trigger.firstElementChild;
        var contract = trigger.lastElementChild;
        var expandChild = expand.firstElementChild;
        contract.scrollLeft = contract.scrollWidth;
        contract.scrollTop = contract.scrollHeight;
        expandChild.style.width = expand.offsetWidth + 1 + 'px';
        expandChild.style.height = expand.offsetHeight + 1 + 'px';
        expand.scrollLeft = expand.scrollWidth;
        expand.scrollTop = expand.scrollHeight;
      };
      var resizeListeners = function(el, event) {
        if (el.offsetWidth !== el.__resizeLast__.width || el.offsetHeight !== el.__resizeLast__.height) {
          el.__resizeLast__.width = el.offsetWidth;
          el.__resizeLast__.height = el.offsetHeight;
          loop(el.__resizeListeners__, function(resizeListener) {
            resizeListener.call(el, event);
          });
        }
      };
      var scrollListener = debounce(function(event) {
        resetTrigger(el);
        resizeListeners(el, event);
      });
      var resizeStart = function(event) {
        if (event.animationName === 'resizeanim') {
          resetTrigger(el);
        }
      };
      if (getStyle(el, 'position') === 'static') {
        setStyle(el, 'position', 'relative');
      }
      var resizeTrigger = el.__resizeTrigger__ = document.createElement('div');
      resizeTrigger.className = 'resize-triggers';
      resizeTrigger.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>';
      on(resizeTrigger, 'animationstart', resizeStart);
      el.__resizeLast__ = {};
      el.__resizeListeners__ = [];
      el.appendChild(resizeTrigger);
      on(el, 'scroll', scrollListener, true);
    }
    if (removeFlg) {
      var index = el.__resizeListeners__.indexOf(fn);
      index !== -1 && el.__resizeListeners__.splice(index, 1);
    } else {
      isFunction(fn) && el.__resizeListeners__.push(fn);
    }
  };
  var addResizeListener = function(el, fn) {
    resizeListener(el, fn);
  };
  var removeResizeListener = function(el, fn) {
    resizeListener(el, fn, true);
  };
  var addHoverListener = function(el, inFn, outFn) {
    if (!isFunction(inFn)) return;
    on(el, 'mouseenter', inFn);
    if (!isFunction(outFn)) outFn = inFn;
    on(el, 'mouseleave', outFn);
  };
  var removeHoverListener = function(el, inFn, outFn) {
    if (!isFunction(inFn)) return;
    off(el, 'mouseenter', inFn);
    if (!isFunction(outFn)) outFn = inFn;
    off(el, 'mouseleave', outFn);
  };
  var addTouchStart = function(el, fn) {
    on(el, 'mousedown', fn);
    on(el, 'touchstart', fn);
  };
  var removeTouchStart = function(el, fn) {
    off(el, 'mousedown', fn);
    off(el, 'touchstart', fn);
  };
  var addTouchMove = function(el, fn) {
    on(el, 'mousemove', fn);
    on(el, 'touchmove', fn);
  };
  var removeTouchMove = function(el, fn) {
    off(el, 'mousemove', fn);
    off(el, 'touchmove', fn);
  };
  var addTouchEnd = function(el, fn) {
    on(el, 'mouseup', fn);
    on(el, 'touchend', fn);
  };
  var removeTouchEnd = function(el, fn) {
    off(el, 'mouseup', fn);
    off(el, 'touchend', fn);
  };
  var screenfull = function() {
    var fn = (function() {
      var fnMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror']
            , ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror']
            , ['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror']
            , ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror']
            , ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];
      var ret = {};
      for (var i = 0, l = fnMap.length; i < l; i++) {
        var val = fnMap[i];
        if (val[1] in document) {
          for (i = 0; i < val.length; i++) {
            ret[fnMap[0][i]] = val[i];
          }
          return ret;
        }
      }
      return null;
    })();
    if (!isDef(fn)) {
      Vue.notify.warning({message: Vue.t('vue.screenfull.canot')});
      return false;
    }
    var screenfull = {
      request: function(elem) {
        var request = fn.requestFullscreen;
        elem = elem || document.documentElement;
        if (/5\.1[.\d]* Safari/.test(navigator.userAgent)) {
          elem[request]();
        } else {
          elem[request]((typeof Element !== 'undefined' && 'ALLOW_KEYBOARD_INPUT' in Element) ? Element.ALLOW_KEYBOARD_INPUT : {});
        }
      },
      exit: function() {
        document[fn.exitFullscreen]();
      },
      toggle: function(elem) {
        if (this.isFullscreen) {
          this.exit();
        } else {
          this.request(elem);
        }
      },
      onchange: function(callback) {
        on(document, fn.fullscreenchange, callback);
      },
      onerror: function(callback) {
        on(document, fn.fullscreenerror, callback);
      },
      raw: fn
    };
    Object.defineProperties(screenfull, {
      isFullscreen: {
        get: function() {
          return Boolean(document[fn.fullscreenElement]);
        }
      },
      element: {
        enumerable: true,
        get: function() {
          return document[fn.fullscreenElement];
        }
      },
      enabled: {
        enumerable: true,
        get: function() {
          return Boolean(document[fn.fullscreenEnabled]);
        }
      }
    });
    if (!isDef(screenfull.enabled)) {
      Vue.notify.warning({message: Vue.t('vue.screenfull.canot')});
      return false;
    }
    screenfull.toggle();
  };
  var getSystemInfo = function() {
    return SystemInfo;
  };
  var setLang = function(lang) {
    if (isString(lang)) Vue.config.lang = lang;
  };
  var setLocale = function(lang, langObjs) {
    Vue.locale(lang, merge({}, Vue.locale(lang), langObjs));
  };
  var popupManager = {
    instances: {},
    zIndex: 2000,
    getInstance: function(id) {
      return popupManager.instances[id];
    },
    register: function(id, instance) {
      if (id && instance) {
        popupManager.instances[id] = instance;
      }
    },
    deregister: function(id) {
      if (id) {
        popupManager.instances[id] = null;
        delete popupManager.instances[id];
      }
    },
    setZindex: function(value) {
        return popupManager.zIndex = value;
    },
    nextZIndex: function() {
      return popupManager.zIndex++;
    },
    modalStack: [],
    openModal: function(id, zIndex) {
      if (!isDef(id) || !isDef(zIndex)) return;
      var modalStack = this.modalStack;
      for (var i = 0, j = modalStack.length; i < j; i++) {
        var item = modalStack[i];
        if (item.id === id) return;
      }
      this.modalStack.push({
        id: id,
        zIndex: zIndex
      });
    },
    closeModal: function(id) {
      var modalStack = this.modalStack;
      if (modalStack.length > 0) {
        var topItem = modalStack[modalStack.length - 1];
        if (topItem.id === id) {
          modalStack.pop();
        } else {
          for (var i = modalStack.length - 1; i >= 0; i--) {
            if (modalStack[i].id === id) {
              modalStack.splice(i, 1);
              break;
            }
          }
        }
      }
    }
  };
  var emitter = {
    methods: {
      dispatch: function(componentName, eventName, params) {
        var parent = this.$parent || this.$root;
        var name = parent.$options.name;
        while (parent && (!isDef(name) || name !== componentName)) {
          parent = parent.$parent;
          if (parent) {
            name = parent.$options.name;
          }
        }
        if (parent) {
          parent.$emit.apply(parent, mergeArray([eventName], params));
        }
      },
      broadcast: function(componentName, eventName, params) {
        var broadcast = function(componentName, eventName, params) {
          loop(this.$children, function(child) {
            var name = child.$options.name;
            if (name === componentName) {
              child.$emit.apply(child, mergeArray([eventName], params));
            } else {
              broadcast.apply(child, mergeArray([componentName, eventName], [params]));
            }
          });
        };
        broadcast.call(this, componentName, eventName, params);
      }
    }
  };
  var menumixin = {
    computed: {
      indexPath: function() {
        var path = [this.index];
        var parent = this.$parent;
        while (parent.$options.name !== 'VueMenu') {
          if (parent.index) {
            path.unshift(parent.index);
          }
          parent = parent.$parent;
        }
        return path;
      },
      rootMenu: function() {
        var parent = this.$parent;
        while (parent && parent.$options.name !== 'VueMenu') {
          parent = parent.$parent;
        }
        return parent;
      },
      parentMenu: function() {
        var parent = this.$parent;
        while (parent && ['VueMenu', 'VueSubmenu'].indexOf(parent.$options.name) === -1) {
          parent = parent.$parent;
        }
        return parent;
      },
      paddingStyle: function() {
        if (this.rootMenu.mode !== 'vertical') return {};
        var padding = 20;
        var parent = this.$parent;

        if (this.rootMenu.collapse) {
          return {
            paddingLeft: '20px',
            paddingRight: '20px'
          };
        } else {
          while (parent && parent.$options.name !== 'VueMenu') {
            if (parent.$options.name === 'VueSubmenu') {
              padding += 20;
            }
            parent = parent.$parent;
          }

          return {
            paddingLeft: padding + 'px'
          };
        }

        
      }
    }
  };
  var collapseTransition = {
    functional: true,
    render: function(createElement, obj) {
      var vueComponent = obj.parent;
      var children = obj.children;
      var data = {
        on: {
          'beforeEnter': function(el) {
            addClass(el, 'collapse-transition');
            if (!isDef(el.dataset)) el.dataset = {};
            el.dataset.oldPaddingTop = el.style.paddingTop;
            el.dataset.oldPaddingBottom = el.style.paddingBottom;
            el.style.height = '0';
            el.style.paddingTop = 0;
            el.style.paddingBottom = 0;
            if (isFunction(vueComponent.collapseBeforeEnter)) {
              vueComponent.collapseBeforeEnter();
            }
          },
          'enter': function(el) {
            el.dataset.oldOverflow = el.style.overflow;
            if (el.scrollHeight !== 0) {
              el.style.height = el.scrollHeight + 'px';
              el.style.paddingTop = el.dataset.oldPaddingTop;
              el.style.paddingBottom = el.dataset.oldPaddingBottom;
            } else {
              el.style.height = '';
              el.style.paddingTop = el.dataset.oldPaddingTop;
              el.style.paddingBottom = el.dataset.oldPaddingBottom;
            }
            el.style.overflow = 'hidden';
            if (isFunction(vueComponent.collapseEnter)) {
              vueComponent.collapseEnter();
            }
          },
          'afterEnter': function(el) {
            removeClass(el, 'collapse-transition');
            el.style.height = '';
            el.style.overflow = el.dataset.oldOverflow;
            if (isFunction(vueComponent.collapseAfterEnter)) {
              vueComponent.collapseAfterEnter();
            }
          },
          'beforeLeave': function(el) {
            if (!isDef(el.dataset)) el.dataset = {};
            el.dataset.oldPaddingTop = el.style.paddingTop;
            el.dataset.oldPaddingBottom = el.style.paddingBottom;
            el.dataset.oldOverflow = el.style.overflow;
            el.style.height = el.scrollHeight + 'px';
            el.style.overflow = 'hidden';
            if (isFunction(vueComponent.collapseBeforeLeave)) {
              vueComponent.collapseBeforeLeave();
            }
          },
          'leave': function(el) {
            if (el.scrollHeight !== 0) {
              addClass(el, 'collapse-transition');
              el.style.height = 0;
              el.style.paddingTop = 0;
              el.style.paddingBottom = 0;
            }
            if (isFunction(vueComponent.collapseLeave)) {
              vueComponent.collapseLeave();
            }
          },
          'afterLeave': function(el) {
            removeClass(el, 'collapse-transition');
            el.style.height = '';
            el.style.overflow = el.dataset.oldOverflow;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
            if (isFunction(vueComponent.collapseAfterLeave)) {
              vueComponent.collapseAfterLeave();
            }
          }
        }
      };
      return createElement('transition', data, children);
    }
  };
  var clickoutside = function() {
    var startClick;
    var nodes = document.__clickoutsideNodes__;
    var CTX = '__clickoutsideContext__';
    if (!isArray(nodes)) {
      nodes = document.__clickoutsideNodes__ = [];
      var clickOutSideFn = function(mouseup, mousedown) {
        mouseup = mouseup || {};
        mousedown = mousedown || {};
        loop(nodes, function(node) {
          var vnode = node[CTX].vnode;
          var binding = node[CTX].binding;
          if (!vnode ||
            !vnode.context ||
            !mouseup.target ||
            !mousedown.target ||
            node.contains(mouseup.target) ||
            node.contains(mousedown.target) ||
            node === mouseup.target ||
            (vnode.context.popperElm &&
            (vnode.context.popperElm.contains(mouseup.target) ||
            vnode.context.popperElm.contains(mousedown.target)))) return;
            
          if (isDef(binding.expression) && isFunction(vnode.context[binding.expression])) {
            vnode.context[binding.expression]();
          } else {
            isFunction(binding.value) && binding.value();
          }
        });
      };
      on(document, 'mousedown', function(e) {
        startClick = e;
      });
      on(document, 'mouseup', function(e) {
        clickOutSideFn(e, startClick);
      });
    }
    return {
      bind: function(el, binding, vnode) {
        el[CTX] = {
          id: createUuid(),
          vnode: vnode,
          binding: binding
        };
        nodes.push(el);
      },
      update: function(el, binding, vnode) {
        el[CTX].binding = binding;
        el[CTX].vnode = vnode;
      },
      unbind: function(el) {
        var id = el[CTX].id;
        loop(nodes, function(node, i) {
          if (node[CTX].id === id) {
            nodes.splice(i, 1);
            delete el[CTX];
            return false;
          }
        });
      }
    };
  };
  var repeatClick = {
    bind: function bind(el, binding, vnode) {
      var interval = null;
      var startTime;
  
      var handler = function () {
        return vnode.context[binding.expression].apply();
      };
  
      var clear = function () {
        if (Date.now() - startTime < 100) {
          handler();
        }
  
        clearInterval(interval);
        interval = null;
      };
  
      on(el, 'mousedown', function (e) {
        if (e.button !== 0) return;
        startTime = Date.now();
        once(document, 'mouseup', clear);
        clearInterval(interval);
        interval = setInterval(handler, 100);
      });
    }
  };
  var getScrollParent = function(el) {
    var parent = el.parentNode;
    if (!isDef(parent)) {
      return el;
    }
    if (parent === document) {
      if (document.body.scrollTop) {
        return document.body;
      } else {
        return document.documentElement;
      }
    }
    if ((['scroll', 'auto'].indexOf(getStyle(parent, 'overflowX')) !== -1 && parent.scrollWidth > parent.clientWidth)
     || (['scroll', 'auto'].indexOf(getStyle(parent, 'overflowY')) !== -1 && parent.scrollHeight > parent.clientHeight)
     || hasClass(parent, 'vue-scrollbar__wrap')) {
      return parent;
    }
    return getScrollParent(el.parentNode);
  };
  var config = new Vue({
    data: function() {
      return {
        notifyStack: false,
        produceModel: false
      };
    },
    watch: {
      produceModel: function(val) {
        Vue.config.productionTip = !val;
        Vue.config.devtools = !val;
        Vue.config.silent = val;
      }
    }
  });

  var keyCode = function keyCode(searchInput) {
    // Keyboard Events
    if (searchInput && typeof searchInput === 'object') {
      var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
  
      if (hasKeyCode) {
        searchInput = hasKeyCode;
      }
    }
  
  
    var search = String(searchInput); // check codes
  
    var foundNamedKeyCodes = codes[search.toLowerCase()];
  
    if (foundNamedKeyCodes) {
      return foundNamedKeyCodes;
    } // check aliases
  
  
    var foundNamedKeyAliases = aliases[search.toLowerCase()];
  
    if (foundNamedKeyAliases) {
      return foundNamedKeyAliases;
    } // weird character?
  
  
    if (search.length === 1) {
      return search.charCodeAt(0);
    }
  
    return undefined;
  };
  
  var codes = {
    'backspace': 8,
    'tab': 9,
    'enter': 13,
    'shift': 16,
    'ctrl': 17,
    'alt': 18,
    'pause/break': 19,
    'caps lock': 20,
    'esc': 27,
    'space': 32,
    'page up': 33,
    'page down': 34,
    'end': 35,
    'home': 36,
    'left': 37,
    'up': 38,
    'right': 39,
    'down': 40,
    // 'add': 43,
    'insert': 45,
    'delete': 46,
    'command': 91,
    'left command': 91,
    'right command': 93,
    'numpad *': 106,
    // 'numpad +': 107,
    'numpad +': 43,
    'numpad add': 43,
    // as a trick
    'numpad -': 109,
    'numpad .': 110,
    'numpad /': 111,
    'num lock': 144,
    'scroll lock': 145,
    'my computer': 182,
    'my calculator': 183,
    ';': 186,
    '=': 187,
    ',': 188,
    '-': 189,
    '.': 190,
    '/': 191,
    '`': 192,
    '[': 219,
    '\\': 220,
    ']': 221,
    '\'': 222 // Helper aliases
  
  };
  var aliases = {
    'windows': 91,
    '': 16,
    '': 18,
    '': 17,
    '': 91,
    'ctl': 17,
    'control': 17,
    'option': 18,
    'pause': 19,
    'break': 19,
    'caps': 20,
    'return': 13,
    'escape': 27,
    'spc': 32,
    'pgup': 33,
    'pgdn': 34,
    'ins': 45,
    'del': 46,
    'cmd': 91
    /*!
     * Programatically add the following
     */
    // lower case chars
  
  };
  
  for (var i = 97; i < 123; i++) {
    codes[String.fromCharCode(i)] = i - 32;
  } // numbers
  
  
  for (var _i = 48; _i < 58; _i++) {
    codes[_i - 48] = _i;
  } // function keys
  
  
  for (var _i2 = 1; _i2 < 13; _i2++) {
    codes['f' + _i2] = _i2 + 111;
  } // numpad keys
  
  
  for (var _i3 = 0; _i3 < 10; _i3++) {
    codes['numpad ' + _i3] = _i3 + 96;
  }
  
  var noop = function noop() {};
  
  var getKeyMap = function getKeyMap(key, bind) {
      var result = {};
      var keyup = bind.keyup;
      var keydown = bind.keydown;
      key.replace('numpad +', 'numpad add').split('+').forEach(function (keyName) {
        switch (keyName.toLowerCase()) {
          case 'ctrl':
          case 'alt':
          case 'shift':
          case 'meta':
            result[keyName] = true;
            break;
  
          default:
            result.keyCode = keyCode(keyName);
        }
      });
      result.callback = {
        keydown: keydown || (keyup ? noop : bind),
        keyup: keyup || noop
      };
      return result;
  };

  function isElementTopLayer(el) {
    var elPos = el.getBoundingClientRect();
    var x = Math.ceil(elPos.left);
    var y = Math.ceil(elPos.top);

    var offset = 3;//3
    var topElementXY = document.elementFromPoint(x + offset, y + offset);
    if(topElementXY == el || el.contains(topElementXY)) {
      return true;
    }
    return false;
  }

  var hotkeyHandlers = {
    click: function (e, el) {
      if(isElementTopLayer(el)) {
        setTimeout(function() {
          el.click();
        }, 0);
      }
    },

    focus: function (e, el) {
      if(isElementTopLayer(el)) {
        setTimeout(function() {
          var vueObj = el.__vue__;
          if(vueObj) {
            if(vueObj.focus) {
              vueObj.focus();
              return;
            } else if(vueObj.$refs.input) {
              vueObj.$refs.input.focus && vueObj.$refs.input.focus();
              return;
            }
          }
          el.focus();
        }, 0);
      }
    },
  };
  function bindEvent(el, binding) {
    var key = binding.arg;
    var handler = binding.value || 'click';
    
    if (typeof handler === 'string') {
      handler = hotkeyHandlers[handler];
    }
    if(!handler) return;

    el._keymap = getKeyMap(key, handler);
    var allow = binding.modifiers.allow || false;

    el._keyHandler = function (e) {
        var hotkey = el._keymap;
        var callback = hotkey.keyCode === e.keyCode &&
          !!hotkey.ctrl === e.ctrlKey &&
          !!hotkey.alt === e.altKey &&
          !!hotkey.shift === e.shiftKey &&
          !!hotkey.meta === e.metaKey &&
          hotkey.callback[e.type];

        if(callback && !allow) {
          e.preventDefault();

          //ie11 f1 problem
          if ( 'onhelp' in window && e.keyCode == 112) {
            window.onhelp = function () {
              return false;
            };
          }
        }
        callback && callback(e, el);
    };
  
    document.addEventListener('keydown', el._keyHandler);
    document.addEventListener('keyup', el._keyHandler);
  }
  
  function unbindEvent(el) {
    document.removeEventListener('keydown', el._keyHandler);
    document.removeEventListener('keyup', el._keyHandler);
  }
  
  Vue.directive('hotkey', {
    bind: function (el, binding) {
      bindEvent.call(this, el, binding);
    },
    componentUpdated: function (el, binding) {
      if (binding.value !== binding.oldValue) {
        unbindEvent.call(this, arguments);
        bindEvent.apply(this, el, binding);
      }
    },
    unbind: unbindEvent
  });
  
  var VueUtil = {
    isDef: isDef,
    isString: isString,
    isNumber: isNumber,
    isNumberStr: isNumberStr,
    isBoolean: isBoolean,
    isFile: isFile,
    isObject: isObject,
    isArray: isArray,
    isFunction: isFunction,
    isDate: isDate,
    isDateObject: isDateObject,
    isNodeList: isNodeList,
    isElement: isElement,
    isVNode: isVNode,
    isVueComponent: isVueComponent,
    toString: toString,
    toDate: toDate,
    formatNumber: formatNumber,
    formatDate: formatDate,
    range: range,
    modifyDate: modifyDate,
    modifyTime: modifyTime,
    modifyWithTimeString: modifyWithTimeString,
    clearTime: clearTime,
    clearMilliseconds: clearMilliseconds,
    limitTimeRange: limitTimeRange,
    parseDate: parseDate,
    prevDate: prevDate,
    nextDate: nextDate,
    timeWithinRange: timeWithinRange,
    changeYearMonthAndClampDate:changeYearMonthAndClampDate,
    prevMonth: prevMonth,
    nextMonth: nextMonth,
    prevYear: prevYear,
    nextYear: nextYear,
    getDayCountOfMonth: getDayCountOfMonth,
    getDayCountOfYear: getDayCountOfYear,
    getFirstDayOfMonth: getFirstDayOfMonth,
    getStartDateOfMonth: getStartDateOfMonth,
    getWeekNumber: getWeekNumber,
    getRangeHours: getRangeHours,
    setRangeData: setRangeData,
    getRangeMinutes: getRangeMinutes,
    addDate: addDate,
    extractDateFormat: extractDateFormat,
    extractTimeFormat: extractTimeFormat,
    loop: loop,
    ownPropertyLoop: ownPropertyLoop,
    map: map,
    filter: filter,
    trim: trim,
    deepCopy: deepCopy,
    merge: merge,
    mergeArray: mergeArray,
    arrayFindIndex: arrayFindIndex,
    arrayFind: arrayFind,
    coerceTruthyValueToArray: coerceTruthyValueToArray,
    createUuid: createUuid,
    on: on,
    off: off,
    once: once,
    removeNode: removeNode,
    insertNodeAt: insertNodeAt,
    scrollBarWidth: scrollBarWidth,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    getStyle: getStyle,
    setStyle: setStyle,
    getCookie: getCookie,
    setCookie: setCookie,
    removeCookie: removeCookie,
    throttle: throttle,
    debounce: debounce,
    addResizeListener: addResizeListener,
    removeResizeListener: removeResizeListener,
    addHoverListener: addHoverListener,
    removeHoverListener: removeHoverListener,
    addTouchStart: addTouchStart,
    addTouchMove: addTouchMove,
    addTouchEnd: addTouchEnd,
    removeTouchStart: removeTouchStart,
    removeTouchMove: removeTouchMove,
    removeTouchEnd: removeTouchEnd,
    screenfull: screenfull,
    getSystemInfo: getSystemInfo,
    setLang: setLang,
    setLocale: setLocale,
    config: config,
    nextZIndex: popupManager.nextZIndex,
    setZIndex: popupManager.setZindex,
    version: version,
    isIE: SystemInfo.browser.toLowerCase() === 'ie',
    isFirefox: SystemInfo.browser.toLowerCase() === 'firefox',
    isChrome: SystemInfo.browser.toLowerCase() === 'chrome',
    component: {
      menumixin: menumixin,
      emitter: emitter,
      collapseTransition: collapseTransition,
      clickoutside: clickoutside,
      repeatClick: repeatClick,
      popupManager: popupManager,
      getScrollParent: getScrollParent
    },
    hotkeyHandlers: hotkeyHandlers,
    _: _
  };
   Vue.prototype.$vu = VueUtil;
  return VueUtil;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(definition);
  } else {
    context.Sortable = definition();
  }
})(this, function() {
  'use strict';
  var dragEl;
  var parentEl;
  var ghostEl;
  var cloneEl;
  var rootEl;
  var nextEl;
  var lastDownEl;
  var scrollEl;
  var scrollParentEl;
  var scrollCustomFn;
  var lastEl;
  var lastCSS;
  var lastParentCSS;
  var oldIndex;
  var newIndex;
  var activeGroup;
  var putSortable;
  var autoScroll = {};
  var tapEvt;
  var touchEvt;
  var moved;
  var R_SPACE = /\s+/g;
  var R_FLOAT = /left|right|inline/;
  var expando = 'Sortable' + (new Date).getTime();
  var win = window;
  var document = win.document;
  var parseInt = win.parseInt;
  var requestAnimationFrame = win.requestAnimationFrame;
  var cancelAnimationFrame = win.cancelAnimationFrame;
  var Polymer = win.Polymer;
  var captureMode = false;
  var passiveMode = false;
  var supportDraggable = ('draggable' in document.createElement('div'));
  var supportCssPointerEvents = (function(el) {
    if (navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie)/i)) {
      return false;
    }
    el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  })();
  var _silent = false;
  var abs = Math.abs;
  var min = Math.min;
  var savedInputChecked = [];
  var touchDragOverListeners = [];
  var _autoScroll = _throttle(function(evt, options, rootEl) {
    if (rootEl && options.scroll) {
      var _this = rootEl[expando], el, rect, sens = options.scrollSensitivity, speed = options.scrollSpeed, x = evt.clientX, y = evt.clientY, winWidth = innerWidth, winHeight = innerHeight, vx, vy, scrollOffsetX, scrollOffsetY;
      if (scrollParentEl !== rootEl) {
        scrollEl = options.scroll;
        scrollParentEl = rootEl;
        scrollCustomFn = options.scrollFn;
        if (scrollEl === true) {
          scrollEl = rootEl;
          do {
            if ((scrollEl.offsetWidth < scrollEl.scrollWidth) || (scrollEl.offsetHeight < scrollEl.scrollHeight)) {
              break;
            }
          } while (scrollEl = scrollEl.parentNode);
        }
      }
      if (scrollEl) {
        el = scrollEl;
        rect = scrollEl.getBoundingClientRect();
        vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);
        vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);
      }
      if (!(vx || vy)) {
        vx = (winWidth - x <= sens) - (x <= sens);
        vy = (winHeight - y <= sens) - (y <= sens);
        (vx || vy) && (el = win);
      }
      if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
        autoScroll.el = el;
        autoScroll.vx = vx;
        autoScroll.vy = vy;
        clearInterval(autoScroll.pid);
        if (el) {
          autoScroll.pid = setInterval(function() {
            scrollOffsetY = vy ? vy * speed : 0;
            scrollOffsetX = vx ? vx * speed : 0;
            if ('function' === typeof (scrollCustomFn)) {
              return scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt);
            }
            if (el === win) {
              win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);
            } else {
              el.scrollTop += scrollOffsetY;
              el.scrollLeft += scrollOffsetX;
            }
          }, 24);
        }
      }
    }
  });
  var _prepareGroup = function(options) {
    function toFn(value, pull) {
      if (value === void 0 || value === true) {
        value = group.name;
      }
      if (typeof value === 'function') {
        return value;
      } else {
        return function(to, from) {
          var fromGroup = from.options.group.name;
          return pull ? value : value && (value.join ? value.indexOf(fromGroup) !== -1 : (fromGroup == value));
        };
      }
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || typeof originalGroup != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  };
  try {
    addEventListener('test', null, Object.defineProperty({}, 'passive', {
      get: function() {
        passiveMode = false;
        captureMode = {
          capture: false,
          passive: passiveMode
        };
      }
    }));
  } catch (e) {
    throw e;
  }
  function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw 'Sortable: ' + el + ' must be HTMLElement, and not ' + Object.prototype.toString.call(el);
    }
    this.el = el;
    this.options = options = _extend({}, options);
    el[expando] = this;
    var defaults = {
      group: Math.random(),
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      scroll: true,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      draggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',
      ghostClass: 'sortable-ghost',
      chosenClass: 'sortable-chosen',
      dragClass: 'sortable-drag',
      ignore: 'a, img',
      filter: null,
      preventOnFilter: true,
      setData: function(dataTransfer, dragEl) {
        dataTransfer.setData('Text', dragEl.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: 'data-id',
      forceFallback: false,
      fallbackClass: 'sortable-fallback',
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      supportPointer: Sortable.supportPointer !== false
    };
    for (var name in defaults) {
      !(name in options) && (options[name] = defaults[name]);
    }
    _prepareGroup(options);
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
    this.nativeDraggable = options.forceFallback ? false : supportDraggable;
    _on(el, 'mousedown', this._onTapStart);
    _on(el, 'touchstart', this._onTapStart);
    options.supportPointer && _on(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      _on(el, 'dragover', this);
      _on(el, 'dragenter', this);
    }
    touchDragOverListeners.push(this._onDragOver);
    options.store && this.sort(options.store.get(this));
  }
  Sortable.prototype = {
    constructor: Sortable,
    _onTapStart: function(evt) {
      var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0], target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0]) || target, filter = options.filter, startIndex;
      _saveInputCheckedState(el);
      if (dragEl) {
        return;
      }
      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return;
      }
      if (originalTarget.isContentEditable) {
        return;
      }
      target = _closest(target, options.draggable, el);
      if (!target) {
        return;
      }
      if (lastDownEl === target) {
        return;
      }
      startIndex = _index(target, options.draggable);
      if (typeof filter === 'function') {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent(_this, originalTarget, 'filter', target, el, el, startIndex);
          preventOnFilter && evt.preventDefault();
          return;
        }
      } else if (filter) {
        filter = filter.split(',').some(function(criteria) {
          criteria = _closest(originalTarget, criteria.trim(), el);
          if (criteria) {
            _dispatchEvent(_this, criteria, 'filter', target, el, el, startIndex);
            return true;
          }
        });
        if (filter) {
          preventOnFilter && evt.preventDefault();
          return;
        }
      }
      if (options.handle && !_closest(originalTarget, options.handle, el)) {
        return;
      }
      this._prepareDragStart(evt, touch, target, startIndex);
    },
    _prepareDragStart: function(evt, touch, target, startIndex) {
      var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
      if (target && !dragEl && (target.parentNode === el)) {
        tapEvt = evt;
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        oldIndex = startIndex;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style['will-change'] = 'all';
        dragStartFn = function() {
          _this._disableDelayedDrag();
          dragEl.draggable = _this.nativeDraggable;
          _toggleClass(dragEl, options.chosenClass, true);
          _this._triggerDragStart(evt, touch);
          _dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, rootEl, oldIndex);
        };
        options.ignore.split(',').forEach(function(criteria) {
          _find(dragEl, criteria.trim(), _disableDraggable);
        });
        _on(ownerDocument, 'mouseup', _this._onDrop);
        _on(ownerDocument, 'touchend', _this._onDrop);
        _on(ownerDocument, 'touchcancel', _this._onDrop);
        _on(ownerDocument, 'selectstart', _this);
        options.supportPointer && _on(ownerDocument, 'pointercancel', _this._onDrop);
        dragStartFn();
      }
    },
    _disableDelayedDrag: function() {
      var ownerDocument = this.el.ownerDocument;
      _off(ownerDocument, 'mouseup', this._disableDelayedDrag);
      _off(ownerDocument, 'touchend', this._disableDelayedDrag);
      _off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
      _off(ownerDocument, 'mousemove', this._disableDelayedDrag);
      _off(ownerDocument, 'touchmove', this._disableDelayedDrag);
      _off(ownerDocument, 'pointermove', this._disableDelayedDrag);
    },
    _triggerDragStart: function(evt, touch) {
      touch = touch || (evt.pointerType == 'touch' ? evt : null);
      if (touch) {
        tapEvt = {
          target: dragEl,
          clientX: touch.clientX,
          clientY: touch.clientY
        };
        this._onDragStart(tapEvt, 'touch');
      } else if (!this.nativeDraggable) {
        this._onDragStart(tapEvt, true);
      } else {
        _on(dragEl, 'dragend', this);
        _on(rootEl, 'dragstart', this._onDragStart);
      }
      try {
        if (document.selection) {
          var emptyTimer = requestAnimationFrame(function() {
            document.selection.empty();
            cancelAnimationFrame(emptyTimer);
          });
        } else {
          getSelection().removeAllRanges();
        }
      } catch (e) {
        throw e;
      }
    },
    _dragStarted: function() {
      if (rootEl && dragEl) {
        var options = this.options;
        _toggleClass(dragEl, options.ghostClass, true);
        _toggleClass(dragEl, options.dragClass, false);
        Sortable.active = this;
        _dispatchEvent(this, rootEl, 'start', dragEl, rootEl, rootEl, oldIndex);
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function() {
      if (touchEvt) {
        if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {
          return;
        }
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;
        if (!supportCssPointerEvents) {
          _css(ghostEl, 'display', 'none');
        }
        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;
        var i = touchDragOverListeners.length;
        if (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          parent = target;
        }
        if (parent) {
          do {
            if (parent[expando]) {
              while (i--) {
                touchDragOverListeners[i]({
                  clientX: touchEvt.clientX,
                  clientY: touchEvt.clientY,
                  target: target,
                  rootEl: parent
                });
              }
              break;
            }
            target = parent;
          } while (parent = parent.parentNode);
        }
        if (!supportCssPointerEvents) {
          _css(ghostEl, 'display', '');
        }
      }
    },
    _onTouchMove: function(evt) {
      if (tapEvt) {
        var options = this.options;
        var fallbackTolerance = options.fallbackTolerance;
        var fallbackOffset = options.fallbackOffset;
        var touch = evt.touches ? evt.touches[0] : evt;
        var dx = (touch.clientX - tapEvt.clientX) + fallbackOffset.x;
        var dy = (touch.clientY - tapEvt.clientY) + fallbackOffset.y;
        var translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';
        if (!Sortable.active) {
          if (fallbackTolerance && min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }
          this._dragStarted();
        }
        this._appendGhost();
        moved = true;
        touchEvt = touch;
        _css(ghostEl, 'webkitTransform', translate3d);
        _css(ghostEl, 'mozTransform', translate3d);
        _css(ghostEl, 'msTransform', translate3d);
        _css(ghostEl, 'transform', translate3d);
        evt.preventDefault();
      }
    },
    _appendGhost: function() {
      if (!ghostEl) {
        var rect = dragEl.getBoundingClientRect(), css = _css(dragEl), options = this.options, ghostRect;
        ghostEl = dragEl.cloneNode(true);
        _toggleClass(ghostEl, options.ghostClass, false);
        _toggleClass(ghostEl, options.fallbackClass, true);
        _toggleClass(ghostEl, options.dragClass, true);
        _css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));
        _css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));
        _css(ghostEl, 'width', rect.width);
        _css(ghostEl, 'height', rect.height);
        _css(ghostEl, 'opacity', '0.8');
        _css(ghostEl, 'position', 'fixed');
        _css(ghostEl, 'zIndex', '100000');
        _css(ghostEl, 'pointerEvents', 'none');
        options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);
        ghostRect = ghostEl.getBoundingClientRect();
        _css(ghostEl, 'width', rect.width * 2 - ghostRect.width);
        _css(ghostEl, 'height', rect.height * 2 - ghostRect.height);
      }
    },
    _onDragStart: function(evt, useFallback) {
      var _this = this;
      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      _this._offUpEvents();
      if (activeGroup.checkPull(_this, _this, dragEl, evt)) {
        cloneEl = _clone(dragEl);
        cloneEl.draggable = false;
        cloneEl.style['will-change'] = '';
        _css(cloneEl, 'display', 'none');
        _toggleClass(cloneEl, _this.options.chosenClass, false);
        _this._cloneId = _nextTick(function() {
          rootEl.insertBefore(cloneEl, dragEl);
          _dispatchEvent(_this, rootEl, 'clone', dragEl);
        });
      }
      _toggleClass(dragEl, options.dragClass, true);
      if (useFallback) {
        if (useFallback === 'touch') {
          _on(document, 'touchmove', _this._onTouchMove);
          _on(document, 'touchend', _this._onDrop);
          _on(document, 'touchcancel', _this._onDrop);
          if (options.supportPointer) {
            _on(document, 'pointermove', _this._onTouchMove);
            _on(document, 'pointerup', _this._onDrop);
          }
        } else {
          _on(document, 'mousemove', _this._onTouchMove);
          _on(document, 'mouseup', _this._onDrop);
        }
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        if (dataTransfer) {
          dataTransfer.effectAllowed = 'move';
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }
        _on(document, 'drop', _this);
        _this._dragStartId = _nextTick(_this._dragStarted);
      }
    },
    _onDragOver: function(evt) {
      var el = this.el, target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = (activeGroup === group), isMovingBetweenSortable = false, canSort = options.sort;
      if (evt.preventDefault !== void 0) {
        evt.preventDefault();
        !options.dragoverBubble && evt.stopPropagation();
      }
      if (dragEl.animated) {
        return;
      }
      moved = true;
      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) : (putSortable === this || ((activeSortable.lastPullMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt)))) && (evt.rootEl === void 0 || evt.rootEl === this.el)) {
        _autoScroll(evt, options, this.el);
        if (_silent) {
          return;
        }
        target = _closest(evt.target, options.draggable, el);
        dragRect = dragEl.getBoundingClientRect();
        if (putSortable !== this) {
          putSortable = this;
          isMovingBetweenSortable = true;
        }
        if (revert) {
          _cloneHide(activeSortable, true);
          parentEl = rootEl;
          if (cloneEl || nextEl) {
            rootEl.insertBefore(dragEl, cloneEl || nextEl);
          } else if (!canSort) {
            rootEl.appendChild(dragEl);
          }
          return;
        }
        if ((el.children.length === 0) || (el.children[0] === ghostEl) || (el === evt.target) && (_ghostIsLast(el, evt))) {
          if (el.children.length !== 0 && el.children[0] !== ghostEl && el === evt.target) {
            target = el.lastElementChild;
          }
          if (target) {
            if (target.animated) {
              return;
            }
            targetRect = target.getBoundingClientRect();
          }
          _cloneHide(activeSortable, isOwner);
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt) !== false) {
            if (!dragEl.contains(el)) {
              el.appendChild(dragEl);
              parentEl = el;
            }
          }
        } else if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {
          if (lastEl !== target) {
            lastEl = target;
            lastCSS = _css(target);
            lastParentCSS = _css(target.parentNode);
          }
          targetRect = target.getBoundingClientRect();
          var width = targetRect.right - targetRect.left;
          var height = targetRect.bottom - targetRect.top;
          var floating = R_FLOAT.test(lastCSS.cssFloat + lastCSS.display) || (lastParentCSS.display == 'flex' && lastParentCSS['flex-direction'].indexOf('row') === 0);
          var isWide = (target.offsetWidth > dragEl.offsetWidth);
          var isLong = (target.offsetHeight > dragEl.offsetHeight);
          var halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5;
          var nextSibling = target.nextElementSibling;
          var after = false;
          if (floating) {
            var elTop = dragEl.offsetTop;
            var tgTop = target.offsetTop;
            if (elTop === tgTop) {
              after = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;
            } else if (target.previousElementSibling === dragEl || dragEl.previousElementSibling === target) {
              after = (evt.clientY - targetRect.top) / height > 0.5;
            } else {
              after = tgTop > elTop;
            }
          } else if (!isMovingBetweenSortable) {
            after = (nextSibling !== dragEl) && !isLong || halfway && isLong;
          }
          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = (moveVector === 1);
            }
            _silent = true;
            var unsilentTimer = requestAnimationFrame(function() {
              _unsilent();
              cancelAnimationFrame(unsilentTimer);
            });
            _cloneHide(activeSortable, isOwner);
            if (!dragEl.contains(el)) {
              if (after && !nextSibling) {
                el.appendChild(dragEl);
              } else {
                target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
              }
            }
            parentEl = dragEl.parentNode;
          }
        }
      }
    },
    _offUpEvents: function() {
      var ownerDocument = this.el.ownerDocument;
      _off(document, 'touchmove', this._onTouchMove);
      _off(document, 'pointermove', this._onTouchMove);
      _off(ownerDocument, 'mouseup', this._onDrop);
      _off(ownerDocument, 'touchend', this._onDrop);
      _off(ownerDocument, 'pointerup', this._onDrop);
      _off(ownerDocument, 'touchcancel', this._onDrop);
      _off(ownerDocument, 'pointercancel', this._onDrop);
      _off(ownerDocument, 'selectstart', this);
    },
    _onDrop: function(evt) {
      var el = this.el;
      var options = this.options;
      clearInterval(this._loopId);
      clearInterval(autoScroll.pid);
      _cancelNextTick(this._cloneId);
      _cancelNextTick(this._dragStartId);
      _off(document, 'mouseover', this);
      _off(document, 'mousemove', this._onTouchMove);
      if (this.nativeDraggable) {
        _off(document, 'drop', this);
        _off(el, 'dragstart', this._onDragStart);
      }
      this._offUpEvents();
      if (evt) {
        if (moved) {
          evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }
        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
        if (rootEl === parentEl || Sortable.active.lastPullMode !== 'clone') {
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }
        if (dragEl) {
          if (this.nativeDraggable) {
            _off(dragEl, 'dragend', this);
          }
          _disableDraggable(dragEl);
          dragEl.style['will-change'] = '';
          _toggleClass(dragEl, this.options.ghostClass, false);
          _toggleClass(dragEl, this.options.chosenClass, false);
          _dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex);
          if (rootEl !== parentEl) {
            newIndex = _index(dragEl, options.draggable);
            if (newIndex >= 0) {
              _dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex);
              _dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex);
              _dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex);
              _dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex);
            }
          } else {
            if (dragEl.nextSibling !== nextEl) {
              newIndex = _index(dragEl, options.draggable);
              if (newIndex >= 0) {
                _dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex);
                _dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex);
              }
            }
          }
          if (Sortable.active) {
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
            }
            _dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex);
            this.save();
          }
        }
      }
      this._nulling();
    },
    _nulling: function() {
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = scrollEl = scrollParentEl = tapEvt = touchEvt = moved = newIndex = lastEl = lastCSS = putSortable = activeGroup = Sortable.active = null;
      savedInputChecked.forEach(function(el) {
        el.checked = true;
      });
      savedInputChecked.length = 0;
    },
    handleEvent: function(evt) {
      switch (evt.type) {
        case 'drop':
        case 'dragend':
          this._onDrop(evt);
          break;
        case 'dragover':
        case 'dragenter':
          if (dragEl) {
            this._onDragOver(evt);
            _globalDragOver(evt);
          }
          break;
        case 'mouseover':
          this._onDrop(evt);
          break;
        case 'selectstart':
          evt.preventDefault();
          break;
      }
    },
    toArray: function() {
      var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
      for (; i < n; i++) {
        el = children[i];
        if (_closest(el, options.draggable, this.el)) {
          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }
      return order;
    },
    sort: function(order) {
      var items = {};
      var rootEl = this.el;
      this.toArray().forEach(function(id, i) {
        var el = rootEl.children[i];
        if (_closest(el, this.options.draggable, rootEl)) {
          items[id] = el;
        }
      }, this);
      order.forEach(function(id) {
        if (items[id]) {
          rootEl.removeChild(items[id]);
          rootEl.appendChild(items[id]);
        }
      });
    },
    save: function() {
      var store = this.options.store;
      store && store.set(this);
    },
    closest: function(el, selector) {
      return _closest(el, selector || this.options.draggable, this.el);
    },
    option: function(name, value) {
      var options = this.options;
      if (value === void 0) {
        return options[name];
      } else {
        options[name] = value;
        if (name === 'group') {
          _prepareGroup(options);
        }
      }
    },
    destroy: function() {
      var el = this.el;
      el[expando] = null;
      _off(el, 'mousedown', this._onTapStart);
      _off(el, 'touchstart', this._onTapStart);
      _off(el, 'pointerdown', this._onTapStart);
      if (this.nativeDraggable) {
        _off(el, 'dragover', this);
        _off(el, 'dragenter', this);
      }
      [].forEach.call(el.querySelectorAll('[draggable]'), function(el) {
        el.removeAttribute('draggable');
      });
      touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);
      this._onDrop();
      this.el = el = null;
    }
  };
  function _cloneHide(sortable, state) {
    if (sortable.lastPullMode !== 'clone') {
      state = true;
    }
    if (cloneEl && (cloneEl.state !== state)) {
      _css(cloneEl, 'display', state ? 'none' : '');
      if (!state) {
        if (cloneEl.state) {
          if (sortable.options.group.revertClone) {
            rootEl.insertBefore(cloneEl, nextEl);
          } else {
            rootEl.insertBefore(cloneEl, dragEl);
          }
        }
      }
      cloneEl.state = state;
    }
  }
  function _closest(el, selector, ctx) {
    if (el) {
      ctx = ctx || document;
      do {
        if ((selector === '>*' && el.parentNode === ctx) || _matches(el, selector)) {
          return el;
        }
      } while (el = _getParentOrHost(el));
    }
    return null;
  }
  function _getParentOrHost(el) {
    var parent = el.host;
    return (parent && parent.nodeType) ? parent : el.parentNode;
  }
  function _globalDragOver(evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = 'move';
    }
    evt.preventDefault();
  }
  function _on(el, event, fn) {
    el.addEventListener(event, fn, captureMode);
  }
  function _off(el, event, fn) {
    el.removeEventListener(event, fn, captureMode);
  }
  function _toggleClass(el, name, state) {
    if (el) {
      if (el.classList) {
        el.classList[state ? 'add' : 'remove'](name);
      } else {
        var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
        el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
      }
    }
  }
  function _css(el, prop, val) {
    var style = el && el.style;
    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, '');
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }
        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style)) {
          prop = '-webkit-' + prop;
        }
        style[prop] = val + (typeof val === 'string' ? '' : 'px');
      }
    }
  }
  function _find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName);
      var i = 0;
      var n = list.length;
      if (iterator) {
        for (; i < n; i++) {
          iterator(list[i], i);
        }
      }
      return list;
    }
    return [];
  }
  function _dispatchEvent(sortable, rootEl, name, targetEl, toEl, fromEl, startIndex, newIndex) {
    sortable = (sortable || rootEl[expando]);
    var evt = document.createEvent('Event');
    var options = sortable.options;
    var onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
    evt.initEvent(name, true, true);
    evt.to = toEl || rootEl;
    evt.from = fromEl || rootEl;
    evt.item = targetEl || rootEl;
    evt.clone = cloneEl;
    evt.oldIndex = startIndex;
    evt.newIndex = newIndex;
    rootEl.dispatchEvent(evt);
    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }
  function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {
    var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || toEl.getBoundingClientRect();
    evt.willInsertAfter = willInsertAfter;
    fromEl.dispatchEvent(evt);
    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvt);
    }
    return retVal;
  }
  function _disableDraggable(el) {
    el.draggable = false;
  }
  function _unsilent() {
    _silent = false;
  }
  function _ghostIsLast(el, evt) {
    var lastEl = el.lastElementChild;
    var rect = lastEl.getBoundingClientRect();
    return (evt.clientY - (rect.top + rect.height) > 5) || (evt.clientX - (rect.left + rect.width) > 5);
  }
  function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent;
    var i = str.length;
    var sum = 0;
    while (i--) {
      sum += str.charCodeAt(i);
    }
    return sum + '';
  }
  function _index(el, selector) {
    var index = 0;
    if (!el || !el.parentNode) {
      return -1;
    }
    while (el && (el = el.previousElementSibling)) {
      if ((el.nodeName.toUpperCase() !== 'TEMPLATE') && (selector === '>*' || _matches(el, selector))) {
        index++;
      }
    }
    return index;
  }
  function _matches(el, selector) {
    if (el) {
      selector = selector.split('.');
      var tag = selector.shift().toUpperCase();
      var re = new RegExp('\\s(' + selector.join('|') + ')(?=\\s)', 'g');
      return ((tag === '' || el.nodeName.toUpperCase() == tag) && (!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length));
    }
    return false;
  }
  function _throttle(callback) {
    var args, _this;
    return function() {
      if (args === void 0) {
        args = arguments;
        _this = this;
        var timer = requestAnimationFrame(function() {
          if (args.length === 1) {
            callback.call(_this, args[0]);
          } else {
            callback.apply(_this, args);
          }
          args = void 0;
          cancelAnimationFrame(timer);
        });
      }
    };
  }
  function _extend(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }
    return dst;
  }
  function _clone(el) {
    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else {
      return el.cloneNode(true);
    }
  }
  function _saveInputCheckedState(root) {
    var inputs = root.getElementsByTagName('input');
    var idx = inputs.length;
    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }
  function _nextTick(fn) {
    return requestAnimationFrame(fn);
  }
  function _cancelNextTick(id) {
    return cancelAnimationFrame(id);
  }
  _on(document, 'touchmove', function(evt) {
    if (Sortable.active) {
      evt.preventDefault();
    }
  });
  Sortable.utils = {
    on: _on,
    off: _off,
    css: _css,
    find: _find,
    is: function(el, selector) {
      return !!_closest(el, selector, el);
    },
    extend: _extend,
    throttle: _throttle,
    closest: _closest,
    toggleClass: _toggleClass,
    clone: _clone,
    index: _index,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick
  };
  Sortable.create = function(el, options) {
    return new Sortable(el, options);
  };
  return Sortable;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'Sortable', 'VueUtil'], definition);
  } else {
    context.VueSortable = definition(context.Vue, context.Sortable, context.VueUtil);
    delete context.VueSortable;
    delete context.Sortable;
  }
})(this, function(Vue, Sortable, VueUtil) {
  'use strict';
  var toConsumableArray = function(arr) {
    if (VueUtil.isArray(arr)) {
      return arr;
    } else {
      var arrayfrom = function(arr) {
        var from = function(arrayLike) {
          if (!VueUtil.isDef(arrayLike)) return [];
          var items = Object(arrayLike);
          var mapFn = arguments.length > 1 ? arguments[1] : null;
          var T = null;
          if (VueUtil.isDef(mapFn)) {
            if (!VueUtil.isFunction(mapFn)) return [];
            if (arguments.length > 2) {
              T = arguments[2];
            }
          }
          var toLength = function(value) {
            var toInteger = function(value) {
              var number = Number(value);
              if (isNaN(number)) return 0;
              if (number === 0 || !isFinite(number)) return number;
              return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
            };
            var maxSafeInteger = Math.pow(2, 53) - 1;
            var len = toInteger(value);
            return Math.min(Math.max(len, 0), maxSafeInteger);
          };
          var len = toLength(items.length);
          var A = [];
          var k = 0;
          var kValue = null;
          while (k < len) {
            kValue = items[k];
            if (mapFn) {
              A.push(!VueUtil.isDef(T) ? mapFn(kValue, k) : mapFn.call(T, kValue, k));
            } else {
              A.push(kValue);
            }
            k += 1;
          }
          return A;
        };
        return from(arr);
      };
      return arrayfrom(arr);
    }
  };
  var emit = function(evtName, evtData) {
    var self = this;
    self.$nextTick(function() {
      self.$emit(evtName.toLowerCase(), evtData);
    });
  };
  var delegateAndEmit = function(evtName) {
    var self = this;
    return function(evtData) {
      if (self.realList !== null) {
        self['onDrag' + evtName](evtData);
      }
      emit.call(self, evtName, evtData);
    };
  };
  var eventsListened = ['Start', 'Add', 'Remove', 'Update', 'End'];
  var eventsToEmit = ['Choose', 'Sort', 'Filter', 'Clone'];
  var draggingElement = null;
  var VueSortable = {
    name: 'VueSortable',
    props: {
      options: Object,
      value: {
        type: Array,
        default: null
      },
      clone: {
        type: Function,
        default: function(original) {
          return original;
        }
      },
      element: {
        type: String,
        default: 'div'
      },
      move: {
        type: Function,
        default: null
      }
    },
    data: function() {
      return {
        componentMode: false
      };
    },
    render: function(createElement) {
      return createElement(this.element, null, this.$slots.default);
    },
    mounted: function() {
      var self = this;
      self.componentMode = self.element.toLowerCase() !== self.$el.nodeName.toLowerCase();
      var optionsAdded = {};
      VueUtil.loop(eventsListened, function(elt) {
        optionsAdded['on' + elt] = delegateAndEmit.call(self, elt);
      });
      VueUtil.loop(eventsToEmit, function(elt) {
        optionsAdded['on' + elt] = emit.bind(self, elt);
      });
      var options = VueUtil.merge({}, self.options, optionsAdded, {
        onMove: function(evt, originalEvent) {
          return self.onDragMove(evt, originalEvent);
        }
      });
      !VueUtil.isDef(options.draggable) && (options.draggable = '>*');
      self._sortable = new Sortable(self.rootContainer, options);
      self.computeIndexes();
    },
    beforeDestroy: function() {
      this._sortable.destroy();
    },
    computed: {
      rootContainer: function() {
        return this.$el;
      },
      isCloning: function() {
        return !!this.options && !!this.options.group && this.options.group.pull === 'clone';
      },
      realList: function() {
        return this.value;
      }
    },
    watch: {
      options: {
        handler: function(newOptionValue) {
          var readonlyProperties = VueUtil.map(VueUtil.mergeArray(['Move'], eventsListened, eventsToEmit), function(evt) {
            return 'on' + evt;
          });
          var sortable = this._sortable;
          VueUtil.ownPropertyLoop(newOptionValue, function(property) {
            if (readonlyProperties.indexOf(property) === -1) {
              sortable.option(property, newOptionValue[property]);
            }
          });
        },
        deep: true
      },
      realList: function() {
        this.computeIndexes();
      }
    },
    methods: {
      getChildrenNodes: function() {
        if (this.componentMode) {
          return this.$children[0].$slots.default;
        }
        return this.$slots.default;
      },
      computeIndexes: function() {
        var computeIndexes = function(slots, children) {
          if (!VueUtil.isArray(slots)) return [];
          var elmFromNodes = VueUtil.map(slots, function(elt) {
            return elt.elm;
          });
          var rawIndexes = VueUtil.map(VueUtil.mergeArray([], toConsumableArray(children)), function(elt) {
            return elmFromNodes.indexOf(elt);
          });
          return VueUtil.filter(rawIndexes, function(index) {
            return index !== -1;
          });
        };
        var self = this;
        self.$nextTick(function() {
          self.visibleIndexes = computeIndexes(self.getChildrenNodes(), self.rootContainer.children);
        });
      },
      getUnderlyingVm: function(htmlElt) {
        var computeVmIndex = function(vnodes, element) {
          if (VueUtil.isArray(vnodes)) {
            return VueUtil.map(vnodes, function(elt) {
              return elt.elm;
            }).indexOf(element);
          } else {
            return -1;
          }
        };
        var index = computeVmIndex(this.getChildrenNodes(), htmlElt);
        if (index === -1)
          return null;
        var element = this.realList[index];
        return {
          index: index,
          element: element
        };
      },
      getUnderlyingPotencialDraggableComponent: function(ref) {
        return ref.__vue__;
      },
      emitChanges: function(evt) {
        var self = this;
        self.$nextTick(function() {
          self.$emit('change', evt);
        });
      },
      alterList: function(onList) {
        var newList = VueUtil.mergeArray([], toConsumableArray(this.value));
        onList(newList);
        this.$emit('input', newList);
      },
      spliceList: function() {
        var _arguments = arguments;
        var spliceList = function(list) {
          return list.splice.apply(list, _arguments);
        };
        this.alterList(spliceList);
      },
      updatePosition: function(oldIndex, newIndex) {
        var updatePosition = function(list) {
          return list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
        };
        this.alterList(updatePosition);
      },
      getRelatedContextFromMoveEvent: function(ref) {
        var to = ref.to;
        var related = ref.related;
        var component = this.getUnderlyingPotencialDraggableComponent(to);
        if (!component) {
          return {
            component: component
          };
        }
        var list = component.realList;
        var context = {
          list: list,
          component: component
        };
        if (to !== related && list && component.getUnderlyingVm) {
          var destination = component.getUnderlyingVm(related);
          if (destination) {
            return VueUtil.merge(destination, context);
          }
        }
        return context;
      },
      getVmIndex: function(domIndex) {
        var indexes = this.visibleIndexes;
        var numberIndexes = indexes.length;
        return (domIndex > numberIndexes - 1) ? numberIndexes : indexes[domIndex];
      },
      getComponent: function() {
        return this.$slots.default[0].componentInstance;
      },
      onDragStart: function(evt) {
        this.context = this.getUnderlyingVm(evt.item);
        evt.item._underlying_vm_ = this.context.element;
        draggingElement = evt.item;
      },
      onDragAdd: function(evt) {
        var element = evt.item._underlying_vm_;
        if (this.isCloning) {
          element = this.clone(evt.item._underlying_vm_);
        }
        if (!VueUtil.isDef(element)) return;
        VueUtil.removeNode(evt.item);
        var newIndex = this.getVmIndex(evt.newIndex);
        this.spliceList(newIndex, 0, element);
        this.computeIndexes();
        var added = {
          element: element,
          newIndex: newIndex
        };
        this.emitChanges({
          added: added
        });
      },
      onDragRemove: function(evt) {
        VueUtil.insertNodeAt(this.rootContainer, evt.item, evt.oldIndex);
        if (this.isCloning) {
          VueUtil.removeNode(evt.clone);
          return;
        }
        var oldIndex = this.context.index;
        this.spliceList(oldIndex, 1);
        var removed = {
          element: this.context.element,
          oldIndex: oldIndex
        };
        this.emitChanges({
          removed: removed
        });
      },
      onDragUpdate: function(evt) {
        var oldIndex = this.context.index;
        var newIndex = this.getVmIndex(evt.newIndex);
        VueUtil.removeNode(evt.item);
        VueUtil.insertNodeAt(evt.from, evt.item, evt.oldIndex);
        this.updatePosition(oldIndex, newIndex);
        var moved = {
          element: this.context.element,
          oldIndex: oldIndex,
          newIndex: newIndex
        };
        this.emitChanges({
          moved: moved
        });
      },
      computeFutureIndex: function(relatedContext, evt) {
        if (!relatedContext.element) {
          return 0;
        }
        var domChildren = VueUtil.filter(VueUtil.mergeArray([], toConsumableArray(evt.to.children)), function(el) {
          return el.style['display'] !== 'none';
        });
        var currentDOMIndex = domChildren.indexOf(evt.related);
        var currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
        var draggedInList = domChildren.indexOf(draggingElement) != -1;
        return (draggedInList || !evt.willInsertAfter) ? currentIndex : currentIndex + 1;
      },
      onDragMove: function(evt) {
        var onMove = this.move;
        if (!onMove || !this.realList) {
          return true;
        }
        var relatedContext = this.getRelatedContextFromMoveEvent(evt);
        var draggedContext = this.context;
        var futureIndex = this.computeFutureIndex(relatedContext, evt);
        VueUtil.merge(draggedContext, {futureIndex: futureIndex});
        VueUtil.merge(evt, {relatedContext: relatedContext, draggedContext: draggedContext});
        return onMove(evt);
      },
      onDragEnd: function(evt) {
        this.computeIndexes();
        draggingElement = null;
      }
    }
  };
  Vue.component(VueSortable.name, VueSortable);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VuePopup = definition(context.Vue, context.VueUtil);
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var PopupManager = VueUtil.component.popupManager;
  VueUtil.on(document, 'keydown', function(event) {
    if (event.keyCode === 27) {
      if (PopupManager.modalStack.length > 0) {
        var topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
        if (!topItem) return;
        var instance = PopupManager.getInstance(topItem.id);
        if (instance.closeOnPressEscape) {
          instance.$emit('visible-change', false);
        }
      }
    }
  });
  var idSeed = 1;
  var VuePopup = {};
  VuePopup.model = {
    prop: 'visible',
    event: 'visible-change'
  };
  VuePopup.props = {
    visible: Boolean,
    openDelay: {},
    closeDelay: {},
    zIndex: {},
    closeOnPressEscape: {
      type: Boolean,
      default: true
    }
  };
  VuePopup.beforeMount = function() {
    this._popupId = 'popup-' + idSeed++;
    PopupManager.register(this._popupId, this);
  };
  VuePopup.beforeDestroy = function() {
    PopupManager.deregister(this._popupId);
    PopupManager.closeModal(this._popupId);
  };
  VuePopup.data = function() {
    return {
      opened: false
    };
  };
  VuePopup.watch = {
    visible: function(val) {
      var getDOM = function(dom) {
        if (dom.nodeType === 3) {
          dom = dom.nextElementSibling || dom.nextSibling;
          getDOM(dom);
        }
        return dom;
      };
      var self = this;
      if (val) {
        if (!self.opened) {
          self.$nextTick(function() {
            var dom = getDOM(self.$el);
            if (VueUtil.getStyle(dom, 'position') === 'static') {
              VueUtil.setStyle(dom, 'position', 'absolute');
            }
            dom.style.zIndex = PopupManager.nextZIndex();
            if (self.closeOnPressEscape)
              PopupManager.openModal(self._popupId, dom.style.zIndex);
          });
        }
      } else {
        PopupManager.closeModal(self._popupId);
        self.$nextTick(function() {
          if (self.opened && self.closeOnPressEscape) {
            var dom = getDOM(self.$el);
            PopupManager.openModal(self._popupId, dom.style.zIndex);
          }
        });
      }
    }
  };
  return VuePopup;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VuePopper = definition(context.Vue, context.VueUtil);
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var getOuterSizes = function(element) {
    var _display = element.style.display;
    var _visibility = element.style.visibility;
    element.style.visibility = 'hidden';
    element.style.display = 'block';
    var calcWidthToForceRepaint = element.offsetWidth;
    var styles = getComputedStyle(element);
    var x = element.offsetHeight + parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
    var y = element.offsetWidth + parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
    var result = {
      width: y,
      height: x
    };
    element.style.display = _display;
    element.style.visibility = _visibility;
    return result;
  };
  var getPopperClientRect = function(popperOffsets) {
    var offsets = VueUtil.merge({}, popperOffsets);
    offsets.right = offsets.left + offsets.width;
    offsets.bottom = offsets.top + offsets.height;
    return offsets;
  };
  var getArrayKeyIndex = function(arr, keyToFind) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === keyToFind) {
        return i;
      }
    }
    return null;
  };
  var getOffsetParent = function(element) {
    var offsetParent = element.offsetParent;
    return offsetParent === document.body || !offsetParent ? document.documentElement : offsetParent;
  };
  var setStyle = function(element, styles) {
    function is_numeric(n) {
      return (n !== '' && !isNaN(parseFloat(n)) && isFinite(n));
    }
    VueUtil.ownPropertyLoop(styles, function(prop) {
      var unit = '';
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  };
  var Popper = function(reference, popper, options) {
    var DEFAULTS = {
      placement: 'bottom',
      gpuAcceleration: true,
      offset: 0,
      boundariesElement: 'viewport',
      boundariesPadding: 5,
      preventOverflowOrder: ['left', 'right', 'top', 'bottom'],
      flipBehavior: 'flip',
      arrowElement: '[x-arrow]',
      modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],
      modifiersIgnored: [],
      forceAbsolute: false,
      removeOnDestroy: true
    };
    this._reference = reference.jquery ? reference[0] : reference;
    this.state = {};
    var isNotDefined = !VueUtil.isDef(popper);
    var isConfig = VueUtil.isObject(popper);
    if (isNotDefined || isConfig) {
      this._popper = this.parse(isConfig ? popper : {});
    } else {
      this._popper = popper.jquery ? popper[0] : popper;
    }
    this._options = VueUtil.merge({}, DEFAULTS, options);
    this._options.modifiers = VueUtil.map(this._options.modifiers, function(modifier) {
      if (this._options.modifiersIgnored.indexOf(modifier) !== -1)
        return;
      if (modifier === 'applyStyle') {
        this._popper.setAttribute('x-placement', this._options.placement);
      }
      return this.modifiers[modifier] || modifier;
    }.bind(this));
    this.state.position = this._getPosition(this._popper, this._reference);
    setStyle(this._popper, {
      position: this.state.position,
      top: 0
    });
    this._setupEventListeners();
    return this;
  };
  Popper.prototype.destroy = function() {
    this._popper.removeAttribute('x-placement');
    this._popper.style.left = '';
    this._popper.style.position = '';
    this._popper.style.top = '';
    this._popper.style.transform = '';
    this._removeEventListeners();
    if (this._options.removeOnDestroy) {
      VueUtil.removeNode(this._popper);
    }
    return this;
  };
  Popper.prototype.update = function() {
    var data = {
      instance: this,
      styles: {}
    };
    data.placement = this._options.placement;
    data._originalPlacement = this._options.placement;
    this._options.autoWidth && setStyle(this._popper, {'width': this._reference.offsetWidth});
    data.offsets = this._getOffsets(this._popper, this._reference, data.placement);
    data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);
    data = this.runModifiers(data, this._options.modifiers);
    if (VueUtil.isFunction(this.state.updateCallback)) {
      this.state.updateCallback(data);
    }
  };
  Popper.prototype.onCreate = function(callback) {
    callback(this);
    return this;
  };
  Popper.prototype.onUpdate = function(callback) {
    this.state.updateCallback = callback;
    return this;
  };
  Popper.prototype.parse = function(config) {
    var defaultConfig = {
      tagName: 'div',
      classNames: ['popper'],
      attributes: [],
      parent: document.body,
      content: '',
      contentType: 'text',
      arrowTagName: 'div',
      arrowClassNames: ['popper__arrow'],
      arrowAttributes: ['x-arrow']
    };
    config = VueUtil.merge({}, defaultConfig, config);
    var d = document;
    var popper = d.createElement(config.tagName);
    addClassNames(popper, config.classNames);
    addAttributes(popper, config.attributes);
    if (config.contentType === 'node') {
      popper.appendChild(config.content.jquery ? config.content[0] : config.content);
    } else if (config.contentType === 'html') {
      popper.innerHTML = config.content;
    } else {
      popper.textContent = config.content;
    }
    if (config.arrowTagName) {
      var arrow = d.createElement(config.arrowTagName);
      addClassNames(arrow, config.arrowClassNames);
      addAttributes(arrow, config.arrowAttributes);
      popper.appendChild(arrow);
    }
    var parent = config.parent.jquery ? config.parent[0] : config.parent;
    if (VueUtil.isString(parent)) {
      parent = d.querySelector(config.parent);
      if (!VueUtil.isDef(parent)) {
        throw 'ERROR: the given \'parent\' doesn\'t exists!';
      }
    }
    if (VueUtil.isNodeList(parent)) {
      parent = parent[0];
    }
    parent.appendChild(popper);
    return popper;
    function addClassNames(element, classNames) {
      VueUtil.loop(classNames, function(className) {
        element.classList.add(className);
      });
    }
    function addAttributes(element, attributes) {
      VueUtil.loop(attributes, function(attribute) {
        element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');
      });
    }
  };
  Popper.prototype._getPosition = function(popper, reference) {
    if (this._options.forceAbsolute) {
      return 'absolute';
    }
    var isFixed = function(element) {
      if (element === document.body) return false;
      var elementPosition = VueUtil.getStyle(element, 'position');
      if (elementPosition === 'fixed' || elementPosition === 'relative') return true;
      return element.parentNode ? isFixed(element.parentNode) : element;
    };
    var isParentFixed = isFixed(reference);
    return isParentFixed ? 'fixed' : 'absolute';
  };
  Popper.prototype._getOffsets = function(popper, reference, placement) {
    placement = placement.split('-')[0];
    var popperOffsets = {};
    popperOffsets.position = this.state.position;
    var getBoundingClientRect = function(element) {
      var rect = element.getBoundingClientRect();
      var isIE = navigator.userAgent.indexOf('MSIE') != -1;
      var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;
      return {
        left: rect.left,
        top: rectTop,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.right - rect.left,
        height: rect.bottom - rectTop
      };
    };
    var getOffsetRectRelativeToCustomParent = function(element, parent, fixed) {
      var elementRect = getBoundingClientRect(element);
      var parentRect = getBoundingClientRect(parent);
      if (fixed) {
        var scrollParent = VueUtil.component.getScrollParent(parent);
        parentRect.top += scrollParent.scrollTop;
        parentRect.bottom += scrollParent.scrollTop;
        parentRect.left += scrollParent.scrollLeft;
        parentRect.right += scrollParent.scrollLeft;
      }
      var rect = {
        top: elementRect.top - parentRect.top,
        left: elementRect.left - parentRect.left,
        bottom: (elementRect.top - parentRect.top) + elementRect.height,
        right: (elementRect.left - parentRect.left) + elementRect.width,
        width: elementRect.width,
        height: elementRect.height
      };
      return rect;
    };
    var isParentFixed = popperOffsets.position === 'fixed';
    var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed);
    var popperRect = getOuterSizes(popper);
    if (['right', 'left'].indexOf(placement) !== -1) {
      popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;
      if (placement === 'left') {
        popperOffsets.left = referenceOffsets.left - popperRect.width;
      } else {
        popperOffsets.left = referenceOffsets.right;
      }
    } else {
      popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;
      if (placement === 'top') {
        popperOffsets.top = referenceOffsets.top - popperRect.height;
      } else {
        popperOffsets.top = referenceOffsets.bottom;
      }
    }
    popperOffsets.width = popperRect.width;
    popperOffsets.height = popperRect.height;
    return {
      popper: popperOffsets,
      reference: referenceOffsets
    };
  };
  Popper.prototype._setupEventListeners = function() {
    this.state.updateBound = this.update.bind(this);
    VueUtil.addResizeListener(this.state.updateBound);
    if (this._options.boundariesElement !== 'window') {
      var target = VueUtil.component.getScrollParent(this._reference);
      if (target === document.body || target === document.documentElement) {
        target = document;
      }
      VueUtil.on(target, 'scroll', this.state.updateBound);
    }
  };
  Popper.prototype._removeEventListeners = function() {
    VueUtil.removeResizeListener(this.state.updateBound);
    if (this._options.boundariesElement !== 'window') {
      var target = VueUtil.component.getScrollParent(this._reference);
      if (target === document.body || target === document.documentElement) {
        target = document;
      }
      VueUtil.off(target, 'scroll', this.state.updateBound);
    }
    this.state.updateBound = null;
  };
  Popper.prototype._getBoundaries = function(data, padding, boundariesElement) {
    var getOffsetRect = function(element) {
      var elementRect = {
        width: element.offsetWidth,
        height: element.offsetHeight,
        left: element.offsetLeft,
        top: element.offsetTop
      };
      elementRect.right = elementRect.left + elementRect.width;
      elementRect.bottom = elementRect.top + elementRect.height;
      return elementRect;
    };
    var boundaries = {};
    var width, height;
    if (boundariesElement === 'window') {
      var body = document.body;
      var html = document.documentElement;
      height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
      width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
      boundaries = {
        top: 0,
        right: width,
        bottom: height,
        left: 0
      };
    } else if (boundariesElement === 'viewport') {
      var offsetParent = getOffsetParent(this._popper);
      var scrollParent = VueUtil.component.getScrollParent(this._popper);
      var offsetParentRect = getOffsetRect(offsetParent);
      var getScrollTopValue = function(element) {
        return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;
      };
      var getScrollLeftValue = function(element) {
        return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;
      };
      var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);
      var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);
      boundaries = {
        top: 0 - (offsetParentRect.top - scrollTop),
        right: document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),
        bottom: document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),
        left: 0 - (offsetParentRect.left - scrollLeft)
      };
    } else {
      if (getOffsetParent(this._popper) === boundariesElement) {
        boundaries = {
          top: 0,
          left: 0,
          right: boundariesElement.clientWidth,
          bottom: boundariesElement.clientHeight
        };
      } else {
        boundaries = getOffsetRect(boundariesElement);
      }
    }
    boundaries.left += padding;
    boundaries.right -= padding;
    boundaries.top = boundaries.top + padding;
    boundaries.bottom = boundaries.bottom - padding;
    return boundaries;
  };
  Popper.prototype.runModifiers = function(data, modifiers, ends) {
    var modifiersToRun = VueUtil.mergeArray([], modifiers);
    if (VueUtil.isDef(ends)) {
      modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));
    }
    VueUtil.loop(modifiersToRun, function(modifier) {
      if (VueUtil.isFunction(modifier)) {
        data = modifier.call(this, data);
      }
    }
      .bind(this));
    return data;
  };
  Popper.prototype.isModifierRequired = function(requesting, requested) {
    var index = getArrayKeyIndex(this._options.modifiers, requesting);
    return !!VueUtil.filter(this._options.modifiers.slice(0, index), function(modifier) {
      return modifier === requested;
    }).length;
  };
  Popper.prototype.modifiers = {};
  Popper.prototype.modifiers.applyStyle = function(data) {
    var styles = {
      position: data.offsets.popper.position
    };
    var left = Math.round(data.offsets.popper.left);
    var top = Math.round(data.offsets.popper.top);
    var prefixedProperty;
    if (this._options.gpuAcceleration && (prefixedProperty = 'transform')) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles.top = 0;
      styles.left = 0;
    } else {
      styles.left = left;
      styles.top = top;
    }
    VueUtil.merge(styles, data.styles);
    setStyle(this._popper, styles);
    this._popper.setAttribute('x-placement', data.placement);
    if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {
      setStyle(data.arrowElement, data.offsets.arrow);
    }
    return data;
  };
  Popper.prototype.modifiers.shift = function(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftVariation = placement.split('-')[1];
    if (shiftVariation) {
      var reference = data.offsets.reference;
      var popper = getPopperClientRect(data.offsets.popper);
      var shiftOffsets = {
        y: {
          start: {
            top: reference.top
          },
          end: {
            top: reference.top + reference.height - popper.height
          }
        },
        x: {
          start: {
            left: reference.left
          },
          end: {
            left: reference.left + reference.width - popper.width
          }
        }
      };
      var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';
      data.offsets.popper = VueUtil.merge(popper, shiftOffsets[axis][shiftVariation]);
    }
    return data;
  };
  Popper.prototype.modifiers.preventOverflow = function(data) {
    var order = this._options.preventOverflowOrder;
    var popper = getPopperClientRect(data.offsets.popper);
    var check = {
      left: function() {
        var left = popper.left;
        if (popper.left < data.boundaries.left) {
          left = Math.max(popper.left, data.boundaries.left);
        }
        return {
          left: left
        };
      },
      right: function() {
        var left = popper.left;
        if (popper.right > data.boundaries.right) {
          left = Math.min(popper.left, data.boundaries.right - popper.width);
        }
        return {
          left: left
        };
      },
      top: function() {
        var top = popper.top;
        if (popper.top < data.boundaries.top) {
          top = Math.max(popper.top, data.boundaries.top);
        }
        return {
          top: top
        };
      },
      bottom: function() {
        var top = popper.top;
        if (popper.bottom > data.boundaries.bottom) {
          top = Math.min(popper.top, data.boundaries.bottom - popper.height);
        }
        return {
          top: top
        };
      }
    };
    VueUtil.loop(order, function(direction) {
      data.offsets.popper = VueUtil.merge(popper, check[direction]());
    });
    return data;
  };
  Popper.prototype.modifiers.keepTogether = function(data) {
    var popper = getPopperClientRect(data.offsets.popper);
    var reference = data.offsets.reference;
    var f = Math.floor;
    if (popper.right < f(reference.left)) {
      data.offsets.popper.left = f(reference.left) - popper.width;
    }
    if (popper.left > f(reference.right)) {
      data.offsets.popper.left = f(reference.right);
    }
    if (popper.bottom < f(reference.top)) {
      data.offsets.popper.top = f(reference.top) - popper.height;
    }
    if (popper.top > f(reference.bottom)) {
      data.offsets.popper.top = f(reference.bottom);
    }
    return data;
  };
  Popper.prototype.modifiers.flip = function(data) {
    if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {
      return data;
    }
    if (data.flipped && data.placement === data._originalPlacement) {
      return data;
    }
    var getOppositePlacement = function(placement) {
      var hash = {
        left: 'right',
        right: 'left',
        bottom: 'top',
        top: 'bottom'
      };
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash[matched];
      });
    };
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];
    if (this._options.flipBehavior === 'flip') {
      flipOrder = [placement, placementOpposite];
    } else {
      flipOrder = this._options.flipBehavior;
    }
    VueUtil.loop(flipOrder, function(step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return;
      }
      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = getPopperClientRect(data.offsets.popper);
      var a = ['right', 'bottom'].indexOf(placement) !== -1;
      if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {
        data.flipped = true;
        data.placement = flipOrder[index + 1];
        if (variation) {
          data.placement += '-' + variation;
        }
        data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;
        data = this.runModifiers(data, this._options.modifiers, this._flip);
      }
    }.bind(this));
    return data;
  };
  Popper.prototype.modifiers.offset = function(data) {
    var offset = this._options.offset;
    var popper = data.offsets.popper;
    if (data.placement.indexOf('left') !== -1) {
      popper.top -= offset;
    } else if (data.placement.indexOf('right') !== -1) {
      popper.top += offset;
    } else if (data.placement.indexOf('top') !== -1) {
      popper.left -= offset;
    } else if (data.placement.indexOf('bottom') !== -1) {
      popper.left += offset;
    }
    return data;
  };
  Popper.prototype.modifiers.arrow = function(data) {
    var arrow = this._options.arrowElement;
    if (VueUtil.isString(arrow)) {
      arrow = this._popper.querySelector(arrow);
    }
    if (!arrow || !this._popper.contains(arrow) || !this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {
      return data;
    }
    var arrowStyle = {};
    var placement = data.placement.split('-')[0];
    var popper = getPopperClientRect(data.offsets.popper);
    var reference = data.offsets.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var side = isVertical ? 'top' : 'left';
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowSize = getOuterSizes(arrow)[len];
    if (reference[opSide] - arrowSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
    }
    if (reference[side] + arrowSize > popper[opSide]) {
      data.offsets.popper[side] += (reference[side] + arrowSize) - popper[opSide];
    }
    var center = reference[side] + (reference[len] / 2) - (arrowSize / 2);
    var sideValue = center - popper[side];
    sideValue = Math.max(Math.min(popper[len] - arrowSize, sideValue), 0);
    arrowStyle[side] = sideValue;
    arrowStyle[altSide] = '';
    data.offsets.arrow = arrowStyle;
    data.arrowElement = arrow;
    return data;
  };
  var VuePopper = {
    props: {
      placement: {
        type: String,
        default: 'bottom'
      },
      reference: {},
      popper: {},
      offset: {
        default: 0
      },
      value: Boolean,
      visibleArrow: Boolean,
      autoWidth: Boolean,
      transition: String,
      append: {},
      popperOptions: {
        type: Object,
        default: function() {
          return {
            boundariesPadding: 5,
            gpuAcceleration: false
          };
        }
      }
    },
    data: function() {
      return {
        showPopper: false
      };
    },
    watch: {
      value: {
        immediate: true,
        handler: function(val) {
          this.showPopper = val;
        }
      },
      showPopper: function(val) {
        if (val) this.$nextTick(this.updatePopper);
        this.$emit('input', val);
      }
    },
    methods: {
      stop: function(e) {
        e.stopPropagation();
      },
      findeAbsoluteParent: function(element) {
        if (element === document.body) return;
        var elementPosition = VueUtil.getStyle(element, 'position');
        if (elementPosition === 'absolute' && element.parentNode) this.appendElement = element.parentNode;
        this.findeAbsoluteParent(element.parentNode);
      },
      createPopper: function() {
        var self = this;
        self.currentPlacement = self.currentPlacement || self.placement;
        if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(self.currentPlacement)) return;
        var options = self.popperOptions || {};
        var popper = self.popperElm = self.popperElm || self.popper || self.$refs.popper;
        var reference = self.referenceElm = self.referenceElm || self.reference || self.$refs.reference;
        if (!reference && self.$slots.reference && self.$slots.reference[0]) reference = self.referenceElm = self.$slots.reference[0].elm;
        if (!popper || !reference) return;
        if (self.visibleArrow) self.appendArrow(popper);
        if (VueUtil.isElement(self.append)) {
          self.appendElement = self.append;
        } else {
          self.appendElement = self.referenceElm.parentNode;
          self.findeAbsoluteParent(self.referenceElm);
        }
        self.appendElement.appendChild(self.popperElm);
        if (self.popperJS && self.popperJS.destroy) self.popperJS.destroy();
        options.placement = self.currentPlacement;
        options.offset = self.offset;
        options.autoWidth = self.autoWidth;
        self.popperJS = new Popper(reference, popper, options);
        self.popperJS.onCreate(function() {
          self.$emit('created', self);
          self.resetTransformOrigin();
          self.$nextTick(self.updatePopper);
        });
        if (VueUtil.isFunction(options.onUpdate)) {
          self.popperJS.onUpdate(options.onUpdate);
        }
        self.popperJS._popper.style.zIndex = VueUtil.nextZIndex();
        !VueUtil.isIE && VueUtil.on(self.popperElm, 'click', self.stop);
      },
      updatePopper: function() {
        this.popperJS ? this.popperJS.update() : this.createPopper();
      },
      destroyPopper: function() {
        if (this.showPopper || !this.popperJS) return;
        this.popperJS.destroy();
        this.popperJS = null;
      },
      resetTransformOrigin: function() {
        var placementMap = {
          top: 'bottom',
          bottom: 'top',
          left: 'right',
          right: 'left'
        };
        var placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];
        var origin = placementMap[placement];
        this.popperJS._popper.style.transformOrigin = ['top', 'bottom'].indexOf(placement) !== -1 ? 'center ' + origin : origin + ' center';
      },
      appendArrow: function(element) {
        if (this.appended) return;
        this.appended = true;
        var arrow = document.createElement('div');
        arrow.setAttribute('x-arrow', '');
        arrow.className = 'popper__arrow';
        element.appendChild(arrow);
      }
    },
    beforeDestroy: function() {
      !VueUtil.isIE && VueUtil.off(this.popperElm, 'click', this.stop);
      this.destroyPopper();
    }
  };
  return VuePopper;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueScrollbar = definition(context.Vue, context.VueUtil);
    delete context.VueScrollbar;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var Bar = {
    name: 'Bar',
    props: {
      vertical: Boolean,
      size: Number,
      move: Number,
      disSize: Number
    },
    computed: {
      bar: function() {
        var BAR_MAP = {
          vertical: {
            offset: 'offsetHeight',
            scroll: 'scrollTop',
            scrollSize: 'scrollHeight',
            size: 'height',
            key: 'vertical',
            axis: 'Y',
            client: 'clientY',
            direction: 'top'
          },
          horizontal: {
            offset: 'offsetWidth',
            scroll: 'scrollLeft',
            scrollSize: 'scrollWidth',
            size: 'width',
            key: 'horizontal',
            axis: 'X',
            client: 'clientX',
            direction: 'left'
          }
        };
        return BAR_MAP[this.vertical ? 'vertical' : 'horizontal'];
      },
      wrap: function() {
        return this.$parent.wrap;
      }
    },
    render: function(createElement) {
      var self = this;
      var move = self.move;
      var size = self.size;
      var bar = self.bar;
      var renderThumbStyle = function(obj) {
        var move = obj.move;
        var size = obj.size;
        var bar = obj.bar;
        if (size === 0) move = 0;
        var style = {};
        if (bar.axis === 'Y') {
          style.marginTop = move + 'px';
        }
        if (bar.axis === 'X') {
          style.marginLeft = move + 'px';
        }
        style[bar.size] = size + 'px';
        return style;
      };
      return createElement('div', {
        class: ['vue-scrollbar__bar', 'is-' + bar.key],
        on: {
          mousedown: self.clickTrackHandler
        }
      }, [createElement('div', {
        ref: 'thumb',
        class: 'vue-scrollbar__thumb',
        on: {
          mousedown: self.clickThumbHandler,
          touchstart: self.clickThumbHandler,
        },
        style: renderThumbStyle({
          size: size,
          move: move,
          bar: bar
        })
      }, [])]);
    },
    methods: {
      clickThumbHandler: function(e) {
        this[this.bar.axis] = e.currentTarget[this.bar.offset] - ((e[this.bar.client] || e.touches[0][this.bar.client]) - e.currentTarget.getBoundingClientRect()[this.bar.direction]);
        this.startDrag(e);
      },
      clickTrackHandler: function(e) {
        var offset = Math.abs(e.target.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]);
        var thumbHalf = this.$refs.thumb[this.bar.offset] / 2;
        this.wrap[this.bar.scroll] = (offset - thumbHalf) / (this.$el[this.bar.offset] + this.disSize) * this.wrap[this.bar.scrollSize];
      },
      startDrag: function(e) {
        e.stopImmediatePropagation();
        VueUtil.addTouchMove(document, this.mouseMoveDocumentHandler);
        VueUtil.addTouchEnd(document, this.mouseUpDocumentHandler);
        document.onselectstart = function() {
          return false;
        };
      },
      mouseMoveDocumentHandler: function(e) {
        var prevPage = this[this.bar.axis];
        if (!prevPage) return;
        var offset = (this.$el.getBoundingClientRect()[this.bar.direction] - (e[this.bar.client] || e.touches[0][this.bar.client])) * -1;
        var thumbClickPosition = this.$refs.thumb[this.bar.offset] - prevPage;
        this.wrap[this.bar.scroll] = (offset - thumbClickPosition) / (this.$el[this.bar.offset] + this.disSize) * this.wrap[this.bar.scrollSize];
      },
      mouseUpDocumentHandler: function(e) {
        this[this.bar.axis] = 0;
        VueUtil.removeTouchMove(document, this.mouseMoveDocumentHandler);
        VueUtil.removeTouchEnd(document, this.mouseUpDocumentHandler);
        document.onselectstart = null;
      }
    }
  };
  var VueScrollbar = {
    name: 'VueScrollbar',
    components: {
      Bar: Bar
    },
    props: {
      wrapClass: {},
      viewClass: {},
      height: Number,
      width: Number,
      noresize: Boolean,
      tag: {
        type: String,
        default: 'div'
      }
    },
    data: function() {
      return {
        sizeWidth: 0,
        sizeHeight: 0,
        moveX: 0,
        moveY: 0,
        disSizeX: 0,
        disSizeY: 0
      };
    },
    computed: {
      wrap: function() {
        return this.$refs.wrap;
      },
      resizeElement: function() {
        var view = this.$refs.resize;
        if (VueUtil.isDef(view) && VueUtil.isElement(view.$el)) {
          return view.$el;
        }
        return view;
      },
      mouseWheelEvent: function() {
        return VueUtil.isFirefox ? 'DOMMouseScroll' : 'mousewheel';
      },
    },
    render: function(createElement) {
      var self = this;
      var viewHeight = null;
      var viewWidth = null;
      if (VueUtil.isNumber(self.height)) {
        viewHeight =  self.height + 'px';
      }
      if (VueUtil.isNumber(self.width)) {
        viewWidth =  self.width + 'px';
      }
      var view = createElement(self.tag, {
        class: ['vue-scrollbar__view', self.viewClass],
        ref: 'resize'
      }, [self.$slots.default]);
      var wrap = createElement('div', {
        ref: 'wrap',
        style: {height: viewHeight, width: viewWidth},
        on: {
          scroll: self.handleScroll
        },
        class: [self.wrapClass, 'vue-scrollbar__wrap']
      }, [view]);
      var nodes = [wrap, createElement(Bar, {
        style: {width: viewWidth},
        attrs: {
          move: self.moveX,
          size: self.sizeWidth,
          disSize: self.disSizeX
        }
      }, []), createElement(Bar, {
        style: {height: viewHeight},
        attrs: {
          vertical: true,
          move: self.moveY,
          size: self.sizeHeight,
          disSize: self.disSizeY
        }
      }, [])];
      return createElement('div', {
        class: 'vue-scrollbar'
      }, nodes);
    },
    methods: {
      isScrollCancel: function(el) {
        if (el === this.wrap) return false;
        var overflowY = VueUtil.getStyle(el, 'overflowY');
        if (['auto', 'scroll'].indexOf(overflowY) !== -1 && el.scrollHeight > el.clientHeight) return true;
        return this.isScrollCancel(el.parentElement);
      },
      scrollMouseWheel: function(e) {
        if (this.isScrollCancel(e.target)) return;
        e.stopPropagation();
        e.preventDefault();
        var wheelDelta = e.wheelDelta || -e.detail;
        var scrollTop = this.wrap.scrollTop;
        var wheel = 90;
        if (wheelDelta < 0) {
          scrollTop += wheel;
        } else {
          scrollTop -= wheel;
        }
        this.wrap.scrollTop = scrollTop;
      },
      touchStart: function(e) {
        if (this.isScrollCancel(e.target)) return;
        e.stopImmediatePropagation();
        VueUtil.addClass(this.$el, 'is-touch');
        var wrap = this.wrap;
        var touches = e.touches[0];
        var tocuhPlace = this.tocuhPlace;
        if (!VueUtil.isDef(tocuhPlace)) {
          tocuhPlace = this.tocuhPlace = {};
        }
        tocuhPlace.startTime = e.timeStamp;
        tocuhPlace.startY = wrap.scrollTop;
        tocuhPlace.tocuhX = touches.pageX;
        tocuhPlace.tocuhY = touches.pageY;
        clearInterval(tocuhPlace.timer);
        VueUtil.on(document, 'touchmove', this.touchMove);
        VueUtil.on(document, 'touchend', this.touchEnd);
      },
      touchMove: function(e) {
        VueUtil.addClass(this.$el, 'touching');
        var touches = e.touches[0];
        var wrap = this.wrap;
        var tocuhPlace = this.tocuhPlace;
        var scrollLeft = tocuhPlace.tocuhX - touches.pageX;
        var scrollTop = tocuhPlace.tocuhY - touches.pageY;
        wrap.scrollLeft = wrap.scrollLeft + scrollLeft;
        wrap.scrollTop = wrap.scrollTop + scrollTop;
        tocuhPlace.tocuhX = touches.pageX;
        tocuhPlace.tocuhY = touches.pageY;
      },
      touchEnd: function(e) {
        var self = this;
        var wrap = this.wrap;
        var tocuhPlace = this.tocuhPlace;
        var timeStamp = e.timeStamp - tocuhPlace.startTime;
        if (timeStamp <= 200) {
          var moveY = Math.floor(((wrap.scrollTop - tocuhPlace.startY) * 100 / timeStamp) / 4);
          tocuhPlace.timer = setInterval(function() {
            var tmpScrollTop = wrap.scrollTop;
            wrap.scrollTop = wrap.scrollTop + moveY;
            moveY > 0 ? moveY-- : moveY++;
            if (moveY === 0 || wrap.scrollTop === tmpScrollTop) {
              VueUtil.removeClass(self.$el, 'touching');
              clearInterval(tocuhPlace.timer);
            }
          }, 66);
        } else {
          VueUtil.removeClass(this.$el, 'touching');
        }
        VueUtil.off(document, 'touchmove',this.touchMove);
        VueUtil.off(document, 'touchend', this.touchEnd);
      },
      handleScroll: VueUtil.throttle(function(e) {
        if (!VueUtil.isDef(e.touches)) VueUtil.removeClass(this.$el, 'is-touch');
        this.update();
        var wrap = this.wrap;
        var moveY = wrap.scrollTop / wrap.scrollHeight * wrap.clientHeight;
        var moveX = wrap.scrollLeft / wrap.scrollWidth * wrap.clientWidth;
        var sizeHeight = this.sizeHeight;
        var sizeWidth = this.sizeWidth;
        var minHeight = wrap.clientHeight * 0.1;
        var minWidth = wrap.clientWidth * 0.1;
        if (sizeHeight < minHeight && sizeHeight !== 0) {
          moveY = wrap.scrollTop / wrap.scrollHeight * (wrap.clientHeight - minHeight + sizeHeight);
          this.sizeHeight = minHeight;
          this.disSizeY = sizeHeight - minHeight;
        }
        if (sizeWidth < minWidth && sizeWidth !== 0) {
          moveX = wrap.scrollLeft / wrap.scrollWidth * (wrap.clientHeight - minWidth + sizeWidth);
          this.sizeWidth = minWidth;
          this.disSizeX = sizeWidth - minWidth;
        }
        if (this.moveY !== moveY) {
          this.moveY = moveY;
          var isTop = (wrap.scrollTop === 0);
          var isBottom = (wrap.scrollHeight - wrap.scrollTop === wrap.clientHeight);
          this.$emit('scrollY', e, wrap.scrollTop, isTop, isBottom);
        }
        if (this.moveX !== moveX) {
          this.moveX = moveX;
          var isLeft = (wrap.scrollLeft === 0);
          var isRight = (wrap.scrollWidth - wrap.scrollLeft === wrap.clientWidth);
          this.$emit('scrollX', e, wrap.scrollLeft, isLeft, isRight);
        }
      }),
      update: function() {
        var wrap = this.wrap;
        var heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
        var widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;
        var sizeHeight = heightPercentage < 100 ? wrap.clientHeight * heightPercentage / 100 : 0;
        var sizeWidth = widthPercentage < 100 ? wrap.clientWidth * widthPercentage / 100 : 0;
        this.sizeHeight = sizeHeight;
        this.sizeWidth = sizeWidth;
        this.disSizeX = 0;
        this.disSizeY = 0;
      },
      goTop: function() {
        this.wrap.scrollTop = 0;
      }
    },
    mounted: function() {
      VueUtil.on(this.wrap, this.mouseWheelEvent, this.scrollMouseWheel);
      VueUtil.on(this.wrap, 'touchstart', this.touchStart);
      VueUtil.addHoverListener(this.wrap, this.handleScroll);
      !this.noresize && this.resizeElement && VueUtil.addResizeListener(this.resizeElement, this.update);
    },
    beforeDestroy: function() {
      VueUtil.off(this.wrap, this.mouseWheelEvent, this.scrollMouseWheel);
      VueUtil.off(this.wrap, 'touchstart', this.touchStart);
      VueUtil.removeHoverListener(this.wrap, this.handleScroll);
      !this.noresize && this.resizeElement && VueUtil.removeResizeListener(this.resizeElement, this.update);
    }
  };
  Vue.component(VueScrollbar.name, VueScrollbar);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueRow = definition(context.Vue);
    delete context.VueRow;
  }
})(this, function(Vue) {
  'use strict';
  var VueRow = {
    template: '<div :style="style" :class="[\'vue-row\', justify !== \'start\' ? \'is-justify-\' + justify : \'\', align !== \'top\' ? \'is-align-\' + align : \'\', {\'vue-row--flex\': type === \'flex\'}]"><slot></slot></div>',
    name: 'VueRow',
    props: {
      gutter: Number,
      type: String,
      justify: {
        type: String,
        default: 'start'
      },
      align: {
        type: String,
        default: 'top'
      }
    },
    computed: {
      style: function() {
        var ret = {};
        if (this.gutter) {
          ret.marginLeft = this.gutter / 2 + 'px';
          ret.marginRight = ret.marginLeft;
        }
        return ret;
      }
    }
  };
  Vue.component(VueRow.name, VueRow);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCol = definition(context.Vue, context.VueUtil);
    delete context.VueCol;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCol = {
    name: 'VueCol',
    props: {
      span: {
        type: Number,
        default: 24
      },
      offset: Number,
      pull: Number,
      push: Number,
      xs: [Number, Object],
      sm: [Number, Object],
      md: [Number, Object],
      lg: [Number, Object]
    },
    computed: {
      gutter: function() {
        return this.$parent.gutter;
      },
      style: function() {
        var ret = {};
        if (this.gutter) {
          ret.paddingLeft = this.gutter / 2 + 'px';
          ret.paddingRight = ret.paddingLeft;
        }
        return ret;
      }
    },
    render: function(createElement) {
      var self = this;
      var classList = [];
      VueUtil.loop(['span', 'offset', 'pull', 'push'], function(prop) {
        if (VueUtil.isDef(self[prop])) {
          classList.push(prop !== 'span' ? 'vue-col-' + prop + '-' + self[prop] : 'vue-col-' + self[prop]);
        }
      });
      VueUtil.loop(['xs', 'sm', 'md', 'lg'], function(size) {
        if (VueUtil.isNumber(self[size])) {
          classList.push('vue-col-' + size + '-' + self[size]);
        } else if (VueUtil.isObject(self[size])) {
          var props = self[size];
          VueUtil.ownPropertyLoop(props, function(prop) {
            classList.push(prop !== 'span' ? 'vue-col-' + size + '-' + prop + '-' + props[prop] : 'vue-col-' + size + '-' + props[prop]);
          });
        }
      });
      return createElement('div', {
        class: ['vue-col', classList],
        style: self.style
      }, [this.$slots.default]);
    }
  };
  Vue.component(VueCol.name, VueCol);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['VueUtil'], definition);
  } else {
    context.VueValidator = definition(context.VueUtil);
  }
})(this, function(VueUtil) {
  'use strict';
  var newMessages = function() {
    return {
      default: 'Validation Error'
    };
  };
  var isEmptyValue = function(value, type) {
    if (!VueUtil.isDef(value)) {
      return true;
    }
    if (type === 'array' && VueUtil.isArray(value) && !value.length) {
      return true;
    }
    var isNativeStringType = function(type) {
      return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'pattern' || type === 'ipv4';
    };
    if (isNativeStringType(type) && VueUtil.isString(value) && !value) {
      return true;
    }
    return false;
  };
  var rulesEnumerable = function(rule, value, source, errors, options) {
    var ENUM = 'enum';
    rule[ENUM] = VueUtil.isArray(rule[ENUM]) ? rule[ENUM] : [];
    if (rule[ENUM].indexOf(value) === -1) {
      errors.push(options.messages.default);
    }
  };
  var rulesPattern = function(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        if (!rule.pattern.test(value)) {
          errors.push(options.messages.default);
        }
      } else if (VueUtil.isString(rule.pattern)) {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(options.messages.default);
        }
      }
    }
  };
  var rulesRange = function(rule, value, source, errors, options) {
    var len = VueUtil.isNumber(rule.len);
    var min = VueUtil.isNumber(rule.min);
    var max = VueUtil.isNumber(rule.max);
    var val = value;
    var key = null;
    var num = rule.type == 'number' || VueUtil.isNumber(value);
    var str = rule.type == 'number' ? false : VueUtil.isString(value);
    var arr = VueUtil.isArray(value);
    if (num) {
      key = 'number';
    } else if (str) {
      key = 'string';
    } else if (arr) {
      key = 'array';
    }
    if (!key) {
      return false;
    }
    if (str || arr) {
      val = value.length;
    }
    if (len) {
      if (val !== rule.len) {
        errors.push(options.messages.default);
      }
    } else if (min && !max && val < rule.min) {
      errors.push(options.messages.default);
    } else if (max && !min && val > rule.max) {
      errors.push(options.messages.default);
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(options.messages.default);
    }
  };
  var rulesRequired = function(rule, value, source, errors, options, type) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
      errors.push(options.messages.default);
    }
  };
  var rulesType = function(rule, value, source, errors, options) {
    var pattern = {
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
      url: new RegExp('^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$', 'i'),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
      ipv4: new RegExp('\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b'),
    };
    var types = {
      integer: function(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      float: function(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function(value) {
        return VueUtil.isArray(value);
      },
      regexp: function(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e) {
          throw e;
        }
      },
      date: function(value) {
        return VueUtil.isFunction(value.getTime) && VueUtil.isFunction(value.getMonth) && VueUtil.isFunction(value.getYear);
      },
      number: function(value) {
        return VueUtil.isNumberStr(value);
      },
      object: function(value) {
        return VueUtil.isObject(value);
      },
      method: function(value) {
        return VueUtil.isFunction(value);
      },
      email: function(value) {
        return VueUtil.isString(value) && !!value.match(pattern.email) && value.length < 255;
      },
      url: function(value) {
        return VueUtil.isString(value) && !!value.match(pattern.url);
      },
      hex: function(value) {
        return VueUtil.isString(value) && !!value.match(pattern.hex);
      },
      ipv4: function(value) {
        return VueUtil.isString(value) && !!value.match(pattern.ipv4);
      }
    };
    if (rule.required && !VueUtil.isDef(value)) {
      rulesRequired(rule, value, source, errors, options);
      return;
    }
    var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex', 'ipv4'];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) !== -1) {
      if (!types[ruleType](value)) {
        errors.push(options.messages.default);
      }
    } else if (ruleType && typeof (value) !== ruleType) {
      errors.push(options.messages.default);
    }
  };
  var rulesWhitespace = function(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === '') {
      errors.push(options.messages.default);
    }
  };
  var rules = {
    enum: rulesEnumerable,
    pattern: rulesPattern,
    range: rulesRange,
    required: rulesRequired,
    type: rulesType,
    whitespace: rulesWhitespace
  };
  var validtorDate = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
        if (value) {
          rules.range(rule, value.getTime(), source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var validtorBoolean = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (VueUtil.isDef(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorArray = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value, 'array') && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, 'array');
      if (!isEmptyValue(value, 'array')) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorType = function(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorString = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value, 'string') && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, 'string');
      if (!isEmptyValue(value, 'string')) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var validtorRequired = function(rule, value, callback, source, options) {
    var errors = [];
    var type = VueUtil.isArray(value) ? 'array' : typeof value;
    rules.required(rule, value, source, errors, options, type);
    callback(errors);
  };
  var validtorRegexp = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorPattern = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value, 'string') && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, 'string')) {
        rules.pattern(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorObject = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (VueUtil.isDef(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorNumber = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (VueUtil.isDef(value)) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorMethod = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (VueUtil.isDef(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validtorEnumerable = function(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || (!rule.required && source.hasOwnProperty(rule.field));
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value) {
        rules['enum'](rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var validators = {
    string: validtorString,
    method: validtorMethod,
    number: validtorNumber,
    boolean: validtorBoolean,
    regexp: validtorRegexp,
    integer: validtorNumber,
    float: validtorNumber,
    array: validtorArray,
    object: validtorObject,
    enum: validtorEnumerable,
    pattern: validtorPattern,
    email: validtorType,
    url: validtorType,
    date: validtorDate,
    hex: validtorType,
    ipv4: validtorType,
    required: validtorRequired
  };
  var Schema = function(descriptor) {
    this.rules = null;
    this._messages = newMessages();
    this.define(descriptor);
  };
  Schema.prototype = {
    messages: function(messages) {
      return VueUtil.merge(this._messages, messages);
    },
    define: function(rules) {
      if (!rules) {
        throw 'No rules';
      }
      if (!VueUtil.isObject(rules)) {
        throw 'Rules must be an object';
      }
      var self = this;
      self.rules = {};
      VueUtil.ownPropertyLoop(rules, function(z) {
        var item = rules[z];
        self.rules[z] = VueUtil.isArray(item) ? item : [item];
      });
    },
    validate: function(source_, o, oc) {
      var source = source_;
      var options = o || {};
      var callback = oc;
      if (VueUtil.isFunction(options)) {
        callback = options;
        options = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      function complete(results) {
        var i;
        var field;
        var errors = [];
        var fields = {};
        function add(e) {
          if (VueUtil.isArray(e)) {
            errors = errors.concat.apply(errors, e);
          } else {
            errors.push(e);
          }
        }
        i = results.length;
        while (i--) {
          add(results[i]);
        }
        if (!errors.length) {
          errors = null;
          fields = null;
        } else {
          i = errors.length;
          while (i--) {
            field = errors[i].field;
            fields[field] = fields[field] || [];
            fields[field].push(errors[i]);
          }
        }
        callback(errors, fields);
      }
      options.messages = VueUtil.merge(this.messages(), options.messages);
      var self = this;
      var arr;
      var value;
      var series = {};
      var keys = options.keys || Object.keys(self.rules);
      VueUtil.loop(keys, function(z) {
        arr = self.rules[z];
        value = source[z];
        VueUtil.loop(arr, function(r) {
          var rule = r;
          if (VueUtil.isFunction(rule.transform)) {
            if (source === source_) {
              source = VueUtil.merge({}, source);
            }
            value = source[z] = rule.transform(value);
          }
          if (VueUtil.isFunction(rule)) {
            rule = {
              validator: rule,
            };
          } else {
            rule = VueUtil.merge({}, rule);
          }
          rule.validator = self.getValidationMethod(rule);
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = self.getType(rule);
          if (!rule.validator) {
            return;
          }
          series[z] = series[z] || [];
          series[z].push({
            rule: rule,
            value: value,
            source: source,
            field: z,
          });
        });
      });
      var errorFields = {};
      var asyncMap = function(objArr, option, func, callback) {
        var flattenObjArr = function(objArr) {
          var ret = [];
          VueUtil.ownPropertyLoop(objArr, function(k) {
            ret.push.apply(ret, objArr[k]);
          });
          return ret;
        };
        var asyncSerialArray = function(arr, func, callback) {
          var index = 0;
          var arrLength = arr.length;
          function next(errors) {
            if (errors && errors.length) {
              callback(errors);
              return;
            }
            var original = index;
            index = index + 1;
            if (original < arrLength) {
              func(arr[original], next);
            } else {
              callback([]);
            }
          }
          next([]);
        };
        if (option.first) {
          var flattenArr = flattenObjArr(objArr);
          return asyncSerialArray(flattenArr, func, callback);
        }
        var firstFields = option.firstFields || [];
        if (firstFields === true) {
          firstFields = Object.keys(objArr);
        }
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total = 0;
        var results = [];
        var next = function(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
          }
        };
        VueUtil.loop(objArrKeys, function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            var asyncParallelArray = function(arr, func, callback) {
              var results = [];
              var total = 0;
              var arrLength = arr.length;
              function count(errors) {
                results.push.apply(results, errors);
                total++;
                if (total === arrLength) {
                  callback(results);
                }
              }
              VueUtil.loop(arr, function(a) {
                func(a, count);
              });
            };
            asyncParallelArray(arr, func, next);
          }
        });
      };
      asyncMap(series, options, function(data, doIt) {
        var rule = data.rule;
        var deep = (VueUtil.isObject(rule.type) || VueUtil.isArray(rule.type)) && (VueUtil.isObject(rule.fields) || VueUtil.isObject(rule.defaultField));
        deep = deep && (rule.required || (!rule.required && data.value));
        rule.field = data.field;
        function addFullfield(key, schema) {
          return VueUtil.merge({}, schema, {
            fullField: rule.fullField + '.' + key
          });
        }
        function cb() {
          var errors = arguments.length > 0 && VueUtil.isDef(arguments[0]) ? arguments[0] : [];
          var complementError = function(rule) {
            return function(oe) {
              if (oe && oe.message) {
                oe.field = oe.field || rule.fullField;
                return oe;
              }
              return {
                message: oe,
                field: oe.field || rule.fullField,
              };
            };
          };
          if (!VueUtil.isArray(errors)) {
            errors = [errors];
          }
          if (errors.length && rule.message) {
            errors = VueUtil.mergeArray([], rule.message);
          }
          errors = VueUtil.map(errors, complementError(rule));
          if (options.first && errors.length) {
            errorFields[rule.field] = 1;
            return doIt(errors);
          }
          if (!deep) {
            doIt(errors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message) {
                errors = VueUtil.map(VueUtil.mergeArray([], rule.message), complementError(rule));
              } else if (options.error) {
                errors = [options.error(rule, options.messages.default)];
              } else {
                errors = [];
              }
              return doIt(errors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              VueUtil.ownPropertyLoop(data.value, function(k) {
                fieldsSchema[k] = rule.defaultField;
              });
            }
            fieldsSchema = VueUtil.merge({}, fieldsSchema, data.rule.fields);
            VueUtil.ownPropertyLoop(fieldsSchema, function(f) {
              var fieldSchema = VueUtil.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
              fieldsSchema[f] = VueUtil.map(fieldSchema, addFullfield.bind(null, f));
            });
            var schema = new Schema(fieldsSchema);
            schema.messages(options.messages);
            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }
            schema.validate(data.value, data.rule.options || options, function(errs) {
              doIt(errs && errs.length ? VueUtil.mergeArray(errors, errs) : errs);
            });
          }
        }
        var res = rule.validator(rule, data.value, cb, data.source, options);
        if (res && res.then) {
          res.then(function() {cb();}, function(e) {cb(e);});
        }
      }, function(results) {
        complete(results);
      });
    },
    getType: function(rule) {
      if (!VueUtil.isDef(rule.type) && (rule.pattern instanceof RegExp)) {
        rule.type = 'pattern';
      }
      if (!VueUtil.isFunction(rule.validator) && (rule.type && !validators.hasOwnProperty(rule.type))) {
        throw 'Unknown rule type ' + rule.type;
      }
      return rule.type || 'string';
    },
    getValidationMethod: function(rule) {
      if (VueUtil.isFunction(rule.validator)) {
        return rule.validator;
      }
      var keys = Object.keys(rule);
      var messageIndex = keys.indexOf('message');
      if (messageIndex !== -1) {
        keys.splice(messageIndex, 1);
      }
      if (keys.length === 1 && keys[0] === 'required') {
        return validators.required;
      }
      return validators[this.getType(rule)] || false;
    },
  };
  Schema.register = function register(type, validator) {
    if (!VueUtil.isFunction(validator)) {
      throw 'Cannot register a validator by type, validator is not a function';
    }
    validators[type] = validator;
  };
  Schema.messages = newMessages();
  return Schema;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueForm = definition(context.Vue, context.VueUtil);
    delete context.VueForm;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueForm = {
    template: '<form :class="[\'vue-form\', labelPosition ? \'vue-form--label-\' + labelPosition : \'\', {\'vue-form--inline\': inline}]"><slot></slot><input style="display:none" /></form>',
    name: 'VueForm',
    props: {
      model: Object,
      rules: Object,
      labelPosition: String,
      labelWidth: String,
      labelSuffix: {
        type: String,
        default: ''
      },
      inline: Boolean,
      showMessage: {
        type: Boolean,
        default: true
      },
      labelResponsive: {
        type: Boolean,
        default: true
      },
      notifyMessage: Boolean,
      customMessageMethod: Function
    },
    watch: {
      rules: function() {
        this.validate();
      }
    },
    data: function() {
      return {
        fields: []
      };
    },
    created: function() {
      this.$on('vue.form.addField', function(field) {
        if (field) {
          this.fields.push(field);
        }
      });
      this.$on('vue.form.removeField', function(field) {
        if (field.prop) {
          this.fields.splice(this.fields.indexOf(field), 1);
        }
      });
    },
    methods: {
      initValue: function() {
        VueUtil.loop(this.fields, function(field) {
          field.initValue();
        });
      },
      isModify: function() {
        var modifyFLg = false;
        VueUtil.loop(this.fields, function(field) {
          if (modifyFLg) return;
          modifyFLg = field.isModify();
        });
        return modifyFLg;
      },
      resetFields: function() {
        VueUtil.loop(this.fields, function(field) {
          field.resetField();
        });
      },
      validate: function(callback) {
        var self = this;
        self.$nextTick(function(){
          var valid = true;
          var count = 0;
          var errorMsgs = [];
          VueUtil.loop(self.fields, function(field, index) {
            field.validate('', function(errors) {
              if (errors) {
                valid = false;
                errorMsgs.push(errors);
              }
              if (VueUtil.isFunction(callback) && ++count === self.fields.length) {
                callback(valid);
              }
            });
          });
          if (errorMsgs.length > 0) {
            if (VueUtil.isFunction(self.customMessageMethod)) {
              self.customMessageMethod(errorMsgs);
            } else if (self.notifyMessage) {
              var createElement = self.$createElement;
              self.$notify.error({
                message: createElement('div', null, [self._l(errorMsgs, function(errorMsg, errorIndex) {
                  return [createElement('span', {key: errorIndex}, [errorMsg]), createElement('br', null, [])];
                })]),
                duration: 0
              });
            }
          }
        });
      },
      validateField: function(prop, cb) {
        var field = VueUtil.filter(this.fields, function(field) {
          return (field.prop === prop);
        })[0];
        if (!field) {
          throw 'must call validateField with valid prop string!';
        }
        field.validate('', cb);
      }
    }
  };
  Vue.component(VueForm.name, VueForm);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VueValidator'], definition);
  } else {
    context.VueFormItem = definition(context.Vue, context.VueUtil, context.VueValidator);
    delete context.VueFormItem;
    delete context.VueValidator;
  }
})(this, function(Vue, VueUtil, VueValidator) {
  'use strict';
  var VueFormItem = {
    template: '<div :class="[\'vue-form-item\', {\'is-notify\': form.notifyMessage || form.customMessageMethod,\'is-error\': validateState === \'error\',\'is-validating\': validateState === \'validating\',\'is-required\': isRequired || required}]"><label :for="prop" :class="[\'vue-form-item__label\', {\'is-responsive\': form.labelResponsive}]" :style="labelStyle" v-if="label" ref="label">{{label + form.labelSuffix}}</label><div class="vue-form-item__content" :style="contentStyle" ref="content"><slot></slot><div class="vue-form-item__error" v-if="validateState === \'error\' && showMessage && form.showMessage && !form.notifyMessage && !form.customMessageMethod">{{validateMessage}}</div></div></div>',
    name: 'VueFormItem',
    mixins: [VueUtil.component.emitter],
    props: {
      label: String,
      labelWidth: String,
      prop: String,
      required: Boolean,
      rules: [Object, Array],
      error: String,
      validateStatus: String,
      showMessage: {
        type: Boolean,
        default: true
      }
    },
    watch: {
      error: function(value) {
        this.validateMessage = value;
        this.validateState = 'error';
      },
      validateStatus: function(value) {
        this.validateState = value;
      },
      label: {
        immediate: true,
        handler: function(val) {
          var self = this;
          if (VueUtil.isDef(val)) {
            self.$nextTick(function() {
              VueUtil.removeResizeListener(self.form.$el, self.resetLabelWidth);
              VueUtil.addResizeListener(self.form.$el, self.resetLabelWidth);
            });
          } else {
            self.$nextTick(function() {
              VueUtil.removeResizeListener(self.form.$el, self.resetLabelWidth);
            });
          }
        }
      }
    },
    computed: {
      labelStyle: function() {
        var ret = {};
        var labelStyleWidth = this.labelStyleWidth();
        if (labelStyleWidth) {
          ret.width = labelStyleWidth;
        }
        return ret;
      },
      contentStyle: function() {
        var ret = {};
        var labelStyleWidth = this.labelStyleWidth();
        if (labelStyleWidth) {
          ret.marginLeft = labelStyleWidth;
        }
        return ret;
      },
      form: function() {
        var parent = this.$parent;
        while (parent.$options.name !== 'VueForm') {
          parent = parent.$parent;
        }
        return parent;
      },
      fieldValue: {
        cache: false,
        get: function() {
          var model = this.form.model;
          if (!model || !this.prop) {
            return;
          }
          var path = this.prop;
          if (path.indexOf(':') !== -1) {
            path = path.replace(/:/, '.');
          }
          return this.getPropByPath(model, path).v;
        }
      }
    },
    data: function() {
      return {
        validateState: '',
        validateMessage: '',
        validateDisabled: false,
        validator: {},
        isRequired: false,
        initialValue: null
      };
    },
    methods: {
      getPropByPath: function(obj, path) {
        var tempObj = obj;
        path = path.replace(/\[(\w+)\]/g, '.$1');
        path = path.replace(/^\./, '');
        var keyArr = path.split('.');
        for (var i = 0, len = keyArr.length; i < len - 1; ++i) {
          var key = keyArr[i];
          tempObj = tempObj[key];
          if (!VueUtil.isDef(tempObj)) {
            throw 'please transfer a valid prop path to form item!';
          }
        }
        return {
          o: tempObj,
          k: keyArr[i],
          v: tempObj[keyArr[i]]
        };
      },
      labelStyleWidth: function() {
        if (this.form.labelPosition === 'top' || (this.form.labelResponsive && VueUtil.getStyle(this.$refs.label, 'display') === 'inline-block')) return '';
        var labelWidth = this.labelWidth || this.form.labelWidth;
        return labelWidth;
      },
      resetLabelWidth: function() {
        var labelStyleWidth = this.labelStyleWidth();
        this.$refs.label && (this.$refs.label.style.width = labelStyleWidth);
        this.$refs.content && (this.$refs.content.style.marginLeft = labelStyleWidth);
      },
      validate: function(trigger, callback) {
        var self = this;
        var noop = function() {};
        if (VueUtil.isFunction(self.form.customMessageMethod)) {
          noop = self.form.customMessageMethod;
        } else if (self.form.notifyMessage) {
          noop = function(errorMsg) {
            if (errorMsg) {
              self.$notify.error({message: errorMsg});
            }
          };
        }
        callback = callback || noop;
        var rules = self.getFilteredRule(trigger);
        if (!rules || rules.length === 0) {
          callback();
          return true;
        }
        self.validateState = 'validating';
        var descriptor = {};
        descriptor[self.prop] = rules;
        var validator = new VueValidator(descriptor);
        var model = {};
        model[self.prop] = self.fieldValue;
        validator.validate(model, {
          firstFields: true
        }, function(errors, fields) {
          self.validateState = !errors ? 'success' : 'error';
          self.validateMessage = errors ? errors[0].message : '';
          callback(self.validateMessage);
        });
      },
      resetField: function() {
        this.validateState = '';
        this.validateMessage = '';
        var model = this.form.model;
        var value = this.fieldValue;
        var path = this.prop;
        if (path.indexOf(':') !== -1) {
          path = path.replace(/:/, '.');
        }
        var prop = this.getPropByPath(model, path);
        this.validateDisabled = true;
        if (Array.isArray(value)) {
          prop.o[prop.k] = [].concat(this.initialValue);
        } else {
          prop.o[prop.k] = this.initialValue;
        }

        this.broadcast('VueTimeSelect', 'fieldReset', this.initialValue);
      },
      isModify: function() {
        this.validateState = '';
        this.validateMessage = '';
        var model = this.form.model;
        var value = this.fieldValue;
        var path = this.prop;
        if (path.indexOf(':') !== -1) {
          path = path.replace(/:/, '.');
        }
        var prop = this.getPropByPath(model, path);
        return (prop.o[prop.k] !== this.initialValue);
      },
      initValue: function() {
        this.initialValue = this.fieldValue;
      },
      getRules: function() {
        var formRules = this.form.rules;
        var selfRuels = this.rules;
        formRules = formRules ? formRules[this.prop] : [];
        return VueUtil.mergeArray([], (selfRuels || formRules || []));
      },
      getFilteredRule: function(trigger) {
        var rules = this.getRules();
        return VueUtil.filter(rules, function(rule) {
          return !rule.trigger || rule.trigger.indexOf(trigger) !== -1;
        });
      },
      onFieldBlur: function() {
        this.validate('blur');
      },
      onFieldChange: function() {
        if (this.validateDisabled) {
          this.validateDisabled = false;
          return;
        }
        this.validate('change');
      }
    },
    mounted: function() {
      var self = this;
      if (self.prop) {
        self.dispatch('VueForm', 'vue.form.addField', [self]);
        self.initValue();
        var rules = self.getRules();
        if (rules.length) {
          VueUtil.loop(rules, function(rule) {
            if (rule.required) {
              self.isRequired = true;
              return false;
            }
          });
          self.$on('vue.form.blur', self.onFieldBlur);
          self.$on('vue.form.change', self.onFieldChange);
        }
      }
    },
    beforeDestroy: function() {
      this.dispatch('VueForm', 'vue.form.removeField', [this]);
      VueUtil.removeResizeListener(this.form.$el, this.resetLabelWidth);
    }
  };
  Vue.component(VueFormItem.name, VueFormItem);
});

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports['Cleave'] = factory();
	else
		root['Cleave'] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = '';

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	/**
	 * Construct a new Cleave instance by passing the configuration object
	 *
	 * @param {String | HTMLElement} element
	 * @param {Object} opts
	 */
	var Cleave = function (element, opts) {
	    var owner = this;

	    if (typeof element === 'string') {
	        owner.element = document.querySelector(element);
	    } else {
	        owner.element = ((typeof element.length !== 'undefined') && element.length > 0) ? element[0] : element;
	    }

	    if (!owner.element) {
	        throw new Error('[cleave.js] Please check the element');
	    }

	    opts.initValue = owner.element.value;

	    owner.properties = Cleave.DefaultProperties.assign({}, opts);

	    owner.init();
	};

	Cleave.prototype = {
	    init: function () {
	        var owner = this, pps = owner.properties;

	        // no need to use this lib
	        if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && (pps.blocksLength === 0 && !pps.prefix)) {
	            owner.onInput(pps.initValue);

	            return;
	        }

	        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);

	        owner.isAndroid = Cleave.Util.isAndroid();
	        owner.lastInputValue = '';

	        owner.onChangeListener = owner.onChange.bind(owner);
	        owner.onKeyDownListener = owner.onKeyDown.bind(owner);
	        owner.onFocusListener = owner.onFocus.bind(owner);
	        owner.onCutListener = owner.onCut.bind(owner);
	        owner.onCopyListener = owner.onCopy.bind(owner);

	        owner.element.addEventListener('input', owner.onChangeListener);
	        owner.element.addEventListener('keydown', owner.onKeyDownListener);
	        owner.element.addEventListener('focus', owner.onFocusListener);
	        owner.element.addEventListener('cut', owner.onCutListener);
	        owner.element.addEventListener('copy', owner.onCopyListener);


	        owner.initPhoneFormatter();
	        owner.initDateFormatter();
	        owner.initTimeFormatter();
	        owner.initNumeralFormatter();

	        // avoid touch input field if value is null
	        // otherwise Firefox will add red box-shadow for <input required />
	        if (pps.initValue || (pps.prefix && !pps.noImmediatePrefix)) {
	            owner.onInput(pps.initValue);
	        }
	    },

	    initNumeralFormatter: function () {
	        var owner = this, pps = owner.properties;

	        if (!pps.numeral) {
	            return;
	        }

	        pps.numeralFormatter = new Cleave.NumeralFormatter(
	            pps.numeralDecimalMark,
	            pps.numeralIntegerScale,
	            pps.numeralDecimalScale,
	            pps.numeralThousandsGroupStyle,
	            pps.numeralPositiveOnly,
	            pps.stripLeadingZeroes,
	            pps.delimiter
	        );
	    },

	    initTimeFormatter: function() {
	        var owner = this, pps = owner.properties;

	        if (!pps.time) {
	            return;
	        }

	        pps.timeFormatter = new Cleave.TimeFormatter(pps.timePattern);
	        pps.blocks = pps.timeFormatter.getBlocks();
	        pps.blocksLength = pps.blocks.length;
	        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
	    },

	    initDateFormatter: function () {
	        var owner = this, pps = owner.properties;

	        if (!pps.date) {
	            return;
	        }

	        pps.dateFormatter = new Cleave.DateFormatter(pps.datePattern);
	        pps.blocks = pps.dateFormatter.getBlocks();
	        pps.blocksLength = pps.blocks.length;
	        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
	    },

	    initPhoneFormatter: function () {
	        var owner = this, pps = owner.properties;

	        if (!pps.phone) {
	            return;
	        }

	        // Cleave.AsYouTypeFormatter should be provided by
	        // external google closure lib
	        try {
	            pps.phoneFormatter = new Cleave.PhoneFormatter(
	                new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode),
	                pps.delimiter
	            );
	        } catch (ex) {
	            throw new Error('[cleave.js] Please include phone-type-formatter.{country}.js lib');
	        }
	    },

	    onKeyDown: function (event) {
	        var owner = this, pps = owner.properties,
	            charCode = event.which || event.keyCode,
	            Util = Cleave.Util,
	            currentValue = owner.element.value;

	        if (charCode === 229
	            && Util.isAndroidBackspaceKeydown(owner.lastInputValue, currentValue)
	        ) {
	            charCode = 8;
	        }

	        owner.lastInputValue = currentValue;

	        // hit backspace when last character is delimiter
	        if (charCode === 8 && Util.isDelimiter(currentValue.slice(-pps.delimiterLength), pps.delimiter, pps.delimiters)) {
	            pps.backspace = true;

	            return;
	        }

	        pps.backspace = false;
	    },

	    onChange: function () {
	        this.onInput(this.element.value);
	    },

	    onFocus: function () {
	        var owner = this,
	            pps = owner.properties;

	        Cleave.Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);
	    },

	    onCut: function (e) {
	        this.copyClipboardData(e);
	        this.onInput('');
	    },

	    onCopy: function (e) {
	        this.copyClipboardData(e);
	    },

	    copyClipboardData: function (e) {
	        var owner = this,
	            pps = owner.properties,
	            Util = Cleave.Util,
	            inputValue = owner.element.value,
	            textToCopy = '';

	        if (!pps.copyDelimiter) {
	            textToCopy = Util.stripDelimiters(inputValue, pps.delimiter, pps.delimiters);
	        } else {
	            textToCopy = inputValue;
	        }

	        try {
	            if (e.clipboardData) {
	                e.clipboardData.setData('Text', textToCopy);
	            } else {
	                window.clipboardData.setData('Text', textToCopy);
	            }

	            e.preventDefault();
	        } catch (ex) {
	            //  empty
	        }
	    },

	    onInput: function (value) {
	        var owner = this, pps = owner.properties,
	            Util = Cleave.Util;

	        // case 1: delete one more character "4"
	        // 1234*| -> hit backspace -> 123|
	        // case 2: last character is not delimiter which is:
	        // 12|34* -> hit backspace -> 1|34*
	        // note: no need to apply this for numeral mode
	        if (!pps.numeral && pps.backspace && !Util.isDelimiter(value.slice(-pps.delimiterLength), pps.delimiter, pps.delimiters)) {
	            value = Util.headStr(value, value.length - pps.delimiterLength);
	        }

          //Cleave.jscustomFormattercleavejscustomFormatter
          if (pps.formatter) {
            value = pps.formatter(value);
          }

	        // phone formatter
	        if (pps.phone) {
	            if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
	                pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);
	            } else {
	                pps.result = pps.phoneFormatter.format(value);
	            }
	            owner.updateValueState();

	            return;
	        }

	        // numeral formatter
	        if (pps.numeral) {
	            if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
	                pps.result = pps.prefix + pps.numeralFormatter.format(value);
	            } else {
	                pps.result = pps.numeralFormatter.format(value);
	            }
	            owner.updateValueState();

	            return;
	        }

	        // date
	        if (pps.date) {
	            value = pps.dateFormatter.getValidatedDate(value);
	        }

	        // time
	        if (pps.time) {
	            value = pps.timeFormatter.getValidatedTime(value);
	        }

	        // strip delimiters
	        value = Util.stripDelimiters(value, pps.delimiter, pps.delimiters);

	        // strip prefix
	        value = Util.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength, pps.result);

	        // strip non-numeric characters
	        value = pps.numericOnly ? Util.strip(value, /[^\d]/g) : value;

	        // convert case
	        value = pps.uppercase ? value.toUpperCase() : value;
	        value = pps.lowercase ? value.toLowerCase() : value;

	        // prefix
	        if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
	            value = pps.prefix + value;

	            // no blocks specified, no need to do formatting
	            if (pps.blocksLength === 0) {
	                pps.result = value;
	                owner.updateValueState();

	                return;
	            }
	        }

	        // update credit card props
	        if (pps.creditCard) {
	            owner.updateCreditCardPropsByValue(value);
	        }

	        // strip over length characters
	        value = Util.headStr(value, pps.maxLength);

	        // apply blocks
	        pps.result = Util.getFormattedValue(
	            value,
	            pps.blocks, pps.blocksLength,
	            pps.delimiter, pps.delimiters, pps.delimiterLazyShow
	        );

	        owner.updateValueState();
	    },

	    updateCreditCardPropsByValue: function (value) {
	        var owner = this, pps = owner.properties,
	            Util = Cleave.Util,
	            creditCardInfo;

	        // At least one of the first 4 characters has changed
	        if (Util.headStr(pps.result, 4) === Util.headStr(value, 4)) {
	            return;
	        }

	        creditCardInfo = Cleave.CreditCardDetector.getInfo(value, pps.creditCardStrictMode);

	        pps.blocks = creditCardInfo.blocks;
	        pps.blocksLength = pps.blocks.length;
	        pps.maxLength = Util.getMaxLength(pps.blocks);

	        // credit card type changed
	        if (pps.creditCardType !== creditCardInfo.type) {
	            pps.creditCardType = creditCardInfo.type;

	            pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);
	        }
	    },

	    updateValueState: function () {
	        var owner = this,
	            Util = Cleave.Util,
	            pps = owner.properties;

	        if (!owner.element) {
	            return;
	        }

	        var endPos = owner.element.selectionEnd;
	        var oldValue = owner.element.value;
	        var newValue = pps.result;

	        endPos = Util.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);

	        // fix Android browser type="text" input field
	        // cursor not jumping issue
	        if (owner.isAndroid) {
	            window.setTimeout(function () {
	                owner.element.value = newValue;
	                Util.setSelection(owner.element, endPos, pps.document, false);
	                owner.callOnValueChanged();
	            }, 1);

	            return;
	        }

	        owner.element.value = newValue;
	        Util.setSelection(owner.element, endPos, pps.document, false);
	        owner.callOnValueChanged();
	    },

	    callOnValueChanged: function () {
	        var owner = this,
	            pps = owner.properties;

	        pps.onValueChanged.call(owner, {
	            target: {
	                value: pps.result,
	                rawValue: owner.getRawValue()
	            }
	        });
	    },

	    setPhoneRegionCode: function (phoneRegionCode) {
	        var owner = this, pps = owner.properties;

	        pps.phoneRegionCode = phoneRegionCode;
	        owner.initPhoneFormatter();
	        owner.onChange();
	    },

	    setRawValue: function (value) {
	        var owner = this, pps = owner.properties;

	        value = value !== undefined && value !== null ? value.toString() : '';

	        if (pps.numeral) {
	            value = value.replace('.', pps.numeralDecimalMark);
	        }

	        pps.backspace = false;

	        owner.element.value = value;
	        owner.onInput(value);
	    },

	    getRawValue: function () {
	        var owner = this,
	            pps = owner.properties,
	            Util = Cleave.Util,
	            rawValue = owner.element.value;

	        if (pps.rawValueTrimPrefix) {
	            rawValue = Util.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result);
	        }

	        if (pps.numeral) {
	            rawValue = pps.numeralFormatter.getRawValue(rawValue);
	        } else {
	            rawValue = Util.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);
	        }

	        return rawValue;
	    },

	    getISOFormatDate: function () {
	        var owner = this,
	            pps = owner.properties;

	        return pps.date ? pps.dateFormatter.getISOFormatDate() : '';
	    },

	    getFormattedValue: function () {
	        return this.element.value;
	    },

	    destroy: function () {
	        var owner = this;

	        owner.element.removeEventListener('input', owner.onChangeListener);
	        owner.element.removeEventListener('keydown', owner.onKeyDownListener);
	        owner.element.removeEventListener('focus', owner.onFocusListener);
	        owner.element.removeEventListener('cut', owner.onCutListener);
	        owner.element.removeEventListener('copy', owner.onCopyListener);
	    },

	    toString: function () {
	        return '[Cleave Object]';
	    }
	};

	Cleave.NumeralFormatter = __webpack_require__(1);
	Cleave.DateFormatter = __webpack_require__(2);
	Cleave.TimeFormatter = __webpack_require__(3);
	Cleave.PhoneFormatter = __webpack_require__(4);
	Cleave.CreditCardDetector = __webpack_require__(5);
	Cleave.Util = __webpack_require__(6);
	Cleave.DefaultProperties = __webpack_require__(7);

	// for angular directive
	((typeof global === 'object' && global) ? global : window)['Cleave'] = Cleave;

	// CommonJS
	module.exports = Cleave;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())));

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	'use strict';

	var NumeralFormatter = function (numeralDecimalMark,
	                                 numeralIntegerScale,
	                                 numeralDecimalScale,
	                                 numeralThousandsGroupStyle,
	                                 numeralPositiveOnly,
	                                 stripLeadingZeroes,
	                                 delimiter) {
	    var owner = this;

	    owner.numeralDecimalMark = numeralDecimalMark || '.';
	    owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;
	    owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;
	    owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;
	    owner.numeralPositiveOnly = !!numeralPositiveOnly;
	    owner.stripLeadingZeroes = stripLeadingZeroes !== false;
	    owner.delimiter = (delimiter || delimiter === '') ? delimiter : ',';
	    owner.delimiterRE = delimiter ? new RegExp('\\' + delimiter, 'g') : '';
	};

	NumeralFormatter.groupStyle = {
	    thousand: 'thousand',
	    lakh:     'lakh',
	    wan:      'wan',
	    none:     'none'    
	};

	NumeralFormatter.prototype = {
	    getRawValue: function (value) {
	        return value.replace(this.delimiterRE, '').replace(this.numeralDecimalMark, '.');
	    },

	    format: function (value) {
	        var owner = this, parts, partInteger, partDecimal = '';

	        // strip alphabet letters
	        value = value.replace(/[A-Za-z]/g, '')
	            // replace the first decimal mark with reserved placeholder
	            .replace(owner.numeralDecimalMark, 'M')

	            // strip non numeric letters except minus and "M"
	            // this is to ensure prefix has been stripped
	            .replace(/[^\dM-]/g, '')

	            // replace the leading minus with reserved placeholder
	            .replace(/^\-/, 'N')

	            // strip the other minus sign (if present)
	            .replace(/\-/g, '')

	            // replace the minus sign (if present)
	            .replace('N', owner.numeralPositiveOnly ? '' : '-')

	            // replace decimal mark
	            .replace('M', owner.numeralDecimalMark);

	        // strip any leading zeros
	        if (owner.stripLeadingZeroes) {
	            value = value.replace(/^(-)?0+(?=\d)/, '$1');
	        }

	        partInteger = value;

	        if (value.indexOf(owner.numeralDecimalMark) >= 0) {
	            parts = value.split(owner.numeralDecimalMark);
	            partInteger = parts[0];
	            partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);
	        }

	        if (owner.numeralIntegerScale > 0) {
	          partInteger = partInteger.slice(0, owner.numeralIntegerScale + (value.slice(0, 1) === '-' ? 1 : 0));
	        }

	        switch (owner.numeralThousandsGroupStyle) {
	        case NumeralFormatter.groupStyle.lakh:
	            partInteger = partInteger.replace(/(\d)(?=(\d\d)+\d$)/g, '$1' + owner.delimiter);

	            break;

	        case NumeralFormatter.groupStyle.wan:
	            partInteger = partInteger.replace(/(\d)(?=(\d{4})+$)/g, '$1' + owner.delimiter);

	            break;

	        case NumeralFormatter.groupStyle.thousand:
	            partInteger = partInteger.replace(/(\d)(?=(\d{3})+$)/g, '$1' + owner.delimiter);

	            break;
	        }

	        return partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : '');
	    }
	};

	module.exports = NumeralFormatter;


/***/ }),
/* 2 */
/***/ (function(module, exports) {

	'use strict';

	var DateFormatter = function (datePattern) {
	    var owner = this;

	    owner.date = [];
	    owner.blocks = [];
	    owner.datePattern = datePattern;
	    owner.initBlocks();
	};

	DateFormatter.prototype = {
	    initBlocks: function () {
	        var owner = this;
	        owner.datePattern.forEach(function (value) {
	            if (value === 'Y') {
	                owner.blocks.push(4);
	            } else {
	                owner.blocks.push(2);
	            }
	        });
	    },

	    getISOFormatDate: function () {
	        var owner = this,
	            date = owner.date;

	        return date[2] ? (
	            date[2] + '-' + owner.addLeadingZero(date[1]) + '-' + owner.addLeadingZero(date[0])
	        ) : '';
	    },

	    getBlocks: function () {
	        return this.blocks;
	    },

	    getValidatedDate: function (value) {
	        var owner = this, result = '';

	        value = value.replace(/[^\d]/g, '');

	        owner.blocks.forEach(function (length, index) {
	            if (value.length > 0) {
	                var sub = value.slice(0, length),
	                    sub0 = sub.slice(0, 1),
	                    rest = value.slice(length);

	                switch (owner.datePattern[index]) {
	                case 'd':
	                    if (sub === '00') {
	                        sub = '01';
	                    } else if (parseInt(sub0, 10) > 3) {
	                        sub = '0' + sub0;
	                    } else if (parseInt(sub, 10) > 31) {
	                        sub = '31';
	                    }

	                    break;

	                case 'm':
	                    if (sub === '00') {
	                        sub = '01';
	                    } else if (parseInt(sub0, 10) > 1) {
	                        sub = '0' + sub0;
	                    } else if (parseInt(sub, 10) > 12) {
	                        sub = '12';
	                    }

	                    break;
	                }

	                result += sub;

	                // update remaining string
	                value = rest;
	            }
	        });

	        return this.getFixedDateString(result);
	    },

	    getFixedDateString: function (value) {
	        var owner = this, datePattern = owner.datePattern, date = [],
	            dayIndex = 0, monthIndex = 0, yearIndex = 0,
	            dayStartIndex = 0, monthStartIndex = 0, yearStartIndex = 0,
	            day, month, year, fullYearDone = false;

	        // mm-dd || dd-mm
	        if (value.length === 4 && datePattern[0].toLowerCase() !== 'y' && datePattern[1].toLowerCase() !== 'y') {
	            dayStartIndex = datePattern[0] === 'd' ? 0 : 2;
	            monthStartIndex = 2 - dayStartIndex;
	            day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
	            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);

	            date = this.getFixedDate(day, month, 0);
	        }

	        // yyyy-mm-dd || yyyy-dd-mm || mm-dd-yyyy || dd-mm-yyyy || dd-yyyy-mm || mm-yyyy-dd
	        if (value.length === 8) {
	            datePattern.forEach(function (type, index) {
	                switch (type) {
	                case 'd':
	                    dayIndex = index;
	                    break;
	                case 'm':
	                    monthIndex = index;
	                    break;
	                default:
	                    yearIndex = index;
	                    break;
	                }
	            });

	            yearStartIndex = yearIndex * 2;
	            dayStartIndex = (dayIndex <= yearIndex) ? dayIndex * 2 : (dayIndex * 2 + 2);
	            monthStartIndex = (monthIndex <= yearIndex) ? monthIndex * 2 : (monthIndex * 2 + 2);

	            day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
	            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
	            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);

	            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;

	            date = this.getFixedDate(day, month, year);
	        }

	        owner.date = date;

	        return date.length === 0 ? value : datePattern.reduce(function (previous, current) {
	            switch (current) {
	            case 'd':
	                return previous + owner.addLeadingZero(date[0]);
	            case 'm':
	                return previous + owner.addLeadingZero(date[1]);
	            default:
	                return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2]) : '');
	            }
	        }, '');
	    },

	    getFixedDate: function (day, month, year) {
	        day = Math.min(day, 31);
	        month = Math.min(month, 12);
	        year = parseInt((year || 0), 10);

	        if ((month < 7 && month % 2 === 0) || (month > 8 && month % 2 === 1)) {
	            day = Math.min(day, month === 2 ? (this.isLeapYear(year) ? 29 : 28) : 30);
	        }

	        return [day, month, year];
	    },

	    isLeapYear: function (year) {
	        return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
	    },

	    addLeadingZero: function (number) {
	        return (number < 10 ? '0' : '') + number;
	    },

	    addLeadingZeroForYear: function (number) {
	        return (number < 10 ? '000' : (number < 100 ? '00' : (number < 1000 ? '0' : ''))) + number;
	    }
	};

	module.exports = DateFormatter;



/***/ }),
/* 3 */
/***/ (function(module, exports) {

	'use strict';

	var TimeFormatter = function (timePattern) {
	    var owner = this;

	    owner.time = [];
	    owner.blocks = [];
	    owner.timePattern = timePattern;
	    owner.initBlocks();
	};

	TimeFormatter.prototype = {
	    initBlocks: function () {
	        var owner = this;
	        owner.timePattern.forEach(function () {
	            owner.blocks.push(2);
	        });
	    },

	    getISOFormatTime: function () {
	        var owner = this,
	            time = owner.time;

	        return time[2] ? (
	            owner.addLeadingZero(time[0]) + ':' + owner.addLeadingZero(time[1]) + ':' + owner.addLeadingZero(time[2])
	        ) : '';
	    },

	    getBlocks: function () {
	        return this.blocks;
	    },

	    getValidatedTime: function (value) {
	        var owner = this, result = '';

	        value = value.replace(/[^\d]/g, '');

	        owner.blocks.forEach(function (length, index) {
	            if (value.length > 0) {
	                var sub = value.slice(0, length),
	                    sub0 = sub.slice(0, 1),
	                    rest = value.slice(length);

	                switch (owner.timePattern[index]) {

	                case 'h':
	                    if (parseInt(sub0, 10) > 2) {
	                        sub = '0' + sub0;
	                    } else if (parseInt(sub, 10) > 23) {
	                        sub = '23';
	                    }

	                    break;

	                case 'm':
	                case 's':
	                    if (parseInt(sub0, 10) > 5) {
	                        sub = '0' + sub0;
	                    } else if (parseInt(sub, 10) > 60) {
	                        sub = '60';
	                    }
	                    break;
	                }

	                result += sub;

	                // update remaining string
	                value = rest;
	            }
	        });

	        return this.getFixedTimeString(result);
	    },

	    getFixedTimeString: function (value) {
	        var owner = this, timePattern = owner.timePattern, time = [],
	            secondIndex = 0, minuteIndex = 0, hourIndex = 0,
	            secondStartIndex = 0, minuteStartIndex = 0, hourStartIndex = 0,
	            second, minute, hour;

	        if (value.length === 6) {
	            timePattern.forEach(function (type, index) {
	                switch (type) {
	                case 's':
	                    secondIndex = index * 2;
	                    break;
	                case 'm':
	                    minuteIndex = index * 2;
	                    break;
	                case 'h':
	                    hourIndex = index * 2;
	                    break;
	                }
	            });

	            hourStartIndex = hourIndex;
	            minuteStartIndex = minuteIndex;
	            secondStartIndex = secondIndex;

	            second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);
	            minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
	            hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);

	            time = this.getFixedTime(hour, minute, second);
	        }

	        if (value.length === 4 && owner.timePattern.indexOf('s') < 0) {
	            timePattern.forEach(function (type, index) {
	                switch (type) {
	                case 'm':
	                    minuteIndex = index * 2;
	                    break;
	                case 'h':
	                    hourIndex = index * 2;
	                    break;
	                }
	            });

	            hourStartIndex = hourIndex;
	            minuteStartIndex = minuteIndex;

	            second = 0;
	            minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
	            hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);

	            time = this.getFixedTime(hour, minute, second);
	        }

	        owner.time = time;

	        return time.length === 0 ? value : timePattern.reduce(function (previous, current) {
	            switch (current) {
	            case 's':
	                return previous + owner.addLeadingZero(time[2]);
	            case 'm':
	                return previous + owner.addLeadingZero(time[1]);
	            case 'h':
	                return previous + owner.addLeadingZero(time[0]);
	            }
	        }, '');
	    },

	    getFixedTime: function (hour, minute, second) {
	        second = Math.min(parseInt(second || 0, 10), 60);
	        minute = Math.min(minute, 60);
	        hour = Math.min(hour, 60);

	        return [hour, minute, second];
	    },

	    addLeadingZero: function (number) {
	        return (number < 10 ? '0' : '') + number;
	    }
	};

	module.exports = TimeFormatter;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	'use strict';

	var PhoneFormatter = function (formatter, delimiter) {
	    var owner = this;

	    owner.delimiter = (delimiter || delimiter === '') ? delimiter : ' ';
	    owner.delimiterRE = delimiter ? new RegExp('\\' + delimiter, 'g') : '';

	    owner.formatter = formatter;
	};

	PhoneFormatter.prototype = {
	    setFormatter: function (formatter) {
	        this.formatter = formatter;
	    },

	    format: function (phoneNumber) {
	        var owner = this;

	        owner.formatter.clear();

	        // only keep number and +
	        phoneNumber = phoneNumber.replace(/[^\d+]/g, '');

	        // strip non-leading +
	        phoneNumber = phoneNumber.replace(/^\+/, 'B').replace(/\+/g, '').replace('B', '+');

	        // strip delimiter
	        phoneNumber = phoneNumber.replace(owner.delimiterRE, '');

	        var result = '', current, validated = false;

	        for (var i = 0, iMax = phoneNumber.length; i < iMax; i++) {
	            current = owner.formatter.inputDigit(phoneNumber.charAt(i));

	            // has ()- or space inside
	            if (/[\s()-]/g.test(current)) {
	                result = current;

	                validated = true;
	            } else {
	                if (!validated) {
	                    result = current;
	                }
	                // else: over length input
	                // it turns to invalid number again
	            }
	        }

	        // strip ()
	        // e.g. US: 7161234567 returns (716) 123-4567
	        result = result.replace(/[()]/g, '');
	        // replace library delimiter with user customized delimiter
	        result = result.replace(/[\s-]/g, owner.delimiter);

	        return result;
	    }
	};

	module.exports = PhoneFormatter;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	'use strict';

	var CreditCardDetector = {
	    blocks: {
	        uatp:          [4, 5, 6],
	        amex:          [4, 6, 5],
	        diners:        [4, 6, 4],
	        discover:      [4, 4, 4, 4],
	        mastercard:    [4, 4, 4, 4],
	        dankort:       [4, 4, 4, 4],
	        instapayment:  [4, 4, 4, 4],
	        jcb15:         [4, 6, 5],
	        jcb:           [4, 4, 4, 4],
	        maestro:       [4, 4, 4, 4],
	        visa:          [4, 4, 4, 4],
	        mir:           [4, 4, 4, 4],
	        unionPay:      [4, 4, 4, 4],
	        general:       [4, 4, 4, 4],
	        generalStrict: [4, 4, 4, 7]
	    },

	    re: {
	        // starts with 1; 15 digits, not starts with 1800 (jcb card)
	        uatp: /^(?!1800)1\d{0,14}/,

	        // starts with 34/37; 15 digits
	        amex: /^3[47]\d{0,13}/,

	        // starts with 6011/65/644-649; 16 digits
	        discover: /^(?:6011|65\d{0,2}|64[4-9]\d?)\d{0,12}/,

	        // starts with 300-305/309 or 36/38/39; 14 digits
	        diners: /^3(?:0([0-5]|9)|[689]\d?)\d{0,11}/,

	        // starts with 51-55/22212720; 16 digits
	        mastercard: /^(5[1-5]\d{0,2}|22[2-9]\d{0,1}|2[3-7]\d{0,2})\d{0,12}/,

	        // starts with 5019/4175/4571; 16 digits
	        dankort: /^(5019|4175|4571)\d{0,12}/,

	        // starts with 637-639; 16 digits
	        instapayment: /^63[7-9]\d{0,13}/,

	        // starts with 2131/1800; 15 digits
	        jcb15: /^(?:2131|1800)\d{0,11}/,

	        // starts with 2131/1800/35; 16 digits
	        jcb: /^(?:35\d{0,2})\d{0,12}/,

	        // starts with 50/56-58/6304/67; 16 digits
	        maestro: /^(?:5[0678]\d{0,2}|6304|67\d{0,2})\d{0,12}/,

	        // starts with 22; 16 digits
	        mir: /^220[0-4]\d{0,12}/,

	        // starts with 4; 16 digits
	        visa: /^4\d{0,15}/,

	        // starts with 62; 16 digits
	        unionPay: /^62\d{0,14}/
	    },

	    getInfo: function (value, strictMode) {
	        var blocks = CreditCardDetector.blocks,
	            re = CreditCardDetector.re;

	        // Some credit card can have up to 19 digits number.
	        // Set strictMode to true will remove the 16 max-length restrain,
	        // however, I never found any website validate card number like
	        // this, hence probably you don't want to enable this option.
	        strictMode = !!strictMode;

	        for (var key in re) {
	            if (re[key].test(value)) {
	                var block;

	                if (strictMode) {
	                    block = blocks.generalStrict;
	                } else {
	                    block = blocks[key];
	                }

	                return {
	                    type: key,
	                    blocks: block
	                };
	            }
	        }

	        return {
	            type:   'unknown',
	            blocks: strictMode ? blocks.generalStrict : blocks.general
	        };
	    }
	};

	module.exports = CreditCardDetector;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	'use strict';

	var Util = {
	    noop: function () {
	    },

	    strip: function (value, re) {
	        return value.replace(re, '');
	    },

	    isDelimiter: function (letter, delimiter, delimiters) {
	        // single delimiter
	        if (delimiters.length === 0) {
	            return letter === delimiter;
	        }

	        // multiple delimiters
	        return delimiters.some(function (current) {
	            if (letter === current) {
	                return true;
	            }
	        });
	    },

	    getDelimiterREByDelimiter: function (delimiter) {
	        return new RegExp(delimiter.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1'), 'g');
	    },

	    getNextCursorPosition: function (prevPos, oldValue, newValue, delimiter, delimiters) {
	      // If cursor was at the end of value, just place it back.
	      // Because new value could contain additional chars.
	      if (oldValue.length === prevPos) {
	          return newValue.length;
	      }

	      return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter ,delimiters);
	    },

	    getPositionOffset: function (prevPos, oldValue, newValue, delimiter, delimiters) {
	        var oldRawValue, newRawValue, lengthOffset;

	        oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);
	        newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);
	        lengthOffset = oldRawValue.length - newRawValue.length;

	        return (lengthOffset !== 0) ? (lengthOffset / Math.abs(lengthOffset)) : 0;
	    },

	    stripDelimiters: function (value, delimiter, delimiters) {
	        var owner = this;

	        // single delimiter
	        if (delimiters.length === 0) {
	            var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : '';

	            return value.replace(delimiterRE, '');
	        }

	        // multiple delimiters
	        delimiters.forEach(function (current) {
	            value = value.replace(owner.getDelimiterREByDelimiter(current), '');
	        });

	        return value;
	    },

	    headStr: function (str, length) {
	        return str.slice(0, length);
	    },

	    getMaxLength: function (blocks) {
	        return blocks.reduce(function (previous, current) {
	            return previous + current;
	        }, 0);
	    },

	    // strip value by prefix length
	    // for prefix: PRE
	    // (PRE123, 3) -> 123
	    // (PR123, 3) -> 23 this happens when user hits backspace in front of "PRE"
	    getPrefixStrippedValue: function (value, prefix, prefixLength, prevValue) {
	        if (value.slice(0, prefixLength) !== prefix) {

	            // Check whether if it is a deletion
	            if (value.length < prevValue.length) {
	                value = value.length > prefixLength ? prevValue : prefix;
	            } else {
	                var diffIndex = this.getFirstDiffIndex(prefix, value.slice(0, prefixLength));
	                value = prefix + value.slice(diffIndex, diffIndex + 1) + value.slice(prefixLength + 1);
	            }
	        }

	        return value.slice(prefixLength);
	    },

	    getFirstDiffIndex: function (prev, current) {
	        var index = 0;

	        while (prev.charAt(index) === current.charAt(index)) {
	            if (prev.charAt(index++) === '') {
	                return -1;
	            }
	        }

	        return index;
	    },

	    getFormattedValue: function (value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {
	        var result = '',
	            multipleDelimiters = delimiters.length > 0,
	            currentDelimiter;

	        // no options, normal input
	        if (blocksLength === 0) {
	            return value;
	        }

	        blocks.forEach(function (length, index) {
	            if (value.length > 0) {
	                var sub = value.slice(0, length),
	                    rest = value.slice(length);

	                if (multipleDelimiters) {
	                    currentDelimiter = delimiters[delimiterLazyShow ? (index - 1) : index] || currentDelimiter;
	                } else {
	                    currentDelimiter = delimiter;
	                }

	                if (delimiterLazyShow) {
	                    if (index > 0) {
	                        result += currentDelimiter;
	                    }

	                    result += sub;
	                } else {
	                    result += sub;

	                    if (sub.length === length && index < blocksLength - 1) {
	                        result += currentDelimiter;
	                    }
	                }

	                // update remaining string
	                value = rest;
	            }
	        });

	        return result;
	    },

	    // move cursor to the end
	    // the first time user focuses on an input with prefix
	    fixPrefixCursor: function (el, prefix, delimiter, delimiters) {
	        if (!el) {
	            return;
	        }

	        var val = el.value,
	            appendix = delimiter || (delimiters[0] || ' ');

	        if (!el.setSelectionRange || !prefix || (prefix.length + appendix.length) < val.length) {
	            return;
	        }

	        var len = val.length * 2;

	        // set timeout to avoid blink
	        setTimeout(function () {
	            el.setSelectionRange(len, len);
	        }, 1);
	    },

	    setSelection: function (element, position, doc) {
	        if (element !== this.getActiveElement(doc)) {
	            return;
	        }

	        // cursor is already in the end
	        if (element && element.value.length <= position) {
	          return;
	        }

	        if (element.createTextRange) {
	            var range = element.createTextRange();

	            range.move('character', position);
	            range.select();
	        } else {
	            try {
	                element.setSelectionRange(position, position);
	            } catch (e) {
	                // eslint-disable-next-line
	                console.warn('The input element type does not support selection');
	            }
	        }
	    },
	    
	    getActiveElement: function(parent) {
	        var activeElement = parent.activeElement;
	        if (activeElement && activeElement.shadowRoot) {
	            return this.getActiveElement(activeElement.shadowRoot);
	        }
	        return activeElement;
	    },

	    isAndroid: function () {
	        return navigator && /android/i.test(navigator.userAgent);
	    },

	    // On Android chrome, the keyup and keydown events
	    // always return key code 229 as a composition that
	    // buffers the users keystrokes
	    // see https://github.com/nosir/cleave.js/issues/147
	    isAndroidBackspaceKeydown: function (lastInputValue, currentInputValue) {
	        if (!this.isAndroid() || !lastInputValue || !currentInputValue) {
	            return false;
	        }

	        return currentInputValue === lastInputValue.slice(0, -1);
	    }
	};

	module.exports = Util;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	/**
	 * Props Assignment
	 *
	 * Separate this, so react module can share the usage
	 */
	var DefaultProperties = {
	    // Maybe change to object-assign
	    // for now just keep it as simple
	    assign: function (target, opts) {
	        target = target || {};
	        opts = opts || {};

	        // credit card
	        target.creditCard = !!opts.creditCard;
	        target.creditCardStrictMode = !!opts.creditCardStrictMode;
	        target.creditCardType = '';
	        target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || (function () {});

	        // phone
	        target.phone = !!opts.phone;
	        target.phoneRegionCode = opts.phoneRegionCode || 'AU';
	        target.phoneFormatter = {};

	        // time
	        target.time = !!opts.time;
	        target.timePattern = opts.timePattern || ['h', 'm', 's'];
	        target.timeFormatter = {};

	        // date
	        target.date = !!opts.date;
	        target.datePattern = opts.datePattern || ['d', 'm', 'Y'];
	        target.dateFormatter = {};

	        // numeral
	        target.numeral = !!opts.numeral;
	        target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;
	        target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;
	        target.numeralDecimalMark = opts.numeralDecimalMark || '.';
	        target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || 'thousand';
	        target.numeralPositiveOnly = !!opts.numeralPositiveOnly;
	        target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;

	        // others
	        target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;

	        target.uppercase = !!opts.uppercase;
	        target.lowercase = !!opts.lowercase;

          target.formatter = typeof opts.customFormatter === 'function' ? opts.customFormatter : null;

	        target.prefix = (target.creditCard || target.date) ? '' : (opts.prefix || '');
	        target.noImmediatePrefix = !!opts.noImmediatePrefix;
	        target.prefixLength = target.prefix.length;
	        target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;
	        target.copyDelimiter = !!opts.copyDelimiter;

	        target.initValue = (opts.initValue !== undefined && opts.initValue !== null) ? opts.initValue.toString() : '';

	        target.delimiter =
	            (opts.delimiter || opts.delimiter === '') ? opts.delimiter :
	                (opts.date ? '/' :
	                    (opts.time ? ':' :
	                        (opts.numeral ? ',' :
	                            (opts.phone ? ' ' :
	                                ' '))));
	        target.delimiterLength = target.delimiter.length;
	        target.delimiterLazyShow = !!opts.delimiterLazyShow;
	        target.delimiters = opts.delimiters || [];

	        target.blocks = opts.blocks || [];
	        target.blocksLength = target.blocks.length;

	        target.root = (typeof global === 'object' && global) ? global : window;
	        target.document = opts.document || target.root.document;

	        target.maxLength = 0;

	        target.backspace = false;
	        target.result = '';

	        target.onValueChanged = opts.onValueChanged || (function () {});

	        return target;
	    }
	};

	module.exports = DefaultProperties;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())));

/***/ })
/******/ ]);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'Cleave'], definition);
  } else {
    context.VueInput = definition(context.Vue, context.VueUtil, context.Cleave);
    delete context.VueInput;
    delete context.Cleave;
  }
})(this, function(Vue, VueUtil, Cleave) {
  'use strict';

  var hiddenTextarea;
  var HIDDEN_STYLE = '\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n';
  var CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

  function calculateNodeStyling(targetElement) {
    var style = window.getComputedStyle(targetElement);
    var boxSizing = style.getPropertyValue('box-sizing');
    var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
    var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
    var contextStyle = CONTEXT_STYLE.map(function (name) {
      return ''.concat(name, ':').concat(style.getPropertyValue(name));
    }).join(';');
    return {
      contextStyle: contextStyle,
      paddingSize: paddingSize,
      borderSize: borderSize,
      boxSizing: boxSizing
    };
  }

  function calcTextareaHeight(targetElement) {
    var minRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var maxRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement('textarea');
      document.body.appendChild(hiddenTextarea);
    }

    var _calculateNodeStyling = calculateNodeStyling(targetElement),
        paddingSize = _calculateNodeStyling.paddingSize,
        borderSize = _calculateNodeStyling.borderSize,
        boxSizing = _calculateNodeStyling.boxSizing,
        contextStyle = _calculateNodeStyling.contextStyle;

    hiddenTextarea.setAttribute('style', ''.concat(contextStyle, ';').concat(HIDDEN_STYLE));
    hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';
    var height = hiddenTextarea.scrollHeight;
    var result = {};

    if (boxSizing === 'border-box') {
      height = height + borderSize;
    } else if (boxSizing === 'content-box') {
      height = height - paddingSize;
    }

    hiddenTextarea.value = '';
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

    if (minRows !== null) {
      var minHeight = singleRowHeight * minRows;

      if (boxSizing === 'border-box') {
        minHeight = minHeight + paddingSize + borderSize;
      }

      height = Math.max(minHeight, height);
      result.minHeight = ''.concat(minHeight, 'px');
    }

    if (maxRows !== null) {
      var maxHeight = singleRowHeight * maxRows;

      if (boxSizing === 'border-box') {
        maxHeight = maxHeight + paddingSize + borderSize;
      }

      height = Math.min(maxHeight, height);
    }

    result.height = ''.concat(height, 'px');
    hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
    hiddenTextarea = null;
    return result;
  }

  var VueInput = {
    template: 
    '<div :class="[type === \'textarea\' ? \'vue-textarea\' : \'vue-input\', size ? \'vue-input--\' + size : \'\', {\'is-disabled\': disabled, '+
    '     \'vue-input-group\': $slots.prepend || $slots.append, \'vue-input-group--append\': $slots.append, \'vue-input-group--prepend\': $slots.prepend,'+
    '     \'is-readonly\': readonly, \'vue-input--prefix\': $slots.prefix || prefixIcon, '+
    '     }]" >'+

    '    <template v-if="type !== \'textarea\'">'+
    '        <div class="vue-input-group__prepend" v-if="$slots.prepend">'+
    '            <slot name="prepend"></slot>'+
    '        </div>'+
    '        <slot name="icon">'+
    '            <i :class="[\'vue-input__icon\', icon, onIconClick ? \'is-clickable\' : \'\']" v-if="icon" @click="handleIconClick" ref="icon"></i>'+
    '        </slot>'+
    '        <input :style="inputStyle" v-if="type !== \'textarea\'" class="vue-input__inner" :type="type==\'number\'?\'input\':type" :name="name" '+
    '               :placeholder="placeholder" :disabled="disabled" :readonly="readonly" :maxlength="maxlength" '+
    '               :minlength="minlength" :autocomplete="autoComplete" :autofocus="autofocus" :tabindex="tabindex" '+
    '               :min="min" :max="max" :form="form" :value="currentValue" ref="input" @input="handleInput" '+
    '               @focus="handleFocus" @blur="handleBlur" @change="handleChange" @compositionstart="handleComposition" '+
    '               @compositionupdate="handleComposition" @compositionend="handleComposition">'+
    
    '        <span class="vue-input__prefix" v-if="$slots.prefix || prefixIcon"> '+
    '          <slot name="prefix"></slot> '+
    '          <i class="vue-input__icon" '+
    '             v-if="prefixIcon" '+
    '             :class="prefixIcon"> '+
    '          </i> '+
    '        </span> '+

    '        <i class="vue-input__icon vue-icon-loading" v-if="validating"></i>'+
    '        <div class="vue-input-group__append" v-if="$slots.append">'+
    '            <slot name="append"></slot>'+
    '        </div>'+
    '    </template>'+
    '    <textarea v-else class="vue-textarea__inner" :value="currentValue" @input="handleInput" ref="textarea" '+
    '             :name="name" :placeholder="placeholder" :disabled="disabled" :style="textareaStyle" :readonly="readonly" '+
    '             :rows="rows" :form="form" :autofocus="autofocus" :tabindex="tabindex" :maxlength="maxlength" :minlength="minlength" '+
    '             @focus="handleFocus" @blur="handleBlur" @change="handleChange" @compositionstart="handleComposition" @compositionupdate="handleComposition" '+
    '             @compositionend="handleComposition"></textarea>'+
    '</div>',
    name: 'VueInput',
    mixins: [VueUtil.component.emitter],
    data: function() {
      return {
        currentValue: this.value,
        textareaCalcStyle: {}
      };
    },
    props: {
      prefixIcon: String,
      value: [String, Number],
      placeholder: String,
      size: String,
      resize: String,
      readonly: Boolean,
      autofocus: Boolean,
      icon: String,
      tabindex: Number,
      disabled: Boolean,
      noime: Boolean,
      type: {
        type: String,
        default: 'text'
      },
      name: String,
      autosize: {
        type: [Boolean, Object],
        default: false
      },
      rows: {
        type: Number,
        default: 2
      },
      autoComplete: {
        type: String,
        default: 'off'
      },
      form: String,
      maxlength: Number,
      minlength: Number,
      max: {},
      min: {},
      cleave: {
        type: Object,
        default: function() {return null;}
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      onIconClick: Function,
      textAlign: String
    },
    computed: {
      textareaStyle: function () {
        return VueUtil.merge({}, this.textareaCalcStyle, {
          resize: this.resize
        });
      },
      validating: function() {
        return this.$parent.validateState === 'validating';
      },
      inputStyle: function() {
        var style={};
        if (['center', 'right'].indexOf(this.textAlign) !== -1) {
          style.textAlign = this.textAlign;
        }
        return style;
      }
    },
    watch: {
      'value': function(val) {
        this.setCurrentValue(val, true);
      }
    },
    methods: {
      focus: function() {
        if (this.type !== 'textarea') {
          this.$refs.input.focus();
        } else {
          this.$refs.textarea.focus();
        }
      },
      handleChange: function(event) {
        this.$emit('change', event.target.value);
      },
      handleBlur: function(event) {
        this.$emit('blur', event);
        if (this.validateEvent) {
          this.dispatch('VueFormItem', 'vue.form.blur', [this.currentValue]);
        }
      },
      inputSelect: function() {
        this.$refs.input.select();
      },
      resizeTextarea: function () {
        var autosize = this.autosize,
            type = this.type;
        if (type !== 'textarea') return;
    
        if (!autosize) {
          this.textareaCalcStyle = {
            minHeight: calcTextareaHeight(this.$refs.textarea).minHeight
          };
          return;
        }
    
        var minRows = autosize.minRows;
        var maxRows = autosize.maxRows;
        this.textareaCalcStyle = calcTextareaHeight(this.$refs.textarea, minRows, maxRows);
      },
      handleFocus: function(event) {
        this.$emit('focus', event);
      },
      handleComposition: function(event) {
        if (event.type === 'compositionend') {
          this.handleInput(event);
        }
      },
      handleInput: function(event) {
        if (this.noime) {
          if(!event.isComposing) {
            this.setCurrentValue(event.target.value);
          } else {
            this.setCurrentValue(this.currentValue,true);
          }
        } else {
          this.setCurrentValue(event.target.value);
        }
      },
      handleIconClick: function(event) {
        if (this.onIconClick) {
          this.onIconClick(event);
        }
        this.$emit('click', event);
      },
      setCurrentValue: function(value, watchFlg) {
        if (!VueUtil.isDef(value)) value = '';
        var self = this;
        if (value === self.currentValue && !watchFlg)
          return;
        self.$nextTick(function() {
          self.resizeTextarea();
        });
        if (self.type !== 'textarea' && self.cleave !== null) {
          var endPos = self.$refs.input.selectionEnd;
          self.$refs.input.value = value;
          var cleaveObj = new Cleave(self.$refs.input, self.cleave);
          self.currentValue = cleaveObj.getFormattedValue();
          if (cleaveObj.getFormattedValue().length >= value.length && !watchFlg) { 
            self.currentValue = value;
          }
          value = cleaveObj.getRawValue();
          cleaveObj.destroy && cleaveObj.destroy();

          var pos = Cleave.Util.getNextCursorPosition(endPos, self.currentValue, cleaveObj.properties.result, cleaveObj.properties.delimiter, cleaveObj.properties.delimiters);
          if (document.activeElement == self.$refs.input) {
            self.$refs.input.setSelectionRange(pos, pos);
          }
          
        } else {
          self.currentValue = value;
        }
        if (self.type == 'number' && VueUtil.isNumberStr(value)) {
          value = parseFloat(value);
        }
        if (!watchFlg) {
          self.$emit('input', value);
        }
        if (self.validateEvent) {
          self.dispatch('VueFormItem', 'vue.form.change', [value]);
        }
      }
    },
    created: function() {
      this.$on('inputSelect', this.inputSelect);
    },
    mounted: function() {
      this.setCurrentValue(this.currentValue, true);
      this.resizeTextarea();
    }
  };
  Vue.component(VueInput.name, VueInput);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueAlert = definition(context.Vue);
    delete context.VueAlert;
  }
})(this, function(Vue) {
  'use strict';
  var VueAlert = {
    template: '<div :class="[\'vue-alert\', typeClass]" v-if="visible"><i :class="[\'vue-alert__icon\', iconClass, \'is-big\']" v-if="showIcon"></i><div class="vue-alert__content"><span class="vue-alert__title is-bold" v-if="title">{{title}}</span><div class="vue-alert__description"><slot></slot></div><i :class="[\'vue-alert__closebtn\', {\'is-customed\': closeText !== \'\', \'vue-icon-close\': closeText === \'\'}]" v-if="closable" @click="close()">{{closeText}}</i></div></div>',
    name: 'VueAlert',
    props: {
      title: {
        type: String,
        default: ''
      },
      description: {
        type: String,
        default: ''
      },
      type: {
        type: String,
        default: 'info'
      },
      closable: {
        type: Boolean,
        default: true
      },
      closeText: {
        type: String,
        default: ''
      },
      showIcon: Boolean,
      dark: Boolean
    },
    data: function() {
      return {
        visible: true
      };
    },
    methods: {
      close: function() {
        this.visible = false;
        this.$emit('close');
      }
    },
    computed: {
      typeClass: function() {
        if (this.dark) {
          return 'vue-alert--' + this.type + '-dark';
        }
        return 'vue-alert--' + this.type;
      },
      iconClass: function() {
        var TYPE_CLASSES_MAP = {
          'success': 'vue-icon-success',
          'warning': 'vue-icon-warning',
          'error': 'vue-icon-error'
        };
        return TYPE_CLASSES_MAP[this.type] || 'vue-icon-information';
      }
    }
  };
  Vue.component(VueAlert.name, VueAlert);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopup', 'VueUtil'], definition);
  } else {
    context.VueAside = definition(context.Vue, context.VuePopup, context.VueUtil);
    delete context.VueAside;
  }
})(this, function(Vue, VuePopup, VueUtil) {
  'use strict';
  var VueAside = {
    template: '<div :class="[{\'vue-aside__static\':relative}]"><div v-show="visibleaside" :class="[\'vue-aside__wrapper\', {\'vue-aside__absolute\':relative}, {\'is-cleanness\': cleannessModal}]" @click.self="handleWrapperClick"></div><transition :name="transitionName"><div v-show="visibleaside" :class="[\'vue-aside\', {\'vue-aside__absolute\':relative}, sizeClass, customClass, positionClass]" ref="aside"><div class="vue-aside__header"><span class="vue-aside__title" v-if="showTitle && !$slots.header">{{title}}</span><slot name="header"></slot><div v-if="showClose" class="vue-aside__headerbtn"><i class="vue-aside__close vue-icon-close" @click=\'handleClose\'></i></div></div><div class="vue-aside__body"><slot></slot></div><div class="vue-aside__footer" v-if="$slots.footer"><slot name="footer"></slot></div></div></transition></div>',
    name: 'VueAside',
    mixins: [VuePopup],
    data: function() {
      return {
        visibleaside: false
      };
    },
    props: {
      title: {
        type: String,
        default: ''
      },
      closeOnClickModal: Boolean,
      closeOnPressEscape: {
        type: Boolean,
        default: true
      },
      showClose: Boolean,
      size: {
        type: String,
        default: 'small'
      },
      position: {
        type: String,
        default: 'right'
      },
      relative: Boolean,
      transition: {
        type: Boolean,
        default: true
      },
      customClass: {
        type: String,
        default: ''
      },
      cleannessModal: Boolean,
      beforeClose: Function
    },
    watch: {
      visibleaside: function(val) {
        if (val) {
          this.opened = true;
          this.$emit('open');
          VueUtil.on(this.$el, 'scroll', this.updatePopper);
          var refsAside = this.$refs.aside;
          this.$nextTick(function() {
            refsAside.scrollTop = 0;
          });
        } else {
          this.opened = false;
          VueUtil.off(this.$el, 'scroll', this.updatePopper);
          this.$emit('close');
        }
      },
      visible: function(val) {
        if (val) {
          this.visibleaside = val;
        } else {
          if (VueUtil.isFunction(this.beforeClose)) {
            var self = this;
            var done = function(resolve) {
              if (!VueUtil.isDef(resolve)) resolve = true;
              if (resolve) {
                self.$nextTick(function() {
                  self.visibleaside = val;
                });
              } else {
                self.$emit('visible-change', true);
              }
            };
            self.beforeClose(done);
          } else {
            this.visibleaside = val;
          }
        }
      }
    },
    computed: {
      showTitle: function() {
        return VueUtil.trim(this.title) === '' ? false : true;
      },
      sizeClass: function() {
        return 'vue-aside--' + this.size;
      },
      positionClass: function() {
        var position = this.position;
        if (['left','right','top','bottom'].indexOf(position) === -1) {
          position = 'right';
        }
        return 'vue-aside-' + position;
      },
      transitionName: function() {
        if (!this.transition) return '';
        var position = this.position;
        if (['left','right','top','bottom'].indexOf(position) === -1) {
          position = 'right';
        }
        return 'aside-' + position;
      }
    },
    methods: {
      handleWrapperClick: function() {
        if (!this.closeOnClickModal) return;
        this.handleClose();
      },
      handleClose: function() {
        this.$emit('visible-change', false);
      }
    }
  };
  Vue.component(VueAside.name, VueAside);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VuePopper'], definition);
  } else {
    context.VueAutocomplete = definition(context.Vue, context.VueUtil, context.VuePopper);
    delete context.VueAutocomplete;
  }
})(this, function(Vue, VueUtil, VuePopper) {
  'use strict';
  var VueAutocompleteSuggestions = {
    template: '<transition @after-leave="destroyPopper"><div v-show="showPopper" :class="[\'vue-autocomplete-suggestion\', {\'is-loading\': $parent.loading}]" :style="{width: dropdownWidth}"><ul class="vue-autocomplete-suggestion__wrap" ref="suggestion"><li v-if="$parent.loading"><i class="vue-icon-loading"></i></li><template v-for="(item, index) in suggestions" v-else><li ref="suggestionList" v-if="!$parent.customItem" :class="{\'highlighted\': $parent.highlightedIndex === index}" @click="select(item)">{{item[props.label]}}</li><component v-else :class="{\'highlighted\': $parent.highlightedIndex === index}" @click="select(item)" :is="$parent.customItem" :item="item" :index="index"></component></template></ul></div></transition>',
    mixins: [VuePopper, VueUtil.component.emitter],
    name: 'VueAutocompleteSuggestions',
    data: function() {
      return {
        dropdownWidth: ''
      };
    },
    props: {
      props: Object,
      suggestions: Array
    },
    methods: {
      select: function(item) {
        this.dispatch('VueAutocomplete', 'item-click', item);
      }
    },
    updated: function() {
      var self = this;
      self.$nextTick(function() {
        self.updatePopper();
      });
    },
    mounted: function() {
      this.$parent.popperElm = this.popperElm = this.$el;
      this.referenceElm = this.$parent.$refs.input.$refs.input;
    },
    created: function() {
      var self = this;
      self.$on('visible', function(val, inputWidth) {
        self.dropdownWidth = inputWidth + 'px';
        self.showPopper = val;
      });
    }
  };
  var VueAutocomplete = {
    template: '<div class="vue-autocomplete" v-clickoutside="close"><vue-input :text-align="textAlign" :autofocus="autofocus" :tabindex="tabindex" ref="input" v-bind="$props" @compositionstart.native="handleComposition" @compositionupdate.native="handleComposition" @compositionend.native="handleComposition" @input="handleInput" @change="handleChange" @focus="handleFocus" @keydown.up.native.prevent="highlight(highlightedIndex - 1)" @keydown.down.native.prevent="highlight(highlightedIndex + 1)" @keydown.enter.native.prevent="handleKeyEnter" @keydown.native.tab="close"><template slot="prepend" v-if="$slots.prepend"><slot name="prepend"></slot></template><template slot="append" v-if="$slots.append"><slot name="append"></slot></template></vue-input><vue-autocomplete-suggestions :props="props" :class="[popperClass ? popperClass : \'\']" ref="suggestions" :suggestions="suggestions" v-if="suggestionVisible"></vue-autocomplete-suggestions></div>',
    name: 'VueAutocomplete',
    mixins: [VueUtil.component.emitter],
    components: {
      VueAutocompleteSuggestions: VueAutocompleteSuggestions
    },
    directives: {
      Clickoutside: VueUtil.component.clickoutside()
    },
    props: {
      props: {
        type: Object,
        default: function() {
          return {
            label: 'value',
            value: 'value'
          };
        }
      },
      popperClass: String,
      placeholder: String,
      disabled: Boolean,
      name: String,
      size: String,
      value: String,
      autofocus: Boolean,
      tabindex: Number,
      textAlign: String,
      fetchSuggestions: Function,
      triggerOnFocus: {
        type: Boolean,
        default: true
      },
      customItem: String,
      icon: String,
      onIconClick: Function
    },
    data: function() {
      return {
        suggestions: [],
        loading: false,
        highlightedIndex: -1,
        activated: false
      };
    },
    computed: {
      suggestionVisible: function() {
        var suggestions = this.suggestions;
        var isValidData = VueUtil.isArray(suggestions) && suggestions.length > 0;
        return (isValidData || this.loading) && this.activated;
      }
    },
    watch: {
      suggestionVisible: function(val) {
        var self = this;
        self.$nextTick(function() {
          self.broadcast('VueAutocompleteSuggestions', 'visible', [val, self.$refs.input.$refs.input.offsetWidth]);
        });
      }
    },
    methods: {
      focus: function() {
        this.$refs.input.focus();
      },
      getData: function(queryString) {
        var self = this;
        self.loading = true;
        self.fetchSuggestions && self.fetchSuggestions(queryString, function(suggestions) {
          self.loading = false;
          if (VueUtil.isArray(suggestions)) {
            self.suggestions = suggestions;
          } else {
            throw 'autocomplete suggestions must be an array';
          }
        });
      },
      handleComposition: function(event) {
        if (event.type === 'compositionend') {
          this.isOnComposition = false;
          this.handleChange(event.data);
        } else {
          this.isOnComposition = true;
        }
      },
      handleInput: function(value) {
        this.handleChange(value);
      },
      handleChange: function(value) {
        this.$emit('input', value);
        if (this.isOnComposition || (!this.triggerOnFocus && !value)) {
          this.suggestions = [];
          return;
        }
        this.getData(value);
      },
      handleFocus: function() {
        this.activated = true;
        if (this.triggerOnFocus) {
          this.getData(this.value);
        }
      },
      close: function() {
        this.activated = false;
      },
      handleKeyEnter: function() {
        if (this.suggestionVisible && this.highlightedIndex >= 0 && this.highlightedIndex < this.suggestions.length) {
          this.select(this.suggestions[this.highlightedIndex]);
        }
      },
      select: function(item) {
        var self = this;
        self.$emit('input', item[self.props.value]);
        self.$emit('select', item);
        self.suggestions = [];
      },
      highlight: function(index) {
        if (!this.suggestionVisible || this.loading) return;
        if (index < 0) index = 0;
        if (index >= this.suggestions.length) {
          index = this.suggestions.length - 1;
        }
        var suggestion = this.$refs.suggestions.$refs.suggestion;
        var suggestionList = this.$refs.suggestions.$refs.suggestionList;
        var highlightItem = suggestionList[index];
        var scrollTop = suggestion.scrollTop;
        var offsetTop = highlightItem.offsetTop;
        if (offsetTop + highlightItem.scrollHeight > (scrollTop + suggestion.clientHeight)) {
          suggestion.scrollTop += highlightItem.scrollHeight;
        }
        if (offsetTop < scrollTop) {
          suggestion.scrollTop -= highlightItem.scrollHeight;
        }
        this.highlightedIndex = index;
      }
    },
    mounted: function() {
      var self = this;
      self.isOnComposition = false;
      self.$on('item-click', function(item) {
        self.select(item);
      });
    },
    beforeDestroy: function() {
      if(this.$refs.suggestions) {
        this.$refs.suggestions.popperJS && this.$refs.suggestions.popperJS.destroy();
        this.$refs.suggestions.$destroy();
      }
    }
  };
  Vue.component(VueAutocomplete.name, VueAutocomplete);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueButtonGroup = definition(context.Vue);
    delete context.VueButtonGroup;
  }
})(this, function(Vue) {
  'use strict';
  var VueButtonGroup = {
    template: '<div class="vue-button-group"><slot></slot></div>',
    name: 'VueButtonGroup'
  };
  Vue.component(VueButtonGroup.name, VueButtonGroup);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueButton = definition(context.Vue);
    delete context.VueButton;
  }
})(this, function(Vue) {
  'use strict';
  var VueButton = {
    template: '<button @dblclick.stop :disabled="disabled || loading" @click="handleClick" :autofocus="autofocus" :tabindex="tabindex" :type="nativeType" :class="[\'vue-button\', type ? \'vue-button--\' + type : \'\', size ? \'vue-button--\' + size : \'\', {\'is-disabled\': disabled, \'is-loading\': loading, \'is-plain\': plain, \'is-circle\': circle}]"><i class="vue-icon-loading" v-if="loading"></i><i :class="icon" v-if="icon && !loading"></i><span v-if="$slots.default"><slot></slot></span></button>',
    name: 'VueButton',
    props: {
      type: {
        type: String,
        default: 'default'
      },
      size: String,
      icon: {
        type: String,
        default: ''
      },
      nativeType: {
        type: String,
        default: 'button'
      },
      loading: Boolean,
      disabled: Boolean,
      plain: Boolean,
      circle: Boolean,
      autofocus: Boolean,
      tabindex: Number
    },
    methods: {
      focus: function() {
        this.$el.focus();
      },
      handleClick: function(evt) {
        this.$emit('click', evt);
      }
    }
  };
  Vue.component(VueButton.name, VueButton);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCheckboxGroup = definition(context.Vue, context.VueUtil);
    delete context.VueCheckboxGroup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCheckboxGroup = {
    template: '<div class="vue-checkbox-group"><slot></slot></div>',
    name: 'VueCheckboxGroup',
    mixins: [VueUtil.component.emitter],
    props: {
      value: {},
      min: Number,
      max: Number,
      size: String,
      fill: String,
      textColor: String,
      disabled: Boolean
    },
    watch: {
      value: function(value) {
        this.dispatch('VueFormItem', 'vue.form.change', [value]);
      }
    }
  };
  Vue.component(VueCheckboxGroup.name, VueCheckboxGroup);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCheckboxButton = definition(context.Vue, context.VueUtil);
    delete context.VueCheckboxButton;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCheckboxButton = {
    template: '<label :class="[\'vue-checkbox-button\', size ? \'vue-checkbox-button--\' + size : \'\', {\'is-disabled\': isDisabled}, {\'is-checked\': isChecked}, {\'is-focus\': focus}]"><input v-if="trueLabel || falseLabel" class="vue-checkbox-button__original" type="checkbox" :name="name" :disabled="isDisabled" :true-value="trueLabel" :false-value="falseLabel" v-model="model" @change="handleChange" @focus="focus = true" @blur="focus = false"><input v-else class="vue-checkbox-button__original" type="checkbox" :name="name" :disabled="disabled" :value="label" v-model="model" @change="handleChange" @focus="focus = true" @blur="focus = false"><span class="vue-checkbox-button__inner" v-if="$slots.default || label" :style="isChecked ? activeStyle : null"><slot>{{label}}</slot></span></label>',
    name: 'VueCheckboxButton',
    mixins: [VueUtil.component.emitter],
    data: function() {
      return {
        selfModel: false,
        focus: false
      };
    },
    props: {
      value: {},
      label: {},
      disabled: Boolean,
      checked: Boolean,
      name: String,
      trueLabel: [String, Number],
      falseLabel: [String, Number]
    },
    computed: {
      model: {
        get: function() {
          return this._checkboxGroup ? this.store : VueUtil.isDef(this.value) ? this.value : this.selfModel;
        },
        set: function(val) {
          if (this._checkboxGroup) {
            var isLimitExceeded = false;
            (VueUtil.isDef(this._checkboxGroup.min) && val.length < this._checkboxGroup.min && (isLimitExceeded = true));
            (VueUtil.isDef(this._checkboxGroup.max) && val.length > this._checkboxGroup.max && (isLimitExceeded = true));
            isLimitExceeded === false && this.dispatch('VueCheckboxGroup', 'input', [val]);
          } else if (VueUtil.isDef(this.value)) {
            this.$emit('input', val);
          } else {
            this.selfModel = val;
          }
        }
      },
      isChecked: function() {
        if (VueUtil.isBoolean(this.model)) {
          return this.model;
        } else if (VueUtil.isArray(this.model)) {
          return this.model.indexOf(this.label) !== -1;
        } else if (VueUtil.isDef(this.model)) {
          return this.model === this.trueLabel;
        }
      },
      _checkboxGroup: function() {
        var parent = this.$parent;
        while (parent) {
          if (parent.$options.name !== 'VueCheckboxGroup') {
            parent = parent.$parent;
          } else {
            return parent;
          }
        }
        return false;
      },
      isDisabled: function() {
        return this.disabled || this._checkboxGroup.disabled;
      },
      store: function() {
        return this._checkboxGroup ? this._checkboxGroup.value : this.value;
      },
      activeStyle: function() {
        return {
          backgroundColor: this._checkboxGroup.fill || '',
          borderColor: this._checkboxGroup.fill || '',
          color: this._checkboxGroup.textColor || '',
          'box-shadow': '-1px 0 0 0 ' + this._checkboxGroup.fill
        };
      },
      size: function() {
        return this._checkboxGroup.size;
      }
    },
    methods: {
      addToStore: function() {
        if (VueUtil.isArray(this.model)
          && this.model.indexOf(this.label) === -1) {
          this.model.push(this.label);
        } else {
          this.model = this.trueLabel || true;
        }
      },
      handleChange: function(ev) {
        var self = this;
        self.$emit('change', ev);
        if (self._checkboxGroup) {
          self.$nextTick(function() {
            self.dispatch('VueCheckboxGroup', 'change', [self._checkboxGroup.value]);
          });
        }
      }
    },
    created: function() {
      this.checked && this.addToStore();
    }
  };
  Vue.component(VueCheckboxButton.name, VueCheckboxButton);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCheckbox = definition(context.Vue, context.VueUtil);
    delete context.VueCheckbox;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCheckbox = {
    template: '<label class="vue-checkbox"><span :class="[\'vue-checkbox__input\', {\'is-disabled\': isDisabled, \'is-checked\': isChecked, \'is-indeterminate\': indeterminate, \'is-focus\': focus}]"><span class="vue-checkbox__inner"></span><input v-if="trueLabel || falseLabel" class="vue-checkbox__original" z-index="0" type="checkbox" :name="name" :disabled="isDisabled" :true-value="trueLabel" :false-value="falseLabel" v-model="model" @change="handleChange" @focus="focus = true" @blur="focus = false"><input v-else class="vue-checkbox__original" type="checkbox" :disabled="isDisabled" :value="label" :name="name" v-model="model" @change="handleChange" @focus="focus = true" @blur="focus = false"></span><span class="vue-checkbox__label" v-if="$slots.default || label"><slot></slot><template v-if="!$slots.default">{{label}}</template></span></label>',
    name: 'VueCheckbox',
    mixins: [VueUtil.component.emitter],
    data: function() {
      return {
        selfModel: false,
        focus: false
      };
    },
    computed: {
      model: {
        get: function() {
          return this.isGroup ? this.store : VueUtil.isDef(this.value) ? this.value : this.selfModel;
        },
        set: function(val) {
          if (this.isGroup) {
            var isLimitExceeded = false;
            (VueUtil.isDef(this._checkboxGroup.min) && val.length < this._checkboxGroup.min && (isLimitExceeded = true));
            (VueUtil.isDef(this._checkboxGroup.max) && val.length > this._checkboxGroup.max && (isLimitExceeded = true));
            isLimitExceeded === false && this.dispatch('VueCheckboxGroup', 'input', [val]);
          } else {
            this.$emit('input', val);
            this.selfModel = val;
          }
        }
      },
      isChecked: function() {
        if (VueUtil.isBoolean(this.model)) {
          return this.model;
        } else if (VueUtil.isArray(this.model)) {
          return this.model.indexOf(this.label) !== -1;
        } else if (VueUtil.isDef(this.model)) {
          return this.model === this.trueLabel;
        }
      },
      isDisabled: function() {
        return this.isGroup
          ? this._checkboxGroup.disabled || this.disabled || (this.elForm || {}).disabled
          : this.disabled || (this.elForm || {}).disabled;
      },
      isGroup: function() {
        var parent = this.$parent;
        while (parent) {
          if (parent.$options.name !== 'VueCheckboxGroup') {
            parent = parent.$parent;
          } else {
            this._checkboxGroup = parent;
            return true;
          }
        }
        return false;
      },
      store: function() {
        return this._checkboxGroup ? this._checkboxGroup.value : this.value;
      }
    },
    props: {
      value: {},
      label: {},
      indeterminate: Boolean,
      disabled: Boolean,
      checked: Boolean,
      name: String,
      trueLabel: [String, Number],
      falseLabel: [String, Number]
    },
    methods: {
      addToStore: function() {
        if (VueUtil.isArray(this.model) && this.model.indexOf(this.label) === -1) {
          this.model.push(this.label);
        } else {
          this.model = this.trueLabel || true;
        }
      },
      handleChange: function(ev) {
        var self = this;
        self.$emit('change', ev);
        if (self.isGroup) {
          self.$nextTick(function(ev) {
            self.dispatch('VueCheckboxGroup', 'change', [self._checkboxGroup.value]);
          });
        }
      }
    },
    created: function() {
      this.checked && this.addToStore();
    }
  };
  Vue.component(VueCheckbox.name, VueCheckbox);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopup', 'VueUtil'], definition);
  } else {
    context.VueDialog = definition(context.Vue, context.VuePopup, context.VueUtil);
    delete context.VueDialog;
  }
})(this, function(Vue, VuePopup, VueUtil) {
  'use strict';
  var VueDialog = {
    template: '<div><div :class="[\'vue-dialog__wrapper\', {\'is-cleanness\': cleannessModal}]" v-show="visibledialog&&size!==\'full\'" @click.self="handleWrapperClick"></div><transition name="dialog-fade"><div v-draggable v-show="visibledialog" :draggable-cancel-selector="draggableCancelSelector" :class="[\'vue-dialog\', sizeClass, customClass]" ref="dialog" :style="style"><div class="vue-dialog__header"><span class="vue-dialog__title" v-if="showTitle && !$slots.header">{{title}}</span><slot name="header"></slot><div class="vue-dialog__headerbtn" v-if="showClose"><i class="vue-dialog__close vue-icon-close" @click=\'handleClose\'></i></div></div><div class="vue-dialog__body"><slot></slot></div><div class="vue-dialog__footer" v-if="$slots.footer"><slot name="footer"></slot></div></div></transition></div>',
    name: 'VueDialog',
    mixins: [VuePopup],
    data: function() {
      return {
        visibledialog: false
      };
    },
    props: {
      title: {
        type: String,
        default: ''
      },
      closeOnClickModal: Boolean,
      closeOnPressEscape: {
        type: Boolean,
        default: true
      },
      showClose: Boolean,
      size: {
        type: String,
        default: 'small'
      },
      customClass: {
        type: String,
        default: ''
      },
      top: {
        type: String,
        default: '15%'
      },
      cleannessModal: Boolean,
      beforeClose: Function,
      draggable: {
        type: Boolean,
        default: true
      }
    },
    watch: {
      visibledialog: function(val) {
        if (val) {
          this.opened = true;
          this.$emit('open');
          VueUtil.on(this.$el, 'scroll', this.updatePopper);
          var refsDialog = this.$refs.dialog;
          this.$nextTick(function() {
            refsDialog.scrollTop = 0;
          });
        } else {
          this.opened = false;
          VueUtil.off(this.$el, 'scroll', this.updatePopper);
          this.$emit('close');
        }
      },
      visible: function(val) {
        if (val) {
          this.visibledialog = val;
        } else {
          if (VueUtil.isFunction(this.beforeClose)) {
            var self = this;
            var done = function(resolve) {
              if (!VueUtil.isDef(resolve)) resolve = true;
              if (resolve) {
                self.$nextTick(function() {
                  self.visibledialog = val;
                });
              } else {
                self.$emit('visible-change', true);
              }
            };
            self.beforeClose(done);
          } else {
            this.visibledialog = val;
          }
        }
      }
    },
    computed: {
      showTitle: function() {
        return VueUtil.trim(this.title) === '' ? false : true;
      },
      sizeClass: function() {
        return 'vue-dialog--' + this.size;
      },
      style: function() {
        return this.size === 'full' ? {} : {'top': this.top};
      },
      draggableCancelSelector: function() {
        return (this.size === 'full' || this.draggable === false) ? '.vue-dialog' : '.vue-dialog__headerbtn, .vue-dialog__body, .vue-dialog__footer';
      }
    },
    methods: {
      handleWrapperClick: function() {
        if (!this.closeOnClickModal) return;
        this.handleClose();
      },
      handleClose: function() {
        this.$emit('visible-change', false);
      }
    }
  };
  Vue.component(VueDialog.name, VueDialog);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueLoading = definition(context.Vue, context.VueUtil);
    delete context.VueLoading;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var directive = function() {
    var VueLoading = Vue.extend({
      template: '<transition @after-leave="handleAfterLeave"><div v-show="visible" :class="[\'vue-loading-mask\', customClass, {\'is-fullscreen\': fullscreen}]"><div class="vue-loading-spinner"><svg class="circular" viewBox="25 25 50 50"><circle class="path" cx="50" cy="50" r="20" fill="none"/></svg><p v-if="text" class="vue-loading-text">{{text}}</p></div></div></transition>',
      data: function() {
        return {
          text: null,
          fullscreen: true,
          visible: false,
          customClass: ''
        };
      },
      methods: {
        handleAfterLeave: function() {
          this.$emit('after-leave');
        }
      }
    });
    var insertDom = function(parent, el, binding) {
      if (!el.domVisible) {
        VueUtil.ownPropertyLoop(el.maskStyle, function(property) {
          el.mask.style[property] = el.maskStyle[property];
        });
        if (el.originalPosition !== 'absolute') {
          parent.style.position = 'relative';
        }
        if (binding.modifiers.fullscreen && binding.modifiers.lock) {
          parent.style.overflow = 'hidden';
        }
        parent.appendChild(el.mask);
        el.domVisible = true;
        el.instance.visible = true;
        el.domInserted = true;
        Vue.nextTick(function() {
          if (binding.modifiers.fullscreen) {
            el.instance.$el.focus();
          }
        });
      }
    };
    var toggleLoading = function(el, binding) {
      if (binding.value) {
        if (binding.modifiers.fullscreen) {
          el.originalPosition = document.body.style.position;
          el.originalOverflow = document.body.style.overflow;
          VueUtil.addClass(el.mask, 'is-fullscreen');
          insertDom(document.body, el, binding);
        } else {
          VueUtil.removeClass(el.mask, 'is-fullscreen');
          if (binding.modifiers.body) {
            el.originalPosition = document.body.style.position;
            VueUtil.loop(['top', 'left'], function(property) {
              var scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
              el.maskStyle[property] = el.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] + 'px';
            });
            VueUtil.loop(['height', 'width'], function(property) {
              el.maskStyle[property] = el.getBoundingClientRect()[property] + 'px';
            });
            insertDom(document.body, el, binding);
          } else {
            el.originalPosition = el.style.position;
            insertDom(el, el, binding);
          }
        }
      } else {
        if (el.domVisible) {
          el.instance.$once('after-leave', function() {
            el.domVisible = false;
            if (binding.modifiers.fullscreen && el.originalOverflow !== 'hidden') {
              document.body.style.overflow = el.originalOverflow;
            }
            if (binding.modifiers.fullscreen || binding.modifiers.body) {
              document.body.style.position = el.originalPosition;
            } else {
              el.style.position = el.originalPosition;
            }
          });
          el.instance.visible = false;
        }
      }
    };
    var doKeyDown = function(e) {
      document.querySelector('.vue-loading-mask.is-fullscreen').focus();
      e.preventDefault();
      return false;
    };
    var bindEvent = function(binding) {
      if (binding.modifiers.fullscreen) {
        if (binding.value) {
          VueUtil.on(document, 'keydown', doKeyDown);
        } else {
          VueUtil.off(document, 'keydown', doKeyDown);
        }
      }
    };
    Vue.directive('loading', {
      bind: function(el, binding) {
        var mask = new VueLoading({
          el: document.createElement('div'),
          data: {
            text: el.getAttribute('vue-loading-text'),
            fullscreen: !!binding.modifiers.fullscreen,
            customClass: el.getAttribute('vue-loading-class'),
          }
        });
        el.instance = mask;
        el.mask = mask.$el;
        el.maskStyle = {};
        toggleLoading(el, binding);
      },
      update: function(el, binding) {
        if (binding.oldValue !== binding.value) {
          toggleLoading(el, binding);
          bindEvent(binding);
        }
      },
      unbind: function(el, binding) {
        if (el.domInserted) {
          el.instance.$destroy();
          VueUtil.off(document, 'keydown', doKeyDown);
        }
      }
    });
  };
  Vue.use(directive);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueMenuItemGroup = definition(context.Vue, context.VueUtil);
    delete context.VueMenuItemGroup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueMenuItemGroup = {
    template: '<li class="vue-menu-item-group"><div class="vue-menu-item-group__title" :style="{paddingLeft: levelPadding + \'px\'}" v-if="showTitle"><template v-if="!$slots.title">{{title}}</template><slot v-else name="title"></slot></div><ul><slot></slot></ul></li>',
    name: 'VueMenuItemGroup',
    inject: ['rootMenu'],
    props: {
      title: {
        type: String,
        default: ''
      }
    },
    data: function() {
      return {
        paddingLeft: 20
      };
    },
    computed: {
      showTitle: function() {
        if (VueUtil.trim(this.title) === '' && !this.$slots.title) {
          return false;
        }
        return true;
      },
      levelPadding: function() {
        var padding = 10;
        var parent = this.$parent;
        if (this.rootMenu.collapse) return 20;
        while (parent && parent.$options.name !== 'VueMenu') {
          if (parent.$options.name === 'VueSubmenu') {
            padding += 20;
          }
          parent = parent.$parent;
        }
        padding === 10 && (padding = 20);
        return padding;
      }
    }
  };
  Vue.component(VueMenuItemGroup.name, VueMenuItemGroup);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueMenuItem = definition(context.Vue, context.VueUtil);
    delete context.VueMenuItem;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueMenuItem = {
    // template: '<li :style="paddingStyle" @click="handleClick" @mouseenter="onMouseEnter" @mouseleave="onMouseLeave" :class="[\'vue-menu-item\', {\'is-active\': active, \'is-disabled\': disabled}]"><template v-else><slot></slot></template></li>',
    template: '<li class="vue-menu-item"'
    + '    :style="[paddingStyle]"'
    + '    :class="{'
    + '      \'is-active\': active,'
    + '      \'is-disabled\': disabled'
    + '    }"'
    + '    @click="handleClick"'
    + '  >'
    + '    <vue-tooltip'
    + '      v-if="parentMenu.$options.name === \'VueMenu\' && rootMenu.collapse && $slots.title"'
    + '      effect="dark"'
    + '      placement="right">'
    + '      <div slot="content"><slot name="title"></slot></div>'
    + '      <div style="position: absolute;left: 0;top: 0;height: 100%;width: 100%;display: inline-block;box-sizing: border-box;padding: 0 20px;">'
    + '        <slot></slot>'
    + '      </div>'
    + '    </vue-tooltip>'
    + '    <template v-else>'
    + '      <slot></slot>'
    + '      <slot name="title"></slot>'
    + '    </template>'
    + '  </li>',
    name: 'VueMenuItem',
    mixins: [VueUtil.component.menumixin, VueUtil.component.emitter],
    props: {
      index: {
        type: String,
        required: true
      },
      route: {
        type: Object,
        required: false
      },
      disabled: Boolean
    },
    computed: {
      active: function() {
        return this.index === this.rootMenu.activedIndex;
      }
    },
    methods: {
      handleClick: function() {
        this.dispatch('VueMenu', 'item-click', this);
      }
    },
    created: function() {
      this.parentMenu.addItem(this);
      this.rootMenu.addItem(this);
    },
    beforeDestroy: function() {
      this.parentMenu.removeItem(this);
      this.rootMenu.removeItem(this);
    }
  };
  Vue.component(VueMenuItem.name, VueMenuItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueMenu = definition(context.Vue, context.VueUtil);
    delete context.VueMenu;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueMenu = {
    template: '<ul :class="[\'vue-menu\', {\'vue-menu--horizontal\': mode === \'horizontal\', \'vue-menu--dark\': theme === \'dark\', \'vue-menu--collapse\': collapse}]"><slot></slot></ul>',
    name: 'VueMenu',
    mixins: [VueUtil.component.emitter],
    props: {
      collapse: Boolean,
      mode: {
        type: String,
        default: 'vertical'
      },
      defaultActive: {
        type: String,
        default: ''
      },
      defaultOpeneds: Array,
      theme: {
        type: String,
        default: 'light'
      },
      uniqueOpened: Boolean,
      router: Boolean,
      menuTrigger: {
        type: String,
        default: 'hover'
      }
    },

    provide: function() {
      return {
        rootMenu: this
      };
    },
    
    data: function() {
      return {
        activedIndex: this.defaultActive,
        openedMenus: VueUtil.mergeArray([], this.defaultOpeneds),
        items: {},
        submenus: {}
      };
    },
    watch: {
      defaultActive: function(value) {
        var item = this.items[value];
        if (!item) return;
        this.activedIndex = value;
        this.initOpenedMenu();
      },

      defaultOpeneds: function(value) {
        if (!this.collapse) {
          this.openedMenus = value;
        }
      },

      collapse: function(value) {
        if (value) this.openedMenus = [];
        this.broadcast('VueSubmenu', 'toggle-collapse', value);
      },

      '$route': {
        immediate: true,
        handler: function(value) {
          if (this.router) {
            var item = this.items[value.path];
            if (!item) return;
            this.activedIndex = value.path;
            this.initOpenedMenu();
          }
        }
      }
    },
    computed: {
      isMenuPopup: function() {
        return this.mode === 'horizontal' || (this.mode === 'vertical' && this.collapse);
      }
    },
    methods: {
      addItem: function(item) {
        this.items[item.index] = item;
      },
      removeItem: function(item) {
        delete this.items[item.index];
      },
      addSubmenu: function(item) {
        this.submenus[item.index] = item;
      },
      removeSubmenu: function(item) {
        delete this.submenus[item.index];
      },
      openMenu: function(index, indexPath) {
        var openedMenus = this.openedMenus;
        if (openedMenus.indexOf(index) !== -1)
          return;
        if (this.uniqueOpened) {
          this.openedMenus = VueUtil.filter(openedMenus, function(index) {
            return indexPath.indexOf(index) !== -1;
          });
        }
        this.openedMenus.push(index);
      },
      closeMenu: function(index, indexPath) {
        var i = this.openedMenus.indexOf(index);
        if (i !== -1) {
          this.openedMenus.splice(i, 1);
        }
      },
      handleSubmenuClick: function(submenu) {
        var isOpened = this.openedMenus.indexOf(submenu.index) !== -1;
        if (isOpened) {
          this.closeMenu(submenu.index, submenu.indexPath);
          this.$emit('close', submenu.index, submenu.indexPath);
        } else {
          this.openMenu(submenu.index, submenu.indexPath);
          this.$emit('open', submenu.index, submenu.indexPath);
        }
      },
      handleItemClick: function(item) {
        this.$emit('select', item.index, item.indexPath, item);

        if (this.mode === 'horizontal' || this.collapse) {
          this.openedMenus = [];
        }

        if (this.router) {
          this.routeToItem(item);
        } else {
          this.activedIndex = item.index;
        }
      },
      initOpenedMenu: function() {
        var self = this;
        var index = self.activedIndex;
        var activeItem = self.items[index];
        if (!activeItem || this.mode === 'horizontal' || this.collapse) return;
        var indexPath = activeItem.indexPath;
        VueUtil.loop(indexPath, function(index) {
          var submenu = self.submenus[index];
          submenu && self.openMenu(index, submenu.indexPath);
        });
      },
      routeToItem: function(item) {
        var route = item.route || item.index;
        try {
          this.$router.push(route);
        } catch (e) {
          throw e;
        }
      }
    },
    mounted: function() {
      this.initOpenedMenu();
      this.$on('item-click', this.handleItemClick);
      this.$on('submenu-click', this.handleSubmenuClick);
    }
  };
  Vue.component(VueMenu.name, VueMenu);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueRadioGroup = definition(context.Vue, context.VueUtil);
    delete context.VueRadioGroup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var keyCode = Object.freeze({
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40
  });

  var VueRadioGroup = {
    template: '<div class="vue-radio-group" role="radiogroup" @keydown="handleKeydown"><slot></slot></div>',
    name: 'VueRadioGroup',
    mixins: [VueUtil.component.emitter],
    props: {
      value: {},
      size: String,
      fill: String,
      textColor: String,
      disabled: Boolean
    },
    watch: {
      value: function(value) {
        this.$emit('change', value);
        this.dispatch('VueFormItem', 'vue.form.change', [this.value]);
      }
    },
    methods: {
      handleKeydown: function handleKeydown(e) {
        //  radio
        var target = e.target;
        var className = target.nodeName === 'INPUT' ? '[type=radio]' : '[role=radio]';
        var radios = this.$el.querySelectorAll(className);
        var length = radios.length;
        var index = [].indexOf.call(radios, target);
        var roleRadios = this.$el.querySelectorAll('[role=radio]');
    
        switch (e.keyCode) {
          case keyCode.LEFT:
          case keyCode.UP:
            e.stopPropagation();
            e.preventDefault();
    
            if (index === 0) {
              roleRadios[length - 1].click();
              roleRadios[length - 1].focus();
            } else {
              roleRadios[index - 1].click();
              roleRadios[index - 1].focus();
            }
    
            break;
    
          case keyCode.RIGHT:
          case keyCode.DOWN:
            e.stopPropagation();
            e.preventDefault();

            if (index === length - 1) {
              roleRadios[0].click();
              roleRadios[0].focus();
            } else {
              roleRadios[index + 1].click();
              roleRadios[index + 1].focus();
            }
    
            break;
    
          default:
            break;
        }
      }
    },
    mounted: function() {
      var radios = this.$el.querySelectorAll('[type=radio]');
      var firstLabel = this.$el.querySelectorAll('[role=radio]')[0];

      if (![].some.call(radios, function (radio) {
        return radio.checked;
      }) && firstLabel) {
        firstLabel.tabIndex = 0;
      }
    }
  };
  Vue.component(VueRadioGroup.name, VueRadioGroup);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueRadioButton = definition(context.Vue);
    delete context.VueRadioButton;
  }
})(this, function(Vue) {
  'use strict';
  var VueRadioButton = {
    template: '<label :class="[\'vue-radio-button\', size ? \'vue-radio-button--\' + size : \'\', {\'is-active\': value === label}, {\'is-disabled\': isDisabled}]"><input class="vue-radio-button__original" :value="label" type="radio" v-model="value" :name="name" :disabled="isDisabled"><span class="vue-radio-button__inner" :style="value === label ? activeStyle : null"><slot></slot><template v-if="!$slots.default">{{label}}</template></span></label>',
    name: 'VueRadioButton',
    props: {
      label: {},
      disabled: Boolean,
      name: String
    },
    computed: {
      value: {
        get: function() {
          return this._radioGroup.value;
        },
        set: function(value) {
          this._radioGroup.$emit('input', value);
        }
      },
      _radioGroup: function() {
        var parent = this.$parent;
        while (parent) {
          if (parent.$options.name !== 'VueRadioGroup') {
            parent = parent.$parent;
          } else {
            return parent;
          }
        }
        return false;
      },
      activeStyle: function() {
        return {
          backgroundColor: this._radioGroup.fill || '',
          borderColor: this._radioGroup.fill || '',
          boxShadow: this._radioGroup.fill ? '-1px 0 0 0 ' + this._radioGroup.fill : '',
          color: this._radioGroup.textColor || ''
        };
      },
      size: function() {
        return this._radioGroup.size;
      },
      isDisabled: function() {
        return this.disabled || this._radioGroup.disabled;
      }
    }
  };
  Vue.component(VueRadioButton.name, VueRadioButton);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopper', 'VueUtil'], definition);
  } else {
    context.VueTooltip = definition(context.Vue, context.VuePopper, context.VueUtil);
    delete context.VueTooltip;
  }
})(this, function(Vue, VuePopper, VueUtil) {
  'use strict';
  var VueTooltip = {
    name: 'VueTooltip',
    mixins: [VuePopper],
    props: {
      disabled: Boolean,
      effect: String,
      popperClass: String,
      content: String,
      visibleArrow: {
        default: true
      },
      options: {
        default: function() {
          return {
            boundariesPadding: 10,
            gpuAcceleration: false
          };
        }
      },
      enterable: Boolean
    },
    beforeCreate: function() {
      var self = this;
      self.popperVM = new Vue({
        data: {node: ''},
        render: function(createElement) {
          return this.node;
        }
      }).$mount();
    },
    beforeDestroy: function() {
      this.popperVM.$destroy();
    },
    render: function(createElement) {
      var self = this;
      var effect = self.effect === 'light' ? 'light' : 'dark';
      if (self.popperVM) {
        self.popperVM.node = createElement('transition', {
          attrs: {
            name: 'tooltip-fade'
          },
          on: {
            afterLeave: self.destroyPopper
          }
        }, [createElement('div', {
          on: {
            mouseleave: function() {
              self.setExpectedState(false);
              self.debounceClose();
            },
            mouseenter: function() {
              self.setExpectedState(true);
            }
          },
          ref: 'popper',
          directives: [{
            name: 'show',
            value: !self.disabled && self.showPopper
          }],
          class: ['vue-tooltip__popper', 'is-' + effect, self.popperClass]
        }, [self.$slots.content || self.content])]);
      }
      if (!self.$slots.default || !self.$slots.default.length) return self.$slots.default;
      var getFirstComponentChild = function(children) {
        return VueUtil.filter(children, function(c) {
          return c && c.tag;
        })[0];
      };
      var vnode = getFirstComponentChild(self.$slots.default);
      if (!vnode) return vnode;
      var data = vnode.data = vnode.data || {};
      var on = vnode.data.on = vnode.data.on || {};
      on.mouseenter = self.addEventHandle(on.mouseenter, function() {self.setExpectedState(true); self.handleShowPopper();});
      on.mouseleave = self.addEventHandle(on.mouseleave, function() {self.setExpectedState(false); self.debounceClose();});
      data.staticClass = self.concatClass(data.staticClass, 'vue-tooltip');
      return vnode;
    },
    mounted: function() {
      this.referenceElm = this.$el;
    },
    methods: {
      debounceClose: VueUtil.debounce(function() {
        this.handleClosePopper();
      }),
      addEventHandle: function(old, fn) {
        return old ? VueUtil.isArray(old) ? VueUtil.mergeArray(old, fn) : [old, fn] : fn;
      },
      concatClass: function(a, b) {
        if (a && a.indexOf(b) !== -1) return a;
        return a ? b ? (a + ' ' + b) : a : (b || '');
      },
      handleShowPopper: function() {
        var self = this;
        if (!self.expectedState) return;
        self.showPopper = true;
      },
      handleClosePopper: function() {
        if (this.enterable && this.expectedState) return;
        this.showPopper = false;
      },
      setExpectedState: function(expectedState) {
        this.expectedState = expectedState;
      }
    }
  };
  Vue.component(VueTooltip.name, VueTooltip);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueRadio = definition(context.Vue, context.VueUtil);
    delete context.VueRadio;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueRadio = {
    template: '<label role="radio" @keydown.space.stop.prevent="model = isDisabled ? model : label" :tabindex="tabIndex" class="vue-radio"><span :class="[\'vue-radio__input\', {\'is-disabled\': isDisabled, \'is-checked\': model === label, \'is-focus\': focus}]"><span class="vue-radio__inner"></span><input class="vue-radio__original" :value="label" type="radio" v-model="model" @focus="focus=true" @blur="focus=false" :name="name" :disabled="isDisabled" tabindex="-1"></span><span class="vue-radio__label"><slot></slot><template v-if="!$slots.default">{{label}}</template></span></label>',
    name: 'VueRadio',
    mixins: [VueUtil.component.emitter],
    props: {
      value: {},
      label: {},
      disabled: Boolean,
      name: String
    },
    data: function() {
      return {
        focus: false
      };
    },
    computed: {
      isGroup: function() {
        var parent = this.$parent;
        while (parent) {
          if (parent.$options.name !== 'VueRadioGroup') {
            parent = parent.$parent;
          } else {
            this._radioGroup = parent;
            return true;
          }
        }
        return false;
      },
      model: {
        get: function() {
          return this.isGroup ? this._radioGroup.value : this.value;
        },
        set: function(val) {
          if (this.isGroup) {
            this.dispatch('VueRadioGroup', 'input', [val]);
          } else {
            this.$emit('input', val);
          }
        }
      },
      isDisabled: function() {
        return this.isGroup ? this._radioGroup.disabled || this.disabled : this.disabled;
      },
      tabIndex: function() {
        return (this.isDisabled || (this.isGroup && this.model !== this.label)) ? -1 : 0;
      }
    }
  };
  Vue.component(VueRadio.name, VueRadio);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueSubmenu = definition(context.Vue, context.VueUtil);
    delete context.VueSubmenu;
  }
})(this, function(Vue, VueUtil) {
  'use strict';

  var VueSubMenu = {
    //template: '<li :class="{\'vue-submenu\': true, \'is-active\': active, \'is-opened\': opened}"><div class="vue-submenu__title" ref="submenu-title" :style="[paddingStyle, titleStyle, { backgroundColor: backgroundColor }]"><slot name="title"></slot><i :class="[\'vue-submenu__icon-arrow\', submenuTitleIcon]"></i></div><template v-if="rootMenu.mode === \'horizontal\'"><ul class="vue-menu" v-show="opened"><slot></slot></ul></template><collapse-transition v-else><ul class="vue-menu" v-show="opened"><slot></slot></ul></collapse-transition></li>',
    render: function(h) {
      var active = this.active,
      opened = this.opened,
      paddingStyle = this.paddingStyle,
      rootMenu = this.rootMenu,
      mode = this.mode,
      disabled = this.disabled,
      $slots = this.$slots,
      isFirstLevel = this.isFirstLevel;

      var popupMenu = h(
        'transition',
        {},
        [h(
          'div',
          {
            ref: 'menu',
            directives: [{
              name: 'show',
              value: opened
            }],
            'class': ['vue-menu--' + mode]
          },
          [h(
            'ul',
            {
              attrs: {
                role: 'menu'
              },
              'class': ['vue-menu vue-menu--popup']
            },
            [$slots.default]
          )]
        )]
      );

      var inlineMenu = h('collapse-transition', [h(
        'ul',
        {
          attrs: {
            role: 'menu'
          },
          'class': 'vue-menu vue-menu--inline',
          directives: [{
            name: 'show',
            value: opened
          }]
        },
        [$slots.default]
      )]);


      var submenuTitleIcon = (
          rootMenu.mode === 'horizontal' && isFirstLevel ||
          rootMenu.mode === 'vertical' && !rootMenu.collapse
        ) ? 'vue-icon-arrow-down' : 'vue-icon-arrow-right';
      
      
      return h(
        'li',
        {
          'class': {
            'vue-submenu': true,
            'is-active': active,
            'is-opened': opened,
            'is-disabled': disabled
          },
          attrs: { role: 'menuitem',
            'aria-haspopup': 'true',
            'aria-expanded': opened
          },
          on: {
            'mouseenter': this.handleMouseenter,
            'mouseleave': this.handleMouseleave,
            'focus': this.handleMouseenter
          }
        },
        [h(
          'div',
          {
            'class': 'vue-submenu__title',
            ref: 'submenu-title',
            on: {
              'click': this.handleClick
            },
      
            style: [paddingStyle]
          },
          [$slots.title, h('i', { 'class': [submenuTitleIcon, 'vue-submenu__icon-arrow'] })]
        ), this.isMenuPopup ? popupMenu : inlineMenu]
      );
    },
    name: 'VueSubmenu',
    mixins: [VueUtil.component.menumixin, VueUtil.component.emitter],
    components: {
      CollapseTransition: VueUtil.component.collapseTransition
    },
    props: {
      index: {
        type: String,
        required: true
      },
      showTimeout: {
        type: Number,
        default: 300
      },
      hideTimeout: {
        type: Number,
        default: 300
      },
      disabled: Boolean
    },
    data: function() {
      return {
        timeout: null,
        items: {},
        submenus: {},
        mouseInChild: false
      };
    },
    computed: {
      opened: function() {
        return (this.rootMenu.openedMenus.indexOf(this.index) !== -1);
      },
      active: {
        cache: false,
        get: function() {
          var isActive = false;
          var submenus = this.submenus;
          var items = this.items;
          VueUtil.ownPropertyLoop(items, function(index) {
            if (items[index].active) {
              isActive = true;
            }
          });
          VueUtil.ownPropertyLoop(submenus, function(index) {
            if (submenus[index].active) {
              isActive = true;
            }
          });
          return isActive;
        }
      },
      mode: function() {
        return this.rootMenu.mode;
      },
      isMenuPopup: function() {
        return this.rootMenu.isMenuPopup;
      },
      isFirstLevel: function() {
        var isFirstLevel = true;
        var parent = this.$parent;
        while (parent && parent !== this.rootMenu) {
          if (['VueSubmenu', 'VueMenuItemGroup'].indexOf(parent.$options.name) > -1) {
            isFirstLevel = false;
            break;
          } else {
            parent = parent.$parent;
          }
        }
        return isFirstLevel;
      }
    },
    watch: {
      opened: function(val) {
        if (this.isMenuPopup) {
          this.$nextTick(function (_) {
            this.updatePopper();
          });
        }
      }
    },
    methods: {
      addItem: function(item) {
        this.items[item.index] = item;
      },
      removeItem: function(item) {
        delete this.items[item.index];
      },
      addSubmenu: function(item) {
        this.submenus[item.index] = item;
      },
      removeSubmenu: function(item) {
        delete this.submenus[item.index];
      },
      handleClick: function() {

        var rootMenu = this.rootMenu;
        var disabled = this.disabled;

        if (rootMenu.menuTrigger === 'hover' && rootMenu.mode === 'horizontal' || rootMenu.collapse && rootMenu.mode === 'vertical' || disabled) {
          return;
        }
        this.dispatch('VueMenu', 'submenu-click', this);
      },

      handleMouseenter: function () {
        var self = this;
    
        var rootMenu = this.rootMenu,
            disabled = this.disabled;

        if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical' || disabled) {
          return;
        }
        this.dispatch('VueSubmenu', 'mouse-enter-child');
        
        clearTimeout(this.timeout);
        this.timeout = setTimeout(function () {
          self.rootMenu.openMenu(self.index, self.indexPath);
        }, this.showTimeout);
      },
      handleMouseleave: function () {
        var self = this;
        var rootMenu = this.rootMenu;
    
        if (rootMenu.menuTrigger === 'click' && rootMenu.mode === 'horizontal' || !rootMenu.collapse && rootMenu.mode === 'vertical') {
          return;
        }
        this.dispatch('VueSubmenu', 'mouse-leave-child');
        clearTimeout(this.timeout);
        this.timeout = setTimeout(function () {
          !self.mouseInChild && self.rootMenu.closeMenu(self.index);
        }, this.hideTimeout);
      },
      updatePopper: function () {
        var submenu = this.$el.querySelector('.vue-menu');

        if(!this.opened) {
          submenu.style.top = '';
          submenu.style.height = '';
          submenu.style.overflow = '';
          return;
        }

        var rect = submenu.getBoundingClientRect();
        if (rect.bottom > window.innerHeight) {
          var over = rect.bottom - window.innerHeight;
          if (over > rect.top) {
            submenu.style.top = -rect.top + 'px';
            submenu.style.height = window.innerHeight + 'px';
            submenu.style.overflow = 'auto';
          } else {
            submenu.style.top = -over + 'px';
          }
        }
      }


      // mouseToggle: VueUtil.debounce(300, function(val) {
      //   if (val) {
      //     this.rootMenu.openMenu(this.index, this.indexPath);
      //   } else {
      //     this.rootMenu.closeMenu(this.index, this.indexPath);
      //   }
      // }),
      // mouseEnter: function() {
      //   this.mouseToggle(true);
      // },
      // mouseLeave: function() {
      //   this.mouseToggle(false);
      // },
      // bindEvents: function() {
      //   var triggerElm;
      //   if (this.rootMenu.mode === 'horizontal' && this.rootMenu.menuTrigger === 'hover') {
      //     triggerElm = this.$el;
      //     VueUtil.on(triggerElm, 'mouseenter', this.mouseEnter);
      //     VueUtil.on(triggerElm, 'mouseleave', this.mouseLeave);
      //   } else {
      //     triggerElm = this.$refs['submenu-title'];
      //     VueUtil.on(triggerElm, 'click', this.handleClick);
      //   }
      // },
      // unBindEvents: function() {
      //   var triggerElm;
      //   if (this.rootMenu.mode === 'horizontal' && this.rootMenu.menuTrigger === 'hover') {
      //     triggerElm = this.$el;
      //     VueUtil.off(triggerElm, 'mouseenter', this.mouseEnter);
      //     VueUtil.off(triggerElm, 'mouseleave', this.mouseLeave);
      //   } else {
      //     triggerElm = this.$refs['submenu-title'];
      //     VueUtil.off(triggerElm, 'click', this.handleClick);
      //   }
      // }
    },
    created: function() {
      this.parentMenu.addSubmenu(this);
      this.rootMenu.addSubmenu(this);
      var self = this;
      this.$on('mouse-enter-child', function() {
        self.mouseInChild = true;
        clearTimeout(self.timeout);
      });
      this.$on('mouse-leave-child', function() {
        self.mouseInChild = false;
        clearTimeout(self.timeout);
      });

    },
    beforeDestroy: function() {
      this.parentMenu.removeSubmenu(this);
      this.rootMenu.removeSubmenu(this);
      // this.unBindEvents();
    },
    mounted: function() {
      // this.bindEvents();
    }
  };
  Vue.component(VueSubMenu.name, VueSubMenu);
});



(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueSwitch = definition(context.Vue);
    delete context.VueSwitch;
  }
})(this, function(Vue) {
  'use strict';
  var VueSwitch = {
    template: '<label :class="[\'vue-switch\', {\'is-disabled\': disabled, \'vue-switch--wide\': hasText}]"><div class="vue-switch__mask" v-show="disabled"></div><input class="vue-switch__input" type="checkbox" @change="handleChange" v-model="_value" :name="name" :disabled="disabled"><span class="vue-switch__core" ref="core" :style="{\'width\': coreWidth + \'px\'}"><span class="vue-switch__button" :style="buttonStyle"></span></span><transition name="label-fade"><div class="vue-switch__label vue-switch__label--left" v-show="value" :style="{\'width\': coreWidth + \'px\'}"><i :class="[onIconClass]" v-if="onIconClass"></i><span v-if="!onIconClass && onText">{{onText}}</span></div></transition><transition name="label-fade"><div class="vue-switch__label vue-switch__label--right" v-show="!value" :style="{\'width\': coreWidth + \'px\'}"><i :class="[offIconClass]" v-if="offIconClass"></i><span v-if="!offIconClass && offText">{{offText}}</span></div></transition></label>',
    name: 'VueSwitch',
    props: {
      value: {
        type: Boolean,
        default: true
      },
      disabled: Boolean,
      width: {
        type: Number,
        default: 0
      },
      onIconClass: {
        type: String,
        default: ''
      },
      offIconClass: {
        type: String,
        default: ''
      },
      onText: {
        type: String,
        default: 'ON'
      },
      offText: {
        type: String,
        default: 'OFF'
      },
      onColor: {
        type: String,
        default: ''
      },
      offColor: {
        type: String,
        default: ''
      },
      name: {
        type: String,
        default: ''
      }
    },
    data: function() {
      return {
        coreWidth: this.width,
        buttonStyle: {
          transform: ''
        }
      };
    },
    computed: {
      hasText: function() {
        return this.onText || this.offText;
      },
      _value: {
        get: function() {
          return this.value;
        },
        set: function(val) {
          this.$emit('input', val);
        }
      }
    },
    watch: {
      value: function() {
        if (this.onColor || this.offColor) {
          this.setBackgroundColor();
        }
        this.handleButtonTransform();
      },
      width: function() {
          this.coreWidth = this.width;
          this.handleButtonTransform();
      }
    },
    methods: {
      handleChange: function(event) {
        this.$emit('change', event.currentTarget.checked);
      },
      handleButtonTransform: function() {
        this.buttonStyle.transform = this.value ? 'translate(' + (this.coreWidth - 20) + 'px, 2px)' : 'translate(2px, 2px)';
      },
      setBackgroundColor: function() {
        var newColor = this.value ? this.onColor : this.offColor;
        this.$refs.core.style.borderColor = newColor;
        this.$refs.core.style.backgroundColor = newColor;
      }
    },
    mounted: function() {
      if (this.width === 0) {
        this.coreWidth = this.hasText ? 58 : 46;
      }
      this.handleButtonTransform();
      if (this.onColor || this.offColor) {
        this.setBackgroundColor();
      }
    }
  };
  Vue.component(VueSwitch.name, VueSwitch);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueTabPane = definition(context.Vue, context.VueUtil);
    delete context.VueTabPane;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueTabPane = {
    template: '<div class="vue-tab-pane" v-show="active"><keep-alive><router-view v-if="router && active && $route.meta.keepAlive"></router-view></keep-alive><router-view v-if="router && active && !$route.meta.keepAlive"></router-view><slot v-if="!router"></slot></div>',
    name: 'VueTabPane',
    props: {
      label: String,
      labelContent: Function,
      name: String,
      closable: Boolean,
      disabled: Boolean
    },
    data: function() {
      return {
        index: null
      };
    },
    computed: {
      isClosable: function() {
        return this.closable || this.$parent.closable;
      },
      active: function() {
        return this.$parent.currentName === (this.name || this.index);
      },
      router: function() {
        return this.$parent.router;
      }
    },
    mounted: function() {
      this.$parent.addPanes(this);
    },
    destroyed: function() {
      this.$parent.removePanes(this);
    },
    watch: {
      label: function() {
        this.$parent.$forceUpdate();
      }
    }
  };
  Vue.component(VueTabPane.name, VueTabPane);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueTabs = definition(context.Vue, context.VueUtil);
    delete context.VueTabs;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueTabNav = {
    props: {
      panes: Array,
      currentName: String,
      editable: Boolean,
      onTabClick: {
        type: Function,
        default: function() {}
      },
      onTabRemove: {
        type: Function,
        default: function() {}
      },
      type: String,
      router: Boolean
    },
    data: function() {
      return {
        scrollable: false,
        navStyle: {
          transform: ''
        }
      };
    },
    methods: {
      routeToItem: function(item) {
        var route = item.name;
        this.$router && this.$router.push(route);
      },
      scrollPrev: function() {
        var currentOffset = this.getCurrentScrollOffset();
        if (!currentOffset) return;
        var tabWidth = this.$refs.tabs[0].offsetWidth;
        var newOffset = currentOffset > tabWidth ? currentOffset - tabWidth : 0;
        this.setOffset(newOffset);
      },
      scrollNext: function() {
        var navWidth = this.$refs.nav.offsetWidth;
        var containerWidth = this.$refs.navScroll.offsetWidth;
        var currentOffset = this.getCurrentScrollOffset();
        if (navWidth - currentOffset <= containerWidth) return;
        var tabWidth = this.$refs.tabs[0].offsetWidth;
        var newOffset = navWidth - currentOffset > tabWidth ? currentOffset + tabWidth : (navWidth - tabWidth);
        this.setOffset(newOffset);
      },
      scrollToActiveTab: function() {
        if (!this.scrollable) return;
        var nav = this.$refs.nav;
        var activeTab = this.$el.querySelector('.is-active');
        var navScroll = this.$refs.navScroll;
        var activeTabBounding = activeTab.getBoundingClientRect();
        var navScrollBounding = navScroll.getBoundingClientRect();
        var navBounding = nav.getBoundingClientRect();
        var currentOffset = this.getCurrentScrollOffset();
        var newOffset = currentOffset;
        if (activeTabBounding.left < navScrollBounding.left) {
          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
        }
        if (activeTabBounding.right > navScrollBounding.right) {
          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
        }
        if (navBounding.right < navScrollBounding.right) {
          newOffset = nav.offsetWidth - navScrollBounding.width;
        }
        this.setOffset(Math.max(newOffset, 0));
      },
      getCurrentScrollOffset: function() {
        var navStyle = this.navStyle;
        return navStyle.transform ? Number(navStyle.transform.match(/translateX\(-(\d+(\.\d+)*)px\)/)[1]) : 0;
      },
      setOffset: function(value) {
        this.navStyle.transform = 'translateX(-' + value + 'px)';
      },
      update: function() {
        if (this.$refs.nav && this.$refs.navScroll) {
          var navWidth = this.$refs.nav.offsetWidth;
          var containerWidth = this.$refs.navScroll.offsetWidth;
          var currentOffset = this.getCurrentScrollOffset();
          if (containerWidth < navWidth) {
            this.scrollable = this.scrollable || {};
            this.scrollable.prev = currentOffset;
            this.scrollable.next = currentOffset + containerWidth < navWidth;
            if (navWidth - currentOffset < containerWidth) {
              this.setOffset(navWidth - containerWidth);
            }
          } else {
            this.scrollable = false;
            if (currentOffset > 0) {
              this.setOffset(0);
            }
          }
        }
      },
      scrollYMouseWheel: function(event) {
        if (this.scrollable) {
          event.preventDefault();
          var wheelDelta = event.wheelDelta || -event.detail;
          if (wheelDelta < 0) {
            this.scrollNext();
          } else {
            this.scrollPrev();
          }
        }
      }
    },
    updated: function() {
      this.$nextTick(this.update);
    },
    render: function(createElement) {
      var type = this.type;
      var panes = this.panes;
      var editable = this.editable;
      var onTabClick = this.onTabClick;
      var onTabRemove = this.onTabRemove;
      var navStyle = this.navStyle;
      var scrollable = this.scrollable;
      var scrollNext = this.scrollNext;
      var scrollPrev = this.scrollPrev;
      var router = this.router;
      var routeToItem = this.routeToItem;
      var scrollBtn = scrollable ? [createElement('span', {
        'class': ['vue-tabs__nav-prev', scrollable.prev ? '' : 'is-disabled'],
        on: {
          'click': scrollPrev
        }
      }, [createElement('i', {
        'class': 'vue-icon-arrow-left'
      }, [])]), createElement('span', {
        'class': ['vue-tabs__nav-next', scrollable.next ? '' : 'is-disabled'],
        on: {
          'click': scrollNext
        }
      }, [createElement('i', {
        'class': 'vue-icon-arrow-right'
      }, [])])] : null;
      var tabs = this._l(panes, function(pane, index) {
        var tabName = pane.name || pane.index || index;
        var closable = pane.isClosable || editable;
        pane.index = '' + index;
        var btnClose = closable ? createElement('span', {'class': 'vue-icon-close', on: {'click': function click(ev) {onTabRemove(pane, ev);}}}, []) : null;
        var tabLabelContent = pane.$slots.label || pane.label;
        return createElement('div', {
          key: index,
          'class': {
            'vue-tabs__item': true,
            'is-active': pane.active,
            'is-disabled': pane.disabled,
            'is-closable': closable
          },
          ref: 'tabs',
          refInFor: true,
          on: {
            'click': function click(ev) {
              router && routeToItem(pane);
              onTabClick(pane, tabName, ev);
            }
          }
        }, [tabLabelContent, btnClose]);
      });
      return createElement('div', {
        'class': ['vue-tabs__nav-wrap', scrollable ? 'is-scrollable' : '']
      }, [scrollBtn, createElement('div', {
        'class': ['vue-tabs__nav-scroll'],
        ref: 'navScroll'
      }, [createElement('div', {
        'class': 'vue-tabs__nav',
        ref: 'nav',
        style: navStyle
      }, [tabs])])]);
    },
    computed: {
      mouseWheel: function() {
        return VueUtil.isFirefox ? 'DOMMouseScroll' : 'mousewheel';
      }
    },
    mounted: function() {
      VueUtil.on(this.$refs.navScroll, this.mouseWheel, this.scrollYMouseWheel);
      VueUtil.addResizeListener(this.$el, this.update);
    },
    beforeDestroy: function() {
      VueUtil.off(this.$refs.navScroll, this.mouseWheel, this.scrollYMouseWheel);
      VueUtil.removeResizeListener(this.$el, this.update);
    }
  };
  var VueTabs = {
    name: 'VueTabs',
    components: {
      TabNav: VueTabNav
    },
    props: {
      type: String,
      closable: Boolean,
      addable: Boolean,
      value: {},
      editable: Boolean,
      tabBottom: Boolean,
      router: Boolean
    },
    data: function() {
      return {
        currentName: this.value,
        panes: []
      };
    },
    watch: {
      value: function(value) {
        this.setCurrentName(value);
      },
      currentName: function(value) {
        var self = this;
        if (self.$refs.nav) {
          self.$nextTick(function() {
            self.$refs.nav.scrollToActiveTab();
          });
        }
      }
    },
    methods: {
      handleTabClick: function(tab, tabName, event) {
        if (tab.disabled)
          return;
        this.setCurrentName(tabName);
        this.$emit('tab-click', tab, event);
      },
      handleTabRemove: function(pane, ev) {
        if (pane.disabled)
          return;
        ev.stopPropagation();
        this.$emit('edit', pane.name, 'remove');
        this.$emit('tab-remove', pane.name);
      },
      handleTabAdd: function() {
        this.$emit('edit', null, 'add');
        this.$emit('tab-add');
      },
      setCurrentName: function(value) {
        this.currentName = value;
        this.$emit('input', value);
      },
      addPanes: function(item) {
        var index = this.$slots.default.indexOf(item.$vnode);
        this.panes.splice(index, 0, item);
      },
      removePanes: function(item) {
        var panes = this.panes;
        var index = panes.indexOf(item);
        if (index !== -1) {
          panes.splice(index, 1);
        }
      }
    },
    render: function(createElement) {
      var type = this.type;
      var handleTabClick = this.handleTabClick;
      var handleTabRemove = this.handleTabRemove;
      var handleTabAdd = this.handleTabAdd;
      var currentName = this.currentName;
      var panes = this.panes;
      var editable = this.editable;
      var addable = this.addable;
      var tabBottom = this.tabBottom;
      var router = this.router;
      var newButton = editable || addable ? createElement('vue-button', {
        'class': 'vue-tabs__new-tab',
        attrs: {
          type: 'text',
          icon: 'vue-icon-plus'
        },
        on: {
          'click': handleTabAdd
        }
      }, []) : null;
      var navData = {
        props: {
          currentName: currentName,
          onTabClick: handleTabClick,
          onTabRemove: handleTabRemove,
          editable: editable,
          type: type,
          panes: panes,
          router: router
        },
        ref: 'nav'
      };
      var header = createElement('div', {
        'class': 'vue-tabs__header'
      }, [newButton, createElement('tab-nav', navData, [])]);
      var panels = createElement('div', {
        'class': 'vue-tabs__content'
      }, [this.$slots.default]);
      return createElement('div', {
        'class': {
          'vue-tabs': true,
          'vue-tabs--card': type === 'card',
          'vue-tabs--border-card': type === 'border-card',
          'header-bottom': tabBottom
        }
      }, [tabBottom ? [panels, header] : [header, panels]]);
    },
    created: function() {
      if (!this.currentName) {
        this.setCurrentName('0');
      }
    }
  };
  Vue.component(VueTabs.name, VueTabs);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueTag = definition(context.Vue);
    delete context.VueTag;
  }
})(this, function(Vue) {
  'use strict';
  var VueTag = {
    template: '<div :class="[\'vue-tag\', type ? \'vue-tag--\' + type : \'\', {\'is-hit\': hit}]" :style="{width: closable ? width+32+\'px\' : width+13+\'px\'}"><span :style="{width: width+\'px\', float: \'left\'}" ref="span"><slot></slot></span><i class="vue-tag__close vue-icon-close" v-if="closable" @click="handleClose"></i></div>',
    name: 'VueTag',
    props: {
      text: String,
      closable: Boolean,
      type: String,
      hit: Boolean,
      width: Number
    },
    methods: {
      handleClose: function(event) {
        this.$emit('close', event);
      }
    },
    mounted: function() {
      var el = this.$el;
      var spanNode = this.$refs.span;
      if (this.width && this.width < spanNode.scrollWidth) {
        el.setAttribute('title', el.innerText);
      }
    }
  };
  Vue.component(VueTag.name, VueTag);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueTableColumn = definition(context.Vue, context.VueUtil);
    delete context.VueTableColumn;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var columnIdSeed = 1;
  var defaults = {
    default: {
      order: ''
    },
    selection: {
      width: 53,
      minWidth: 53,
      realWidth: 53,
      order: '',
      className: 'vue-table-column--selection'
    },
    expand: {
      width: 53,
      minWidth: 53,
      realWidth: 53,
      order: ''
    },
    index: {
      width: 53,
      minWidth: 53,
      realWidth: 53,
      order: ''
    }
  };
  var forced = {
    selection: {
      property: 'selectionColumn',
      renderHeader: function(createElement) {
        var states = this.store.states;
        return createElement('vue-checkbox', {
          on: {
            change: this.toggleAllSelection
          },
          attrs: {
            value: states.isAllSelected,
            indeterminate: states.selection.length > 0 && !states.isAllSelected
          }
        }, []);
      },
      renderCell: function(createElement, data) {
        var row = data.row;
        var column = data.column;
        var store = data.store;
        var index = data.$index;
        return createElement('vue-checkbox', {
          attrs: {
            disabled: !!column.selectable && !column.selectable.call(null, row, index),
            value: store.isSelected(row)
          },
          on: {
            input: function() {
              store.commit('rowSelectedChanged', row);
            }
          }
        }, []);
      },
      sortable: false,
      resizable: false
    },
    index: {
      property: 'indexColumn',
      renderHeader: function(createElement) {
        return '#';
      },
      renderCell: function(createElement, data) {
        var n = data.$index;
        return createElement('div', null, [n + 1]);
      },
      sortable: false
    },
    expand: {
      property: 'expandColumn',
      renderHeader: function(createElement) {
        return '';
      },
      renderCell: function(createElement, data, proxy) {
        var row = data.row;
        var store = data.store;
        var expanded = store.states.expandRows.indexOf(row) !== -1;
        return createElement('div', {
          class: 'vue-table__expand-icon ' + (expanded ? 'vue-table__expand-icon--expanded' : ''),
          on: {
            click: function() {
              return proxy.handleExpandClick(row);
            }
          }
        }, [createElement('i', {
          class: 'vue-icon vue-icon-arrow-right'
        }, [])]);
      },
      sortable: false,
      resizable: false,
      className: 'vue-table__expand-column'
    }
  };
  var VueTableColumn = {
    name: 'VueTableColumn',
    render: function(createElement) {
      var slots = this.$slots.default;
      return createElement('div', slots);
    },
    props: {
      type: {
        type: String,
        default: 'default'
      },
      label: String,
      printLabel: String,
      className: [String, Function],
      labelClassName: String,
      property: String,
      prop: String,
      width: {},
      minWidth: {},
      sortable: Boolean,
      sortMethod: Function,
      resizable: {
        type: Boolean,
        default: true
      },
      context: {},
      align: String,
      headerAlign: String,
      showOverflowTooltip: Boolean,
      fixed: [Boolean, String],
      formatter: Function,
      selectable: Function,
      visible: {
        type: Boolean,
        default: true
      },
      filterable: Boolean,
      filtered: {
        type: Boolean,
        default: false
      },
      filterMethod: Function,
      filteredValue: Array,
      filters: Array,
      complexFilters: Array,
      aggregate: {
        type: String,
        default: ''
      },
      aggregateLabel: String,
      labelColspan: Boolean,
      colspan: Boolean,
      rowspan: Boolean
    },
    beforeCreate: function() {
      this.row = {};
      this.column = {};
      this.$index = 0;
    },
    computed: {
      owner: function() {
        var parent = this.$parent;
        while (parent && !parent.tableId) {
          parent = parent.$parent;
        }
        return parent;
      }
    },
    created: function() {
      var self = this;
      var columnIdTable = self.$parent.columnId++;
      var columnId = self.columnId = ((self.$parent.tableId || (self.$parent.columnId + '_')) + 'column_' + columnIdSeed++);
      var parent = self.$parent;
      var owner = self.owner;
      var type = self.type;
      var width = self.width;
      if (VueUtil.isDef(width)) {
        width = parseInt(width, 10);
        if (isNaN(width)) {
          width = null;
        }
      }
      var minWidth = self.minWidth;
      if (VueUtil.isDef(minWidth)) {
        minWidth = parseInt(minWidth, 10);
        if (isNaN(minWidth)) {
          minWidth = 80;
        }
      }
      var getDefaultColumn = function(type, options) {
        var column = {};
        VueUtil.merge(column, defaults[type || 'default'], options);
        column.realWidth = column.width || column.minWidth;
        return column;
      };
      var column = getDefaultColumn(type, {
        id: columnId,
        columnId: columnIdTable,
        label: self.label,
        printLabel: self.printLabel,
        className: self.className,
        labelClassName: self.labelClassName,
        property: self.prop || self.property,
        type: type,
        renderCell: null,
        renderHeader: self.renderHeader,
        minWidth: minWidth,
        width: width,
        visible: self.visible,
        context: self.context,
        align: self.align ? 'is-' + self.align : null,
        headerAlign: self.headerAlign ? 'is-' + self.headerAlign : 'is-center',
        sortable: self.sortable,
        sortMethod: self.sortMethod,
        resizable: self.resizable,
        showOverflowTooltip: self.showOverflowTooltip,
        formatter: self.formatter,
        selectable: self.selectable,
        fixed: self.fixed === '' ? true : self.fixed,
        fixedIndex: -1,
        filterMethod: self.filterMethod,
        filterable: self.filterable,
        complexFilters: self.complexFilters || [],
        filtered: self.filtered,
        filterOpened: false,
        filteredValue: self.filteredValue || [],
        filters: self.filters || [],
        aggregate: self.aggregate,
        aggregateLabel: self.aggregateLabel,
        labelColspan: self.labelColspan,
        rowspan: self.rowspan,
        getCellClass: function(rowIndex, cellIndex, rowData) {
          var classes = [];
          var className = self.className;
          if (VueUtil.isString(className)) {
            classes.push(className);
          } else if (VueUtil.isFunction(className)) {
            classes.push(className.call(null, rowIndex, cellIndex, rowData) || '');
          }
          return classes.join(' ');
        }
      });
      VueUtil.merge(column, forced[type] || {});
      self.columnConfig = column;
      var renderCell = column.renderCell;
      var renderHeader = column.renderHeader;
      column.renderHeader = function() {
        if (self.$scopedSlots.header) {
          column.renderHeader = function(h, scope) {
            return self.$scopedSlots.header(scope);
          };
        } else {
          column.renderHeader = renderHeader;
        }
      };
      if (type === 'expand') {
        owner.renderExpanded = function(createElement, data) {
          return self.$scopedSlots.default ? self.$scopedSlots.default(data) : self.$slots.default;
        };
        column.renderCell = function(createElement, data) {
          return createElement('div', {
            class: 'cell'
          }, [renderCell(createElement, data, this._renderProxy)]);
        };
        return;
      }
      column.renderCell = function(createElement, data) {
        if (self.$scopedSlots.default) {
          renderCell = function() {
            return self.$scopedSlots.default(data);
          };
        }
        if (!renderCell) {
          renderCell = function(createElement, data) {
            var row = data.row;
            var column = data.column;
            var property = column.property;
            var value = row[property];
            if (property && property.indexOf('.') !== -1) {
              var getValueByPath = function(object, prop) {
                prop = prop || '';
                var paths = prop.split('.');
                var current = object;
                var result = null;
                VueUtil.loop(paths, function(path, i) {
                  if (!current) return false;
                  if (i === paths.length - 1) {
                    result = current[path];
                    return false;
                  }
                  current = current[path];
                });
                return result;
              };
              value = getValueByPath(row, property);
            }
            if (VueUtil.isFunction(column.formatter)) {
              return column.formatter(row, column, value);
            }
            return value;
          };
        }
        return self.showOverflowTooltip ? createElement('div',
            {class: 'cell vue-tooltip'},
          [renderCell(createElement, data)]) : createElement('div', {
            class: 'cell'
          }, [renderCell(createElement, data)]);
      };
    },
    destroyed: function() {
      if (!this.$parent) return;
      this.owner.store.commit('removeColumn', this.columnConfig);
    },
    watch: {
      label: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.label = newVal;
          this.owner.doLayout();
        }
      },
      prop: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.property = newVal;
        }
      },
      property: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.property = newVal;
        }
      },
      align: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.align = newVal ? 'is-' + newVal : null;
          if (!this.headerAlign) {
            this.columnConfig.headerAlign = newVal ? 'is-' + newVal : null;
          }
        }
      },
      headerAlign: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.headerAlign = 'is-' + (newVal ? newVal : this.align);
        }
      },
      width: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.width = newVal;
          this.owner.doLayout();
        }
      },
      minWidth: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.minWidth = newVal;
          this.owner.doLayout();
        }
      },
      fixed: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.fixed = newVal;
          this.owner.doLayout();
        }
      },
      sortable: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.sortable = newVal;
        }
      },
      visible: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.visible = newVal;
          this.owner.doLayout();
        }
      },
      labelColspan: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.labelColspan = newVal;
          this.owner.doLayout();
        }
      },
      rowspan: function(newVal) {
        if (this.columnConfig) {
          this.columnConfig.rowspan = newVal;
          this.owner.doLayout();
        }
      }
    },
    mounted: function() {
      var owner = this.owner;
      var columnIndex;
      columnIndex = [].indexOf.call(owner.$refs.hiddenColumns.children, this.$el);

      if (columnIndex == -1) {
        columnIndex = [].indexOf.call(owner.$refs.hiddenColumns.children,this.$parent.$el);
      }
      owner.store.commit('insertColumn', this.columnConfig, columnIndex);
    }
  };
  Vue.component(VueTableColumn.name, VueTableColumn);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VuePopper'], definition);
  } else {
    context.VueTable = definition(context.Vue, context.VueUtil, context.VuePopper);
    delete context.VueTable;
  }
})(this, function(Vue, VueUtil, VuePopper) {
  'use strict';

  function defaultFilterMethod(filter, value) {
    switch (filter.operations) {
      case '=':
        return value === filter.conditions;
      case '>':
        return value > filter.conditions;
      case '<':
        return value < filter.conditions;
      case '<=':
        return value <= filter.conditions;
      case '>=':
        return value >= filter.conditions;
      case '<>':
        return value !== filter.conditions;
      case '%':
        return value.indexOf(filter.conditions) !== -1;
    }
  }

  var TableStore = function(table, initialState) {
    this.table = table;
    this.states = {
      _columns: [],
      columns: [],
      labelColumns: [],
      fixedColumns: [],
      rightFixedColumns: [],
      _data: null,
      filteredData: null,
      data: null,
      sortingColumns: [],
      isAllSelected: false,
      selection: [],
      selectable: null,
      currentRow: null,
      hoverRow: null,
      filters: {},
      expandRows: [],
      aggregates: [],
      defaultExpandAll: false
    };
    VueUtil.merge(this.states, initialState);
  };
  TableStore.prototype.mutations = {
    setData: function(states, data) {
      var table = this.table;
      var dataInstanceChanged = states._data !== data;
      states._data = data;
      states.filteredData = data;
      states.data = this.sortData((data || []), states);
      VueUtil.loop(states.data, function(data, index) {
        data.$index = index;
      });
      var oldCurrentRow = states.currentRow;
      if (states.data.indexOf(oldCurrentRow) === -1) {
        states.currentRow = null;
        if (states.currentRow !== oldCurrentRow) {
          table.$emit('current-change', null, oldCurrentRow);
        }
      }
      if (dataInstanceChanged) {
        this.clearSelection();
      } else {
        var selection = states.selection || [];
        var deleted = VueUtil.filter(selection, function(item) {
          return states.data.indexOf(item) === -1;
        });
        VueUtil.loop(deleted, function(deletedItem) {
          selection.splice(selection.indexOf(deletedItem), 1);
        });
        if (deleted.length) {
          table.$emit('selection-change', selection);
        }
      }
      this.updateAllSelected();
      if (states.defaultExpandAll) {
        states.expandRows = VueUtil.mergeArray([], states.data);
      }
      VueUtil.isVueComponent(table.$refs.tableBody) && table.$refs.tableBody.resetDelta(data.length);
      Vue.nextTick(function() {
        table.updateScrollY();
        table.resizeZone();
      });
    },
    changeSortCondition: function(states) {
      var self = this;
      states.data = self.sortData((states.filteredData || states._data || []), states);
      
      //
      VueUtil.loop(states.data, function(data, index) {
        data.$index = index;
      });
      
      if (this.table.highlightFirstAfterSort && states.data.length) {
        this.table.setCurrentRow(states.data[0]);
      } else {
        this.table.setCurrentRow(null);
      }

      self.table.$emit('sort-change', self.states.sortingColumns);
      Vue.nextTick(function() {
        self.table.updateScrollY();
        self.table.resizeZone();
      });
    },
    filterChange: function(states, options) {
      var self = this;
      var values = options.values;
      var column = options.column;
      var silent = options.silent;
      var prop = column.property;
      if (prop) {
        if (values && Object.keys(values).length === 0) {
          delete states.filters[column.id];
        } else {
          if (states.filters[column.id]) {
            states.filters[column.id] = VueUtil.merge(states.filters[column.id], values);
          } else {
            states.filters[column.id] = values;
          }

          column.filtered = false;
          var savedFilterRule = states.filters[column.id];
          if ((savedFilterRule.complexFilters && savedFilterRule.complexFilters.length > 0)
          || (savedFilterRule.simpleFilters && savedFilterRule.simpleFilters.length > 0)) {
            column.filtered = true;
          }
        }
      }

      var data = states._data;
      var filters = states.filters;
      VueUtil.ownPropertyLoop(filters, function(columnId) {
        var values = filters[columnId];
        var column = self.getColumnById(columnId);

        if(!values || !column) return;

        if(values.complexFilters && values.complexFilters.length > 0) {
          values.complexFilters.forEach(function(filter) {
            data = VueUtil.filter(data, function(row) {
                return defaultFilterMethod.call(null, filter, row[column.property]);
            });
          });
        }

        if(values.simpleFilters && values.simpleFilters.length > 0) {
          if (column.filterMethod) {
            data = VueUtil.filter(data, function(row) {
              return values.some(function(value) {
                return column.filterMethod.call(null, value, row);
              });
            });
          } else {
            var columnKey = column.property;
            data = VueUtil.filter(data, function(row) {
              return values.simpleFilters.some(function(value) {
                return row[columnKey] === value;
              });
            });
          }
        }
      });
      states.filteredData = data;
      states.data = self.sortData(data, states);

      //
      VueUtil.loop(states.data, function(data, index) {
        data.$index = index;
      });

      //
      if (this.table.highlightFirstAfterFilter && data.length) {
        this.table.setCurrentRow(data[0]);
      } else {
        this.table.setCurrentRow(null);
      }

      if (!silent) {
        self.table.$emit('filter-change', filters);
      }
      self.table.$refs.tableBody.resetDelta(data.length);
      Vue.nextTick(function() {
        self.table.updateScrollY();
        self.table.resizeZone();
      });
    },
    insertColumn: function(states, column, index) {
      var array = states._columns;
      if (VueUtil.isDef(index)) {
        array.splice(index, 0, column);
      } else {
        array.push(column);
      }
      if (column.type === 'selection') {
        states.selectable = column.selectable;
      }
      this.updateColumns();
    },
    removeColumn: function(states, column) {
      var _columns = states._columns;
      if (_columns.length) {
        _columns.splice(_columns.indexOf(column), 1);
      }
      this.updateColumns();
    },
    reorderColumn: function (states, index, toIndex) {
      if(index === toIndex) return;
      var array = states._columns;

      if (index > toIndex) {
        array.splice(toIndex, 0, array[index]);
        array.splice(index + 1, 1);
      }
      else {
        array.splice(toIndex + 1, 0, array[index]);
        array.splice(index, 1);
      }

      this.updateColumns();
    },
    setHoverRow: function(states, row) {
      states.hoverRow = row;
    },
    setCurrentRow: function(states, row) {
      var oldCurrentRow = states.currentRow;
      states.currentRow = row;
      if (oldCurrentRow !== row) {
        this.table.$emit('current-change', row, oldCurrentRow);
      }
    },
    rowSelectedChanged: function(states, row) {
      var changed = this.toggleRowSelection(row);
      var selection = states.selection;
      if (changed) {
        var table = this.table;
        table.$emit('selection-change', selection);
        table.$emit('select', selection, row);
      }
      this.updateAllSelected();
    },
    toggleRowExpanded: function(states, row, expanded) {
      var expandRows = states.expandRows;
      if (VueUtil.isDef(expanded)) {
        var index = expandRows.indexOf(row);
        if (expanded) {
          if (index === -1)
            expandRows.push(row);
        } else {
          if (index !== -1)
            expandRows.splice(index, 1);
        }
      } else {
        var index = expandRows.indexOf(row);
        if (index === -1) {
          expandRows.push(row);
        } else {
          expandRows.splice(index, 1);
        }
      }
      var table = this.table;
      Vue.nextTick(function(){
        table.$emit('expand', row, expandRows.indexOf(row) !== -1);
      });
    },
    toggleAllSelection: function(states) {
      var data = states.data || [];
      var value = !states.isAllSelected;
      var selection = this.states.selection;
      var selectionChanged = false;
      var self = this;
      VueUtil.loop(data, function(item, index) {
        if (states.selectable) {
          if (states.selectable.call(null, item, index) && self.toggleRowSelection(item, value)) {
            selectionChanged = true;
          }
        } else {
          if (self.toggleRowSelection(item, value)) {
            selectionChanged = true;
          }
        }
      });
      var table = this.table;
      if (selectionChanged) {
        table.$emit('selection-change', selection);
      }
      table.$emit('select-all', selection);
      states.isAllSelected = value;
    }
  };
  TableStore.prototype.getAggregate = function(columns, data) {
    var labelMap = {
      'sum': Vue.t('vue.table.sumText'),
      'count': Vue.t('vue.table.countText'),
      'average': Vue.t('vue.table.averageText'),
      'min': Vue.t('vue.table.minText'),
      'max': Vue.t('vue.table.maxText'),
    };
    var aggregates = this.states.aggregates = [];
    if (data.length === 0) return;
    VueUtil.loop(columns, function(column) {
      var aggregate = '';
      var resultMap = {};
      resultMap.max = '';
      resultMap.min = '';
      resultMap.sum = '';
      resultMap.average = '';
      resultMap.label = '';
      resultMap.property = column.property;
      var aggregateType = column.aggregate.toLowerCase();
      var aggregateLabel = labelMap[aggregateType];
      if (VueUtil.isDef(column.aggregateLabel)) aggregateLabel = column.aggregateLabel;
      if (VueUtil.isDef(aggregateLabel)) {
        var max = null;
        var min = null;
        var sum = null;
        var precision = 0;
        var valueCount = 0;
        resultMap.count = data.length;
        VueUtil.loop(data, function(row) {
          var value = Number(row[column.property]);
          if (VueUtil.isNumber(value)) {
            var decimal = ('' + value).split('.')[1];
            decimal && decimal.length > precision ? precision = decimal.length : null;
            VueUtil.isDef(max) ? value > max ? max = value : null : max = value;
            VueUtil.isDef(min) ? value < min ? min = value : null : min = value;
            VueUtil.isDef(sum) ? sum = sum + value : sum = value;
            valueCount++;
          }
        });
        if (valueCount > 0) {
          resultMap.max = max;
          resultMap.min = min;
          resultMap.sum = sum;
          resultMap.average = (sum / valueCount);
        }
        var columnAggregate = resultMap[aggregateType];
        if (!VueUtil.isNumber(columnAggregate)) {
          aggregate = aggregateLabel;
        } else {
          if (aggregateType === 'count') precision = 0;
          columnAggregate = VueUtil.formatNumber(columnAggregate, precision); 
          aggregateLabel ? aggregate = aggregateLabel + ': ' + columnAggregate : aggregate = columnAggregate;
        }
        resultMap.label = aggregate;
      }
      aggregates.push(resultMap);
    });
  };
  TableStore.prototype.updateLabelColumns = function() {
    var states = this.states;
    var labelColumns = [];
    var colColumns = [];
    var tableColumns = states._columns;
    var i = tableColumns.length;
    while (i--) {
      var column = tableColumns[i];
      if (column.labelColspan) {
        colColumns.push(column);
      } else {
        if (colColumns.length > 0) {
          colColumns.reverse();
          column.colColumns = VueUtil.mergeArray([], colColumns);
          colColumns = [];
        }
        labelColumns.push(column);
      }
    }
    labelColumns.reverse();
    states.labelColumns = labelColumns;
  };
  TableStore.prototype.updateColumns = function() {
    var states = this.states;
    var columns = [];
    states.fixedColumns = [];
    states.rightFixedColumns = [];
    VueUtil.loop(VueUtil.mergeArray([], states._columns), function(column) {
      if (column.visible) {
        columns.push(column);
        if (column.fixed === true || column.fixed === 'left') {
          //Bug #1230
          // if (column.type === 'selection') {
          //   column.fixed = false;
          // } else {
            states.fixedColumns.push(column);
          // }
        }
        if (column.fixed === 'right') {
          //Bug #1230
          // if (column.type === 'selection') {
          //   column.fixed = false;
          // } else {
            states.rightFixedColumns.push(column);
          // }
        }
      }
    });
    states.fixedColumns.sort(function(a, b) {
      return a.fixedIndex > b.fixedIndex;
    });
    states.rightFixedColumns.sort(function(a, b) {
      return a.fixedIndex < b.fixedIndex;
    });
    if (states.fixedColumns.length > 0 && columns[0] && columns[0].type === 'selection' && !columns[0].fixed) {
      columns[0].fixed = true;
      states.fixedColumns.unshift(columns[0]);
    }
    states.columns = VueUtil.mergeArray([], states.fixedColumns, VueUtil.filter(columns, function(column) {
      return !column.fixed;
    }), states.rightFixedColumns);
    this.updateLabelColumns();
  };
  TableStore.prototype.rowspanData = function(data) {
    var columns = this.states.columns;
    VueUtil.loop(columns, function(column) {
      if (column.rowspan) {
        var val1 = null;
        var val2 = null;
        var startIndex = null;
        column.rowspanAry = [];
        column.rowspanStartAry = [];
        VueUtil.loop(data, function(row, index) {
          val1 = row[column.property];
          if (val1 === val2) {
            column.rowspanAry.push(index);
          }
          val2 = val1;
        });
        var spanItem = null;
        VueUtil.loop(column.rowspanAry, function(rowspan, index) {
          var startSpan = rowspan - 1;
          if (column.rowspanAry.indexOf(startSpan) === -1) {
            spanItem = {};
            spanItem.start = startSpan;
            spanItem.spanNum = 2;
            column.rowspanStartAry.push(spanItem);
          } else {
            spanItem.spanNum++;
          }
        });
      }
    });
  };
  TableStore.prototype.sortData = function(data, states) {
    var sortingColumns = states.sortingColumns;
    if (sortingColumns.length !== 0) {
      var orderBy = function(data, sortList) {
        return VueUtil.mergeArray([], data).sort(function(data1, data2) {
          var index = 0;
          var column = sortList[index];
          index++;
          var sortBy = function() {
            var value1 = data1[column.property];
            var value2 = data2[column.property];
            var sortOrder = 1;
            if (column.order === 'descending') {
              sortOrder = -1;
            }
            if (value1 === value2) {
              if (index === sortList.length) return;
              column = sortList[index];
              index++;
              return sortBy();
            }
            if (VueUtil.isFunction(column.sortMethod)) {
              return column.sortMethod(value1, value2, data1, data2) ? sortOrder : -sortOrder;
            } else {
              return value1 > value2 ? sortOrder : -sortOrder;
            }
          };
          return sortBy();
        });
      };
      data = orderBy(data, sortingColumns);
    }
    return data;
  };
  TableStore.prototype.getColumnById = function(columnId) {
    var column = null;
    var columns = this.states._columns;
    var i = columns.length;
    while (i--) {
      var item = columns[i];
      if (item.id === columnId) {
        column = item;
        break;
      }
    }
    return column;
  };
  TableStore.prototype.isSelected = function(row) {
    return (this.states.selection || []).indexOf(row) !== -1;
  };
  TableStore.prototype.clearSelection = function() {
    var states = this.states;
    states.isAllSelected = false;
    var oldSelection = states.selection;
    states.selection = [];
    if (oldSelection.length > 0) {
      this.table.$emit('selection-change', states.selection);
    }
  };
  TableStore.prototype.toggleRowSelection = function(row, selected) {
    var changed = false;
    var selection = this.states.selection;
    var index = selection.indexOf(row);
    if (!VueUtil.isDef(selected)) {
      if (index === -1) {
        selection.push(row);
        changed = true;
      } else {
        selection.splice(index, 1);
        changed = true;
      }
    } else {
      if (selected && index === -1) {
        selection.push(row);
        changed = true;
      } else if (!selected && index !== -1) {
        selection.splice(index, 1);
        changed = true;
      }
    }
    return changed;
  };
  TableStore.prototype.updateAllSelected = function() {
    var states = this.states;
    var selection = states.selection;
    var selectable = states.selectable;
    var data = states.data;
    if (!data || data.length === 0) {
      states.isAllSelected = false;
      return;
    }
    var selectedMap;
    var isSelected = function(row) {
      return selection.indexOf(row) !== -1;
    };
    var isAllSelected = true;
    var selectedCount = 0;
    var i = data.length;
    while (i--) {
      var item = data[i];
      if (selectable) {
        var isRowSelectable = selectable.call(null, item, i);
        if (isRowSelectable) {
          if (!isSelected(item)) {
            isAllSelected = false;
            break;
          } else {
            selectedCount++;
          }
        }
      } else {
        if (!isSelected(item)) {
          isAllSelected = false;
          break;
        } else {
          selectedCount++;
        }
      }
    }
    if (selectedCount === 0) isAllSelected = false;
    states.isAllSelected = isAllSelected;
  };
  TableStore.prototype.commit = function(name) {
    var mutations = this.mutations;
    var args = [];
    VueUtil.loop(arguments, function(arg, index) {
      if (index === 0) return;
      args.push(arg);
    });
    if (mutations[name]) {
      mutations[name].apply(this, VueUtil.mergeArray([this.states], args));
    } else {
      throw 'Action not found: ' + name;
    }
  };
  var TableLayout = function(options) {
    this.table = null;
    this.store = null;
    this.fit = true;
    this.showHeader = true;
    this.height = null;
    this.scrollX = false;
    this.scrollY = false;
    this.bodyWidth = null;
    this.fixedWidth = null;
    this.rightFixedWidth = null;
    this.headerHeight = 44;
    this.viewportHeight = null;
    this.bodyHeight = null;
    this.fixedBodyHeight = null;
    this.gutterWidth = VueUtil.scrollBarWidth();
    VueUtil.merge(this, options);
  };
  TableLayout.prototype.updateScrollY = function() {
    var refs = this.table.$refs;
    if (!refs.tableBody || !refs.bodyWrapper) return;
    this.scrollY = false;
    var tbody = refs.tableBody.$refs.tbody;
    if (VueUtil.isNumber(this.height) && VueUtil.isElement(tbody)) {
      var bodyWrapper = refs.bodyWrapper;
      if (tbody.offsetHeight > bodyWrapper.offsetHeight) this.scrollY = true;
    }
  };
  TableLayout.prototype.setHeight = function(value) {
    var el = this.table.$el;
    if (!el) return;
    if (VueUtil.isString(value) && /^\d+$/.test(value)) {
      value = Number(value);
    }
    if (VueUtil.isNumber(value)) {
      this.height = value;
      el.style.height = value + 'px';
    } else if (VueUtil.isString(value)) {
      if (value === '') {
        el.style.height = '';
      }
    }
    this.updateHeight();
  };
  TableLayout.prototype.updateHeight = function() {
    var height = 0;
    var el = this.table.$el;
    if (VueUtil.isElement(el)) height = el.clientHeight;
    this.headerHeight = 0;
    if (!this.showHeader) {
      if (VueUtil.isNumber(this.height)) {
        this.bodyHeight = height;
      }
      this.fixedBodyHeight = this.scrollX ? height - this.gutterWidth : height;
    } else {
      var headerWrapper = this.table.$refs.headerWrapper;
      if (VueUtil.isDef(headerWrapper)) {
        this.headerHeight = headerWrapper.offsetHeight;
      }
      var headerHeight = this.headerHeight;
      var footerHeight = 0;
      var footerWrapper = this.table.$refs.footerWrapper;
      if (this.table.showFooter && footerWrapper) {
        footerHeight = footerWrapper.clientHeight;
      }
      var hfHeight = headerHeight + footerHeight;
      var bodyHeight = height - hfHeight;
      if (VueUtil.isNumber(this.height)) {
        this.bodyHeight = bodyHeight;
      }
      this.fixedBodyHeight = this.scrollX ? bodyHeight - this.gutterWidth : bodyHeight;
    }
    this.viewportHeight = this.scrollX ? height - this.gutterWidth : height;
    if (this.table.showFooter) this.viewportHeight = height;
  };
  TableLayout.prototype.update = function() {
    var fit = this.fit;
    var columns = this.store.states.columns;
    var bodyWidth = 0;
    var el = this.table.$el;
    if (VueUtil.isElement(el)) bodyWidth = el.clientWidth;
    var bodyMinWidth = 0;
    var flexColumns = [];
    var allColumnsWidth = 0;
    VueUtil.loop(columns, function(column) {
      if (!VueUtil.isNumber(column.width)) {
        flexColumns.push(column);
        allColumnsWidth = allColumnsWidth + (column.minWidth || 80);
      }
      bodyMinWidth += column.width || column.minWidth || 80;
      column.realWidth = column.width || column.realWidth;
    });
    this.scrollX = bodyMinWidth > bodyWidth;
    this.bodyWidth = bodyMinWidth;
    var flexColumnLen = flexColumns.length;
    if (flexColumnLen > 0 && fit) {
      if (bodyMinWidth <= bodyWidth - this.gutterWidth) {
        this.scrollX = false;
        var totalFlexWidth = bodyWidth - this.gutterWidth - bodyMinWidth;
        var noneFirstWidth = 0;
        var flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
        while (flexColumnLen--) {
          if (flexColumnLen === 0) break;
          var column = flexColumns[flexColumnLen];
          var flexWidth = Math.floor((column.minWidth || 80) * flexWidthPerPixel);
          noneFirstWidth += flexWidth;
          column.realWidth = (column.minWidth || 80) + flexWidth;
        }
        flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
      } else {
        this.scrollX = true;
        VueUtil.loop(flexColumns, function(column) {
          column.realWidth = column.minWidth || 80;
        });
      }
      this.bodyWidth = Math.max(bodyMinWidth, bodyWidth);
    }
    var fixedColumns = this.store.states.fixedColumns;
    var fixedWidth = 0;
    VueUtil.loop(fixedColumns, function(column) {
      fixedWidth += column.realWidth || 80;
    });
    this.fixedWidth = fixedWidth;
    var rightFixedColumns = this.store.states.rightFixedColumns;
    var rightFixedWidth = 0;
    VueUtil.loop(rightFixedColumns, function(column) {
      rightFixedWidth += column.realWidth || 80;
    });
    this.rightFixedWidth = rightFixedWidth;
  };
  var TableBody = {
    props: {
      fixed: String
    },
    render: function(createElement) {
      var self = this;
      if (!VueUtil.isDef(self.delta)) this.createDelta();
      var delta = self.delta;
      var columns = self.store.states.columns;
      var storeData = self.store.states.data;
      if (self.fixed) {
        if (((self.fixed === 'left') && self.store.states.fixedColumns.length > 0)
        || (self.fixed === 'right' && self.store.states.rightFixedColumns.length > 0)) {
          delta = self.tableBody.delta;
          self.$nextTick(self.doResetCurrentRow);
        } else {
          return null;
        }
      } else {
        self.scrollFilter(storeData, delta);
      }
      if (delta.data.length === 0) return null;
      self.store.rowspanData(delta.data);
      return createElement('table', {
        class: 'vue-table__body',
        attrs: {
          cellspacing: '0',
          cellpadding: '0',
          border: '0'
        },
        style: {
          'margin-top': delta.marginTop + 'px',
          'margin-bottom': delta.marginBottom + 'px'
        }
      }, [createElement('colgroup', null, [self._l(columns, function(column, columnIndex) {
        return createElement('col', {
          key: columnIndex,
          attrs: {
            name: column.id,
            width: column.realWidth || column.width || 80
          }
        }, []);
      }), !self.fixed && (self.layout.scrollX || self.layout.scrollY) && self.layout.gutterWidth ? createElement('col', {
        attrs: {
          name: 'gutter',
          width: 0
        }
      }, []) : '']), createElement('tbody', {ref: 'tbody'}, [VueUtil.mergeArray(self._l(delta.data, function(row, index) {
        var $index = row.$index;
        return [createElement('tr', {
          style: self.rowStyle ? self.getRowStyle(row, $index) : null,
          key: $index,
          ref: 'trow'+$index,
          on: {
            dblclick: function(e) {
              return self.handleDoubleClick(e, row);
            },
            contextmenu: function(e) {
              return self.handleContextMenu(e, row);
            },
            mouseenter: function(e) {
              return self.handleMouseEnter(row);
            },
            mouseleave: function(e) {
              return self.handleMouseLeave();
            }
          },
          class: ['vue-table__row', self.getRowClass(row, $index)]
        }, [self._l(columns, function(column, cellIndex) {
          if (column.rowspan && column.rowspanAry.indexOf(index) !== -1) {
            return null;
          } else {
            var rowspanNum = null;
            if (column.rowspan) {
              VueUtil.loop(column.rowspanStartAry, function(rowspan) {
                if (rowspan.start === index) {
                  rowspanNum = rowspan.spanNum;
                }
              });
            }
            return createElement('td', {
              key: cellIndex,
              attrs: {
                rowspan: rowspanNum
              },
              class: ['vue-table__cell', $index % 2 === 1 ? 'grey' : '', column.align, column.getCellClass($index, cellIndex, row) || '', self.$parent.isCellHidden(cellIndex, self.fixed) ? 'is-hidden' : '', column.renderCell ? 'template-column-cell' : ''],
              on: {
                click: function(e) {
                  return self.handleClick(e, row, column);
                },
                mouseenter: function(e) {
                  return self.handleCellMouseEnter(e, row, column);
                },
                mouseleave: function(e) {
                  return self.handleCellMouseLeave(e, row, column);
                }
              }
            }, [column.renderCell.call(self._renderProxy, createElement, {
              row: row,
              column: column,
              $index: $index,
              store: self.store,
              _self: self.$parent.$vnode.context
            }), column.showOverflowTooltip ? createElement('vue-tooltip', {
              attrs: {
                effect: self.$parent.tooltipEffect,
                placement: 'top',
                content: self.tooltipContent,
                append: self.$parent.$el
              },
              ref: 'tooltip'+column.property+$index
            }, []) : null]);
          }
        }), !self.fixed && (self.layout.scrollX || self.layout.scrollY) && self.layout.gutterWidth ? createElement('td', {
          class: 'vue-table__cell gutter'
        }, []) : '']), self.store.states.expandRows.indexOf(row) !== -1 ? createElement('tr', {class: ['vue-table__row', 'vue-table__expanded-row']}, [createElement('td', {
          attrs: {
            colspan: columns.length
          },
          class: ['vue-table__cell', 'vue-table__expanded-cell', self.getExpandClass(row, $index)]
        }, [self.$parent.renderExpanded ? self.$parent.renderExpanded(createElement, {
          row: row,
          $index: $index,
          store: self.store
        }) : ''])]) : null];
      }), self._self.$parent.$slots.append)])]);
    },
    watch: {
      'store.states.hoverRow': function(newVal) {
        this.doResetHoverRow(newVal);
      },
      'store.states.currentRow': function(newVal) {
        this.doResetCurrentRow(newVal);
      }
    },
    computed: {
      store: function() {
        return this.$parent.store;
      },
      layout: function() {
        return this.$parent.layout;
      },
      rowClassName: function() {
        return this.$parent.rowClassName;
      },
      rowStyle: function() {
        return this.$parent.rowStyle;
      },
      expandClassName: function() {
        return this.$parent.expandClassName;
      },
      highlightCurrent: function() {
        return this.$parent.highlightCurrentRow;
      },
      highlightHover: function() {
        return this.$parent.highlightHoverRow;
      },
      tableBody: function() {
        return this.$parent.$refs.tableBody;
      },
      fixedTableBody: function() {
        return this.$parent.$refs.fixedTableBody;
      },
      rightFixedTableBody: function() {
        return this.$parent.$refs.rightFixedTableBody;
      }
    },
    data: function() {
      return {
        tooltipContent: ''
      };
    },
    methods: {
      createDelta: function() {
        if (this.fixed) return;
        var delta = this.delta = Object.create(null);
        delta.start = 0;
        delta.end = 0;
        delta.total = 0;
        delta.keeps = 0;
        delta.marginTop = 0;
        delta.marginBottom = 0;
        delta.size = 40;
        delta.remain = 0;
        delta.data = [];
        var table = this.$parent;
        if (table.height && table.lazyload) {
          delta.remain = Math.floor(table.height * 1 / delta.size) + 10;
          delta.end = delta.remain;
          delta.keeps = delta.remain;
        }
      },
      resetDelta: function(dataLen) {
        if (this.fixed) return;
        var delta = this.delta;
        if (delta.keeps === 0) return;
        delta.start = 0;
        if (dataLen <= delta.remain) {
          delta.end = dataLen;
          //delta.keeps = dataLen;
        } else {
          delta.end = delta.remain;
          delta.keeps = delta.remain;
        }
      },
      scrollFilter: function(storeData, delta) {
        delta.data = [];
        if (delta.keeps === 0 || storeData.length <= delta.keeps) {
          delta.marginTop = 0;
          delta.marginBottom = 0;
          delta.data = storeData;
        } else {
          delta.total = storeData.length;
          delta.marginTop = delta.size * delta.start;
          delta.marginBottom = delta.size * (delta.total - delta.keeps - delta.start);
          for (var i = delta.start, j = delta.end; i < j; i++) {
            delta.data.push(storeData[i]);
          }
        }
      },
      updateZone: function(offset) {
        if (this.fixed) return;
        var delta = this.delta;
        if (delta.keeps === 0) return;
        delta.size = 40;
        if (VueUtil.isElement(this.$refs.tbody)) delta.size = this.$refs.tbody.firstElementChild.offsetHeight;
        delta.remain = Math.floor(this.$parent.height * 1 / delta.size) + 11;
        delta.keeps = delta.remain;
        if (delta.total <= delta.keeps) return;
        var overs = Math.floor(offset / delta.size) - 6;
        overs < 0 && (overs = 0);
        var start = overs;
        var end = overs + delta.keeps;
        if (overs + delta.keeps >= delta.total) {
          end = delta.total;
          start = delta.total - delta.keeps;
        }
        delta.end = end;
        delta.start = start;
        this.forceUpdate();
        this.$nextTick(this.doResetCurrentRow);
      },
      forceUpdate: VueUtil.throttle(function() {
        this.tableBody.$forceUpdate();
        this.fixedTableBody.$forceUpdate();
        this.rightFixedTableBody.$forceUpdate();
      }),
      doResetCurrentRow: VueUtil.throttle(function(currentRow) {
        this.tableBody.resetCurrentRow(currentRow);
        this.fixedTableBody.resetCurrentRow(currentRow);
        this.rightFixedTableBody.resetCurrentRow(currentRow);
      }),
      doResetHoverRow: function(hoverRow) {
        this.tableBody.resetHoverRow(hoverRow);
        this.fixedTableBody.resetHoverRow(hoverRow);
        this.rightFixedTableBody.resetHoverRow(hoverRow);
      },
      resetCurrentRow: function(currentRowObj) {
        if (!this.highlightCurrent) return;
        var oldCurrentRow = this.currentRow;
        oldCurrentRow && oldCurrentRow.classList.remove('current-row');
        if (!VueUtil.isDef(currentRowObj)) currentRowObj = this.store.states.currentRow;
        if (!VueUtil.isDef(currentRowObj)) return;
        var currentRow = this.$refs['trow'+currentRowObj.$index];
        currentRow && currentRow.classList.add('current-row');
        this.currentRow = currentRow;
      },
      resetHoverRow: function(hoverRowObj) {
        if (!this.highlightHover) return;
        var oldHoverRow = this.hoverRow;
        oldHoverRow && oldHoverRow.classList.remove('hover-row');
        if (!VueUtil.isDef(hoverRowObj)) return;
        var hoverRow = this.$refs['trow'+hoverRowObj.$index];
        hoverRow && hoverRow.classList.add('hover-row');
        this.hoverRow = hoverRow;
      },
      getCell: function(event) {
        var cell = event.target;
        while (cell && cell.tagName.toUpperCase() !== 'HTML') {
          if (cell.tagName.toUpperCase() === 'TD') {
            return cell;
          }
          cell = cell.parentNode;
        }
        return null;
      },
      getRowStyle: function(row, index) {
        var rowStyle = this.rowStyle;
        if (VueUtil.isFunction(rowStyle)) {
          return rowStyle.call(null, row, index);
        }
        return rowStyle;
      },
      getRowClass: function(row, index) {
        var classes = [];
        var rowClassName = this.rowClassName;
        if (VueUtil.isString(rowClassName)) {
          classes.push(rowClassName);
        } else if (VueUtil.isFunction(rowClassName)) {
          classes.push(rowClassName.call(null, row, index) || '');
        }
        return classes.join(' ');
      },
      getExpandClass: function(row, index) {
        var classes = [];
        var expandClassName = this.expandClassName;
        if (VueUtil.isString(expandClassName)) {
          classes.push(expandClassName);
        } else if (VueUtil.isFunction(expandClassName)) {
          classes.push(expandClassName.call(null, row, index) || '');
        }
        return classes.join(' ');
      },
      handleCellMouseEnter: function(event, row, column) {
        var cell = this.getCell(event);
        if (!cell) return;
        var table = this.$parent;
        var hoverState = table.hoverState = {cell: cell, column: column, row: row};
        table.$emit('cell-mouse-enter', hoverState.row, hoverState.column, hoverState.cell, event);
        var cellChild = event.target.querySelector('.cell');
        if (column.showOverflowTooltip && cellChild.scrollWidth > cellChild.offsetWidth) {
          var tooltip = this.$refs['tooltip'+column.property+this.store.states.data.indexOf(row)];
          this.tooltipContent = cell.innerText;
          tooltip.referenceElm = cell;
          tooltip.setExpectedState(true);
          tooltip.handleShowPopper();
        }
      },
      handleCellMouseLeave: function(event, row, column) {
        var cell = this.getCell(event);
        if (!cell) return;
        var table = this.$parent;
        var oldHoverState = table.hoverState;
        table.$emit('cell-mouse-leave', oldHoverState.row, oldHoverState.column, oldHoverState.cell, event);
        var cellChild = event.target.querySelector('.cell');
        if (column.showOverflowTooltip && cellChild.scrollWidth > cellChild.offsetWidth) {
          var tooltip = this.$refs['tooltip'+column.property+this.store.states.data.indexOf(row)];
          tooltip.setExpectedState(false);
          tooltip.handleClosePopper();
        }
      },
      handleMouseEnter: function(row) {
        this.store.commit('setHoverRow', row);
      },
      handleMouseLeave: function() {
        this.store.commit('setHoverRow', null);
      },
      handleContextMenu: function(event, row) {
        this.$parent.$emit('row-contextmenu', row, event);
      },
      handleDoubleClick: function(event, row) {
        this.$parent.$emit('row-dblclick', row, event);
      },
      handleClick: function(event, row, column) {
        var table = this.$parent;
        var cell = this.getCell(event);
        if (cell) {
          table.$emit('cell-click', row, column, cell, event);
        }
        this.store.commit('setCurrentRow', row);
        table.$emit('row-click', row, event, column);
      },
      handleExpandClick: function(row) {
        this.store.commit('toggleRowExpanded', row);
      }
    }
  };
  var VueTableFilterPanel = {
    template: '<transition @after-leave="destroyPopper"> \
    <div class="vue-table-filter" v-show="showPopper" v-clickoutside="handleOutsideClick"> \
      <div class="vue-table-filter__content"> \
        <vue-checkbox-group v-model="filteredValue"> \
          <vue-list scrollbar :height="150" ref="list" class="vue-table-filter__list"> \
            <vue-list-item v-for="(filter, index) in complexFilters" :key="\'complexFilters\'+index" class="vue-table-filter__list-item"> \
              <template>\
              <label class="vue-checkbox table-complexfilter">\
                <span class="vue-checkbox__input is-checked">\
                  <span @mousedown.left.stop="removeComplexFilter(filter)" class="vue-checkbox__inner"></span>\
                </span>\
                <span class="vue-checkbox__label">{{filter.operations + \' \' + filter.conditions}}</span>\
              </label> \
              </template>\
            </vue-list-item>\
            <vue-list-item v-if="column.filterable" v-for="(filter, index) in filters" :key="index" class="vue-table-filter__list-item"> \
              <vue-checkbox :label="filter.value">{{filter.text}}</vue-checkbox> \
            </vue-list-item> \
          </vue-list> \
        </vue-checkbox-group> \
      </div> \
      <div class="vue-table-filter__bottom"> \
        <vue-button @click="handleConfirm" type="text" :disabled="filteredValue.length === 0">{{$t(\'vue.table.confirmFilter\')}}</vue-button> \
        <vue-button type="text" @click="handleReset">{{$t(\'vue.table.resetFilter\')}}</vue-button> \
      </div> \
    </div> \
  </transition>',
    name: 'VueTableFilterPanel',
    mixins: [VuePopper],
    directives: {
      Clickoutside: VueUtil.component.clickoutside()
    },
    props: {
      placement: {
        type: String,
        default: 'bottom'
      }
    },
    methods: {
      handleOutsideClick: function() {
        this.showPopper = false;
      },
      handleConfirm: function() {
        this.confirmFilter(this.filteredValue, this.column.complexFilters);
        this.handleOutsideClick();
      },
      handleReset: function() {
        this.filteredValue = [];
        this.column.complexFilters = [];
        this.handleConfirm();
      },
      confirmFilter: function(filteredValue, complexFilters) {
        this.table.store.commit('filterChange', {
          column: this.column,
          values: {simpleFilters: filteredValue, complexFilters: complexFilters}
        });
      },
      removeComplexFilter: function(filter) {
        var index = this.column.complexFilters.indexOf(filter);
        if (index > -1) {
          this.column.complexFilters.splice(index , 1);
          if(!this.column.filterable && this.column.complexFilters.length == 0) {
            this.handleOutsideClick();
          }
        }

        this.confirmFilter(this.filteredValue, this.column.complexFilters);
      }
    },
    computed: {
      filters: function() {
        if (this.column && this.column.filters.length > 0) return this.column.filters;
        var filterList = [];
        var column = this.column;
        VueUtil.loop(this.table.store.states._data, function(row) {
          var columnData = {};
          columnData.value = row[column.property];
          columnData.text = row[column.property];
          if (filterList.map(function(e) { return e.value; }).indexOf(columnData.value) === -1) {
            filterList.push(columnData);
          }
        });
        return filterList;
      },
      complexFilters: function() {
        if (this.column) {
          return this.column.complexFilters || [];
        }
        return [];
      },
      filteredValue: {
        get: function() {
          if (this.column) {
            return this.column.filteredValue || [];
          }
          return [];
        },
        set: function(value) {
          if (this.column) {
            this.column.filteredValue = value;
          }
        }
      }
    },
    mounted: function() {
      var self = this;
      self.popperElm = self.$el;
      self.referenceElm = self.cell;
      self.dropdown = Object.create(null);
      self.dropdown.dropdowns = [];
      self.dropdown.open = function(instance) {
        if (instance) {
          this.dropdowns.push(instance);
        }
      };
      self.dropdown.close = function(instance) {
        var index = this.dropdowns.indexOf(instance);
        if (index !== -1) {
          this.dropdowns.splice(instance, 1);
        }
      };
      self.$watch('showPopper', function(value) {
        if (self.column)
          self.column.filterOpened = value;
        if (value) {
          self.dropdown.open(self);
          self.$nextTick(self.$refs.list.updateZone);
        } else {
          self.dropdown.close(self);
        }
      });
    }
  };
  var TableHeader = {
    render: function(createElement) {
      if (!this.$parent.showHeader
        || ((this.fixed === 'left') && this.store.states.fixedColumns.length === 0)
        || (this.fixed === 'right' && this.store.states.rightFixedColumns.length === 0)) return null;
      var self = this;
      var columns = self.store.states.columns;
      var columnRows = self.convertToRows(columns);
      return createElement('table', {
        class: 'vue-table__header',
        attrs: {
          cellspacing: '0',
          cellpadding: '0',
          border: '0'
        }
      }, [createElement('colgroup', null, [self._l(columns, function(column, columnIndex) {
        return createElement('col', {
          key: columnIndex,
          attrs: {
            name: column.id,
            width: column.realWidth || column.width || 80
          }
        }, []);
      }), !self.fixed && (self.layout.scrollX || self.layout.scrollY) && self.layout.gutterWidth ? createElement('col', {
        attrs: {
          name: 'gutter',
          width: self.layout.gutterWidth
        }
      }, []) : '']), createElement('thead', null, [self._l(columnRows, function(columns, rowIndex) {
        return createElement('tr', {class: ['vue-table__row'], key:rowIndex}, [self._l(columns, function(column, cellIndex) {
          return column.labelColspan ? null : createElement('th', {
            key: cellIndex,
            attrs: {
              colspan: column.labelColspanNum
            },
            on: {
              mousemove: function(e) {
                return self.handleMouseMove(e, column);
              },
              mouseout: self.handleMouseOut,
              mousedown: function(e) {
                return self.handleMouseDown(e, column);
              },
              touchstart: function(e) {
                return self.handleMouseDown(e, column);
              },
              click: function(e) {
                return self.handleHeaderClick(e, column);
              }
            },
            class: ['vue-table__column', column.order, column.headerAlign, rowIndex === 0 && self.$parent.isCellHidden(cellIndex, self.fixed) ? 'is-hidden' : '', 'is-leaf', column.labelClassName, column.renderHeader ? 'template-column-header' : '']
          }, [createElement('div', {
            class: ['cell', column.filtered || column.order ? 'highlight' : ''],
            style: {'width': column.renderHeader ? '100%' : '', 'padding': column.renderHeader ? 0 : ''},
          }, [column.renderHeader ? column.renderHeader.call(self._renderProxy, createElement, {
            column: column,
            $index: cellIndex,
            store: self.store,
            _self: self.$vnode.context
          }) : createElement('span', { class: ['vue-table_column-label', 'vue-table_column-label-' + column.property], domProps: {innerHTML: column.label}}),
            column.sortable && !column.renderHeader ? createElement('span', {
            class: 'vue-table__sort-wrapper',
            on: {
              click: function(e) {
                return self.handleSortClick(e, column);
              }
            }
          }, [createElement('i', {
            class: ['is-sort', column.order === 'descending' ? 'vue-icon-sort-desc' : 'vue-icon-sort-asc'],
          }, [])]) : '', (column.filterable || (column.complexFilters && column.complexFilters.length > 0)) && !column.renderHeader ? createElement('span', {
            class: 'vue-table__column-filter-trigger',
            on: {
              click: function(e) {
                return self.handleFilterClick(e, column);
              }
            }
          }, [createElement('i', {
            class: ['vue-icon-filter', column.filtered ? 'is-filtered' : '']
          }, [])]) : ''])]);
        }), !self.fixed && (self.layout.scrollX || self.layout.scrollY) && self.layout.gutterWidth ? createElement('th', {
          class: 'vue-table__column gutter'
        }, []) : '']);
      })])]);
    },
    props: {
      fixed: String
    },
    computed: {
      store: function() {
        return this.$parent.store;
      },
      layout: function() {
        return this.$parent.layout;
      },
      border: function() {
        return this.$parent.border;
      },
      defaultSort: function() {
        return this.$parent.defaultSort;
      }
    },
    created: function() {
      this.filterPanels = {};
    },
    mounted: function() {
      this.draggingColumn = null;
      this.dragging = false;
      this.dragState = {};
      this.setDefaultSortColumn();
    },
    beforeDestroy: function() {
      var panels = this.filterPanels;
      VueUtil.ownPropertyLoop(panels, function(prop) {
        if (VueUtil.isVueComponent(panels[prop])) {
          panels[prop].$destroy();
        }
      });
    },
    methods: {
      setDefaultSortColumn: function() {
        if (this.fixed) return;
        var self = this;
        var sortingColumns = self.store.states.sortingColumns;
        VueUtil.loop(self.defaultSort, function(sort) {
          VueUtil.loop(self.store.states.columns, function(column) {
            if (column.property === sort.prop) {
              column.order = sort.order;
              sortingColumns.push(column);
            }
          });
        });
      },
      convertToRows: function(columns) {
        var rows = [[]];
        var colspan = 1;
        var i = columns.length;
        while (i--) {
          var column = columns[i];
          column.labelColspanNum = 1;
          if (!column.labelColspan) {
            column.labelColspanNum = colspan;
            colspan = 1;
          } else {
            colspan++;
          }
          rows[0].push(column);
        }
        rows[0].reverse();
        return rows;
      },
      toggleAllSelection: function() {
        this.store.commit('toggleAllSelection');
      },
      handleFilterClick: function(event, column) {
        event.stopPropagation();
        var target = event.target;

        if (target.tagName == 'SPAN') {
          target = target.querySelector('i');
        }
        var cell = target.parentNode;
        var filterPanel = this.filterPanels[column.id];
        if (filterPanel && column.filterOpened) {
          filterPanel.showPopper = false;
          return;
        }
        if (!filterPanel) {
          filterPanel = new Vue(VueTableFilterPanel);
          this.filterPanels[column.id] = filterPanel;
          filterPanel.table = this.$parent;
          filterPanel.cell = cell;
          filterPanel.column = column;
          filterPanel.$mount(document.createElement('div'));
        } else {
          if(filterPanel.referenceElm !== cell) {
            filterPanel.referenceElm = cell;
          }
        }
        this.$nextTick(function() {
          filterPanel.showPopper = true;
        });
      },
      handleHeaderClick: function(event, column) {
        this.$parent.$emit('header-click', column, event);
      },
      handleMouseDown: function(event, column) {
        var self = this;
        if (event.touches) {
          self.handleMouseMove(event, column);
        }
        if (self.draggingColumn && self.border) {
          self.dragging = true;
          self.$parent.resizeProxyVisible = true;
          var tableEl = self.$parent.$el;
          var tableLeft = tableEl.getBoundingClientRect().left;
          var columnEl = event.currentTarget;
          var columnRect = columnEl.getBoundingClientRect();
          var minLeft = columnRect.left - tableLeft + 30;
          columnEl.classList.add('noclick');
          self.dragState = {
            startMouseLeft: event.clientX || event.touches[0].clientX,
            startLeft: columnRect.right - tableLeft,
            startColumnLeft: columnRect.left - tableLeft,
            tableLeft: tableLeft
          };
          var resizeProxy = self.$parent.$refs.resizeProxy;
          resizeProxy.style.left = self.dragState.startLeft + 'px';
          document.onselectstart = function() {
            return false;
          };
          document.ondragstart = function() {
            return false;
          };
          var handleMouseMove = function(event) {
            var deltaLeft = (event.clientX || event.touches[0].clientX) - self.dragState.startMouseLeft;
            var proxyLeft = self.dragState.startLeft + deltaLeft;
            resizeProxy.style.left = Math.max(minLeft, proxyLeft) + 'px';
          };
          var handleMouseUp = function() {
            if (self.dragging) {
              var finalLeft = parseInt(resizeProxy.style.left, 10);
              var startLeft = self.dragState.startLeft;
              var startColumnLeft = self.dragState.startColumnLeft;
              var draggingColumnNum = 1;
              if (VueUtil.isArray(column.colColumns)) {
                draggingColumnNum = draggingColumnNum + column.colColumns.length;
              }
              var columnWidth = parseInt((finalLeft - startColumnLeft) / draggingColumnNum);
              column.width = column.realWidth = columnWidth;
              VueUtil.loop(column.colColumns, function(colColumn){
                colColumn.width = colColumn.realWidth = columnWidth;
              });
              self.$parent.$emit('header-dragend', finalLeft - startColumnLeft, startLeft - startColumnLeft, column, event);
              document.body.style.cursor = '';
              self.dragging = false;
              self.draggingColumn = null;
              self.dragState = {};
              self.$parent.resizeProxyVisible = false;
              self.$parent.doLayout();
            }
            VueUtil.removeTouchMove(document, handleMouseMove);
            VueUtil.removeTouchEnd(document, handleMouseUp);
            document.onselectstart = null;
            document.ondragstart = null;
            self.$nextTick(function() {
              columnEl.classList.remove('noclick');
            });
          };
          VueUtil.addTouchMove(document, handleMouseMove);
          VueUtil.addTouchEnd(document, handleMouseUp);
        }
      },
      handleMouseMove: function(event, column) {
        var target = event.target;
        while (target && !VueUtil.hasClass(target, 'vue-table__column')) {
          target = target.parentNode;
        }
        if (!column || !column.resizable) return;
        if (!this.dragging && this.border) {
          var rect = target.getBoundingClientRect();
          var bodyStyle = document.body.style;
          if (rect.width > 12 && rect.right - (event.pageX || event.touches[0].pageX) < 8) {
            bodyStyle.cursor = 'col-resize';
            this.draggingColumn = column;
          } else if (!this.dragging) {
            bodyStyle.cursor = '';
            this.draggingColumn = null;
          }
        }
      },
      handleMouseOut: function() {
        document.body.style.cursor = '';
      },
      toggleOrder: function(order) {
        return !order ? 'ascending' : order === 'ascending' ? 'descending' : null;
      },
      handleSortClick: function(event, column) {
        event.stopPropagation();
        var target = event.target;
        while (target && !VueUtil.hasClass(target, 'vue-table__column')) {
          target = target.parentNode;
        }
        if (target && VueUtil.hasClass(target, 'vue-table__column')) {
          if (target.classList.contains('noclick')) {
            target.classList.remove('noclick');
            return;
          }
        }
        var states = this.store.states;
        var sortingColumns = states.sortingColumns;
        column.order = this.toggleOrder(column.order);
        var sortIndex = sortingColumns.indexOf(column);
        if (sortIndex === -1) {
          sortingColumns.push(column);
        } else if (column.order === null) {
          sortingColumns.splice(sortIndex, 1);
        }
        this.store.commit('changeSortCondition');
      }
    }
  };
  var TableFooter = {
    render: function(createElement) {
      if (!this.$parent.showFooter
        || ((this.fixed === 'left') && this.store.states.fixedColumns.length === 0)
        || (this.fixed === 'right' && this.store.states.rightFixedColumns.length === 0)) return null;
      var self = this;
      var aggregates = self.fixed ? self.$parent.$refs.tableFooter.aggregates : self.aggregates;
      var columns = self.store.states.columns;
      return createElement('table', {
        class: 'vue-table__footer',
        attrs: {
          cellspacing: '0',
          cellpadding: '0',
          border: '0'
        }
      }, [createElement('colgroup', null, [self._l(columns, function(column, columnIndex) {
        return createElement('col', {
          key: columnIndex,
          attrs: {
            name: column.id,
            width: column.realWidth || column.width || 80
          }
        }, []);
      }), !self.fixed && (self.layout.scrollX || self.layout.scrollY) && self.layout.gutterWidth ? createElement('col', {
        attrs: {
          name: 'gutter',
          width: self.layout.gutterWidth
        }
      }, []) : '']), createElement('tfoot', null, [createElement('tr', {class: ['vue-table__row']}, [self._l(columns, function(column, cellIndex) {
        return createElement('th', {
          key: cellIndex,
          attrs: {
            colspan: column.colSpan,
            rowspan: column.rowSpan
          },
          class: ['vue-table__column', column.align, column.className || '', self.$parent.isCellHidden(cellIndex, self.fixed) ? 'is-hidden' : '', 'is-leaf', column.labelClassName]
        }, [createElement('div', {
          class: ['cell', column.labelClassName]
        }, [aggregates[cellIndex] ? aggregates[cellIndex].label : ''])]);
      }), !self.fixed && (self.layout.scrollX || self.layout.scrollY) && self.layout.gutterWidth ? createElement('th', {
        class: 'vue-table__column gutter'
      }, []) : ''])])]);
    },
    props: {
      fixed: String,
    },
    data: function() {
      return {
        aggregates: []
      };
    },
    computed: {
      store: function() {
        return this.$parent.store;
      },
      layout: function() {
        return this.$parent.layout;
      }
    },
    watch: {
      '$parent.emptyLabel': function() {
        if (this.$parent.showFooter && !this.fixed) {
          this.store.getAggregate(this.store.states.columns, this.store.states.data);
          this.aggregates = this.store.states.aggregates;
        }
      }
    }
  };
  var TableContextMenu = {
    template: '<vue-dialog :size="size" v-model="dialogVisible" custom-class="vue-table-context-menu" :title="$t(\'vue.table.contextMenu\')" \
      show-close @close="closeHandle"> \
      <vue-tabs> \
        <vue-tab-pane :label="$t(\'vue.table.pin\')"> \
          <vue-form label-width="100px"> \
            <vue-form-item :label="$t(\'vue.table.leftPin\')"> \
              <vue-select clearable v-model="pinForm.leftPin" multiple @change="leftPin" @remove-tag="noPin" value-key="id"> \
                <vue-option v-for="(column, index) in labelColumns" :key="index" :label="column.label?column.label:(column.type==\'index\'?\'#\':\' \')" :value="column"></vue-option> \
              </vue-select> \
            </vue-form-item> \
            <vue-form-item :label="$t(\'vue.table.rightPin\')"> \
              <vue-select clearable v-model="pinForm.rightPin" multiple @change="rightPin" @remove-tag="noPin" value-key="id"> \
                <vue-option v-for="(column, index) in labelColumns" :key="index" :label="column.label?column.label:(column.type==\'index\'?\'#\':\' \')" :value="column"></vue-option> \
              </vue-select> \
            </vue-form-item> \
          </vue-form> \
        </vue-tab-pane> \
        <vue-tab-pane :label="$t(\'vue.table.sort\')"> \
          <vue-list scrollbar :height="150" :default-selected="false"> \
            <vue-list-item v-for="(column, index) in labelColumns" v-if="column.type != \'index\'" :key="index"> \
              <vue-button type="text" style="padding-left:15px" @click="removeSortColumn(column, true)">{{column.label?column.label:(column.type=="index"?"#":"&nbsp;")}}</vue-button> \
              <div style="float:right;"> \
                <vue-button style="padding:10px 0 0 0;" :style="{color: column.order === \'ascending\' ? \'#eb9e05\' : \'rgb(151, 168, 190)\'}" \
                  icon="vue-icon-caret-top" type="text" @click="sortColumn(column)"></vue-button> \
                <vue-button style="padding:10px 15px 0 0;" :style="{color: column.order === \'descending\' ? \'#eb9e05\' : \'rgb(151, 168, 190)\'}" \
                  icon="vue-icon-caret-bottom" type="text" @click="sortColumn(column, true)"></vue-button> \
              </div> \
              <vue-divider v-if="index!==labelColumns.length-1"></vue-divider> \
            </vue-list-item> \
          </vue-list> \
          <vue-form label-width="70px"> \
            <vue-form-item :label="$t(\'vue.table.sortBy\')"> \
              <vue-tag hit style="margin:5px 5px 0 0;" v-for="(column, index) in sortList" :key="index" closable \
                type="info" @close="removeSortColumn(column)">{{column.label?column.label:(column.type=="index"?"#":"&nbsp;")}}<i style="padding:5px 0 0 5px;" :class="[{\'vue-icon-caret-top\': column.order === \'ascending\'}, {\'vue-icon-caret-bottom\': column.order === \'descending\'}]"></i></vue-tag> \
            </vue-form-item> \
          </vue-form> \
        </vue-tab-pane> \
        <vue-tab-pane :label="$t(\'vue.table.filter\')"> \
          <vue-form label-width="100px" :model="filterForm"> \
            <vue-form-item :label="$t(\'vue.table.column\')"> \
              <vue-select v-model="filterForm.filterColumn"> \
                <vue-option v-for="(column, index) in labelColumns" v-if="column.type != \'index\'" :key="index" :label="column.label?column.label:(column.type==\'index\'?\'#\':\' \')" :value="column"></vue-option> \
              </vue-select> \
            </vue-form-item> \
            <vue-form-item :label="$t(\'vue.table.conditions\')"> \
              <vue-input icon="vue-icon-search" v-model="filterForm.conditions" :on-icon-click="filterColumn" \
                @keydown.enter.native="filterColumn" ref="filterInput"> \
                <vue-select slot="prepend" v-model="filterForm.operations" style="width:80px;font-size:21px;" \
                  @change="operationsChange"> \
                  <vue-option v-for="(item, index) in operations" :key="index" :label="item" :value="item"></vue-option> \
                </vue-select> \
              </vue-input> \
            </vue-form-item> \
          </vue-form> \
          <vue-divider></vue-divider> \
          <vue-form label-width="100px"> \
            <vue-form-item :label="$t(\'vue.table.filterBy\')"> \
            <template v-for="(column, column_index) in labelColumns" > \
              <vue-tag hit style="margin:5px 5px 0 0;" v-for="(filter, index) in column.complexFilters" :key="column_index+\'__\'+index" closable \
                type="info" @close="removeFilterColumn(column, filter)">{{column.label?column.label:(column.type=="index"?"#":"&nbsp;")}} {{filter.operations}} {{filter.conditions}}</vue-tag> \
            </template> \
            </vue-form-item> \
          </vue-form> \
        </vue-tab-pane> \
        <vue-tab-pane :label="$t(\'vue.table.display\')"> \
          <vue-list scrollbar :height="150" :default-selected="false"> \
            <vue-list-item v-for="(column, index) in labelColumns" :key="index" @select="displayColumn(column)" \
              style="cursor:pointer;"> \
              <vue-button type="text" style="padding-left:15px">{{column.label?column.label:(column.type=="index"?"#":"&nbsp;")}}</vue-button> \
              <div style="float:right;"> \
              <vue-button style="padding:10px 0 0 0;" :style="{visibility: index==0?\'hidden\': \'visible\'}" \
              icon="vue-icon-caret-top" type="text" @click.stop="reorderColumn(index, \'up\')"></vue-button> \
            <vue-button style="padding:10px 15px 0 0;" :style="{visibility: index==labelColumns.length-1?\'hidden\': \'visible\'}"  \
              icon="vue-icon-caret-bottom" type="text" @click.stop="reorderColumn(index, \'down\')"></vue-button> \
                <vue-button style="padding:10px 15px 0 0;" :style="{color: column.visible ? \'#13ce66\' : \'#a94442\'}" \
                  :icon="column.visible ? \'vue-icon-success\' : \'vue-icon-error\'" type="text"></vue-button> \
              </div> \
              <vue-divider v-if="index!==labelColumns.length-1"></vue-divider> \
            </vue-list-item> \
          </vue-list> \
        </vue-tab-pane> \
        <vue-tab-pane :label="$t(\'vue.table.exportData\')"> \
          <vue-form label-width="100px"> \
            <vue-form-item :label="$t(\'vue.table.fileName\')"> \
              <vue-input v-model="fileName"></vue-input> \
            </vue-form-item> \
          </vue-form> \
          <div style="text-align:right"> \
            <vue-button @click="exportData(true)" plain type="info" icon="vue-icon-download2">{{$t(\'vue.table.exportOrgData\')}}</vue-button> \
            <vue-button @click="exportData(false)" type="primary" \
              icon="vue-icon-download2">{{$t(\'vue.table.exportHandleData\')}}</vue-button> \
          </div> \
        </vue-tab-pane> \
      </vue-tabs> \
    </vue-dialog>',
    data: function() {
      return {
        tableColumns: [],
        pinForm: {
          leftPin: [],
          rightPin: []
        },
        filterForm: {
          filterColumn: null,
          conditions: null,
          operations: '='
        },
        operations: ['=', '<', '>', '<=', '>=', '<>', '%'],
        sortList: [],
        filterList: [],
        dialogVisible: false,
        fileName: ''
      };
    },
    props: {
      visible: Boolean,
    },
    model: {
      prop: 'visible'
    },
    watch: {
      visible: function(val) {
        this.dialogVisible = val;
      }
    },
    computed: {
      size: function() {
        return VueUtil.getSystemInfo().device === 'Mobile' ? 'full' : 'small';
      },
      store: function() {
        return this.$parent.store;
      },
      labelColumns: function() {
        return this.$parent.store.states.labelColumns;
      }
    },
    methods: {
      closeHandle: function() {
        this.$parent.showContextMenu = false;
      },
      operationsChange: function() {
        this.$nextTick(this.$refs.filterInput.focus);
      },
      exportData: function(flg) {
        var params = {};
        params.fileName = this.fileName;
        params.original = flg;
        this.$parent.exportCsv(params);
      },
      noPin: function(tag) {
        this.removePin(tag.value);
      },
      removePin: function(column) {
        column.fixed = false;
        this.$parent.doLayout();
      },
      leftPin: function(columns) {
        if (columns.length <= 0) {
          var layoutFLg = false;
          VueUtil.loop(this.tableColumns, function(column) {
            if (column.fixed === true || column.fixed === 'left') {
              column.fixed = false;
              layoutFLg = true;
            }
          });
          if (layoutFLg) this.$parent.doLayout();
          return;
        }
        var self = this;
        VueUtil.loop(columns, function(column, index) {
          var rightIndex = self.pinForm.rightPin.indexOf(column);
          if (rightIndex !== -1) self.pinForm.rightPin.splice(rightIndex, 1);
          column.fixed = 'left';
          column.fixedIndex = index;
          VueUtil.loop(column.colColumns, function(colColumn) {
            colColumn.fixed = 'left';
            colColumn.fixedIndex = index;
          });
        });
        this.$parent.doLayout();
      },
      rightPin: function(columns) {
        if (columns.length <= 0) {
          var layoutFLg = false;
          VueUtil.loop(this.tableColumns, function(column) {
            if (column.fixed === 'right') {
              column.fixed = false;
              layoutFLg = true;
            }
          });
          if (layoutFLg) this.$parent.doLayout();
          return;
        }
        var self = this;
        VueUtil.loop(columns, function(column, index) {
          var leftIndex = self.pinForm.leftPin.indexOf(column);
          if (leftIndex !== -1) self.pinForm.leftPin.splice(leftIndex, 1);
          column.fixed = 'right';
          column.fixedIndex = index;
          VueUtil.loop(column.colColumns, function(colColumn) {
            colColumn.fixed = 'right';
            colColumn.fixedIndex = index;
          });
        });
        this.$parent.doLayout();
      },
      sortColumn: function(column, descFlg) {
        column.sortable = true;
        if (descFlg) {
          column.order = 'descending';
        } else {
          column.order = 'ascending';
        }
        var sortIndex = this.store.states.sortingColumns.indexOf(column);
        if (sortIndex === -1) {
          this.store.states.sortingColumns.push(column);
        }
        this.doSort();
      },
      removeSortColumn: function(column, flg) {
        if (flg) column.sortable = false;
        var sortIndex = this.sortList.indexOf(column);
        if (sortIndex === -1) return;
        column.order = '';
        this.sortList.splice(sortIndex, 1);
        this.doSort();
      },
      doSort: function() {
        this.store.commit('changeSortCondition');
      },
      filterColumn: function() {
        var self = this;
        var filterColumn = this.filterForm.filterColumn;
        if (!VueUtil.isDef(filterColumn)) return;

        if (!filterColumn.complexFilters) filterColumn.complexFilters = [];
        var complexFilters = filterColumn.complexFilters;

        var found = VueUtil.arrayFind(complexFilters, function(filter) {
          return filter.operations == self.filterForm.operations
              && filter.conditions == self.filterForm.conditions;
        });

        if(!found) {
          complexFilters.push({
            conditions: this.filterForm.conditions,
            operations: this.filterForm.operations
          });
        }
        this.doFilter(filterColumn);
      },
      removeFilterColumn: function(column,filter) {
        var store = this.store;

        if(filter) {
          var index = column.complexFilters.indexOf(filter);
          if (index > -1) {
            column.complexFilters.splice(index , 1);
          }
        } else {
          column.complexFilters = [];
        }


        store.commit('filterChange', {
          column: column,
          values: {complexFilters: column.complexFilters}
        });


        this.$forceUpdate();
      },
      doFilter: function(filterColumn) {

        var store = this.store;
        store.commit('filterChange', {
          column: filterColumn,
          values: {complexFilters: filterColumn.complexFilters}
        });
        this.doSort();
        this.$forceUpdate();
      },
      displayColumn: function(column) {
        column.visible = !column.visible;
        VueUtil.loop(column.colColumns, function(colColumn) {
          colColumn.visible = !colColumn.visible;
        });
        this.$parent.doLayout();
      },
      reorderColumn: function(index, direction) {
        var toIndex = direction === 'up' ? index - 1 : index + 1;
        this.store.commit('reorderColumn', index, toIndex);
      }
    },
    mounted: function() {
      if (this.store) {
        var tableColumns = this.tableColumns;
        VueUtil.loop(this.store.states._columns, function(column) {
          if (column.property !== 'selectionColumn'
            && column.property !== 'indexColumn'
            && column.property !== 'expandColumn') {
            tableColumns.push(column);
          }
        });
        this.pinForm.leftPin = this.store.states.fixedColumns;
        this.pinForm.rightPin = this.store.states.rightFixedColumns;
        this.sortList = this.store.states.sortingColumns;
      }
    }
  };
  var VueTable = {
    template: '<div :class="[\'vue-table\', {\'vue-table--fit\': fit, \'vue-table--striped\': stripe, \'vue-table--border\': border}]" @mouseleave="handleMouseLeave($event)" :style="{width: layout.bodyWidth <= 0 ? \'0px\' : \'\'}"><div class="hidden-columns" ref="hiddenColumns"><slot></slot></div><div class="vue-table__main"><div class="vue-table__header-wrapper" ref="headerWrapper" v-show="showHeader"><table-header ref="tableHeader" :style="{width: layout.bodyWidth ? layout.bodyWidth + \'px\' : \'\'}"></table-header></div><div class="vue-table__body-wrapper" ref="bodyWrapper" tabindex="0" :style="[bodyHeight]"><table-body ref="tableBody" :style="{width: bodyWidth}"></table-body><div :style="{width: bodyWidth}" class="vue-table__empty-block" v-show="!data || data.length === 0"><span class="vue-table__empty-text"><slot name="empty">{{emptyText || emptyLabel}}</slot></span></div></div><div class="vue-table__footer-wrapper" ref="footerWrapper" v-show="showFooter"><table-footer ref="tableFooter" :style="{width: layout.bodyWidth ? layout.bodyWidth + \'px\' : \'\'}"></table-footer></div></div><div class="vue-table__fixed" v-show="leftFixedCount > 0" :style="[{width: layout.fixedWidth ? layout.fixedWidth + \'px\' : \'\'}, fixedHeight]"><div class="vue-table__fixed-header-wrapper" ref="fixedHeaderWrapper" v-show="showHeader"><table-header fixed="left" :style="{width: layout.fixedWidth ? layout.fixedWidth + \'px\' : \'\'}"></table-header></div><div class="vue-table__fixed-body-wrapper" ref="fixedBodyWrapper" :style="[{top: layout.headerHeight + \'px\'}, fixedBodyHeight]"><table-body ref="fixedTableBody" fixed="left" :style="{width: layout.fixedWidth ? layout.fixedWidth + \'px\' : \'\'}"></table-body></div><div class="vue-table__fixed-footer-wrapper" ref="fixedFooterWrapper" v-show="showFooter"><table-footer fixed="left" :style="{width: layout.fixedWidth ? layout.fixedWidth + \'px\' : \'\'}"></table-footer></div></div><div class="vue-table__fixed-right" v-show="rightFixedCount > 0" :style="[{width: layout.rightFixedWidth ? layout.rightFixedWidth + \'px\' : \'\'}, {right: layout.scrollY ? (border ? layout.gutterWidth : (layout.gutterWidth || 1)) + \'px\' : \'\'}, fixedHeight]"><div class="vue-table__fixed-header-wrapper" ref="rightFixedHeaderWrapper" v-show="showHeader"><table-header fixed="right" :style="{width: layout.rightFixedWidth ? layout.rightFixedWidth + \'px\' : \'\'}"></table-header></div><div class="vue-table__fixed-body-wrapper" ref="rightFixedBodyWrapper" :style="[{top: layout.headerHeight + \'px\'}, fixedBodyHeight]"><table-body ref="rightFixedTableBody" fixed="right" :style="{width: layout.rightFixedWidth ? layout.rightFixedWidth + \'px\' : \'\'}"></table-body></div><div class="vue-table__fixed-footer-wrapper" ref="rightFixedFooterWrapper" v-show="showFooter"><table-footer fixed="right" :style="{width: layout.rightFixedWidth ? layout.rightFixedWidth + \'px\' : \'\'}"></table-footer></div></div><div class="vue-table__fixed-right-patch" v-show="rightFixedCount > 0" :style="{width: layout.scrollY ? layout.gutterWidth + \'px\' : \'0\', height: layout.headerHeight + \'px\'}"></div><div class="vue-table__column-resize-proxy" ref="resizeProxy" v-show="resizeProxyVisible"></div><table-context-menu ref="contextMenu" v-if="contextMenu" v-model="showContextMenu""></table-context-menu></div>',
    name: 'VueTable',
    props: {
      data: {
        type: Array,
        default: function() {
          return [];
        }
      },
      lazyload: Boolean,
      height: [String, Number],
      fit: {
        type: Boolean,
        default: true
      },
      stripe: Boolean,
      border: Boolean,
      context: {},
      showHeader: {
        type: Boolean,
        default: true
      },
      showFooter: Boolean,
      contextMenu: Boolean,
      rowClassName: [String, Function],
      rowStyle: [Object, Function],
      highlightCurrentRow: Boolean,
      highlightFirstAfterFilter: Boolean,
      highlightFirstAfterSort: Boolean,
      highlightHoverRow: {
        type: Boolean,
        default: true
      },
      emptyText: String,
      defaultExpandAll: Boolean,
      defaultSort: {
        type: Array,
        default: function() {
          return [];
        }
      },
      tooltipEffect: {
        type: String,
        default: 'light'
      },
      expandClassName: [String, Function]
    },
    components: {
      TableHeader: TableHeader,
      TableBody: TableBody,
      TableFooter: TableFooter,
      TableContextMenu: TableContextMenu
    },
    activated: function() {
      var refs = this.$refs;
      var scrollTop = this.bodyScroll.top;
      refs.bodyWrapper.scrollTop = scrollTop;
      refs.fixedBodyWrapper.scrollTop = scrollTop;
      refs.rightFixedBodyWrapper.scrollTop = scrollTop;
    },
    methods: {
      clearFilters: function() {
        var filterPanels = this.$refs.tableHeader.filterPanels;

        for (var key in filterPanels) {
          filterPanels[key].handleReset();
        }
      },
      clearSorts: function() {
        var self = this;
        self.store.states.sortingColumns = [];
        self.$refs.contextMenu && (self.$refs.contextMenu.sortList = []);
        VueUtil.loop(self.store.states.columns, function(column) {
          column.order = null;
        });
        self.store.commit('changeSortCondition');
      },
      exportCsv: function(params) {
        if (!VueUtil.isObject(params)) params = {};
        if (params.fileName) {
          if (params.fileName.indexOf('.csv') === -1) {
            params.fileName += '.csv';
          }
        } else {
          params.fileName = 'table.csv';
        }
        if (!VueUtil.isDef(params.original)) params.original = true;
        var columns = params.original ? this.store.states._columns : this.store.states.columns;
        columns = VueUtil.filter(columns, function(column) {
          return (column.property !== 'selectionColumn'
            && column.property !== 'indexColumn'
            && column.property !== 'expandColumn');
        });
        var datas = params.original ? this.store.states._data : this.store.states.data;
        var footer = [];
        if (this.showFooter) {
          footer = VueUtil.map(VueUtil.filter(this.store.states.aggregates, function(aggregate) {
            return (aggregate.property !== 'selectionColumn'
              && aggregate.property !== 'indexColumn'
              && aggregate.property !== 'expandColumn');
          }), function(aggregate) {
            return aggregate.label;
          });
        }
        var appendLine = function(content, row, options) {
          var separator = options.separator;
          var line = VueUtil.map(row, function(data) {
            return '"' + VueUtil.toString(data).replace(/"/g, '""') + '"';
          });
          content.push(line.join(separator));
        };
        var tableDataToCsv = function(columns, datas, footer, options) {
          options = VueUtil.merge({}, {separator: ','}, options);
          var columnOrder;
          var content = [];
          var column = [];
          if (columns) {
            columnOrder = VueUtil.map(columns, function(v) {
              if (VueUtil.isString(v)) return v;
              column.push(VueUtil.isDef(v.printLabel) ? v.printLabel : VueUtil.isDef(v.label) ? v.label : v.property);
              return v.property;
            });
            if (column.length > 0) appendLine(content, column, options);
          } else {
            columnOrder = [];
            VueUtil.loop(datas, function(v) {
              if (!VueUtil.isArray(v)) {
                VueUtil.mergeArray(columnOrder, Object.keys(v));
              }
            });
            if (columnOrder.length > 0) {
              columnOrder = VueUtil.filter(columnOrder, function(value, index, self) {return self.indexOf(value) === index;});
              appendLine(content, columnOrder, options);
            }
          }
          VueUtil.loop(datas, function(row) {
            if (!VueUtil.isArray(row)) {
              row = VueUtil.map(columnOrder, function(k) {return VueUtil.isDef(row[k]) ? row[k] : '';});
            }
            appendLine(content, row, options);
          });
          if (VueUtil.isArray(footer)) {
            appendLine(content, footer, options);
          }
          return content.join('\r\n');
        };
        var data = tableDataToCsv(columns, datas, footer, params);
        var getDownloadUrl = function(text) {
          var BOM = '\uFEFF';
          if (Blob && URL && URL.createObjectURL) {
            var csvData = new Blob([BOM + text], {type: 'text/csv'});
            return URL.createObjectURL(csvData);
          } else {
            return 'data:attachment/csv;charset=utf-8,' + BOM + encodeURIComponent(text);
          }
        };
        var exportFile = function(fileName, text) {
          if (navigator.msSaveBlob) {
            var BOM = '\uFEFF';
            var csvData = new Blob([BOM + text], {type: 'text/csv'});
            navigator.msSaveBlob(csvData, fileName);
          } else {
            try {
              var link = document.createElement('a');
              link.download = fileName;
              link.href = getDownloadUrl(text);
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            } catch (e) {
              Vue.notify.warning({message: Vue.t('vue.screenfull.canot')});
              throw e;
            }
          }
        };
        exportFile(params.fileName, data);
      },
      columnFilter: function(columnProp, value) {
        var filterColumn = null;
        if (VueUtil.isString(columnProp)) {
          VueUtil.loop(this.store.states._columns, function(column){
            if (VueUtil.isDef(filterColumn)) return;
            if (column.property === columnProp) filterColumn = column;
          });
        } else {
          filterColumn = columnProp;
        }
        this.store.commit('filterChange', {
          column: filterColumn,
          values: value
        });
      },
      multipleColumnSort: function(sortList) {
        this.store.states.sortingColumns = sortList || [];
        this.store.commit('changeSortCondition');
      },
      toggleContextMenu: function() {
        if (this.contextMenu) this.showContextMenu = !this.showContextMenu;
      },
      getUserSetting: function(field) {
        var userSetting = {
          columns: [],
          columnsOrder: []
        };

        if (this.store) {
          VueUtil.loop(this.store.states._columns, function(column) {
            userSetting.columnsOrder.push(column.columnId);
              var setting = {
                id: column.columnId,
                property: column.property,
              };

              if (!field || field.indexOf('order') > -1) {
                setting.order = column.order;
              }
              if (!field || field.indexOf('fixed') > -1) {
                setting.fixed = column.fixed;
              }
              if (!field || field.indexOf('visible') > -1) {
                setting.visible = column.visible;
              }
              if (!field || field.indexOf('filter') > -1) {
                setting.filter = {complexFilters: column.complexFilters, simpleFilters: column.filteredValue};
              }
              userSetting.columns.push(setting);
          });
          // this.pinForm.leftPin = this.store.states.fixedColumns;
          // this.pinForm.rightPin = this.store.states.rightFixedColumns;
          // this.sortList = this.store.states.sortingColumns;
        }

        return userSetting;
      },
      setUserSetting: function(userSetting) {
        if(!userSetting) {
          return;
        }
        var self = this;
        if(userSetting.columnsOrder) {
          userSetting.columnsOrder.forEach(function(orderId, toIndex) {

            var index = VueUtil.arrayFindIndex(self.store.states._columns, function(column) {
              return column.columnId == orderId;
            });

            self.store.commit('reorderColumn', index, toIndex);
          });
        }

        if(!userSetting.columns) {
          return;
        }
        var columns = this.store.states._columns;

        self.clearSorts();
        self.$refs.contextMenu.pinForm = {
          leftPin: [],
          rightPin: []
        };

        userSetting.columns.forEach(function(setting) {
          var column = VueUtil.arrayFind(columns, function(column) {
            return (column.columnId == setting.id && column.property == setting.property);
          });
          column.fixed = false;
          column.visible = true;

          self.store.commit('filterChange', {
            column: column,
            values: {},
            silent: true
          });

          if (setting.fixed == 'left') {
            self.$refs.contextMenu.pinForm.leftPin.push(column);
          }

          if (setting.fixed == 'right') {
            self.$refs.contextMenu.pinForm.rightPin.push(column);
          }

          if (setting.order) {
            self.$refs.contextMenu.sortColumn(column, setting.order == 'descending');
          }

          if ((setting.filter.complexFilters && setting.filter.complexFilters.length > 0) 
          || (setting.filter.simpleFilters && setting.filter.simpleFilters.length > 0)) {
            column.complexFilters = setting.filter.complexFilters || [];
            column.filteredValue = setting.filter.simpleFilters || [];
            self.store.commit('filterChange', {
              column: column,
              values: setting.filter,
            });
            
          }

          if (setting.visible === false) {
            self.$refs.contextMenu.displayColumn(column);
          }
        });

        self.$refs.contextMenu.filterForm = {
          filterColumn: null,
          conditions: null,
          operations: '='
        };
        self.doLayout();
      },
      setCurrentRow: function(row, scrollTo) {
        this.store.commit('setCurrentRow', row);
        if (scrollTo) {
          var rowEl = this.$refs.tableBody.$refs['trow'+row.$index];
          var bodyHeight = this.$refs.bodyWrapper.offsetHeight;
          var oldScrollTop = this.$refs.bodyWrapper.scrollTop;
          var maxScrollTop = rowEl.offsetTop + this.$refs.tableBody.delta.marginTop;
          var minScrollTop = maxScrollTop - (bodyHeight - rowEl.offsetHeight);
          
          if(oldScrollTop > maxScrollTop) this.$refs.bodyWrapper.scrollTop = maxScrollTop;
          if(oldScrollTop < minScrollTop) this.$refs.bodyWrapper.scrollTop = minScrollTop;
        }
      },
      getCurrentRow: function() {
        return this.store.states.currentRow;
      },
      getSelection: function() {
        return this.store.states.selection;
      },
      toggleRowSelection: function(row, selected) {
        if (this.store.toggleRowSelection(row, selected)) {
          this.$emit('selection-change', this.store.states.selection);
        }
        this.store.updateAllSelected();
      },
      clearSelection: function() {
        this.store.clearSelection();
      },
      handleMouseLeave: function() {
        this.store.commit('setHoverRow', null);
        if (this.hoverState) this.hoverState = null;
      },
      updateScrollY: function() {
        this.layout.updateScrollY();
        var refs = this.$refs;
        refs.fixedBodyWrapper && (refs.fixedBodyWrapper.scrollTop = this.bodyScroll.top);
        refs.rightFixedBodyWrapper && (refs.rightFixedBodyWrapper.scrollTop = this.bodyScroll.top);
      },
      isCellHidden: function(index, fixed) {
        if (fixed === 'left') {
          return index >= this.leftFixedCount;
        }
        if (fixed === 'right') {
          return index < this.store.states.columns.length - this.rightFixedCount;
        }
        return (index < this.leftFixedCount) || (index >= this.store.states.columns.length - this.rightFixedCount);
      },
      bodyScrollFn: function(event) {
        var refs = this.$refs;
        var scrollLeft = refs.bodyWrapper.scrollLeft;
        var scrollTop = refs.bodyWrapper.scrollTop;
        if (this.bodyScroll.left !== scrollLeft) {
          this.bodyScroll.left = scrollLeft;
          refs.headerWrapper.scrollLeft = scrollLeft;
          refs.footerWrapper.scrollLeft = scrollLeft;
          if (scrollLeft === 0) {
            this.$emit('scroll-left');
          }
          if (scrollLeft === refs.bodyWrapper.scrollWidth - refs.bodyWrapper.clientWidth) {
            this.$emit('scroll-right');
          }
        }
        if (this.bodyScroll.top !== scrollTop) {
          refs.tableBody.updateZone(scrollTop);
          this.bodyScroll.top = scrollTop;
          refs.fixedBodyWrapper.scrollTop = scrollTop;
          refs.rightFixedBodyWrapper.scrollTop = scrollTop;
          if (scrollTop === 0) {
            this.$emit('scroll-top');
          }
          if (scrollTop === refs.bodyWrapper.scrollHeight - refs.bodyWrapper.clientHeight) {
            this.$emit('scroll-bottom');
          }
        }
      },
      scrollYMouseWheel: function(event) {
        var refs = this.$refs;
        if (this.layout.scrollY) {
          event.preventDefault();
          var wheelDelta = event.wheelDelta || -event.detail;
          var scrollTop = this.bodyScroll.top;
          var wheel = 40;
          if (VueUtil.isElement(refs.tableBody.$refs.tbody)) wheel = refs.tableBody.$refs.tbody.firstElementChild.offsetHeight;
          wheel = wheel * 3;
          if (wheelDelta < 0) {
            scrollTop += wheel;
          } else {
            scrollTop -= wheel;
          }
          var scrollBottom = refs.bodyWrapper.scrollHeight - refs.bodyWrapper.clientHeight;
          scrollTop < 0 ? scrollTop = 0 : null;
          scrollTop > scrollBottom ? scrollTop = scrollBottom : null;
          refs.bodyWrapper.scrollTop = scrollTop;
          refs.fixedBodyWrapper.scrollTop = scrollTop;
          refs.rightFixedBodyWrapper.scrollTop = scrollTop;
        }
      },
      scrollXMouseWheel: function(event) {
        var refs = this.$refs;
        if (this.layout.scrollX) {
          event.preventDefault();
          var wheelDelta = event.wheelDelta || -event.detail;
          var scrollLeft = this.bodyScroll.left;
          if (wheelDelta < 0) {
            scrollLeft += 80;
          } else {
            scrollLeft -= 80;
          }
          var scrollRight = refs.bodyWrapper.scrollWidth - refs.bodyWrapper.clientWidth;
          scrollLeft < 0 ? scrollLeft = 0 : null;
          scrollLeft > scrollRight ? scrollLeft = scrollRight : null;
          refs.bodyWrapper.scrollLeft = scrollLeft;
          refs.headerWrapper.scrollLeft = scrollLeft;
          refs.footerWrapper.scrollLeft = scrollLeft;
        }
      },
      bodyKeydownFn: function(e) {
        if (e.keyCode == 38 || e.keyCode == 40) {
          e.preventDefault();
          var index = this.store.states.data.indexOf(this.store.states.currentRow);
          if(e.keyCode == 38) index--;
          if(e.keyCode == 40) index++;
          var focusToRow = this.store.states.data[index];
          if (focusToRow) {
            this.setCurrentRow(focusToRow, true);
          }
        }
      },
      bindEvents: function() {
        var refs = this.$refs;
        var mouseWheel = VueUtil.isFirefox ? 'DOMMouseScroll' : 'mousewheel';
        VueUtil.on(refs.bodyWrapper, 'keydown', this.bodyKeydownFn);
        VueUtil.on(refs.bodyWrapper, 'scroll', this.bodyScrollFn);
        VueUtil.on(refs.bodyWrapper, mouseWheel, this.scrollYMouseWheel);
        VueUtil.on(refs.fixedBodyWrapper, mouseWheel, this.scrollYMouseWheel);
        VueUtil.on(refs.rightFixedBodyWrapper, mouseWheel, this.scrollYMouseWheel);
        VueUtil.on(refs.headerWrapper, mouseWheel, this.scrollXMouseWheel);
        VueUtil.on(refs.fixedHeaderWrapper, mouseWheel, this.scrollXMouseWheel);
        VueUtil.on(refs.rightFixedHeaderWrapper, mouseWheel, this.scrollXMouseWheel);
        VueUtil.on(refs.footerWrapper, mouseWheel, this.scrollXMouseWheel);
        VueUtil.on(refs.fixedFooterWrapper, mouseWheel, this.scrollXMouseWheel);
        VueUtil.on(refs.rightFixedFooterWrapper, mouseWheel, this.scrollXMouseWheel);
        if (this.fit) {
          VueUtil.addResizeListener(this.$el, this.doLayout);
        }
      },
      unBindEvents: function() {
        var refs = this.$refs;
        var mouseWheel = VueUtil.isFirefox ? 'DOMMouseScroll' : 'mousewheel';
        VueUtil.off(refs.bodyWrapper, 'scroll', this.bodyScrollFn);
        VueUtil.off(refs.bodyWrapper, mouseWheel, this.scrollYMouseWheel);
        VueUtil.off(refs.fixedBodyWrapper, mouseWheel, this.scrollYMouseWheel);
        VueUtil.off(refs.rightFixedBodyWrapper, mouseWheel, this.scrollYMouseWheel);
        VueUtil.off(refs.headerWrapper, mouseWheel, this.scrollXMouseWheel);
        VueUtil.off(refs.fixedHeaderWrapper, mouseWheel, this.scrollXMouseWheel);
        VueUtil.off(refs.rightFixedHeaderWrapper, mouseWheel, this.scrollXMouseWheel);
        VueUtil.off(refs.footerWrapper, mouseWheel, this.scrollXMouseWheel);
        VueUtil.off(refs.fixedFooterWrapper, mouseWheel, this.scrollXMouseWheel);
        VueUtil.off(refs.rightFixedFooterWrapper, mouseWheel, this.scrollXMouseWheel);
        if (this.fit) {
          VueUtil.removeResizeListener(this.$el, this.doLayout);
        }
      },
      resizeZone: function() {
        var refs = this.$refs;
        refs.tableBody && refs.tableBody.updateZone(this.bodyScroll.top);
        if (this.showFooter) {
          this.store.getAggregate(this.store.states.columns, this.store.states.data);
          refs.tableFooter.aggregates = this.store.states.aggregates;
        }
      },
      doLayout: function() {
        var self = this;
        self.store.updateColumns();
        self.$nextTick(function() {
          self.layout.update();
          self.layout.updateHeight();
          self.updateScrollY();
          self.resizeZone();
        });
      }
    },
    created: function() {
      this.tableId = 'vue-table_';
      this.columnId = 1;
    },
    computed: {
      emptyLabel: function() {
        return this.$t('vue.table.emptyText');
      },
      leftFixedCount: function() {
        return this.store.states.fixedColumns.length;
      },
      rightFixedCount: function() {
        return this.store.states.rightFixedColumns.length;
      },
      bodyHeight: function() {
        var style = {};
        style = {
          height: this.layout.bodyHeight ? this.layout.bodyHeight + 'px' : ''
        };
        return style;
      },
      bodyWidth: function() {
        var layout = this.layout;
        return layout.bodyWidth ? layout.bodyWidth - (layout.scrollY ? layout.gutterWidth : 0) + 'px' : '';
      },
      fixedBodyHeight: function() {
        var style = {};
        var layout = this.layout;
        if (this.height) {
          style = {
            height: layout.fixedBodyHeight ? layout.fixedBodyHeight + 'px' : ''
          };
        }
        return style;
      },
      fixedHeight: function() {
        var style = {};
        var layout = this.layout;
        style = {
          height: layout.viewportHeight ? layout.viewportHeight + 'px' : ''
        };
        return style;
      }
    },
    watch: {
      height: function(val) {
        this.layout.setHeight(val);
      },
      data: {
        immediate: true,
        handler: function(val) {
          var store = this.store;
          store.commit('setData', val);
          VueUtil.loop(store.states.columns, function(column) {
            if ((column.filteredValue && column.filteredValue.length) 
            || column.complexFilters && column.complexFilters.length) {
              store.commit('filterChange', {
                column: column,
                values: {complexFilters: column.complexFilters, simpleFilters: column.filteredValue},
                silent: true
              });
            }
          });

          if (store.states.sortingColumns.length > 0) {
            this.$nextTick(function() {
              store.commit('changeSortCondition');
            });
          }
        }
      },
      showHeader: function() {
        this.doLayout();
      },
      showFooter: function() {
        this.doLayout();
      },
      lazyload: function(val) {
        if (this.height) {
          var delta = this.$refs.tableBody.delta;
          if (val) {
            delta.keeps = this.height * 1;
          } else {
            delta.keeps = 0;
          }
          this.doLayout();
        }
      }
    },
    beforeDestroy: function() {
      this.unBindEvents();
    },
    mounted: function() {
      this.layout.setHeight(this.height);
      this.bindEvents();
      this.doLayout();

      //tablecontextmenutable Bug #1263
      if (this.contextMenu) {
        this.$el.parentNode.appendChild(this.$refs.contextMenu.$el);
      }
    },
    data: function() {
      var store = new TableStore(this, {defaultExpandAll: self.defaultExpandAll});
      var layout = new TableLayout({
        store: store,
        table: this,
        fit: this.fit,
        showHeader: self.showHeader
      });
      return {
        store: store,
        layout: layout,
        renderExpanded: null,
        resizeProxyVisible: false,
        showContextMenu: false,
        bodyScroll: {left: 0, top: 0}
      };
    }
  };
  Vue.component(VueTable.name, VueTable);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueOption = definition(context.Vue, context.VueUtil);
    delete context.VueOption;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueOption = {
    template: '<li @mouseenter="hoverItem" @click.stop="selectOptionClick" v-show="visible" :class="[\'vue-select-dropdown__item\', {\'selected\': itemSelected, \'is-disabled\': disabled || groupDisabled || limitReached, \'hover\': itemHover}]"><slot><span>{{currentLabel}}</span></slot></li>',
    name: 'VueOption',
    mixins: [VueUtil.component.emitter],
    props: {
      value: {
        required: true
      },
      label: [String, Number],
      selected: Boolean,
      created: Boolean,
      disabled: Boolean
    },
    data: function() {
      return {
        index: -1,
        groupDisabled: false,
        visible: true,
        hitState: false
      };
    },
    computed: {
      currentLabel: function() {
        return this.label || ((VueUtil.isString(this.value) || VueUtil.isNumber(this.value)) ? this.value : '');
      },
      currentValue: function() {
        return this.value || this.label || '';
      },
      parent: function() {
        var result = this.$parent;
        while (!result.isSelect) {
          result = result.$parent;
        }
        return result;
      },
      itemSelected: function() {
        if (!this.parent.multiple) {
          return this.value === this.parent.value;
        } else {
          return this.parent.value.indexOf(this.value) !== -1;
        }
      },
      itemHover: function() {
        return this.parent.hoverIndex === this.parent.options.indexOf(this);
      },
      limitReached: function() {
        if (this.parent.multiple) {
          return !this.itemSelected && this.parent.value.length >= this.parent.multipleLimit && this.parent.multipleLimit > 0;
        } else {
          return false;
        }
      }
    },
    watch: {
      currentLabel: function() {
        if (!this.created && !this.parent.remote)
          this.dispatch('VueSelect', 'setSelected');
      },
      value: function() {
        if (!this.created && !this.parent.remote)
          this.dispatch('VueSelect', 'setSelected');
      }
    },
    methods: {
      handleGroupDisabled: function(val) {
        this.groupDisabled = val;
      },
      hoverItem: function() {
        if (!this.disabled && !this.groupDisabled) {
          this.parent.hoverIndex = this.parent.options.indexOf(this);
        }
      },
      selectOptionClick: function() {
        if (this.disabled !== true && this.groupDisabled !== true) {
          this.dispatch('VueSelect', 'handleOptionClick', this);
        }
      },
      queryChange: function(query) {
        var parsedQuery = String(query).replace(/(\^|\(|\)|\[|\]|\$|\*|\+|\.|\?|\\|\{|\}|\|)/g, '\\$1');
        this.visible = new RegExp(parsedQuery, 'i').test(this.currentLabel) || this.created;
        if (!this.visible) {
          this.parent.filteredOptionsCount--;
        }
      },
      resetIndex: function() {
        var self = this;
        self.$nextTick(function() {
          self.index = self.parent.options.indexOf(self);
        });
      }
    },
    created: function() {
      this.parent.options.push(this);
      this.parent.cachedOptions.push(this);
      this.parent.optionsCount++;
      this.parent.filteredOptionsCount++;
      this.index = this.parent.options.indexOf(this);
      this.$on('queryChange', this.queryChange);
      this.$on('handleGroupDisabled', this.handleGroupDisabled);
      this.$on('resetIndex', this.resetIndex);
    },
    beforeDestroy: function() {
      this.dispatch('VueSelect', 'onOptionDestroy', this);
    }
  };
  Vue.component(VueOption.name, VueOption);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueOptionGroup = definition(context.Vue, context.VueUtil);
    delete context.VueOptionGroup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueOptionGroup = {
    template: '<ul class="vue-select-group__wrap"><li class="vue-select-group__title" v-show="visible">{{label}}</li><li><ul class="vue-select-group"><slot></slot></ul></li></ul>',
    name: 'VueOptionGroup',
    mixins: [VueUtil.component.emitter],
    props: {
      label: String,
      disabled: Boolean
    },
    data: function() {
      return {
        visible: true
      };
    },
    watch: {
      disabled: function(val) {
        this.broadcast('VueOption', 'handleGroupDisabled', val);
      }
    },
    methods: {
      queryChange: function() {
        this.visible = this.$children && VueUtil.isArray(this.$children) && this.$children.some(function(option) {
          return option.visible === true;
        });
      }
    },
    created: function() {
      this.$on('queryChange', this.queryChange);
    },
    mounted: function() {
      if (this.disabled) {
        this.broadcast('VueOption', 'handleGroupDisabled', this.disabled);
      }
    }
  };
  Vue.component(VueOptionGroup.name, VueOptionGroup);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopper'], definition);
  } else {
    context.VueSelectDropdown = definition(context.Vue, context.VuePopper);
    delete context.VueSelectDropdown;
  }
})(this, function(Vue, VuePopper) {
  'use strict';
  var VueSelectDropdown = {
    template: '<div :class="[\'vue-select-dropdown\', {\'is-multiple\': $parent.multiple}, popperClass]"><slot></slot></div>',
    name: 'VueSelectDropdown',
    mixins: [VuePopper],
    props: {
      placement: {
        type: String,
        default: 'bottom-start',
      },
      autoWidth: {
        type: Boolean,
        default: true
      }
    },
    computed: {
      popperClass: function() {
        return this.$parent.popperClass;
      }
    },
    mounted: function() {
      this.referenceElm = this.$parent.$refs.reference.$el;
      this.$parent.popperElm = this.popperElm = this.$el;
      this.$on('updatePopper', this.updatePopper);
      this.$on('destroyPopper', this.destroyPopper);
    }
  };
  Vue.component(VueSelectDropdown.name, VueSelectDropdown);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueSelect = definition(context.Vue, context.VueUtil);
    delete context.VueSelect;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var getValueByPath = function(object, prop) {
    prop = prop || '';
    var paths = prop.split('.');
    var current = object;
    var result = null;
    VueUtil.loop(paths, function(path, i) {
      if (!current) return false;
      if (i === paths.length - 1) {
        result = current[path];
        return false;
      }
      current = current[path];
    });
    return result;
  };
  var VueSelect = {
    template: 
    '<div class="vue-select" v-clickoutside="handleClose"> \
      <div :class="[\'vue-select__tags\', {\'no-reset-height\': !autoHeight}]" v-if="multiple" @click.stop="toggleMenu" \
        ref="tags" :style="{\'max-width\': inputWidth - 32 + \'px\'}"> \
        <transition-group @after-leave="resetInputHeight"> \
          <vue-tag v-for="(item, index) in selected" :key="getValueKey(item)" :closable="!disabled" hit :type="disabled ? \'\' : \'info\'" \
            @close="deleteTag($event, item)"><span class="vue-select__tags-text">{{item.currentLabel}}</span></vue-tag> \
        </transition-group><input type="text" :class="[\'vue-select__input\', {\'is-mini\': size===\'mini\'}]" @focus="visible = true" \
          :disabled="disabled" @keyup="managePlaceholder" @keydown="resetInputState" @keydown.down.prevent="navigateOptions(\'next\')" \
          @keydown.up.prevent="navigateOptions(\'prev\')" @keydown.enter.prevent="selectOption" @keydown.esc.prevent="visible = false" \
          @keydown.delete="deletePrevTag" v-model="query" v-if="filterable" :style="{width: inputLength + \'px\', \'max-width\': inputWidth - 42 + \'px\'}" \
          ref="input"></div> \
      <vue-input ref="reference" v-model="selectedLabel" type="text" :text-align="textAlign" \
        :placeholder="placeholderLang" :autofocus="autofocus" :tabindex="tabindex" :name="name" :size="size" \
        :disabled="disabled" :readonly="!filterable || multiple" :validate-event="false" @click="handleIconClick" \
        @mousedown.native="handleMouseDown" @keyup.native="debouncedOnInputChange" @input="keepMenu" @keydown.native.down.prevent="navigateOptions(\'next\')" \
        @keydown.native.up.prevent="navigateOptions(\'prev\')" @keydown.native.enter.prevent="selectOption" \
        @keydown.native.esc.prevent="visible = false" @keydown.native.tab="visible = false" @paste.native="debouncedOnInputChange" \
        @mouseenter.native="inputHovering = true" @mouseleave.native="inputHovering = false" :icon="iconClass"></vue-input> \
      <transition @after-leave="destroyPopper" @after-enter="handleMenuEnter"> \
        <vue-select-dropdown ref="popper" v-show="visible && emptyText !== false"> \
          <ul :class="[\'vue-select-dropdown__list\', {\'is-empty\': !allowCreate && filteredOptionsCount === 0}]" \
            v-show="options.length > 0 && !loading"> \
            <vue-option :value="query" created v-if="showNewOption"></vue-option> \
            <slot></slot> \
          </ul> \
          <p class="vue-select-dropdown__empty" v-if="emptyText && !allowCreate">{{emptyText}}</p> \
        </vue-select-dropdown> \
      </transition> \
    </div>',
    mixins: [VueUtil.component.emitter],
    name: 'VueSelect',
    computed: {
      iconClass: function() {
        var criteria; 
        if (this.multiple) {
          if (this.visible) {
            criteria = this.clearable && !this.disabled && this.inputHovering;
            return criteria && !this.multipleLimit ? 'vue-icon-success is-show-check' : (this.remote && this.filterable ? '' : 'vue-icon-arrow-up is-reverse');
          } else {
            criteria = this.clearable && !this.disabled && this.inputHovering && VueUtil.isDef(this.value) && this.value.length > 0;
            return criteria ? 'vue-icon-error is-show-close' : (this.remote && this.filterable ? '' : 'vue-icon-arrow-up');
          }
        } else {
          criteria = this.clearable && !this.disabled && this.inputHovering && VueUtil.isDef(this.value) && this.value !== '';
          return criteria ? 'vue-icon-error is-show-close' : (this.remote && this.filterable ? '' : 'vue-icon-arrow-up');
        }
      },
      emptyText: function() {
        if (this.loading) {
          return this.loadingText || this.$t('vue.select.loading');
        } else {
          if (this.remote && this.query === '' && this.options.length === 0)
            return false;
          if (this.filterable && this.options.length > 0 && this.filteredOptionsCount === 0) {
            return this.noMatchText || this.$t('vue.select.noMatch');
          }
          if (this.options.length === 0) {
            return this.noDataText || this.$t('vue.select.noData');
          }
        }
        return null;
      },
      showNewOption: function() {
        var self = this;
        var hasExistingOption = VueUtil.filter(self.options, function(option) {
          return !option.created;
        }).some(function(option) {
          return option.currentLabel === self.query;
        });
        return self.filterable && self.allowCreate && self.query !== '' && !hasExistingOption;
      },
      placeholderLang: function() {
        if (this.multiple) {
          if (VueUtil.isArray(this.value) && this.value.length > 0) {
            return '';
          } else {
            if (!this.currentPlaceholder) {
              return this.$t('vue.select.placeholder');
            }
            return this.currentPlaceholder;
          }
        }
        if (!this.placeholder)
          return this.$t('vue.select.placeholder');
        return this.placeholder;
      }
    },
    directives: {
      Clickoutside: VueUtil.component.clickoutside()
    },
    props: {
      name: String,
      value: {required: true},
      size: String,
      disabled: Boolean,
      clearable: Boolean,
      filterable: Boolean,
      allowCreate: Boolean,
      loading: Boolean,
      popperClass: String,
      remote: Boolean,
      loadingText: String,
      noMatchText: String,
      noDataText: String,
      autofocus: Boolean,
      textAlign: String,
      tabindex: Number,
      remoteMethod: Function,
      filterMethod: Function,
      multiple: Boolean,
      multipleLimit: {
        type: Number,
        default: 0
      },
      placeholder: String,
      autoHeight: {
        type: Boolean,
        default: true
      },
      valueKey: {
        type: String,
        default: 'value'
      },
    },
    data: function() {
      return {
        options: [],
        cachedOptions: [],
        createdLabel: null,
        createdSelected: false,
        selected: this.multiple ? [] : {},
        isSelect: true,
        inputLength: 20,
        inputWidth: 0,
        cachedPlaceHolder: '',
        optionsCount: 0,
        filteredOptionsCount: 0,
        dropdownUl: null,
        visible: false,
        selectedLabel: '',
        hoverIndex: -1,
        query: '',
        bottomOverflowBeforeHidden: 0,
        topOverflowBeforeHidden: 0,
        optionsAllDisabled: false,
        inputHovering: false,
        currentPlaceholder: ''
      };
    },
    watch: {
      multiple: function(val) {
        var self = this;
        if (self.$refs.reference) {
          self.$refs.reference.setCurrentValue('');
        }
        if (val) {
          self.selected = [];
          self.$nextTick(function() {
            self.$emit('input', []);
          });
        } else {
          self.selected = {};
          self.$nextTick(function() {
            self.$emit('input', '');
          });
        }
      },
      value: function(val) {
        if (this.multiple) {
          this.resetInputHeight();
          if (val.length > 0 || (this.$refs.input && this.query !== '')) {
            this.currentPlaceholder = '';
          } else {
            this.currentPlaceholder = this.cachedPlaceHolder;
          }
        }
        this.setSelected();
        if (this.filterable && !this.multiple) {
          this.inputLength = 20;
        }
        this.$emit('change', val);
        this.dispatch('VueFormItem', 'vue.form.change', val);
      },
      query: function(val) {
        var self = this;
        self.$nextTick(function() {
          self.broadcast('VueSelectDropdown', 'updatePopper');
        });
        self.hoverIndex = -1;
        if (self.multiple && self.filterable) {
          self.resetInputHeight();
        }
        if (self.remote && VueUtil.isFunction(self.remoteMethod)) {
          self.hoverIndex = -1;
          self.remoteMethod(val);
          self.broadcast('VueOption', 'resetIndex');
        } else if (VueUtil.isFunction(self.filterMethod)) {
          self.filterMethod(val);
          self.broadcast('VueOptionGroup', 'queryChange');
        } else {
          self.filteredOptionsCount = self.optionsCount;
          self.broadcast('VueOption', 'queryChange', val);
          self.broadcast('VueOptionGroup', 'queryChange');
        }
      },
      visible: function(val) {
        var self = this;
        if (!val) {
          self.$refs.reference.$refs.input.blur();
          self.handleIconHide();
          self.broadcast('VueSelectDropdown', 'destroyPopper');
          if (self.$refs.input) {
            self.$refs.input.blur();
          }
          self.query = '';
          self.selectedLabel = '';
          self.inputLength = 20;
          self.resetHoverIndex();
          self.$nextTick(function() {
            if (self.$refs.input && self.$refs.input.value === '' && self.selected.length === 0) {
              self.currentPlaceholder = self.cachedPlaceHolder;
            }
          });
          if (!self.multiple) {
            self.getOverflows();
            if (self.selected) {
              if (self.filterable && self.allowCreate && self.createdSelected && self.createdOption) {
                self.selectedLabel = self.createdLabel;
              } else {
                self.selectedLabel = self.selected.currentLabel;
              }
              if (self.filterable)
                self.query = self.selectedLabel;
            }
          }
        } else {
          self.handleIconShow();
          self.broadcast('VueSelectDropdown', 'updatePopper');
          if (self.filterable) {
            self.query = self.selectedLabel;
            if (self.multiple) {
              self.$refs.input.focus();
            } else {
              if (!self.remote) {
                self.broadcast('VueOption', 'queryChange', '');
                self.broadcast('VueOptionGroup', 'queryChange');
              }
              //self.broadcast('VueInput', 'inputSelect');
            }
          }
        }
        self.$emit('visible-change', val);
      },
      options: function(val) {
        var self = this;
        self.optionsAllDisabled = val.length === VueUtil.filter(val, function(item) {
          return item.disabled === true;
        }).length;
        if (self.multiple) {
          self.resetInputHeight();
        }
        var inputs = self.$el.querySelectorAll('input');
        if ([].indexOf.call(inputs, document.activeElement) === -1) {
          self.setSelected();
        }
      }
    },
    methods: {
      focus: function() {
        this.$refs.reference && this.$nextTick(this.$refs.reference.focus);
      },
      handleIconHide: function() {
        var icon = this.$refs.reference.$refs.icon;
        if (icon) {
          VueUtil.removeClass(icon, 'is-reverse');
        }
      },
      handleIconShow: function() {
        var icon = this.$refs.reference.$refs.icon;
        if (icon && !VueUtil.hasClass(icon, 'vue-icon-error')) {
          VueUtil.addClass(icon, 'is-reverse');
        }
      },
      handleMenuEnter: function() {
        if (!this.dropdownUl) {
          this.dropdownUl = this.$refs.popper.$el;
          this.getOverflows();
        }
      },
      getOverflows: function() {
        if (this.dropdownUl && this.selected && this.selected.$el) {
          var selectedRect = this.selected.$el.getBoundingClientRect();
          var popperRect = this.$refs.popper.$el.getBoundingClientRect();
          this.bottomOverflowBeforeHidden = selectedRect.bottom - popperRect.bottom;
          this.topOverflowBeforeHidden = selectedRect.top - popperRect.top;
        }
      },
      getOption: function(value) {
        var option = VueUtil.filter(this.cachedOptions, function(option) {
          return option.value === value;
        })[0];
        if (option)
          return option;
        var label = VueUtil.isString(value) || VueUtil.isNumber(value) ? value : '';
        var newOption = {
          value: value,
          currentLabel: label
        };
        return newOption;
      },
      setSelected: function() {
        var self = this;
        if (!self.multiple) {
          var option = self.getOption(self.value);
          if (option.created) {
            self.createdLabel = option.currentLabel;
            self.createdSelected = true;
          } else {
            self.createdSelected = false;
          }
          self.selectedLabel = option.currentLabel;
          self.selected = option;
          if (self.filterable)
            self.query = self.selectedLabel;
          return;
        }
        var result = [];
        VueUtil.loop(self.value, function(value) {
          result.push(self.getOption(value));
        });
        self.selected = result;
        self.$nextTick(function() {
          self.resetInputHeight();
        });
      },
      handleIconClick: function(event) {
        if (this.iconClass.indexOf('vue-icon-error') !== -1) {
          this.deleteSelected(event);
        } else if (this.iconClass.indexOf('vue-icon-success') !== -1) {
          var value = [];
          VueUtil.loop(this.options, function(option) {
            if (!option.disabled) {
              value.push(option.value);
            }
          });
          this.$emit('input', value);
        } else {
          this.toggleMenu();
        }
      },
      handleMouseDown: function(event) {
        if (event.target.tagName !== 'INPUT')
          return;
        if (this.visible) {
          this.handleClose();
          this.focus();
          event.preventDefault();
        } else {
          this.toggleMenu();
        }
      },
      destroyPopper: function() {
        this.$refs.popper.destroyPopper();
      },
      handleClose: function() {
        this.visible = false;
      },
      deletePrevTag: function(e) {
        if (e.target.value.length <= 0) {
          var value = VueUtil.mergeArray([], this.value);
          value.pop();
          this.$emit('input', value);
        }
      },
      managePlaceholder: function() {
        if (this.currentPlaceholder !== '') {
          this.currentPlaceholder = this.$refs.input.value ? '' : this.cachedPlaceHolder;
        }
      },
      resetInputState: function(e) {
        if (e.keyCode !== 8) {
          this.inputLength = this.$refs.input.value.length * 15 + 20;
          this.resetInputHeight();
        }
      },
      resetInputHeight: function() {
        var self = this;
        if (!this.autoHeight) return;
        self.$nextTick(function() {
          var sizeMap = {'large': 42, 'small': 30, 'mini': 22};
          var input = self.$refs.reference.$refs.input;
          var icon = self.$refs.reference.$refs.icon;
          var size = sizeMap[self.size] || 36;
          var newHeight = (parseInt(self.$refs.tags.children[0].offsetHeight / size, 10) + 1) * size + 'px';
          input.style.height = newHeight;
          icon.style.lineHeight = newHeight;
          if (self.visible && self.emptyText !== false) {
            self.broadcast('VueSelectDropdown', 'updatePopper');
          }
        });
      },
      resetHoverIndex: function() {
        var self = this;
        self.$nextTick(function() {
          if (!self.multiple) {
            self.hoverIndex = self.options.indexOf(self.selected);
          } else {
            if (self.selected.length > 0) {
              self.hoverIndex = Math.min.apply(null, VueUtil.map(self.selected, function(item) {
                return self.options.indexOf(item);
              }));
            } else {
              self.hoverIndex = -1;
            }
          }
        });
      },
      handleOptionSelect: function(option) {
        if (this.multiple) {
          var value = VueUtil.mergeArray([], this.value);
          var optionIndex = value.indexOf(option.value);
          if (optionIndex !== -1) {
            value.splice(optionIndex, 1);
          } else if (this.multipleLimit <= 0 || value.length < this.multipleLimit) {
            value.push(option.value);
          }
          this.$emit('input', value);
          if (option.created) {
            this.query = '';
            this.inputLength = 20;
          }
          if (this.filterable) {
            this.$refs.input.focus();
          } else {
            this.focus();
          }
        } else {
          this.$emit('input', option.value);
          this.visible = false;
          this.focus();
        }
      },
      toggleMenu: function() {
        if (this.filterable && this.query === '' && this.visible) {
          return;
        }
        if (!this.disabled) {
          this.visible = !this.visible;
        }
      },
      keepMenu: function() {
        if (!this.visible) {
          this.visible = true;
        }
      },
      navigateOptions: function(direction) {
        if (!this.visible) {
          this.visible = true;
          return;
        }
        if (this.options.length === 0 || this.filteredOptionsCount === 0)
          return;
        this.optionsAllDisabled = this.options.length === VueUtil.filter(this.options, function(item) {return item.disabled === true;}).length;
        if (!this.optionsAllDisabled) {
          if (direction === 'next') {
            this.hoverIndex++;
            if (this.hoverIndex === this.options.length) {
              this.hoverIndex = 0;
            }
            this.resetScrollTop();
            if (this.options[this.hoverIndex].disabled === true || this.options[this.hoverIndex].groupDisabled === true || !this.options[this.hoverIndex].visible) {
              this.navigateOptions('next');
            }
          }
          if (direction === 'prev') {
            this.hoverIndex--;
            if (this.hoverIndex < 0) {
              this.hoverIndex = this.options.length - 1;
            }
            this.resetScrollTop();
            if (this.options[this.hoverIndex].disabled === true || this.options[this.hoverIndex].groupDisabled === true || !this.options[this.hoverIndex].visible) {
              this.navigateOptions('prev');
            }
          }
        }
      },
      resetScrollTop: function() {
        var bottomOverflowDistance = this.options[this.hoverIndex].$el.getBoundingClientRect().bottom - this.$refs.popper.$el.getBoundingClientRect().bottom;
        var topOverflowDistance = this.options[this.hoverIndex].$el.getBoundingClientRect().top - this.$refs.popper.$el.getBoundingClientRect().top;
        if (bottomOverflowDistance > 0) {
          this.dropdownUl.scrollTop += bottomOverflowDistance;
        }
        if (topOverflowDistance < 0) {
          this.dropdownUl.scrollTop += topOverflowDistance;
        }
      },
      selectOption: function(event) {
        if (this.visible) {
          event.stopPropagation();
        }
        if (this.options[this.hoverIndex]) {
          this.handleOptionSelect(this.options[this.hoverIndex]);
        }
      },
      deleteSelected: function(event) {
        event && event.stopPropagation();
        if (this.multiple) {
          this.$emit('input', []);
        } else {
          this.$emit('input', '');
        }
        this.visible = false;
      },
      deleteTag: function(event, tag) {
        var index = this.selected.indexOf(tag);
        if (index !== -1 && !this.disabled) {
          var value = VueUtil.mergeArray([], this.value);
          value.splice(index, 1);
          this.$emit('input', value);
          this.$emit('remove-tag', tag);
        }
        event.stopPropagation();
      },
      onInputChange: function() {
        if (this.filterable) {
          this.query = this.selectedLabel;
        }
      },
      onOptionDestroy: function(option) {
        this.optionsCount--;
        this.filteredOptionsCount--;
        var index = this.options.indexOf(option);
        if (index !== -1) {
          this.options.splice(index, 1);
        }
        
        var self = this;
        VueUtil.throttle(100, function() {
          self.broadcast('VueOption', 'resetIndex');
        }).apply(self);
      },
      resetInputWidth: function() {
        this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
      },
      handleResize: function() {
        this.resetInputWidth();
        if (this.multiple) this.resetInputHeight();
      },
      debouncedOnInputChange: VueUtil.debounce(function() {
        this.onInputChange();
      }),
      getValueKey: function(item) {
        if (Object.prototype.toString.call(item.value).toLowerCase() !== '[object object]') {
          return item.value;
        } else {
          return getValueByPath(item.value, this.valueKey);
        }
      }
    },
    created: function() {
      this.cachedPlaceHolder = this.currentPlaceholder = this.placeholder;
      if (this.multiple && !VueUtil.isArray(this.value)) this.$emit('input', []);
      if (!this.multiple && VueUtil.isArray(this.value)) this.$emit('input', '');
      this.setSelected();
      this.$on('handleOptionClick', this.handleOptionSelect);
      this.$on('onOptionDestroy', this.onOptionDestroy);
      this.$on('setSelected', this.setSelected);
    },
    mounted: function() {
      VueUtil.addResizeListener(this.$el, this.handleResize);
      if (this.remote && this.multiple) {
        this.resetInputHeight();
      }
      this.$nextTick(function() {
        if (this.$refs.reference.$el) {
          this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
        }
      });
    },
    beforeDestroy: function() {
      VueUtil.removeResizeListener(this.$el, this.handleResize);
    }
  };
  Vue.component(VueSelect.name, VueSelect);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueTree = definition(context.Vue, context.VueUtil);
    delete context.VueTree;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var NODE_KEY = '$treeNodeId';
  var getChildState = function(node) {
    var all = true;
    var none = true;
    var allWithoutDisable = true;
    VueUtil.loop(node, function(n) {
      if (n.checked !== true || n.indeterminate) {
        all = false;
        if (!n.disabled) {
          allWithoutDisable = false;
        }
      }
      if (n.checked !== false || n.indeterminate) {
        none = false;
      }
    });
    return {
      all: all,
      none: none,
      allWithoutDisable: allWithoutDisable,
      half: !all && !none
    };
  };
  var reInitChecked = function(node) {
    var childState = getChildState(node.childNodes);
    var all = childState.all;
    var none = childState.none;
    var half = childState.half;
    if (all) {
      node.checked = true;
      node.indeterminate = false;
    } else if (half) {
      node.checked = false;
      node.indeterminate = true;
    } else if (none) {
      node.checked = false;
      node.indeterminate = false;
    }
    var parent = node.parent;
    if (!parent || parent.level === 0) return;
    if (!node.store.checkStrictly) {
      reInitChecked(parent);
    }
  };
  var getPropertyFromData = function(node, prop) {
    var props = node.store.props;
    var data = node.data || {};
    var config = props[prop];
    if (VueUtil.isFunction(config)) {
      return config(data, node);
    }
    if (VueUtil.isString(config)) {
      return data[config];
    }
    if (!VueUtil.isDef(config)) {
      return '';
    }
  };
  var nodeIdSeed = 0;
  var Node = function(options) {
    var self = this;
    self.id = nodeIdSeed++;
    self.text = null;
    self.checked = false;
    self.indeterminate = false;
    self.data = null;
    self.expanded = false;
    self.parent = null;
    self.visible = true;
    VueUtil.ownPropertyLoop(options, function(name) {
      self[name] = options[name];
    });
    self.level = 0;
    self.loaded = false;
    self.childNodes = [];
    self.loading = false;
    self.label = self.getLabel();
    self.icon = self.getIcon();
    self.key = self.getKey();
    self.disabled = self.getDisabled();
    if (self.parent) {
      self.level = self.parent.level + 1;
    }
    var store = self.store;
    if (!store) throw 'store is required!';
    store.registerNode(self);
    var props = store.props;
    if (props && VueUtil.isDef(props.isLeaf)) {
      var isLeaf = getPropertyFromData(self, 'isLeaf');
      if (VueUtil.isBoolean(isLeaf)) {
        self.isLeafByUser = isLeaf;
      }
    }
    if (store.lazy !== true && self.data) {
      self.setData(self.data);
      if (store.defaultExpandAll) {
        self.expanded = true;
      }
    } else if (self.level > 0 && store.lazy && store.defaultExpandAll) {
      self.expand();
    }
    if (!self.data) return;
    var defaultExpandedKeys = store.defaultExpandedKeys;
    var key = store.key;
    if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(self.key) !== -1) {
      self.expand(null, store.autoExpandParent);
    }
    if (key && store.currentNodeKey && self.key === store.currentNodeKey) {
      store.currentNode = self;
    }
    if (store.lazy) {
      store._initDefaultCheckedNode(self);
    }
    self.updateLeafState();
  };
  Node.prototype.setData = function(data) {
    var self = this;
    if (!VueUtil.isArray(data)) {
      var markNodeData = function(node, data) {
        if (data[NODE_KEY]) return;
        Object.defineProperty(data, NODE_KEY, {
          value: node.id,
          enumerable: false,
          configurable: false,
          writable: false
        });
      };
      markNodeData(self, data);
    }
    self.data = data;
    self.childNodes = [];
    var children;
    if (self.level === 0 && self.data instanceof Array) {
      children = self.data;
    } else {
      children = getPropertyFromData(self, 'children') || [];
    }
    VueUtil.loop(children, function(child) {
      self.insertChild({
        data: child
      });
    });
  };
  Node.prototype.getLabel = function() {
    return getPropertyFromData(this, 'label');
  };
  Node.prototype.getIcon = function(node) {
    return getPropertyFromData(this, 'icon');
  };
  Node.prototype.getDisabled = function() {
    return getPropertyFromData(this, 'disabled');
  };
  Node.prototype.getKey = function() {
    var self = this;
    var nodeKey = self.store.key;
    if (self.data)
      return self.data[nodeKey];
    return null;
  };
  Node.prototype.insertChild = function(child, index) {
    if (!child) throw 'insertChild error: child is required.';
    var self = this;
    if (!(child instanceof Node)) {
      VueUtil.merge(child, {parent: self, store: self.store});
      child = new Node(child);
    }
    child.level = self.level + 1;
    if (!VueUtil.isDef(index) || index < 0) {
      self.childNodes.push(child);
    } else {
      self.childNodes.splice(index, 0, child);
    }
    self.updateLeafState();
  };
  Node.prototype.insertBefore = function(child, ref) {
    var self = this;
    var index;
    if (ref) {
      index = self.childNodes.indexOf(ref);
    }
    self.insertChild(child, index);
  };
  Node.prototype.insertAfter = function(child, ref) {
    var self = this;
    var index;
    if (ref) {
      index = self.childNodes.indexOf(ref);
      if (index !== -1)
        index += 1;
    }
    self.insertChild(child, index);
  };
  Node.prototype.removeChild = function(child) {
    var self = this;
    var index = self.childNodes.indexOf(child);
    if (index !== -1) {
      self.store && self.store.deregisterNode(child);
      child.parent = null;
      self.childNodes.splice(index, 1);
    }
    self.updateLeafState();
  };
  Node.prototype.removeChildByData = function(data) {
    var self = this;
    var targetNode = null;
    VueUtil.loop(self.childNodes, function(node) {
      if (node.data === data) {
        targetNode = node;
      }
    });
    if (targetNode) {
      self.removeChild(targetNode);
    }
  };
  Node.prototype.expand = function(callback, expandParent) {
    var self = this;
    var done = function() {
      if (expandParent) {
        var parent = self.parent;
        while (parent.level > 0) {
          parent.expanded = true;
          parent = parent.parent;
        }
      }
      self.expanded = true;
      if (callback)
        callback();
    };
    if (self.shouldLoadData()) {
      self.loadData(function(data) {
        if (VueUtil.isArray(data)) {
          var initLazyLoadChild = function(node) {
            if (node.checked) {
              var childNodes = node.childNodes;
              VueUtil.loop(childNodes, function(child) {
                if (!child.disabled) {
                  child.checked = true;
                }
              });
            }
            var parent = node.parent;
            if (!parent || parent.level === 0) return;
            reInitChecked(parent);
          };
          initLazyLoadChild(self);
          done();
        }
      });
    } else {
      done();
    }
  };
  Node.prototype.doCreateChildren = function(array, defaultProps) {
    var self = this;
    defaultProps = defaultProps || {};
    VueUtil.loop(array, function(item) {
      self.insertChild(VueUtil.merge({
        data: item
      }, defaultProps));
    });
  };
  Node.prototype.collapse = function() {
    this.expanded = false;
  };
  Node.prototype.shouldLoadData = function() {
    return this.store.lazy === true && this.store.load && !this.loaded;
  };
  Node.prototype.updateLeafState = function() {
    var self = this;
    if (self.store.lazy === true && self.loaded !== true && VueUtil.isDef(self.isLeafByUser)) {
      self.isLeaf = selfk.isLeafByUser;
      return;
    }
    var childNodes = self.childNodes;
    if (!self.store.lazy || (self.store.lazy === true && self.loaded === true)) {
      self.isLeaf = !childNodes || childNodes.length === 0;
      return;
    }
    self.isLeaf = false;
  };
  Node.prototype.setChecked = function(value, deep, recursion, passValue) {
    var self = this;
    self.indeterminate = value === 'half';
    self.checked = value === true;
    var selfChildState = getChildState(self);
    var all = selfChildState.all;
    var allWithoutDisable = selfChildState.allWithoutDisable;
    if (self.childNodes.length && !all && allWithoutDisable) {
      self.checked = false;
      value = false;
    }
    var handleDescendants = function(lazy) {
      if (deep && !lazy) {
        var childNodes = self.childNodes;
        VueUtil.loop(childNodes, function(child) {
          passValue = passValue || value !== false;
          var isCheck = child.disabled ? child.checked : passValue;
          child.setChecked(isCheck, deep, true, passValue);
        });
        var childState = getChildState(childNodes);
        var half = childState.half;
        var all = childState.all;
        if (!all) {
          self.checked = all;
          self.indeterminate = half;
        }
      }
    };
    if (!self.store.checkStrictly && self.shouldLoadData()) {
      self.loadData(function() {
        handleDescendants(true);
      }, {
          checked: value !== false
        });
    } else {
      handleDescendants();
    }
    var parent = self.parent;
    if (!parent || parent.level === 0) return;
    if (!self.store.checkStrictly && !recursion) {
      reInitChecked(parent);
    }
  };
  Node.prototype.getChildren = function() {
    var self = this;
    var data = self.data;
    if (!data) return null;
    var props = self.store.props;
    var children = 'children';
    if (props) {
      children = props.children || 'children';
    }
    if (!VueUtil.isDef(data[children])) {
      data[children] = null;
    }
    return data[children];
  };
  Node.prototype.updateChildren = function() {
    var self = this;
    var newData = self.getChildren() || [];
    var oldData = VueUtil.map(self.childNodes, function(node) {
      return node.data;
    });
    var newDataMap = {};
    var newNodes = [];
    VueUtil.loop(newData, function(item, index) {
      if (item[NODE_KEY]) {
        newDataMap[item[NODE_KEY]] = {
          index: index,
          data: item
        };
      } else {
        newNodes.push({
          index: index,
          data: item
        });
      }
    });
    VueUtil.loop(oldData, function(item) {
      if (!newDataMap[item[NODE_KEY]])
        self.removeChildByData(item);
    });
    VueUtil.loop(newNodes, function(args) {
      var index = args.index;
      var data = args.data;
      self.insertChild({
        data: data
      }, index);
    });
    self.updateLeafState();
  };
  Node.prototype.loadData = function(callback, defaultProps) {
    var self = this;
    defaultProps = defaultProps || {};
    if (self.store.lazy === true && self.store.load && !self.loaded && (!self.loading || Object.keys(defaultProps).length)) {
      self.loading = true;
      var resolve = function(children) {
        self.loaded = true;
        self.loading = false;
        self.childNodes = [];
        self.doCreateChildren(children, defaultProps);
        self.updateLeafState();
        if (callback) {
          callback.call(self, children);
        }
      };
      self.store.load(self, resolve);
    } else {
      if (callback) {
        callback.call(self);
      }
    }
  };
  var TreeStore = function(options) {
    var self = this;
    self.currentNode = null;
    self.currentNodeKey = null;
    VueUtil.ownPropertyLoop(options, function(option) {
      self[option] = options[option];
    });
    self.nodesMap = {};
    self.root = new Node({
      data: self.data,
      store: self
    });
    if (self.lazy && self.load) {
      var loadFn = self.load;
      loadFn(self.root, function(data) {
        self.root.doCreateChildren(data);
        self._initDefaultCheckedNodes();
      });
    } else {
      self._initDefaultCheckedNodes();
    }
  };
  TreeStore.prototype.filter = function(value) {
    var self = this;
    var filterNodeMethod = self.filterNodeMethod;
    var traverse = function(node) {
      var childNodes = node.root ? node.root.childNodes : node.childNodes;
      VueUtil.loop(childNodes, function(child) {
        child.visible = filterNodeMethod.call(child, value, child.data, child);
        traverse(child);
      });
      if (!node.visible && childNodes.length) {
        var allHidden = true;
        VueUtil.loop(childNodes, function(child) {
          if (child.visible)
            allHidden = false;
        });
        if (node.root) {
          node.root.visible = allHidden === false;
        } else {
          node.visible = allHidden === false;
        }
      }
      if (node.visible && !node.isLeaf)
        node.expand();
    };
    traverse(self);
  };
  TreeStore.prototype.setData = function(newVal) {
    var self = this;
    var instanceChanged = newVal !== self.root.data;
    self.root.setData(newVal);
    if (instanceChanged) {
      self._initDefaultCheckedNodes();
    }
  };
  TreeStore.prototype.getNode = function(data) {
    var getNodeKey = function(key, data) {
      if (!key)
        return data[NODE_KEY];
      return data[key];
    };
    var key = VueUtil.isObject(data) ? getNodeKey(this.key, data) : data;
    return this.nodesMap[key];
  };
  TreeStore.prototype.insertBefore = function(data, refData) {
    var self = this;
    var refNode = self.getNode(refData);
    refNode.parent.insertBefore({
      data: data
    }, refNode);
  };
  TreeStore.prototype.insertAfter = function(data, refData) {
    var self = this;
    var refNode = self.getNode(refData);
    refNode.parent.insertAfter({
      data: data
    }, refNode);
  };
  TreeStore.prototype.remove = function(data) {
    var self = this;
    var node = self.getNode(data);
    if (node && node.parent) {
      node.parent.removeChild(node);
    }
  };
  TreeStore.prototype.append = function(data, parentData) {
    var self = this;
    var parentNode = parentData ? self.getNode(parentData) : self.root;
    if (parentNode) {
      parentNode.insertChild({
        data: data
      });
    }
  };
  TreeStore.prototype._initDefaultCheckedNodes = function() {
    var self = this;
    var defaultCheckedKeys = self.defaultCheckedKeys || [];
    var nodesMap = self.nodesMap;
    VueUtil.loop(defaultCheckedKeys, function(checkedKey) {
      var node = nodesMap[checkedKey];
      if (node) {
        node.setChecked(true, !self.checkStrictly);
      }
    });
  };
  TreeStore.prototype._initDefaultCheckedNode = function(node) {
    var self = this;
    var defaultCheckedKeys = self.defaultCheckedKeys || [];
    var nodeKey = node.key || node.getKey();
    if (defaultCheckedKeys.indexOf(nodeKey) !== -1) {
      node.setChecked(true, !self.checkStrictly);
    }
  };
  TreeStore.prototype.setDefaultCheckedKey = function(newVal) {
    var self = this;
    if (newVal !== self.defaultCheckedKeys) {
      self.defaultCheckedKeys = newVal;
      self._initDefaultCheckedNodes();
    }
  };
  TreeStore.prototype.registerNode = function(node) {
    var self = this;
    var key = self.key;
    if (!key || !node || !node.data)
      return;
    var nodeKey = node.key || node.getKey();
    if (nodeKey)
      self.nodesMap[nodeKey] = node;
  };
  TreeStore.prototype.deregisterNode = function(node) {
    var self = this;
    var key = self.key;
    if (!key || !node || !node.data)
      return;
    var nodeKey = node.key || node.getKey();
    delete self.nodesMap[nodeKey];
  };
  TreeStore.prototype.getCheckedNodes = function() {
    var self = this;
    var leafOnly = arguments.length > 0 && VueUtil.isDef(arguments[0]) ? arguments[0] : false;
    var indeterminate = arguments.length > 1 && VueUtil.isDef(arguments[1]) ? arguments[1] : false;
    var visibleOnly = arguments.length > 2 && VueUtil.isDef(arguments[2]) ? arguments[2] : false;

    var checkedNodes = [];
    var traverse = function(node) {
      var childNodes = node.root ? node.root.childNodes : node.childNodes;
      VueUtil.loop(childNodes, function(child) {
        if(!visibleOnly || (visibleOnly && child.visible)) {
          if ((!leafOnly && (child.checked || (indeterminate && child.indeterminate)) ) || (leafOnly && child.isLeaf && child.checked)) {
            checkedNodes.push(child.data);
          }
        }
        traverse(child);
      });
    };
    traverse(self);
    return checkedNodes;
  };
  TreeStore.prototype.getCheckedKeys = function() {
    var self = this;
    var leafOnly = arguments.length > 0 && VueUtil.isDef(arguments[0]) ? arguments[0] : false;
    var indeterminate = arguments.length > 1 && VueUtil.isDef(arguments[1]) ? arguments[1] : false;
    var visibleOnly = arguments.length > 2 && VueUtil.isDef(arguments[2]) ? arguments[2] : false;

    var key = self.key;
    var allNodes = self._getAllNodes();
    var keys = [];
    VueUtil.loop(allNodes, function(node) {
      if(!visibleOnly || (visibleOnly && child.visible)) {
        if (!leafOnly || (leafOnly && node.isLeaf)) {
          if (node.checked || (indeterminate && node.indeterminate)) {
            keys.push((node.data || {})[key]);
          }
        }
      }
    });
    return keys;
  };
  TreeStore.prototype._getAllNodes = function() {
    var self = this;
    var allNodes = [];
    var nodesMap = self.nodesMap;
    VueUtil.ownPropertyLoop(nodesMap, function(nodeKey) {
      allNodes.push(nodesMap[nodeKey]);
    });
    return allNodes;
  };
  TreeStore.prototype._setCheckedKeys = function(key) {
    var self = this;
    var leafOnly = arguments.length > 1 && VueUtil.isDef(arguments[1]) ? arguments[1] : false;
    var checkedKeys = arguments[2];
    var allNodes = self._getAllNodes().sort(function(a, b) {return b.level - a.level;});
    var cache = {};
    var keys = Object.keys(checkedKeys);
    VueUtil.loop(allNodes, function(node) {
      node.setChecked(false, false);
    });
    VueUtil.loop(allNodes, function(node) {
      var nodeKey = node.data[key] + '';
      var checked = keys.indexOf(nodeKey) !== -1;
      if (!checked) {
        if (node.checked && !cache[nodeKey]) {
          node.setChecked(false, false);
        }
        return;
      }
      var parent = node.parent;
      while (parent && parent.level > 0) {
        cache[parent.data[key]] = true;
        parent = parent.parent;
      }
      if (node.isLeaf || self.checkStrictly) {
        node.setChecked(true, false);
        return;
      }
      node.setChecked(true, true);
      if (leafOnly) {
        node.setChecked(false, false);
        var traverse = function(node) {
          var childNodes = node.childNodes || [];
          VueUtil.loop(childNodes, function(child) {
            if (!child.isLeaf) {
              child.setChecked(false, false);
            }
            traverse(child);
          });
        };
        traverse(node);
      }
    });
  };
  TreeStore.prototype.setCheckedNodes = function(array) {
    var self = this;
    var leafOnly = arguments.length > 1 && VueUtil.isDef(arguments[1]) ? arguments[1] : false;
    var key = self.key;
    var checkedKeys = {};
    VueUtil.loop(array, function(item) {
      checkedKeys[(item || {})[key]] = true;
    });
    self._setCheckedKeys(key, leafOnly, checkedKeys);
  };
  TreeStore.prototype.setCheckedKeys = function(keys, leafonly) {
    var self = this;
    var leafOnly = arguments.length > 1 && VueUtil.isDef(arguments[1]) ? arguments[1] : false;
    self.defaultCheckedKeys = keys;
    var key = self.key;
    var checkedKeys = {};
    VueUtil.loop(keys, function(key) {
      checkedKeys[key] = true;
    });
    self._setCheckedKeys(key, leafOnly, checkedKeys);
  };
  TreeStore.prototype.setDefaultExpandedKeys = function(keys) {
    var self = this;
    keys = keys || [];
    self.defaultExpandedKeys = keys;
    VueUtil.loop(keys, function(key) {
      var node = self.getNode(key);
      if (node) node.expand(null, self.autoExpandParent);
    });
  };
  TreeStore.prototype.setChecked = function(data, checked, deep) {
    var self = this;
    var node = self.getNode(data);
    if (node) {
      node.setChecked(!!checked, deep);
    }
  };
  TreeStore.prototype.getCurrentNode = function() {
    return this.currentNode;
  };
  TreeStore.prototype.setCurrentNode = function(node) {
    this.currentNode = node;
  };
  TreeStore.prototype.setCurrentNodeKey = function(key) {
    var self = this;
    if (!key) {
      self.currentNode = null;
    } else {
      var node = self.getNode(key);
      if (node) {
        self.currentNode = node;
      }
    }
  };
  var VueTreeNode = {
    template: '<div @click.stop="handleClick" v-show="node.visible" :class="[\'vue-tree-node\', {\'is-expanded\': childNodeRendered && expanded,\'is-current\': tree.store.currentNode === node,\'is-hidden\': !node.visible}]"><div class="vue-tree-node__content" :style="{\'padding-left\': (node.level - 1) * tree.indent + \'px\'}"><span @click.stop="handleExpandIconClick" :class="[\'vue-tree-node__expand-icon\', {\'is-leaf\': node.isLeaf, expanded: !node.isLeaf && expanded}]"></span><vue-checkbox v-if="showCheckbox" v-model="node.checked" :indeterminate="node.indeterminate" :disabled="!!node.disabled" @change="handleCheckChange"></vue-checkbox><span v-if="node.loading" class="vue-tree-node__loading-icon vue-icon-loading"></span><node-content :node="node"></node-content></div><collapse-transition><div class="vue-tree-node__children" v-show="expanded"><vue-tree-node :render-content="renderContent" v-for="child in node.childNodes" :key="getNodeKey(child)" :node="child" @node-expand="handleChildNodeExpand"></vue-tree-node></div></collapse-transition></div>',
    name: 'VueTreeNode',
    mixins: [VueUtil.component.emitter],
    props: {
      node: {
        default: function() {
          return {};
        }
      },
      props: {},
      renderContent: Function
    },
    components: {
      CollapseTransition: VueUtil.component.collapseTransition,
      NodeContent: {
        props: {
          node: {
            required: true
          }
        },
        render: function(createElement) {
          var parent = this.$parent;
          var node = this.node;
          var data = node.data;
          var store = node.store;
          return (parent.renderContent ? parent.renderContent.call(parent._renderProxy, createElement, {
            _self: parent.tree.$vnode.context,
            node: node,
            data: data,
            store: store
          }) : createElement('span', {
            class: 'vue-tree-node__label'
          }, [this.node.label]));
        }
      }
    },
    data: function() {
      return {
        tree: null,
        expanded: false,
        childNodeRendered: false,
        showCheckbox: false,
        oldChecked: null,
        oldIndeterminate: null
      };
    },
    watch: {
      'node.indeterminate': function(val) {
        this.handleSelectChange(this.node.checked, val);
      },
      'node.checked': function(val) {
        this.handleSelectChange(val, this.node.indeterminate);
      },
      'node.expanded': function(val) {
        this.expanded = val;
        if (val) {
          this.childNodeRendered = true;
        }
      }
    },
    methods: {
      getNodeKey: function(node, index) {
        var nodeKey = this.tree.nodeKey;
        if (nodeKey && node) {
          return node.data[nodeKey];
        }
        return index;
      },
      handleSelectChange: function(checked, indeterminate) {
        if (this.oldChecked !== checked && this.oldIndeterminate !== indeterminate) {
          this.tree.$emit('check-change', this.node.data, checked, indeterminate);
        }
        this.oldChecked = checked;
        this.indeterminate = indeterminate;
      },
      handleClick: function() {
        var store = this.tree.store;
        store.setCurrentNode(this.node);
        this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);
        this.tree.currentNode = this;
        if (this.tree.expandOnClickNode) {
          this.handleExpandIconClick();
        }
        this.tree.$emit('node-click', this.node.data, this.node, this);
      },
      handleExpandIconClick: function() {
        if (this.node.isLeaf)
          return;
        if (this.expanded) {
          this.tree.$emit('node-collapse', this.node.data, this.node, this);
          this.node.collapse();
        } else {
          this.node.expand();
          this.$emit('node-expand', this.node.data, this.node, this);
        }
      },
      handleCheckChange: function(ev) {
        this.node.setChecked(ev.target.checked, !this.tree.checkStrictly);
      },
      handleChildNodeExpand: function(nodeData, node, instance) {
        this.broadcast('VueTreeNode', 'tree-node-expand', node);
        this.tree.$emit('node-expand', nodeData, node, instance);
      }
    },
    created: function() {
      var self = this;
      var parent = self.$parent;
      if (parent.isTree) {
        self.tree = parent;
      } else {
        self.tree = parent.tree;
      }
      var tree = self.tree;
      if (!tree) {
        throw 'Can not find node\'s tree.';
      }
      var props = tree.props || {};
      var childrenKey = props['children'] || 'children';
      self.$watch('node.data.' + childrenKey, function() {
        self.node.updateChildren();
      });
      self.showCheckbox = tree.showCheckbox;
      if (self.node.expanded) {
        self.expanded = true;
        self.childNodeRendered = true;
      }
      if (self.tree.accordion) {
        self.$on('tree-node-expand', function(node) {
          if (self.node !== node) {
            self.node.collapse();
          }
        });
      }
    }
  };
  var VueTree = {
    template: 
    '<div :class="[\'vue-tree\', {\'vue-tree--highlight-current\': highlightCurrent}]"> \
      <vue-tree-node v-for="child in root.childNodes" :node="child" :props="props" :key="getNodeKey(child)" \
        :render-content="renderContent" @node-expand="handleNodeExpand"></vue-tree-node> \
      <div class="vue-tree__empty-block" v-if="!root.childNodes || root.childNodes.length === 0"><span class="vue-tree__empty-text">{{$t(\'vue.tree.emptyText\')}}</span></div> \
    </div>',
    name: 'VueTree',
    mixins: [VueUtil.component.emitter],
    components: {
      VueTreeNode: VueTreeNode
    },
    data: function() {
      return {
        store: null,
        root: null,
        currentNode: null
      };
    },
    props: {
      data: {
        type: Array
      },
      nodeKey: String,
      checkStrictly: Boolean,
      defaultExpandAll: Boolean,
      expandOnClickNode: {
        type: Boolean,
        default: true
      },
      autoExpandParent: {
        type: Boolean,
        default: true
      },
      defaultCheckedKeys: Array,
      defaultExpandedKeys: Array,
      renderContent: Function,
      showCheckbox: Boolean,
      props: {
        default: function() {
          return {
            children: 'children',
            label: 'label',
            icon: 'icon',
            disabled: 'disabled'
          };
        }
      },
      lazy: Boolean,
      highlightCurrent: Boolean,
      currentNodeKey: [String, Number],
      load: Function,
      filterNodeMethod: Function,
      accordion: Boolean,
      indent: {
        type: Number,
        default: 16
      }
    },
    computed: {
      children: {
        set: function(value) {
          this.data = value;
        },
        get: function() {
          return this.data;
        }
      }
    },
    watch: {
      defaultCheckedKeys: function(newVal) {
        this.store.defaultCheckedKeys = newVal;
        this.store.setDefaultCheckedKey(newVal);
      },
      defaultExpandedKeys: function(newVal) {
        this.store.defaultExpandedKeys = newVal;
        this.store.setDefaultExpandedKeys(newVal);
      },
      currentNodeKey: function(newVal) {
        this.store.setCurrentNodeKey(newVal);
        this.store.currentNodeKey = newVal;
      },
      data: function(newVal) {
        this.store.setData(newVal);
      }
    },
    methods: {
      filter: function(value) {
        if (!this.filterNodeMethod) throw 'filterNodeMethod is required when filter';
        this.store.filter(value);
      },
      getNodeKey: function(node, index) {
        var nodeKey = this.nodeKey;
        if (nodeKey && node) {
          return node.data[nodeKey];
        }
        return index;
      },
      getCurrentNode: function() {
        var currentNode = this.store.getCurrentNode();
        return currentNode ? currentNode.data : null;
      },
      getCurrentKey: function() {
        if (!this.nodeKey) return null;
        var currentNode = this.store.getCurrentNode();
        return currentNode ? currentNode.data[this.nodeKey] : null;
      },
      setCurrentNode: function(node) {
        if (!this.nodeKey) throw 'nodeKey is required in setCheckedNodes';
        if (!node) return this.store.setCurrentNodeKey(null);
        var key = node[this.nodeKey];
        return this.store.setCurrentNodeKey(key);
      },
      setCurrentKey: function(key) {
        if (!this.nodeKey) throw 'nodeKey is required in setCheckedNodes';
        return this.store.setCurrentNodeKey(key);
      },
      getCheckedNodes: function(leafOnly, indeterminate, visibleOnly) {
        return this.store.getCheckedNodes(leafOnly, indeterminate, visibleOnly);
      },
      getCheckedKeys: function(leafOnly, indeterminate, visibleOnly) {
        return this.store.getCheckedKeys(leafOnly, indeterminate, visibleOnly);
      },
      setCheckedNodes: function(nodes, leafOnly) {
        if (!this.nodeKey) throw 'nodeKey is required in setCheckedNodes';
        this.store.setCheckedNodes(nodes, leafOnly);
      },
      setCheckedKeys: function(keys, leafOnly) {
        if (!this.nodeKey) throw 'nodeKey is required in setCheckedNodes';
        this.store.setCheckedKeys(keys, leafOnly);
      },
      setChecked: function(data, checked, deep) {
        this.store.setChecked(data, checked, deep);
      },
      handleNodeExpand: function(nodeData, node, instance) {
        this.broadcast('VueTreeNode', 'tree-node-expand', node);
        this.$emit('node-expand', nodeData, node, instance);
      }
    },
    created: function() {
      var self = this;
      self.isTree = true;
      self.store = new TreeStore({
        key: self.nodeKey,
        data: self.data,
        lazy: self.lazy,
        props: self.props,
        load: self.load,
        currentNodeKey: self.currentNodeKey,
        checkStrictly: self.checkStrictly,
        defaultCheckedKeys: self.defaultCheckedKeys,
        defaultExpandedKeys: self.defaultExpandedKeys,
        autoExpandParent: self.autoExpandParent,
        defaultExpandAll: self.defaultExpandAll,
        filterNodeMethod: self.filterNodeMethod
      });
      self.root = self.store.root;
    }
  };
  Vue.component(VueTree.name, VueTree);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCarousel = definition(context.Vue, context.VueUtil);
    delete context.VueCarousel;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCarousel = {
    template: '<div :class="[\'vue-carousel\', {\'vue-carousvue--card\': type === \'card\'}]" @mouseenter.stop="handleMouseEnter" @mouseleave.stop="handleMouseLeave" @touchstart.stop="handleTouchStart" @mousedown.stop="handleMouseDrag"><div class="vue-carousel__container" :style="{height: height}"><transition name="carousel-arrow-left"><button type="button" v-if="arrow !== \'never\'" v-show="arrow === \'always\' || hover" @mouseenter="handleButtonEnter(\'left\')" @mouseleave="handleButtonLeave" @click.stop="throttledArrowClick(activeIndex - 1)" class="vue-carousel__arrow vue-carousel__arrow--left"><i class="vue-icon-arrow-left"></i></button></transition><transition name="carousel-arrow-right"><button type="button" v-if="arrow !== \'never\'" v-show="arrow === \'always\' || hover" @mouseenter="handleButtonEnter(\'right\')" @mouseleave="handleButtonLeave" @click.stop="throttledArrowClick(activeIndex + 1)" class="vue-carousel__arrow vue-carousel__arrow--right"><i class="vue-icon-arrow-right"></i></button></transition><slot></slot></div><ul v-if="indicatorPosition !== \'none\'" :class="[\'vue-carousel__indicators\', {\'vue-carousel__indicators--outside\': indicatorPosition === \'outside\' || type === \'card\'}]"><li v-for="(item, index) in items" :class="[\'vue-carousel__indicator\', {\'is-active\': index === activeIndex}]" @mouseenter="throttledIndicatorHover(index)" @click.stop="handleIndicatorClick(index)"><button type="button" class="vue-carousel__button"></button></li></ul></div>',
    name: 'VueCarousel',
    props: {
      initialIndex: {
        type: Number,
        default: 0
      },
      height: String,
      trigger: {
        type: String,
        default: 'hover'
      },
      autoplay: {
        type: Boolean,
        default: true
      },
      interval: {
        type: Number,
        default: 3000
      },
      indicatorPosition: String,
      indicator: {
        type: Boolean,
        default: true
      },
      arrow: {
        type: String,
        default: 'hover'
      },
      hoverStop: {
        type: Boolean,
        default: true
      },
      mousewhell: {
        type: Boolean,
        default: false
      },
      mousedrag: {
        type: Boolean,
        default: false
      },
      wrap: {
        type: Boolean,
        default: true
      },
      type: String
    },
    data: function() {
      return {
        items: [],
        activeIndex: -1,
        hover: false
      };
    },
    watch: {
      items: function(val) {
        if (val.length > 0)
          this.setActiveItem(0);
      },
      activeIndex: function(val, oldVal) {
        this.resetItemPosition();
        this.$emit('change', val, oldVal);
      }
    },
    methods: {
      handleMouseEnter: function() {
        this.hover = true;
        if (this.hoverStop) this.pauseTimer();
      },
      handleMouseLeave: function() {
        this.hover = false;
        if (this.hoverStop) this.startTimer();
      },
      handleMouseDrag: function(e) {
        if(!this.mousedrag) {
          return;
        }
        e.stopImmediatePropagation();
        this.mousedownX = e.clientX;
        this.mousemove = 0;
        VueUtil.on(document, 'mousemove', this.handleMousemove);
        VueUtil.on(document, 'mouseup', this.handleMouseup);
      },
      handleMousemove: function(e) {
        this.mousemove = this.mousedownX - e.clientX;
      },
      handleMouseup: function() {
        VueUtil.off(document, 'mousemove', this.handleMousemove);
        VueUtil.off(document, 'mouseup', this.handleMouseup);

        var mousemove = this.mousemove;
        if (mousemove > 10) {
          this.throttledArrowClick(this.activeIndex + 1);
        }
        if (mousemove < -10) {
          this.throttledArrowClick(this.activeIndex - 1);
        }
      },
      handleTouchStart: function(e) {
        e.stopImmediatePropagation();
        var tocuhPlace = this.tocuhPlace = {};
        var touches = e.touches[0];
        tocuhPlace.tocuhX = touches.pageX;
        VueUtil.on(document, 'touchmove', this.handleTouchMove);
        VueUtil.on(document, 'touchend', this.handleTouchEnd);
      },
      handleTouchMove: function(e) {
        var touches = e.touches[0];
        var tocuhPlace = this.tocuhPlace;
        tocuhPlace.touchMove = tocuhPlace.tocuhX - touches.pageX;
      },
      handleTouchEnd: function(e) {
        var tocuhPlace = this.tocuhPlace;
        if (tocuhPlace.touchMove > 10) {
          this.throttledArrowClick(this.activeIndex + 1);
        }
        if (tocuhPlace.touchMove < -10) {
          this.throttledArrowClick(this.activeIndex - 1);
        }
        VueUtil.off(document, 'touchmove',this.handleTouchMove);
        VueUtil.off(document, 'touchend', this.handleTouchEnd);
      },
      itemInStage: function(item, index) {
        var length = this.items.length;
        if (index === length - 1 && item.inStage && this.items[0].active || (item.inStage && this.items[index + 1] && this.items[index + 1].active)) {
          return 'left';
        } else if (index === 0 && item.inStage && this.items[length - 1].active || (item.inStage && this.items[index - 1] && this.items[index - 1].active)) {
          return 'right';
        }
        return false;
      },
      handleButtonEnter: function(arrow) {
        var self = this;
        VueUtil.loop(self.items, function(item, index) {
          if (arrow === self.itemInStage(item, index)) {
            item.hover = true;
          }
        });
      },
      handleButtonLeave: function() {
        var self = this;
        VueUtil.loop(self.items, function(item) {
          item.hover = false;
        });
      },
      updateItems: function() {
        this.items = VueUtil.filter(this.$children, function(child) {
          return child.$options.name === 'VueCarouselItem';
        });
      },
      resetItemPosition: function() {
        var self = this;
        VueUtil.loop(self.items, function(item, index) {
          item.translateItem(index, self.activeIndex);
        });
      },
      playSlides: function() {
        if (this.activeIndex < this.items.length - 1) {
          this.activeIndex++;
        } else {
          this.activeIndex = 0;
        }
      },
      pauseTimer: function() {
        clearInterval(this.timer);
      },
      startTimer: function() {
        if (this.interval <= 0 || !this.autoplay) return;
        this.timer = setInterval(this.playSlides, this.interval);
      },
      setActiveItem: function(index) {
        if (VueUtil.isString(index)) {
          var filteredItems = VueUtil.filter(this.items, function(item) {
            return item.name === index;
          });
          if (filteredItems.length > 0) {
            index = this.items.indexOf(filteredItems[0]);
          }
        }
        index = Number(index);
        if (isNaN(index) || index !== Math.floor(index)) {
          return;
        }
        var length = this.items.length;
        if (index < 0) {
          if (this.wrap) {
            this.activeIndex = length - 1;
          }
        } else if (index >= length) {
          if (this.wrap) {
            this.activeIndex = 0;
          }
        } else {
          this.activeIndex = index;
        }
      },
      prev: function() {
        this.setActiveItem(this.activeIndex - 1);
      },
      next: function() {
        this.setActiveItem(this.activeIndex + 1);
      },
      handleIndicatorClick: function(index) {
        this.activeIndex = index;
      },
      handleIndicatorHover: function(index) {
        if (this.trigger === 'hover' && index !== this.activeIndex) {
          this.activeIndex = index;
        }
      }
    },
    created: function() {
      var self = this;
      self.timer = null;
      self.throttledArrowClick = function(index) {
        self.setActiveItem(index);
      };
      self.throttledIndicatorHover = function(index) {
        self.handleIndicatorHover(index);
      };
    },
    mounted: function() {
      var self = this;
      self.updateItems();
      self.$nextTick(function() {
        VueUtil.addResizeListener(self.$el, self.resetItemPosition);
        if (self.initialIndex < self.items.length && self.initialIndex >= 0) {
          self.activeIndex = self.initialIndex;
        }
        self.startTimer();
      });
    },
    beforeDestroy: function() {
      this.pauseTimer();
      this.$el && VueUtil.removeResizeListener(this.$el, this.resetItemPosition);
    }
  };
  Vue.component(VueCarousel.name, VueCarousel);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueCarouselItem = definition(context.Vue);
    delete context.VueCarouselItem;
  }
})(this, function(Vue) {
  'use strict';
  function throttle(delay, noTrailing, callback, debounceMode) {
    var timeoutID;
    var cancelled = false;
    var lastExec = 0;

    function clearExistingTimeout() {
        if (timeoutID) {
            clearTimeout(timeoutID);
        }
    }

    function cancel() {
        clearExistingTimeout();
        cancelled = true;
    }

    if (typeof noTrailing !== 'boolean') {
        debounceMode = callback;
        callback = noTrailing;
        noTrailing = undefined;
    }

    function wrapper() {

        var self = this;
        var elapsed = Date.now() - lastExec;
        var args = arguments;

        if (cancelled) {
            return;
        }
        function exec() {
            lastExec = Date.now();
            callback.apply(self, args);
        }

        function clear() {
            timeoutID = undefined;
        }

        if (debounceMode && !timeoutID) {
            exec();
        }

        clearExistingTimeout();

        if (debounceMode === undefined && elapsed > delay) {
            exec();
        } else if (noTrailing !== true) {
            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
        }
    }

    wrapper.cancel = cancel;
    return wrapper;

}
  var VueCarouselItem = {
    template: '<div v-show="ready" :class="[\'vue-carousel__item\', {\'is-active\': active, \'vue-carousel__item--card\': $parent.type === \'card\', \'is-in-stage\': inStage, \'is-hover\': hover}]" \
              @click="handleItemClick" @mousewheel="handleMousewheel" :style=\'{msTransform: "translateX(" + translate + "px) scale(" + scale + ")", webkitTransform: "translateX(" + translate + "px) scale(" + scale + ")", transform: "translateX(" + translate + "px) scale(" + scale + ")"}\'>\
                <div v-if="$parent.type === \'card\'" v-show="!active" class="vue-carousel__mask"></div>\
                <slot></slot>\
              </div>',
    name: 'VueCarouselItem',
    props: {
      name: String
    },
    data: function() {
      return {
        hover: false,
        translate: 0,
        scale: 1,
        active: false,
        ready: false,
        inStage: false
      };
    },
    methods: {
      processIndex: function(index, activeIndex, length) {
        if (activeIndex === 0 && index === length - 1) {
          return -1;
        } else if (activeIndex === length - 1 && index === 0) {
          return length;
        } else if (index < activeIndex - 1 && activeIndex - index >= length / 2) {
          return length + 1;
        } else if (index > activeIndex + 1 && index - activeIndex >= length / 2) {
          return -2;
        }
        return index;
      },
      calculateTranslate: function(index, activeIndex, parentWidth) {
        if (this.inStage) {
          return parentWidth * ((2 - this.cardScale) * (index - activeIndex) + 1) / 4;
        } else if (index < activeIndex) {
          return -(1 + this.cardScale) * parentWidth / 4;
        } else {
          return (3 + this.cardScale) * parentWidth / 4;
        }
      },
      translateItem: function(index, activeIndex) {
        var parentWidth = this.$parent.$el.offsetWidth;
        var length = this.$parent.items.length;
        if (index !== activeIndex && length > 2) {
          index = this.processIndex(index, activeIndex, length);
        }
        if (this.$parent.type === 'card') {
          this.inStage = Math.round(Math.abs(index - activeIndex)) <= 1;
          this.active = index === activeIndex;
          this.translate = this.calculateTranslate(index, activeIndex, parentWidth);
          this.scale = this.active ? 1 : this.cardScale;
        } else {
          this.active = index === activeIndex;
          this.translate = parentWidth * (index - activeIndex);
        }
        this.ready = true;
      },
      handleItemClick: function() {
        var parent = this.$parent;
        if (parent && parent.type === 'card') {
          var index = parent.items.indexOf(this);
          parent.setActiveItem(index);
        }
      },
      handleMousewheel: throttle(500, true, function(e) {
        var parent = this.$parent;
        if (!parent.mousewhell) {
          return;
        }
        if (e.wheelDelta > 0) {
          parent.prev();
        } else {
          parent.next();
        }
      })
    },
    created: function() {
      this.$parent && this.$parent.updateItems();
      this.cardScale = 0.83;
    },
    destroyed: function() {
      this.$parent && this.$parent.updateItems();
    }
  };
  Vue.component(VueCarouselItem.name, VueCarouselItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueCard = definition(context.Vue);
    delete context.VueCard;
  }
})(this, function(Vue) {
  'use strict';
  var VueCard = {
    template: '<div  :class="[shadow ? \'is-\' + shadow + \'-shadow\' : \'is-hover-shadow\', \'vue-card\']"><div class="vue-card__header" v-if="$slots.header || header"><slot name="header">{{header}}</slot></div><div class="vue-card__body" :style="bodyStyle"><slot></slot></div></div>',
    name: 'VueCard',
    props: {
      header: {},
      bodyStyle: {},
      shadow: String
    }
  };
  Vue.component(VueCard.name, VueCard);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VuePopper'], definition);
  } else {
    context.VuePopover = definition(context.Vue, context.VueUtil, context.VuePopper);
    delete context.VuePopover;
  }
})(this, function(Vue, VueUtil, VuePopper) {
  'use strict';
  var VuePopover = {
    template: '<span><transition @after-leave="destroyPopper"><div :class="[\'vue-popover\', popperClass, {\'no-arrow\': !visibleArrow}]" ref="popper" v-show="!disabled && showPopper" :style="{width: popoverWidth + \'px\' \}"><div class="vue-popover__title" v-if="title" v-text="title"></div><slot>{{content}}</slot></div></transition><slot name="reference"></slot></span>',
    name: 'VuePopover',
    mixins: [VuePopper],
    props: {
      trigger: {
        type: String,
        default: 'click',
        validator: function(value) {
          return ['click', 'focus', 'hover', 'manual'].indexOf(value) !== -1;
        }
      },
      title: String,
      disabled: Boolean,
      content: String,
      reference: {},
      popperClass: String,
      width: [String, Number],
      visibleArrow: {
        type: Boolean,
        default: true
      }
    },
    data: function() {
      return {
        popoverWidth: null
      };
    },
    watch: {
      showPopper: function(newVal, oldVal) {
        if (newVal) {
          this.popoverWidth = this.width;
          if (!this.popoverWidth) {
            var reference = this.reference || this.$refs.reference;
            this.popoverWidth = parseInt(VueUtil.getStyle(reference, 'width'));
          }
          this.$emit('show');
        } else {
          this.$emit('hide');
        }
      }
    },
    methods: {
      bindEvents: function() {
        var self = this;
        var reference = self.reference || self.$refs.reference;
        var popper = self.popper || self.$refs.popper;
        if (!reference && self.$slots.reference && self.$slots.reference[0]) {
          reference = self.referenceElm = self.$slots.reference[0].elm;
        }
        if (self.trigger === 'click') {
          VueUtil.on(reference, 'click', self.doToggle);
          VueUtil.on(document, 'click', self.documentClick);
        } else if (self.trigger === 'hover') {
          VueUtil.on(reference, 'mouseenter', self.mouseEnter);
          VueUtil.on(popper, 'mouseenter', self.mouseEnter);
          VueUtil.on(reference, 'mouseleave', self.mouseLeave);
          VueUtil.on(popper, 'mouseleave', self.mouseLeave);
        } else if (self.trigger === 'focus') {
          var found = false;
          if ([].slice.call(reference.children).length) {
            VueUtil.loop(reference.childNodes, function(child) {
              if (child.nodeName === 'INPUT' || child.nodeName === 'TEXTAREA') {
                VueUtil.on(child, 'focus', self.doShow);
                VueUtil.on(child, 'blur', self.doClose);
                found = true;
                return false;
              }
            });
          }
          if (found) return;
          if (reference.nodeName === 'INPUT' || reference.nodeName === 'TEXTAREA') {
            VueUtil.on(reference, 'focus', self.doShow);
            VueUtil.on(reference, 'blur', self.doClose);
          } else {
            VueUtil.on(reference, 'mousedown', self.doShow);
            VueUtil.on(reference, 'mouseup', self.doClose);
          }
        }
      },
      unBindEvents: function() {
        var self = this;
        var reference = self.reference || self.$refs.reference;
        var popper = self.popper || self.$refs.popper;
        if (!reference && self.$slots.reference && self.$slots.reference[0]) {
          reference = self.referenceElm = self.$slots.reference[0].elm;
        }
        if (self.trigger === 'click') {
          VueUtil.off(reference, 'click', self.doToggle);
          VueUtil.off(document, 'click', self.documentClick);
        } else if (self.trigger === 'hover') {
          VueUtil.off(reference, 'mouseenter', self.mouseEnter);
          VueUtil.off(popper, 'mouseenter', self.mouseEnter);
          VueUtil.off(reference, 'mouseleave', self.mouseLeave);
          VueUtil.off(popper, 'mouseleave', self.mouseLeave);
        } else if (self.trigger === 'focus') {
          var found = false;
          if ([].slice.call(reference.children).length) {
            VueUtil.loop(reference.childNodes, function(child) {
              if (child.nodeName === 'INPUT' || child.nodeName === 'TEXTAREA') {
                VueUtil.off(child, 'focus', self.doShow);
                VueUtil.off(child, 'blur', self.doClose);
                found = true;
                return false;
              }
            });
          }
          if (found) return;
          if (reference.nodeName === 'INPUT' || reference.nodeName === 'TEXTAREA') {
            VueUtil.off(reference, 'focus', self.doShow);
            VueUtil.off(reference, 'blur', self.doClose);
          } else {
            VueUtil.off(reference, 'mousedown', self.doShow);
            VueUtil.off(reference, 'mouseup', self.doClose);
          }
        }
      },
      doToggle: function() {
        this.showPopper = !this.showPopper;
      },
      doShow: function() {
        this.showPopper = true;
      },
      doClose: function() {
        this.showPopper = false;
      },
      mouseToggle: VueUtil.debounce(30, function(showPopper) {
        this.showPopper = showPopper;
      }),
      mouseEnter: function() {
        this.mouseToggle(true);
      },
      mouseLeave: function() {
        this.mouseToggle(false);
      },
      documentClick: function(e) {
        var reference = this.reference || this.$refs.reference;
        var popper = this.popper || this.$refs.popper;
        if (!reference && this.$slots.reference && this.$slots.reference[0]) {
          reference = this.referenceElm = this.$slots.reference[0].elm;
        }
        if (!this.$el || !reference || this.$el.contains(e.target) || reference.contains(e.target) || !popper || popper.contains(e.target))
          return;
        this.showPopper = false;
      }
    },
    mounted: function() {
      this.bindEvents();
    },
    destroyed: function() {
      this.unBindEvents();
    }
  };
  var directive = function(el, binding, vnode) {
    vnode.context.$refs[binding.arg].$refs.reference = el;
  };
  Vue.directive('popover', directive);
  VuePopover.directive = directive;
  Vue.component(VuePopover.name, VuePopover);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopper', 'VueUtil'], definition);
  } else {
    context.VueCascader = definition(context.Vue, context.VuePopper, context.VueUtil);
    delete context.VueCascader;
  }
})(this, function(Vue, VuePopper, VueUtil) {
  'use strict';
  var VueCascaderMenu = {
    name: 'VueCascaderMenu',
    data: function() {
      return {
        inputWidth: 0,
        options: [],
        props: {},
        visible: false,
        activeValue: [],
        value: [],
        expandTrigger: 'click',
        changeOnSelect: false,
        popperClass: ''
      };
    },
    watch: {
      visible: function(value) {
        if (value) {
          this.activeValue = this.value;
        }
      },
      value: {
        immediate: true,
        handler: function(value) {
          this.activeValue = value;
        }
      }
    },
    computed: {
      activeOptions: {
        cache: false,
        get: function() {
          var self = this;
          var activeValue = self.activeValue;
          var configurableProps = ['label', 'value', 'children', 'disabled'];
          var formatOptions = function(options) {
            VueUtil.loop(options, function(option) {
              if (option.__IS__FLAT__OPTIONS) return;
              VueUtil.loop(configurableProps, function(prop) {
                var value = option[self.props[prop] || prop];
                if (value)
                  option[prop] = value;
              });
              if (VueUtil.isArray(option.children)) {
                formatOptions(option.children);
              }
            });
          };
          var loadActiveOptions = function(options, activeOptions) {
            options = options || [];
            activeOptions = activeOptions || [];
            var level = activeOptions.length;
            activeOptions[level] = options;
            var active = activeValue[level];
            if (active) {
              options = VueUtil.filter(options, function(option) {
                return option.value === active;
              })[0];
              if (options && options.children) {
                loadActiveOptions(options.children, activeOptions);
              }
            }
            return activeOptions;
          };
          formatOptions(self.options);
          return loadActiveOptions(self.options);
        }
      }
    },
    methods: {
      select: function(item, menuIndex) {
        if (item.__IS__FLAT__OPTIONS) {
          this.activeValue = item.value;
        } else if (menuIndex) {
          this.activeValue.splice(menuIndex, this.activeValue.length - 1, item.value);
        } else {
          this.activeValue = [item.value];
        }
        this.$emit('pick', this.activeValue);
      },
      handleMenuLeave: function() {
        this.$emit('menuLeave');
      },
      activeItem: function(item, menuIndex) {
        var len = this.activeOptions.length;
        this.activeValue.splice(menuIndex, len, item.value);
        this.activeOptions.splice(menuIndex + 1, len, item.children);
        if (this.changeOnSelect) {
          this.$emit('pick', this.activeValue, false);
        } else {
          this.$emit('activeItemChange', this.activeValue);
        }
      }
    },
    render: function(createElement) {
      var self = this;
      var activeValue = self.activeValue
        , activeOptions = self.activeOptions
        , visible = self.visible
        , expandTrigger = self.expandTrigger
        , popperClass = self.popperClass;
      var menus = self._l(activeOptions, function(menu, menuIndex) {
        var isFlat = false;
        var items = self._l(menu, function(item, itemIndex) {
          var events = {
            on: {}
          };
          if (item.__IS__FLAT__OPTIONS)
            isFlat = true;
          if (!item.disabled) {
            if (item.children) {
              var triggerEvent = {
                click: 'click',
                hover: 'mouseenter'
              }[expandTrigger];
              events.on[triggerEvent] = function() {
                self.activeItem(item, menuIndex);
              };
            } else {
              events.on.click = function() {
                self.select(item, menuIndex);
              };
            }
          }
          return createElement('li', {
            key: itemIndex,
            class: {
              'vue-cascader-menu__item': !0,
              'vue-cascader-menu__item--extensible': item.children,
              'is-active': item.value === activeValue[menuIndex],
              'is-disabled': item.disabled
            },
            on: events.on
          }, [item.label]);
        });
        var menuStyle = {};
        if (isFlat) {
          menuStyle.minWidth = self.inputWidth + 'px';
        }
        return createElement('ul', {
          key: menuIndex,
          class: {
            'vue-cascader-menu': true,
            'vue-cascader-menu--flexible': isFlat
          },
          style: menuStyle
        }, [items]);
      });
      return createElement('transition', {
        on: {
          'after-leave': self.handleMenuLeave
        }
      }, [createElement('div', {
        directives: [{
          name: 'show',
          value: visible
        }],
        class: ['vue-cascader-menus', popperClass]
      }, [menus])]);
    }
  };
  var popperMixin = {
    props: {
      placement: {
        type: String,
        default: 'bottom-start'
      },
      offset: VuePopper.props.offset,
      popperOptions: VuePopper.props.options
    },
    methods: VuePopper.methods,
    data: VuePopper.data,
    beforeDestroy: VuePopper.beforeDestroy
  };
  var VueCascader = {
    template: '<span :class="[\'vue-cascader\', {\'is-opened\': menuVisible, \'is-disabled\': disabled},size ? \'vue-cascader--\' + size : \'\']" @click="handleClick" @mouseenter="inputHover = true" @mouseleave="inputHover = false" ref="reference" v-clickoutside="handleClickoutside"><vue-input :text-align="textAlign" ref="input" :autofocus="autofocus" :tabindex="tabindex" :readonly="!filterable" :placeholder="currentLabels.length ? \'\' : placeholderLang" v-model="inputValue" @change="debouncedInputChange" :validate-event="false" :size="size" :disabled="disabled"><template slot="icon"><i key="1" v-if="clearable && inputHover && currentLabels.length" class="vue-input__icon vue-icon-error vue-cascader__clearIcon" @click="clearValue"></i><i key="2" v-else :class="[\'vue-input__icon vue-icon-arrow-up\', {\'is-reverse\': menuVisible}]"></i></template></vue-input><span class="vue-cascader__label" v-show="inputValue === \'\'"><template v-if="showAllLevels"><template v-for="(label, index) in currentLabels">{{label}}<span v-if="index < currentLabels.length - 1"> / </span></template></template><template v-else>{{currentLabels[currentLabels.length - 1]}}</template></span></span>',
    name: 'VueCascader',
    directives: {
      Clickoutside: VueUtil.component.clickoutside()
    },
    mixins: [popperMixin, VueUtil.component.emitter],
    props: {
      options: {
        type: Array,
        required: true
      },
      props: {
        type: Object,
        default: function() {
          return {
            children: 'children',
            label: 'label',
            value: 'value',
            disabled: 'disabled'
          };
        }
      },
      value: {
        type: Array,
        default: function() {
          return [];
        }
      },
      placeholder: String,
      disabled: Boolean,
      clearable: Boolean,
      changeOnSelect: Boolean,
      popperClass: String,
      expandTrigger: {
        type: String,
        default: 'click'
      },
      filterable: Boolean,
      size: String,
      autofocus: Boolean,
      textAlign: String,
      tabindex: Number,
      showAllLevels: {
        type: Boolean,
        default: true
      }
    },
    data: function() {
      return {
        currentValue: this.value,
        menu: null,
        menuVisible: false,
        inputHover: false,
        inputValue: '',
        flatOptions: null
      };
    },
    computed: {
      placeholderLang: function() {
        if (!this.placeholder)
          return this.$t('vue.cascader.placeholder');
        return this.placeholder;
      },
      labelKey: function() {
        return this.props.label || 'label';
      },
      valueKey: function() {
        return this.props.value || 'value';
      },
      childrenKey: function() {
        return this.props.children || 'children';
      },
      currentLabels: function() {
        var self = this;
        var options = self.options || [];
        var labels = [];
        VueUtil.loop(self.currentValue, function(value) {
          var targetOption = VueUtil.filter(options, function(option) {
            return option[self.valueKey] === value;
          })[0];
          if (targetOption) {
            labels.push(targetOption[self.labelKey]);
            options = targetOption[self.childrenKey];
          }
        });
        return labels;
      }
    },
    watch: {
      menuVisible: function(value) {
        value ? this.showMenu() : this.hideMenu();
      },
      value: function(value) {
        this.currentValue = value;
      },
      currentValue: function(value) {
        this.dispatch('VueFormItem', 'vue.form.change', [value]);
      },
      options: {
        deep: true,
        handler: function(value) {
          if (!this.menu) {
            this.initMenu();
          }
          this.flatOptions = this.flattenOptions(this.options);
          this.menu.options = value;
        }
      }
    },
    methods: {
      focus: function() {
        this.$refs.input.focus();
      },
      initMenu: function() {
        this.menu = new Vue(VueCascaderMenu).$mount();
        this.menu.options = this.options;
        this.menu.props = this.props;
        this.menu.expandTrigger = this.expandTrigger;
        this.menu.changeOnSelect = this.changeOnSelect;
        this.menu.popperClass = this.popperClass;
        this.popperElm = this.menu.$el;
        this.menu.$on('pick', this.handlePick);
        this.menu.$on('activeItemChange', this.handleActiveItemChange);
        this.menu.$on('menuLeave', this.destroyPopper);
      },
      showMenu: function() {
        var self = this;
        if (!self.menu) {
          self.initMenu();
        }
        self.menu.value = VueUtil.mergeArray([], self.currentValue);
        self.menu.visible = true;
        self.menu.options = self.options;
        self.$nextTick(function() {
          self.updatePopper();
          self.menu.inputWidth = self.$refs.input.$el.offsetWidth - 2;
        });
      },
      hideMenu: function() {
        this.inputValue = '';
        this.menu.visible = false;
      },
      handleActiveItemChange: function(value) {
        var self = this;
        self.$nextTick(function() {
          self.updatePopper();
        });
        self.$emit('active-item-change', value);
      },
      handlePick: function(value, close) {
        if (!VueUtil.isDef(close)) close = true;
        this.currentValue = value;
        this.$emit('input', value);
        this.$emit('change', value);
        if (close) {
          this.menuVisible = false;
        }
        this.$nextTick(this.focus);
      },
      handleInputChange: function(value) {
        var self = this;
        if (!self.menuVisible)
          return;
        var flatOptions = self.flatOptions;
        if (!value) {
          self.menu.options = self.options;
          return;
        }
        var filteredFlatOptions = VueUtil.filter(flatOptions, function(optionsStack) {
          return optionsStack.some(function(option) {
            return new RegExp(value, 'i').test(option[self.labelKey]);
          });
        });
        if (filteredFlatOptions.length > 0) {
          filteredFlatOptions = VueUtil.map(filteredFlatOptions, function(optionStack) {
            return {
              __IS__FLAT__OPTIONS: true,
              value:  VueUtil.map(optionStack, function(item) {
                return item[self.valueKey];
              }),
              label: self.renderFilteredOptionLabel(value, optionStack)
            };
          });
        } else {
          filteredFlatOptions = [{
            __IS__FLAT__OPTIONS: true,
            label: self.$t('vue.cascader.noMatch'),
            value: '',
            disabled: true
          }];
        }
        self.menu.options = filteredFlatOptions;
      },
      renderFilteredOptionLabel: function(inputValue, optionsStack) {
        var self = this;
        return  VueUtil.map(optionsStack, function(option, index) {
          var label = option[self.labelKey];
          var keywordIndex = label.toLowerCase().indexOf(inputValue.toLowerCase());
          var labelPart = label.slice(keywordIndex, inputValue.length + keywordIndex);
          var node = keywordIndex !== -1 ? self.highlightKeyword(label, labelPart) : label;
          return index === 0 ? node : [' / ', node];
        });
      },
      highlightKeyword: function(label, keyword) {
        var self = this;
        var h = self._c;
        return  VueUtil.map(label.split(keyword), function(node, index) {
          return index === 0 ? node : [h('span', {
            class: {
              'vue-cascader-menu__item__keyword': true
            }
          }, [self._v(keyword)]), node];
        });
      },
      flattenOptions: function(options, ancestor) {
        options = options || [];
        ancestor = ancestor || [];
        var self = this;
        var flatOptions = [];
        VueUtil.loop(options, function(option) {
          var optionsStack = VueUtil.mergeArray(ancestor, option);
          if (!option[self.childrenKey]) {
            flatOptions.push(optionsStack);
          } else {
            if (self.changeOnSelect) {
              flatOptions.push(optionsStack);
            }
            VueUtil.mergeArray(flatOptions, self.flattenOptions(option[self.childrenKey], optionsStack));
          }
        });
        return flatOptions;
      },
      clearValue: function(ev) {
        ev.stopPropagation();
        this.handlePick([], true);
      },
      handleClickoutside: function() {
        this.menuVisible = false;
      },
      handleClick: function() {
        if (this.disabled)
          return;
        if (this.filterable) {
          this.menuVisible = true;
          return;
        }
        this.menuVisible = !this.menuVisible;
      },
      debouncedInputChange: VueUtil.debounce(function(value) {
        this.handleInputChange(value);
      })
    },
    mounted: function() {
      this.flatOptions = this.flattenOptions(this.options);
    },
    beforeDestroy: function() {
      if (this.menu) {
        this.menu.$destroy();
      }
    }
  };
  Vue.component(VueCascader.name, VueCascader);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueStep = definition(context.Vue, context.VueUtil);
    delete context.VueStep;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueStep = {
    template: '<div :style="[style, isLast ? \'\' : {marginRight: - $parent.stepOffset + \'px\'}]" :class="[\'vue-step\', \'is-\' + $parent.direction]"><div :class="[\'vue-step__head\', \'is-\' + currentStatus, {\'is-text\': !icon}]"><div :style="isLast ? \'\' : {marginRight: $parent.stepOffset + \'px\'}" :class="[\'vue-step__line\', \'is-\' + $parent.direction, {\'is-icon\': icon}]"><i class="vue-step__line-inner" :style="lineStyle"></i></div><span class="vue-step__icon"><slot v-if="currentStatus !== \'success\' && currentStatus !== \'error\'" name="icon"><i v-if="icon" :class="icon"></i><div v-else>{{index + 1}}</div></slot><i v-else :class="[\'vue-icon-\' + (currentStatus === \'success\' ? \'check\' : \'close\')]"></i></span></div><div class="vue-step__main" :style="{marginLeft: mainOffset}"><div ref="title" :class="[\'vue-step__title\', \'is-\' + currentStatus]"><slot name="title">{{title}}</slot></div><div :class="[\'vue-step__description\', \'is-\' + currentStatus]"><slot></slot></div></div></div>',
    name: 'VueStep',
    props: {
      title: String,
      icon: String,
      status: String
    },
    data: function() {
      return {
        index: -1,
        lineStyle: {},
        mainOffset: 0,
        internalStatus: ''
      };
    },
    beforeCreate: function() {
      this.$parent.steps.push(this);
    },
    computed: {
      currentStatus: function() {
        return this.status || this.internalStatus;
      },
      isLast: function() {
        var parent = this.$parent;
        return parent.steps[parent.steps.length - 1] === this;
      },
      style: function() {
        var parent = this.$parent;
        var isCenter = parent.center;
        var len = parent.steps.length;
        if (isCenter && this.isLast) {
          return {};
        }
        var space = (VueUtil.isNumber(parent.space) ? parent.space + 'px' : parent.space ? parent.space : 100 / (isCenter ? len - 1 : len) + '%');
        if (parent.direction === 'horizontal') {
          return {
            width: space
          };
        } else {
          if (!this.isLast) {
            return {
              height: space
            };
          }
        }
      }
    },
    methods: {
      updateStatus: function(val) {
        var prevChild = this.$parent.$children[this.index - 1];
        if (val > this.index) {
          this.internalStatus = this.$parent.finishStatus;
        } else if (val === this.index) {
          this.internalStatus = this.$parent.processStatus;
        } else {
          this.internalStatus = 'wait';
        }
        if (prevChild)
          prevChild.calcProgress(this.internalStatus);
      },
      calcProgress: function(status) {
        var step = 100;
        var style = {};
        style.transitionDelay = 150 * this.index + 'ms';
        if (status === this.$parent.processStatus) {
          step = 50;
        } else if (status === 'wait') {
          step = 0;
          style.transitionDelay = (-150 * this.index) + 'ms';
        }
        style.borderWidth = step ? '1px' : 0;
        this.$parent.direction === 'vertical' ? style.height = step + '%' : style.width = step + '%';
        this.lineStyle = style;
      }
    },
    mounted: function() {
      var self = this;
      var parent = self.$parent;
      if (parent.direction === 'horizontal') {
        if (parent.alignCenter) {
          self.mainOffset = -self.$refs.title.getBoundingClientRect().width / 2 + 16 + 'px';
        }
      }
      var unwatch = self.$watch('index', function(val) {
        self.$watch('$parent.active', self.updateStatus, {
          immediate: true
        });
        unwatch();
      });

      self.$watch('$parent.alignCenter', function(value) {
        if(value) {
            self.mainOffset = -self.$refs.title.getBoundingClientRect().width / 2 + 16 + 'px';
        } else {
            self.mainOffset = 0;
        }
      });
    }
  };
  Vue.component(VueStep.name, VueStep);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueSteps = definition(context.Vue, context.VueUtil);
    delete context.VueSteps;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueSteps = {
    template: '<div :class="[\'vue-steps\', \'is-\' + direction, center ? \'is-center\' : \'\']"><slot></slot></div>',
    name: 'VueSteps',
    props: {
      space: [Number, String],
      active: Number,
      direction: {
        type: String,
        default: 'horizontal'
      },
      alignCenter: Boolean,
      center: Boolean,
      finishStatus: {
        type: String,
        default: 'finish'
      },
      processStatus: {
        type: String,
        default: 'process'
      }
    },
    data: function() {
      return {
        steps: [],
        stepOffset: 0
      };
    },
    watch: {
      active: function(newVal, oldVal) {
        this.$emit('change', newVal, oldVal);
      },
      steps: function(steps) {
        var self = this;
        VueUtil.loop(steps, function(child, index) {
          child.index = index;
        });
        if (self.center) {
          var len = steps.length;
          self.$nextTick(function() {
            self.stepOffset = steps[len - 1].$el.getBoundingClientRect().width / (len - 1);
          });
        }
      }
    }
  };
  Vue.component(VueSteps.name, VueSteps);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueDropdown = definition(context.Vue, context.VueUtil);
    delete context.VueDropdown;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueDropdown = {
    template: '',
    name: 'VueDropdown',
    mixins: [VueUtil.component.emitter],
    directives: {
      Clickoutside: VueUtil.component.clickoutside()
    },
    props: {
      trigger: {
        type: String,
        default: 'hover'
      },
      menuAlign: {
        type: String,
        default: 'end'
      },
      type: String,
      size: String,
      splitButton: Boolean,
      hideOnClick: {
        type: Boolean,
        default: true
      }
    },
    data: function() {
      return {
        visible: false
      };
    },
    beforeDestroy: function() {
      this.unBindEvents();
    },
    mounted: function() {
      this.$on('menu-item-click', this.handleMenuItemClick);
      this.bindEvents();
    },
    watch: {
      visible: function(val) {
        this.broadcast('VueDropdownMenu', 'visible', val);
        this.$emit('visible-change', val);
      }
    },
    methods: {
      toggle: VueUtil.debounce(30, function(visible) {
        this.visible = visible;
      }),
      show: function() {
        this.toggle(true);
      },
      hide: function() {
        this.toggle(false);
      },
      handleClick: function() {
        this.visible = !this.visible;
      },
      bindEvents: function() {
        var trigger = this.trigger;
        var show = this.show;
        var hide = this.hide;
        var handleClick = this.handleClick;
        var splitButton = this.splitButton;
        var triggerElm = splitButton ? this.$refs.trigger.$el : this.$slots.default[0].elm;
        if (trigger === 'hover') {
          VueUtil.on(triggerElm, 'mouseenter', show);
          VueUtil.on(triggerElm, 'mouseleave', hide);
          var dropdownElm = this.$slots.dropdown[0].elm;
          VueUtil.on(dropdownElm, 'mouseenter', show);
          VueUtil.on(dropdownElm, 'mouseleave', hide);
        } else if (trigger === 'click') {
          VueUtil.on(triggerElm, 'click', handleClick);
        }
      },
      unBindEvents: function() {
        var trigger = this.trigger;
        var show = this.show;
        var hide = this.hide;
        var handleClick = this.handleClick;
        var splitButton = this.splitButton;
        var triggerElm = splitButton ? this.$refs.trigger.$el : this.$slots.default[0].elm;
        if (trigger === 'hover') {
          VueUtil.off(triggerElm, 'mouseenter', show);
          VueUtil.off(triggerElm, 'mouseleave', hide);
          var dropdownElm = this.$slots.dropdown[0].elm;
          VueUtil.off(dropdownElm, 'mouseenter', show);
          VueUtil.off(dropdownElm, 'mouseleave', hide);
        } else if (trigger === 'click') {
          VueUtil.off(triggerElm, 'click', handleClick);
        }
        
      },
      handleMenuItemClick: function(command, instance) {
        if (this.hideOnClick) {
          this.visible = false;
        }
        this.$emit('command', command, instance);
      }
    },
    render: function(createElement) {
      var self = this;
      var hide = self.hide
        , splitButton = self.splitButton
        , type = self.type
        , size = self.size;
      var handleClick = function() {
        self.$emit('click');
      };
      var triggerElm = !splitButton ? self.$slots.default : createElement('vue-button-group', null, [createElement('vue-button', {
        attrs: {
          type: type,
          size: size
        },
        nativeOn: {
          click: handleClick
        }
      }, [self.$slots.default]), createElement('vue-button', {
        ref: 'trigger',
        attrs: {
          type: type,
          size: size
        },
        class: 'vue-dropdown__caret-button'
      }, [createElement('i', {
        class: 'vue-dropdown__icon vue-icon-arrow-down'
      }, [])])]);
      return createElement('div', {
        class: 'vue-dropdown',
        directives: [{
          name: 'clickoutside',
          value: hide
        }]
      }, [triggerElm, self.$slots.dropdown]);
    }
  };
  Vue.component(VueDropdown.name, VueDropdown);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueDropdownItem = definition(context.Vue, context.VueUtil);
    delete context.VueDropdownItem;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueDropdownItem = {
    template: '<li :class="[\'vue-dropdown-menu__item\', {\'is-disabled\': disabled, \'vue-dropdown-menu__item--divided\': divided}]" @click="handleClick"><slot></slot></li>',
    name: 'VueDropdownItem',
    mixins: [VueUtil.component.emitter],
    props: {
      command: String,
      disabled: Boolean,
      divided: Boolean
    },
    methods: {
      handleClick: function(e) {
        this.dispatch('VueDropdown', 'menu-item-click', [this.command, this]);
      }
    }
  };
  Vue.component(VueDropdownItem.name, VueDropdownItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePopper'], definition);
  } else {
    context.VueDropdownMenu = definition(context.Vue, context.VuePopper);
    delete context.VueDropdownMenu;
  }
})(this, function(Vue, VuePopper) {
  'use strict';
  var VueDropdownMenu = {
    template: '<transition @after-leave="destroyPopper"><div class="vue-dropdown-menu" v-show="showPopper"><ul class="vue-dropdown-menu__view"><slot></slot></ul></div></transition>',
    name: 'VueDropdownMenu',
    mixins: [VuePopper],
    created: function() {
      var self = this;
      self.$on('updatePopper', self.updatePopper);
      self.$on('visible', function(val) {
        self.showPopper = val;
      });
    },
    mounted: function() {
      this.$parent.popperElm = this.popperElm = this.$el;
      this.referenceElm = this.$parent.$el;
    },
    watch: {
      '$parent.menuAlign': {
        immediate: true,
        handler: function(val) {
          this.currentPlacement = 'bottom-' + val;
        }
      }
    }
  };
  Vue.component(VueDropdownMenu.name, VueDropdownMenu);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCollapse = definition(context.Vue, context.VueUtil);
    delete context.VueCollapse;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCollapse = {
    template: '<div class="vue-collapse"><slot></slot></div>',
    name: 'VueCollapse',
    props: {
      accordion: Boolean,
      value: {
        type: [Array, String, Number],
        default: function() {
          return [];
        }
      },
      expandOnClickHeader: {
        type: Boolean,
        default: true
      }
    },
    data: function() {
      return {
        activeNames: VueUtil.mergeArray([], this.value)
      };
    },
    watch: {
      value: function(value) {
        this.activeNames = VueUtil.mergeArray([], value);
      }
    },
    methods: {
      setActiveNames: function(activeNames) {
        activeNames = VueUtil.mergeArray([], activeNames);
        var value = this.accordion ? activeNames[0] : activeNames;
        this.activeNames = activeNames;
        this.$emit('input', value);
      },
      handleItemClick: function(item) {
        if (this.accordion) {
          this.setActiveNames(
            this.activeNames[0] &&
              this.activeNames[0] === item.name
              ? '' : item.name
          );
        } else {
          var activeNames = VueUtil.mergeArray([], this.activeNames);
          var index = activeNames.indexOf(item.name);
          if (index !== -1) {
            activeNames.splice(index, 1);
          } else {
            activeNames.push(item.name);
          }
          this.setActiveNames(activeNames);
        }
      }
    },
    created: function() {
      this.$on('item-click', this.handleItemClick);
    }
  };
  Vue.component(VueCollapse.name, VueCollapse);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueCollapseItem = definition(context.Vue, context.VueUtil);
    delete context.VueCollapseItem;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueCollapseItem = {
    template: '<div :class="[\'vue-collapse-item\', {\'is-active\': isActive}]"><div :class="[\'vue-collapse-item__header\', {\'header-expand\': headerExpand}]" @click="handleHeaderClick"><i class="vue-collapse-item__header__arrow vue-icon-arrow-right" @click="handleIconClick" v-show="expandOnClick"></i><slot name="title">{{title}}</slot></div><collapse-transition><div class="vue-collapse-item__wrap" v-show="isActive"><div class="vue-collapse-item__content"><slot></slot></div></div></collapse-transition></div>',
    name: 'VueCollapseItem',
    mixins: [VueUtil.component.emitter],
    components: {
      CollapseTransition: VueUtil.component.collapseTransition
    },
    data: function() {
      return {
        contentWrapStyle: {
          height: 'auto',
          display: 'block'
        },
        contentHeight: 0
      };
    },
    props: {
      title: String,
      expandOnClick: {
        type: Boolean,
        default: true
      },
      name: {
        type: [String, Number],
        default: function() {
          return this._uid;
        }
      }
    },
    computed: {
      isActive: function() {
        return this.$parent.activeNames.indexOf(this.name) !== -1;
      },
      headerExpand: function() {
        return this.$parent.expandOnClickHeader;
      }
    },
    methods: {
      handleIconClick: function() {
        if (!this.headerExpand && this.expandOnClick) {
          this.dispatch('VueCollapse', 'item-click', this);
        }
      },
      handleHeaderClick: function() {
        if (this.headerExpand && this.expandOnClick) {
          this.dispatch('VueCollapse', 'item-click', this);
        }
      },
      collapseAfterEnter: function() {
        this.$parent.$emit('change', this.$parent.activeNames);
      },
      collapseAfterLeave: function() {
        this.$parent.$emit('change', this.$parent.activeNames);
      }
    }
  };
  Vue.component(VueCollapseItem.name, VueCollapseItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueBadge = definition(context.Vue, context.VueUtil);
    delete context.VueBadge;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueBadge = {
    template: '<div class="vue-badge"><slot></slot><sup v-show="!hidden && ( content || isDot )" v-text="content" :class="[\'vue-badge__content\', {\'is-fixed\': $slots.default, \'is-dot\': isDot }]"></sup></div>',
    name: 'VueBadge',
    props: {
      value: {},
      max: Number,
      isDot: Boolean,
      hidden: Boolean
    },
    computed: {
      content: function() {
        if (this.isDot) return;
        var value = this.value;
        var max = this.max;
        if (VueUtil.isNumber(value) && VueUtil.isNumber(max)) {
          return max < value ? max + '+' : value;
        }
        return value;
      }
    }
  };
  Vue.component(VueBadge.name, VueBadge);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueBreadcrumb = definition(context.Vue);
    delete context.VueBreadcrumb;
  }
})(this, function(Vue) {
  'use strict';
  var VueBreadcrumb = {
    template: '<div class="vue-breadcrumb"><slot></slot></div>',
    name: 'VueBreadcrumb',
    props: {
      separator: {
        type: String,
        default: '/'
      }
    }
  };
  Vue.component(VueBreadcrumb.name, VueBreadcrumb);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueBreadcrumbItem = definition(context.Vue, context.VueUtil);
    delete context.VueBreadcrumbItem;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueBreadcrumbItem = {
    template: '<span class="vue-breadcrumb__item"><span class="vue-breadcrumb__item__inner" ref="link"><slot></slot></span><span class="vue-breadcrumb__separator">{{$parent.separator}}</span></span>',
    name: 'VueBreadcrumbItem',
    props: {
      to: {},
      replace: Boolean
    },
    methods: {
      linkToDo: function() {
        var to = this.to;
        if (to && this.$router) {
          this.replace ? this.$router.replace(to) : this.$router.push(to);
        } else {
          this.$emit('click');
        }
      }
    },
    mounted: function() {
      VueUtil.on(this.$refs.link, 'click', this.linkToDo);
    },
    beforeDestroy: function() {
      VueUtil.off(this.$refs.link, 'click', this.linkToDo);
    }
  };
  Vue.component(VueBreadcrumbItem.name, VueBreadcrumbItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VuePopper'], definition);
  } else {
    context.VuePicker = definition(context.Vue, context.VueUtil, context.VuePopper);
  }
})(this, function(Vue, VueUtil, VuePopper) {
  'use strict';
  var NewPopper = {
    props: {
      appendToBody: VuePopper.props.appendToBody,
      offset: VuePopper.props.offset,
      boundariesPadding: VuePopper.props.boundariesPadding,
      autoWidth:VuePopper.props.autoWidth
    },
    methods: VuePopper.methods,
    data: function() {return VueUtil.merge({ visibleArrow: false }, VuePopper.data);},
    beforeDestroy: VuePopper.beforeDestroy
  };
  var formatDate = VueUtil.formatDate,
      parseDate = VueUtil.parseDate,
      isDateObject = VueUtil.isDateObject,
      getWeekNumber = VueUtil.getWeekNumber;

  
  var DEFAULT_FORMATS = {
    date: 'yyyy-MM-dd',
    month: 'yyyy-MM',
    datetime: 'yyyy-MM-dd HH:mm:ss',
    time: 'HH:mm:ss',
    week: 'yyyywWW',
    timerange: 'HH:mm:ss',
    daterange: 'yyyy-MM-dd',
    monthrange: 'yyyy-MM',
    datetimerange: 'yyyy-MM-dd HH:mm:ss',
    year: 'yyyy'
  };
  var HAVE_TRIGGER_TYPES = [
    'date',
    'datetime',
    'time',
    'time-select',
    'week',
    'month',
    'year',
    'daterange',
    'monthrange',
    'timerange',
    'datetimerange',
    'dates'
  ];
  var DATE_FORMATTER = function(value, format) {
    if (format === 'timestamp') return value.getTime();
    return formatDate(value, format);
  };
  var DATE_PARSER = function(text, format) {
    if (format === 'timestamp') return new Date(Number(text));
    return parseDate(text, format);
  };
  var RANGE_FORMATTER = function(value, format) {
    if (Array.isArray(value) && value.length === 2) {
      var start = value[0];
      var end = value[1];

      if (start && end) {
        return [DATE_FORMATTER(start, format), DATE_FORMATTER(end, format)];
      }
    }
    return '';
  };
  var RANGE_PARSER = function(array, format, separator) {
    if (!Array.isArray(array)) {
      array = array.split(separator);
    }
    if (array.length === 2) {
      var range1 = array[0];
      var range2 = array[1];

      return [DATE_PARSER(range1, format), DATE_PARSER(range2, format)];
    }
    return [];
  };
  var TYPE_VALUE_RESOLVER_MAP = {
    default: {
      formatter: function (value) {
        if (!value) return '';
        return '' + value;
      },
      parser: function (text) {
        if (text === undefined || text === '') return null;
        return text;
      }
    },
    week: {
      formatter: function (value, format) {
        var week = getWeekNumber(value);
        var month = value.getMonth();
        var trueDate = new Date(value);
  
        if (week === 1 && month === 11) {
          trueDate.setHours(0, 0, 0, 0);
          trueDate.setDate(trueDate.getDate() + 3 - (trueDate.getDay() + 6) % 7);
        }
  
        var date = formatDate(trueDate, format);
        date = /WW/.test(date) ? date.replace(/WW/, week < 10 ? '0' + week : week) : date.replace(/W/, week);
        return date;
      },
      parser: function (text, format) {
        // parse as if a normal date
        return TYPE_VALUE_RESOLVER_MAP.date.parser(text, format);
      }
    },
    date: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    datetime: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    daterange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    monthrange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    datetimerange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    timerange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    time: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    month: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    year: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    number: {
      formatter: function (value) {
        if (!value) return '';
        return '' + value;
      },
      parser: function (text) {
        var result = Number(text);
  
        if (!isNaN(text)) {
          return result;
        } else {
          return null;
        }
      }
    },
    dates: {
      formatter: function (value, format) {
        return value.map(function (date) {
          return DATE_FORMATTER(date, format);
        });
      },
      parser: function (value, format) {
        return (typeof value === 'string' ? value.split(', ') : value).map(function (date) {
          return date instanceof Date ? date : DATE_PARSER(date, format);
        });
      }
    }
  };
  var PLACEMENT_MAP = {
    left: 'bottom-start',
    center: 'bottom',
    right: 'bottom-end'
  };

  var parseAsFormatAndType = function (value, customFormat, type) {
    var rangeSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '-';
    if (!value) return null;
    var parser = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP['default']).parser;
    var format = customFormat || DEFAULT_FORMATS[type];
    return parser(value, format, rangeSeparator);
  };
  
  var formatAsFormatAndType = function (value, customFormat, type) {
    if (!value) return null;
    var formatter = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP['default']).formatter;
    var format = customFormat || DEFAULT_FORMATS[type];
    return formatter(value, format);
  };
  /*
  * Considers:
  *   1. Date object
  *   2. date string
  *   3. array of 1 or 2
  */
  
  
  var valueEquals = function (a, b) {
    // considers Date object and string
    var dateEquals = function (a, b) {
      var aIsDate = a instanceof Date;
      var bIsDate = b instanceof Date;
  
      if (aIsDate && bIsDate) {
        return a.getTime() === b.getTime();
      }
  
      if (!aIsDate && !bIsDate) {
        return a === b;
      }
  
      return false;
    };
  
    var aIsArray = a instanceof Array;
    var bIsArray = b instanceof Array;
  
    if (aIsArray && bIsArray) {
      if (a.length !== b.length) {
        return false;
      }
  
      return a.every(function (item, index) {
        return dateEquals(item, b[index]);
      });
    }
  
    if (!aIsArray && !bIsArray) {
      return dateEquals(a, b);
    }
  
    return false;
  };
  
  var isString = function (val) {
    return typeof val === 'string' || val instanceof String;
  };
  
  var validator = function (val) {
    // either: String, Array of String, null / undefined
    return val === null || val === undefined || isString(val) || Array.isArray(val) && val.length === 2 && val.every(isString);
  };

  var VuePicker = {
    template: 
    '  <vue-input'+
    '    class="vue-date-editor"'+
    '    :class="\'vue-date-editor--\' + type"'+
    '    :readonly="!editable || readonly || type === \'dates\' || type === \'week\'"'+
    '    :disabled="pickerDisabled"'+
    '    :size="pickerSize"'+
    '    :name="name"'+
    '    v-bind="firstInputId"'+
    '    v-if="!ranged"'+
    '    v-clickoutside="handleClose"'+
    '    :placeholder="placeholder"'+
    '    @focus="handleFocus"'+
    '    @keydown.native="handleKeydown"'+
    '    :value="displayValue"'+
    '    @input="function (value) {return userInput = value;}"'+
    '    @change="handleChange"'+
    '    @mouseenter.native="handleMouseEnter"'+
    '    @mouseleave.native="showClose = false"'+
    '    :validateEvent="false"'+
    '    :icon="showClose ? \'\' + clearIcon : \'\'"'+
    '    :on-icon-click="handleClickIcon"'+
    '    ref="reference">'+
    '    <i slot="prefix"'+
    '      class="vue-input__icon"'+
    '      :class="triggerClass"'+
    '      @click="handleFocus">'+
    '    </i>'+
    // '    <i slot="suffix"'+
    // '      class="vue-input__icon"'+
    // '      @click="handleClickIcon"'+
    // '      :class="[showClose ? \'\' + clearIcon : \'\']"'+
    // '      v-if="haveTrigger">'+
    // '    </i>'+
    '  </vue-input>'+
    '  <div'+
    '    class="vue-date-editor vue-range-editor vue-input__inner"'+
    '    :class="['+
    '      \'vue-date-editor--\' + type,'+
    '      pickerSize ? \'vue-range-editor--\' + pickerSize  : \'\','+
    '      pickerDisabled ? \'is-disabled\' : \'\','+
    '      pickerVisible ? \'is-active\' : \'\''+
    '    ]"'+
    '    @click="handleRangeClick"'+
    '    @mouseenter="handleMouseEnter"'+
    '    @mouseleave="showClose = false"'+
    '    @keydown="handleKeydown"'+
    '    ref="reference"'+
    '    v-clickoutside="handleClose"'+
    '    v-else>'+
    '    <i :class="[\'vue-input__icon\', \'vue-range__icon\', triggerClass]"></i>'+
    '    <input'+
    '      autocompvare="off"'+
    '      :placeholder="startPlaceholder"'+
    '      :value="displayValue && displayValue[0]"'+
    '      :disabled="pickerDisabled"'+
    '      v-bind="firstInputId"'+
    '      :readonly="!editable || readonly"'+
    '      :name="name && name[0]"'+
    '      @input="handleStartInput"'+
    '      @change="handleStartChange"'+
    '      @focus="handleFocus"'+
    '      class="vue-range-input">'+
    '    <slot name="range-separator">'+
    '      <span class="vue-range-separator">{{ rangeSeparator }}</span>'+
    '    </slot>'+
    '    <input'+
    '      autocompvare="off"'+
    '      :placeholder="endPlaceholder"'+
    '      :value="displayValue && displayValue[1]"'+
    '      :disabled="pickerDisabled"'+
    '      v-bind="secondInputId"'+
    '      :readonly="!editable || readonly"'+
    '      :name="name && name[1]"'+
    '      @input="handleEndInput"'+
    '      @change="handleEndChange"'+
    '      @focus="handleFocus"'+
    '      class="vue-range-input">'+
    '    <i'+
    '      @click="handleClickIcon"'+
    '      v-if="haveTrigger"'+
    '      :class="[showClose ? \'\' + clearIcon : \'\']"'+
    '      class="vue-input__icon vue-range__close-icon">'+
    '    </i>'+
    '  </div>',
    mixins: [VueUtil.component.emitter, NewPopper],
    directives: {
      Clickoutside: VueUtil.component.clickoutside()
    },
    props: {
      size: String,
      format: String,
      valueFormat: String,
      readonly: Boolean,
      placeholder: String,
      startPlaceholder: String,
      endPlaceholder: String,
      prefixIcon: String,
      clearIcon: {
        type: String,
        default: 'vue-icon-close'
      },
      name: {
        default: '',
        validator: validator
      },
      disabled: Boolean,
      clearable: {
        type: Boolean,
        default: true
      },
      id: {
        default: '',
        validator: validator
      },
      popperClass: String,
      editable: {
        type: Boolean,
        default: true
      },
      align: {
        type: String,
        default: 'left'
      },
      value: {},
      defaultValue: {},
      defaultTime: {},
      rangeSeparator: {
        default: '-'
      },
      pickerOptions: {},
      unlinkPanels: Boolean,
      validateEvent: {
        type: Boolean,
        default: true
      }
    },
    data: function () {
      return {
        pickerVisible: false,
        showClose: false,
        userInput: null,
        valueOnOpen: null,
        // value when picker opens, used to determine whether to emit change
        unwatchPickerOptions: null
      };
    },
    watch: {
      pickerVisible: function (val) {
        if (this.readonly || this.pickerDisabled) return;
  
        if (val) {
          this.showPicker();
          this.valueOnOpen = Array.isArray(this.value) ?  this.value.slice() : this.value;
        } else {
          this.hidePicker();
          this.emitChange(this.value);
          this.userInput = null;
  
          if (this.validateEvent) {
            this.dispatch('VueFormItem', 'vue.form.blur');
          }
  
          this.$emit('blur', this);
          this.blur();
        }
      },
      parsedValue: {
        immediate: true,
        handler: function (val) {
          if (this.picker) {
            this.picker.value = val;
          }
        }
      },
      defaultValue: function (val) {
        // NOTE: should eventually move to jsx style picker + panel ?
        if (this.picker) {
          this.picker.defaultValue = val;
        }
      },
      value: function (val, oldVal) {
        if (!valueEquals(val, oldVal) && !this.pickerVisible && this.validateEvent) {
          this.dispatch('VueFormItem', 'vue.form.change', val);
        }
      }
    },
    computed: {
      ranged: function () {
        return this.type.indexOf('range') > -1;
      },
      reference: function () {
        var reference = this.$refs.reference;
        return reference.$el || reference;
      },
      refInput: function () {
        if (this.reference) {
          return [].slice.call(this.reference.querySelectorAll('input'));
        }
  
        return [];
      },
      valueIsEmpty: function () {
        var val = this.value;
  
        if (Array.isArray(val)) {
          for (var i = 0, len = val.length; i < len; i++) {
            if (val[i]) {
              return false;
            }
          }
        } else {
          if (val) {
            return false;
          }
        }
  
        return true;
      },
      triggerClass: function () {
        return this.prefixIcon || (this.type.indexOf('time') !== -1 ? 'vue-icon-time' : 'vue-icon-date');
      },
      selectionMode: function () {
        if (this.type === 'week') {
          return 'week';
        } else if (this.type === 'month') {
          return 'month';
        } else if (this.type === 'year') {
          return 'year';
        } else if (this.type === 'dates') {
          return 'dates';
        }
  
        return 'day';
      },
      haveTrigger: function () {
        if (typeof this.showTrigger !== 'undefined') {
          return this.showTrigger;
        }
  
        return HAVE_TRIGGER_TYPES.indexOf(this.type) !== -1;
      },
      displayValue: function () {
        var formattedValue = formatAsFormatAndType(this.parsedValue, this.format, this.type, this.rangeSeparator);
  
        if (Array.isArray(this.userInput)) {
          return [this.userInput[0] || formattedValue && formattedValue[0] || '', this.userInput[1] || formattedValue && formattedValue[1] || ''];
        } else if (this.userInput !== null) {
          return this.userInput;
        } else if (formattedValue) {
          return this.type === 'dates' ? formattedValue.join(', ') : formattedValue;
        } else {
          return '';
        }
      },
      parsedValue: function () {
        if (!this.value) return this.value; // component value is not set
  
        if (this.type === 'time-select') return this.value; // time-select does not require parsing, this might change in next major version
  
        var valueIsDateObject = isDateObject(this.value) || Array.isArray(this.value) && this.value.every(isDateObject);
  
        if (valueIsDateObject) {
          return this.value;
        }
  
        if (this.valueFormat) {
          return parseAsFormatAndType(this.value, this.valueFormat, this.type, this.rangeSeparator) || this.value;
        } // NOTE: deal with common but incorrect usage, should remove in next major version
        // user might provide string / timestamp without value-format, coerce them into date (or array of date)
  
        return Array.isArray(this.value) ? this.value.map(function (val) {
          return new Date(val);
        }) : new Date(this.value);
      },
      _elFormItemSize: function _elFormItemSize() {
        return (this.elFormItem || {}).elFormItemSize;
      },
      pickerSize: function () {
        return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
      },
      pickerDisabled: function () {
        return this.disabled || (this.elForm || {}).disabled;
      },
      firstInputId: function () {
        var obj = {};
        var id;
  
        if (this.ranged) {
          id = this.id && this.id[0];
        } else {
          id = this.id;
        }
  
        if (id) obj.id = id;
        return obj;
      },
      secondInputId: function () {
        var obj = {};
        var id;
  
        if (this.ranged) {
          id = this.id && this.id[1];
        }
  
        if (id) obj.id = id;
        return obj;
      }
    },
    created: function () {
      // vue-popper
      this.popperOptions = {
        boundariesPadding: 0,
        gpuAcceleration: false
      };
      this.placement = PLACEMENT_MAP[this.align] || PLACEMENT_MAP.left;
      this.$on('fieldReset', this.handleFieldReset);
    },
    methods: {
      focus: function () {
        if (!this.ranged) {
          this.$refs.reference.focus();
        } else {
          this.handleFocus();
        }
      },
      blur: function () {
        this.refInput.forEach(function (input) {
          return input.blur();
        });
      },
      // {parse, formatTo} Value deals maps component value with internal Date
      parseValue: function (value) {
        var isParsed = isDateObject(value) || Array.isArray(value) && value.every(isDateObject);
  
        if (this.valueFormat && !isParsed) {
          return parseAsFormatAndType(value, this.valueFormat, this.type, this.rangeSeparator) || value;
        } else {
          return value;
        }
      },
      formatToValue: function (date) {
        var isFormattable = isDateObject(date) || Array.isArray(date) && date.every(isDateObject);
  
        if (this.valueFormat && isFormattable) {
          return formatAsFormatAndType(date, this.valueFormat, this.type, this.rangeSeparator);
        } else {
          return date;
        }
      },
      // {parse, formatTo} String deals with user input
      parseString: function (value) {
        var type = Array.isArray(value) ? this.type : this.type.replace('range', '');
        return parseAsFormatAndType(value, this.format, type);
      },
      formatToString: function (value) {
        var type = Array.isArray(value) ? this.type : this.type.replace('range', '');
        return formatAsFormatAndType(value, this.format, type);
      },
      handleMouseEnter: function () {
        if (this.readonly || this.pickerDisabled) return;
  
        if (!this.valueIsEmpty && this.clearable) {
          this.showClose = true;
        }
      },
      handleChange: function () {
        if (this.userInput) {
          var value = this.parseString(this.displayValue);
  
          if (value) {
            this.picker.value = value;
  
            if (this.isValidValue(value)) {
              this.emitInput(value);
              this.userInput = null;
            }
          }
        }
  
        if (this.userInput === '') {
          this.emitInput(null);
          this.emitChange(null);
          this.userInput = null;
        }
      },
      handleStartInput: function (event) {
        if (this.userInput) {
          this.userInput = [event.target.value, this.userInput[1]];
        } else {
          this.userInput = [event.target.value, null];
        }
      },
      handleEndInput: function (event) {
        if (this.userInput) {
          this.userInput = [this.userInput[0], event.target.value];
        } else {
          this.userInput = [null, event.target.value];
        }
      },
      handleStartChange: function (event) {
        var value = this.parseString(this.userInput && this.userInput[0]);
  
        if (value) {
          this.userInput = [this.formatToString(value), this.displayValue[1]];
          var newValue = [value, this.picker.value && this.picker.value[1]];
          this.picker.value = newValue;
  
          if (this.isValidValue(newValue)) {
            this.emitInput(newValue);
            this.userInput = null;
          }
        }
      },
      handleEndChange: function (event) {
        var value = this.parseString(this.userInput && this.userInput[1]);
  
        if (value) {
          this.userInput = [this.displayValue[0], this.formatToString(value)];
          var newValue = [this.picker.value && this.picker.value[0], value];
          this.picker.value = newValue;
  
          if (this.isValidValue(newValue)) {
            this.emitInput(newValue);
            this.userInput = null;
          }
        }
      },
      handleClickIcon: function (event) {
        if (this.readonly || this.pickerDisabled) return;
  
        if (this.showClose) {
          this.valueOnOpen = this.value;
          event.stopPropagation();
          this.emitInput(null);
          this.emitChange(null);
          this.showClose = false;
  
          if (this.picker && typeof this.picker.handleClear === 'function') {
            this.picker.handleClear();
          }
        } else {
          this.pickerVisible = !this.pickerVisible;
        }
      },
      handleClose: function () {
        if (!this.pickerVisible) return;
        this.pickerVisible = false;
  
        if (this.type === 'dates') {
          // restore to former value
          var oldValue = parseAsFormatAndType(this.valueOnOpen, this.valueFormat, this.type, this.rangeSeparator) || this.valueOnOpen;
          this.emitInput(oldValue);
        }
      },
      handleFieldReset: function (initialValue) {
        this.userInput = initialValue === '' ? null : initialValue;
      },
      handleFocus: function () {
        var type = this.type;
  
        if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {
          this.pickerVisible = true;
        }
  
        this.$emit('focus', this);
      },
      handleKeydown: function (event) {
        var self = this;
  
        var keyCode = event.keyCode; // ESC
  
        if (keyCode === 27) {
          this.pickerVisible = false;
          event.stopPropagation();
          return;
        } // Tab
  
  
        if (keyCode === 9) {
          if (!this.ranged) {
            this.handleChange();
            this.pickerVisible = this.picker.visible = false;
            this.blur();
            event.stopPropagation();
          } else {
            // user may change focus between two input
            setTimeout(function () {
              if (self.refInput.indexOf(document.activeElement) === -1) {
                self.pickerVisible = false;
  
                self.blur();
  
                event.stopPropagation();
              }
            }, 0);
          }
  
          return;
        } // Enter
  
  
        if (keyCode === 13) {
          if (this.userInput === '' || this.isValidValue(this.parseString(this.displayValue))) {
            this.handleChange();
            this.pickerVisible = this.picker.visible = false;
            this.blur();
          }
  
          event.stopPropagation();
          return;
        } // if user is typing, do not let picker handle key input
  
  
        if (this.userInput) {
          event.stopPropagation();
          return;
        } // delegate other keys to panel
  
  
        if (this.picker && this.picker.handleKeydown) {
          this.picker.handleKeydown(event);
        }
      },
      handleRangeClick: function () {
        var type = this.type;
  
        if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {
          this.pickerVisible = true;
        }
  
        this.$emit('focus', this);
      },
      hidePicker: function () {
        if (this.picker) {
          this.picker.resetView && this.picker.resetView();
          this.pickerVisible = this.picker.visible = false;
          this.destroyPopper();
        }
      },
      showPicker: function () {
        var self = this;
  
        if (this.$isServer) return;
  
        if (!this.picker) {
          this.mountPicker();
        }
  
        this.pickerVisible = this.picker.visible = true;
        this.updatePopper();
        this.picker.value = this.parsedValue;
        this.picker.resetView && this.picker.resetView();
        this.$nextTick(function () {
          self.picker.adjustSpinners && self.picker.adjustSpinners();
        });
      },
      mountPicker: function () {
        var self = this;
  
        this.picker = new Vue(this.panel).$mount();
        this.picker.defaultValue = this.defaultValue;
        this.picker.defaultTime = this.defaultTime;
        this.picker.popperClass = this.popperClass;
        this.popperElm = this.picker.$el;
        this.picker.width = this.reference.getBoundingClientRect().width;
        this.picker.showTime = this.type === 'datetime' || this.type === 'datetimerange';
        this.picker.selectionMode = this.selectionMode;
        this.picker.unlinkPanels = this.unlinkPanels;
        this.picker.arrowControl = this.arrowControl || this.timeArrowControl || false;
        this.$watch('format', function (format) {
          self.picker.format = format;
        });
  
        var updateOptions = function () {
          var options = self.pickerOptions;
  
          if (options && options.selectableRange) {
            var ranges = options.selectableRange;
            var parser = TYPE_VALUE_RESOLVER_MAP.datetimerange.parser;
            var format = DEFAULT_FORMATS.timerange;
            ranges = Array.isArray(ranges) ? ranges : [ranges];
            self.picker.selectableRange = ranges.map(function (range) {
              return parser(range, format, self.rangeSeparator);
            });
          }
  
          for (var option in options) {
            if (options.hasOwnProperty(option) && //  time-picker 
            option !== 'selectableRange') {
              self.picker[option] = options[option];
            }
          } // main format must prevail over undocumented pickerOptions.format
  
  
          if (self.format) {
            self.picker.format = self.format;
          }
        };
  
        updateOptions();
        this.unwatchPickerOptions = this.$watch('pickerOptions', function () {
          return updateOptions();
        }, {
          deep: true
        });
        this.$el.appendChild(this.picker.$el);
        this.picker.resetView && this.picker.resetView();
        this.picker.$on('dodestroy', this.doDestroy);
        this.picker.$on('pick', function () {
          var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          self.userInput = null;
          self.pickerVisible = self.picker.visible = visible;
  
          self.emitInput(date);
  
          self.picker.resetView && self.picker.resetView();
        });
        this.picker.$on('select-range', function (start, end, pos) {
          if (self.refInput.length === 0) return;
  
          if (!pos || pos === 'min') {
            self.refInput[0].setSelectionRange(start, end);
  
            self.refInput[0].focus();
          } else if (pos === 'max') {
            self.refInput[1].setSelectionRange(start, end);
  
            self.refInput[1].focus();
          }
        });
      },
      unmountPicker: function () {
        if (this.picker) {
          this.picker.$destroy();
          this.picker.$off();
  
          if (typeof this.unwatchPickerOptions === 'function') {
            this.unwatchPickerOptions();
          }
  
          this.picker.$el.parentNode.removeChild(this.picker.$el);
        }
      },
      emitChange: function (val) {
        // determine user real change only
        if (!valueEquals(val, this.valueOnOpen)) {
          this.$emit('change', val);
          this.valueOnOpen = val;
  
          if (this.validateEvent) {
            this.dispatch('VueFormItem', 'vue.form.change', val);
          }
        }
      },
      emitInput: function (val) {
        var formatted = this.formatToValue(val);
  
        if (!valueEquals(this.value, formatted)) {
          this.$emit('input', formatted);
        }
      },
      isValidValue: function (value) {
        if (!this.picker) {
          this.mountPicker();
        }
  
        if (this.picker.isValidValue) {
          return value && this.picker.isValidValue(value);
        } else {
          return true;
        }
      }
    }
  };
  return VuePicker;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePicker'], definition);
  } else {
    context.VueTimeSelect = definition(context.Vue, context.VuePicker);
    delete context.VueTimeSelect;
  }
})(this, function(Vue, VuePicker) {
  'use strict';
  
  var parseTime = function (time) {
    var values = (time || '').split(':');
  
    if (values.length >= 2) {
      var hours = parseInt(values[0], 10);
      var minutes = parseInt(values[1], 10);
      return {
        hours: hours,
        minutes: minutes
      };
    }
    /* istanbul ignore next */
    return null;
  };
  
  var compareTime = function (time1, time2) {
    var value1 = parseTime(time1);
    var value2 = parseTime(time2);
    var minutes1 = value1.minutes + value1.hours * 60;
    var minutes2 = value2.minutes + value2.hours * 60;
  
    if (minutes1 === minutes2) {
      return 0;
    }
  
    return minutes1 > minutes2 ? 1 : -1;
  };
  
  var formatTime = function (time) {
    return (time.hours < 10 ? '0' + time.hours : time.hours) + ':' + (time.minutes < 10 ? '0' + time.minutes : time.minutes);
  };
  
  var nextTime = function (time, step) {
    var timeValue = parseTime(time);
    var stepValue = parseTime(step);
    var next = {
      hours: timeValue.hours,
      minutes: timeValue.minutes
    };
    next.minutes += stepValue.minutes;
    next.hours += stepValue.hours;
    next.hours += Math.floor(next.minutes / 60);
    next.minutes = next.minutes % 60;
    return formatTime(next);
  };
  
  function scrollIntoView(container, selected) {
    if (Vue.prototype.$isServer) return;
  
    if (!selected) {
      container.scrollTop = 0;
      return;
    }
  
    var offsetParents = [];
    var pointer = selected.offsetParent;
  
    while (pointer && container !== pointer && container.contains(pointer)) {
      offsetParents.push(pointer);
      pointer = pointer.offsetParent;
    }
  
    var top = selected.offsetTop + offsetParents.reduce(function (prev, curr) {
      return prev + curr.offsetTop;
    }, 0);
    var bottom = top + selected.offsetHeight;
    var viewRectTop = container.scrollTop;
    var viewRectBottom = viewRectTop + container.clientHeight;
  
    if (top < viewRectTop) {
      container.scrollTop = top;
    } else if (bottom > viewRectBottom) {
      container.scrollTop = bottom - container.clientHeight;
    }
  }

  var TimeSelect = {
    template: '  <transition name="vue-zoom-in-top" @before-enter="handleMenuEnter" @after-leave="$emit(\'destroyPopper\')">'+
    '    <div'+
    '      ref="popper"'+
    '      v-show="visible"'+
    '      :style="{ width: width + \'px\' }"'+
    '      :class="popperClass"'+
    '      class="vue-picker-panel time-select vue-popper">'+
    '      <vue-scrollbar noresize wrap-class="vue-picker-panel__content">'+
    '        <div class="time-select-item"'+
    '          v-for="item in items"'+
    '          :class="{ selected: value === item.value, disabled: item.disabled, default: item.value === defaultValue }"'+
    '          :disabled="item.disabled"'+
    '          :key="item.value"'+
    '          @click="handleClick(item)">{{ item.value }}</div>'+
    '      </vue-scrollbar>'+
    '    </div>'+
    '  </transition>',
    watch: {
      value: function (val) {
        var self = this;
  
        if (!val) return;
        this.$nextTick(function () {
          return self.scrollToOption();
        });
      }
    },
    methods: {
      handleClick: function (item) {
        if (!item.disabled) {
          this.$emit('pick', item.value);
        }
      },
      handleClear: function () {
        this.$emit('pick', null);
      },
      scrollToOption: function () {
        var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.selected';
        var menu = this.$refs.popper.querySelector('.vue-picker-panel__content');
        scrollIntoView(menu, menu.querySelector(selector));
      },
      handleMenuEnter: function () {
        var self = this;
  
        var selected = this.items.map(function (item) {
          return item.value;
        }).indexOf(this.value) !== -1;
        var hasDefault = this.items.map(function (item) {
          return item.value;
        }).indexOf(this.defaultValue) !== -1;
        var option = selected && '.selected' || hasDefault && '.default' || '.time-select-item:not(.disabled)';
        this.$nextTick(function () {
          return self.scrollToOption(option);
        });
      },
      scrollDown: function (step) {
        var items = this.items;
        var length = items.length;
        var total = items.length;
        var index = items.map(function (item) {
          return item.value;
        }).indexOf(this.value);
  
        while (total--) {
          index = (index + step + length) % length;
  
          if (!items[index].disabled) {
            this.$emit('pick', items[index].value, true);
            return;
          }
        }
      },
      isValidValue: function (date) {
        return this.items.filter(function (item) {
          return !item.disabled;
        }).map(function (item) {
          return item.value;
        }).indexOf(date) !== -1;
      },
      handleKeydown: function (event) {
        var keyCode = event.keyCode;
  
        if (keyCode === 38 || keyCode === 40) {
          var mapping = {
            40: 1,
            38: -1
          };
          var offset = mapping[keyCode.toString()];
          this.scrollDown(offset);
          event.stopPropagation();
          return;
        }
      }
    },
    data: function () {
      return {
        popperClass: '',
        start: '09:00',
        end: '18:00',
        step: '00:30',
        value: '',
        defaultValue: '',
        visible: false,
        minTime: '',
        maxTime: '',
        width: 0
      };
    },
    computed: {
      items: function () {
        var start = this.start;
        var end = this.end;
        var step = this.step;
        var result = [];
  
        if (start && end && step) {
          var current = start;
  
          while (compareTime(current, end) <= 0) {
            result.push({
              value: current,
              disabled: compareTime(current, this.minTime || '-1:-1') <= 0 || compareTime(current, this.maxTime || '100:100') >= 0
            });
            current = nextTime(current, step);
          }
        }
  
        return result;
      }
    }
  };
  var VueTimeSelect = {
    mixins: [VuePicker],
    name: 'VueTimeSelect',
    props: {
      type: {
        type: String,
        default: 'time-select'
      }
    },
    beforeCreate: function() {
      this.panel = TimeSelect;
    }
  };
  Vue.component(VueTimeSelect.name, VueTimeSelect);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePicker', 'VueUtil'], definition);
  } else {
    context.VueTimePicker = definition(context.Vue, context.VuePicker, context.VueUtil);
  }
})(this, function(Vue, VuePicker, VueUtil) {
  'use strict';

  var limitTimeRange = VueUtil.limitTimeRange,
    isDate = VueUtil.isDate,
    clearMilliseconds = VueUtil.clearMilliseconds,
    timeWithinRange = VueUtil.timeWithinRange,
    getRangeHours = VueUtil.getRangeHours,
    getRangeMinutes = VueUtil.getRangeMinutes,
    modifyTime = VueUtil.modifyTime,
    parseDate = VueUtil.parseDate,
    modifyDate = VueUtil.modifyDate;

  var MIN_TIME = parseDate('00:00:00', 'HH:mm:ss');
  var MAX_TIME = parseDate('23:59:59', 'HH:mm:ss');
  
  var minTimeOfDay = function (date) {
    return modifyDate(MIN_TIME, date.getFullYear(), date.getMonth(), date.getDate());
  };
  
  var maxTimeOfDay = function (date) {
    return modifyDate(MAX_TIME, date.getFullYear(), date.getMonth(), date.getDate());
  };
  
  var advanceTime = function (date, amount) {
    return new Date(Math.min(date.getTime() + amount, maxTimeOfDay(date).getTime()));
  };

  var TimeSpinner = {
    template: '  <div class="vue-time-spinner" :class="{ \'has-seconds\': showSeconds }">'+
    '    <template v-if="!arrowControl">'+
    '      <vue-scrollbar'+
    '        @mouseenter.native="emitSelectRange(\'hours\')"'+
    '        @mousemove.native="adjustCurrentSpinner(\'hours\')"'+
    '        class="vue-time-spinner__wrapper"'+
    '        wrap-style="max-height: inherit;"'+
    '        view-class="vue-time-spinner__list"'+
    '        noresize'+
    '        tag="ul"'+
    '        ref="hours">'+
    '        <li'+
    '          @click="handleClick(\'hours\', { value: hour, disabled: disabled })"'+
    '          v-for="(disabled, hour) in hoursList"'+
    '          class="vue-time-spinner__item"'+
    '          :key="hour"'+
    '          :class="{ \'active\': hour === hours, \'disabled\': disabled }">{{ (\'0\' + (amPmMode ? (hour % 12 || 12) : hour )).slice(-2) }}{{ amPm(hour) }}</li>'+
    '      </vue-scrollbar>'+
    '      <vue-scrollbar'+
    '        @mouseenter.native="emitSelectRange(\'minutes\')"'+
    '        @mousemove.native="adjustCurrentSpinner(\'minutes\')"'+
    '        class="vue-time-spinner__wrapper"'+
    '        wrap-style="max-height: inherit;"'+
    '        view-class="vue-time-spinner__list"'+
    '        noresize'+
    '        tag="ul"'+
    '        ref="minutes">'+
    '        <li'+
    '          @click="handleClick(\'minutes\', { value: key, disabled: false })"'+
    '          v-for="(enabled, key) in minutesList"'+
    '          :key="key"'+
    '          class="vue-time-spinner__item"'+
    '          :class="{ \'active\': key === minutes, disabled: !enabled }">{{ (\'0\' + key).slice(-2) }}</li>'+
    '      </vue-scrollbar>'+
    '      <vue-scrollbar'+
    '        v-show="showSeconds"'+
    '        @mouseenter.native="emitSelectRange(\'seconds\')"'+
    '        @mousemove.native="adjustCurrentSpinner(\'seconds\')"'+
    '        class="vue-time-spinner__wrapper"'+
    '        wrap-style="max-height: inherit;"'+
    '        view-class="vue-time-spinner__list"'+
    '        noresize'+
    '        tag="ul"'+
    '        ref="seconds">'+
    '        <li'+
    '          @click="handleClick(\'seconds\', { value: key, disabled: false })"'+
    '          v-for="(second, key) in 60"'+
    '          class="vue-time-spinner__item"'+
    '          :class="{ \'active\': key === seconds }"'+
    '          :key="key">{{ (\'0\' + key).slice(-2) }}</li>'+
    '      </vue-scrollbar>'+
    '    </template>'+
    '    <template v-if="arrowControl">'+
    '      <div'+
    '        @mouseenter="emitSelectRange(\'hours\')"'+
    '        class="vue-time-spinner__wrapper is-arrow">'+
    '        <i v-repeat-click="decrease" class="vue-time-spinner__arrow vue-icon-arrow-up"></i>'+
    '        <i v-repeat-click="increase" class="vue-time-spinner__arrow vue-icon-arrow-down"></i>'+
    '        <ul class="vue-time-spinner__list" ref="hours">'+
    '          <li'+
    '            class="vue-time-spinner__item"'+
    '            :class="{ \'active\': hour === hours, \'disabled\': hoursList[hour] }"'+
    '            v-for="(hour, key) in arrowHourList"'+
    '            :key="key">{{ hour === undefined ? \'\' : (\'0\' + (amPmMode ? (hour % 12 || 12) : hour )).slice(-2) + amPm(hour) }}</li>'+
    '        </ul>'+
    '      </div>'+
    '      <div'+
    '        @mouseenter="emitSelectRange(\'minutes\')"'+
    '        class="vue-time-spinner__wrapper is-arrow">'+
    '        <i v-repeat-click="decrease" class="vue-time-spinner__arrow vue-icon-arrow-up"></i>'+
    '        <i v-repeat-click="increase" class="vue-time-spinner__arrow vue-icon-arrow-down"></i>'+
    '        <ul class="vue-time-spinner__list" ref="minutes">'+
    '          <li'+
    '            class="vue-time-spinner__item"'+
    '            :class="{ \'active\': minute === minutes }"'+
    '            v-for="(minute, key) in arrowMinuteList"'+
    '            :key="key">'+
    '            {{ minute === undefined ? \'\' : (\'0\' + minute).slice(-2) }}'+
    '          </li>'+
    '        </ul>'+
    '      </div>'+
    '      <div'+
    '        @mouseenter="emitSelectRange(\'seconds\')"'+
    '        class="vue-time-spinner__wrapper is-arrow"'+
    '        v-if="showSeconds">'+
    '        <i v-repeat-click="decrease" class="vue-time-spinner__arrow vue-icon-arrow-up"></i>'+
    '        <i v-repeat-click="increase" class="vue-time-spinner__arrow vue-icon-arrow-down"></i>'+
    '        <ul class="vue-time-spinner__list" ref="seconds">'+
    '          <li'+
    '            v-for="(second, key) in arrowSecondList"'+
    '            class="vue-time-spinner__item"'+
    '            :class="{ \'active\': second === seconds }"'+
    '            :key="key">'+
    '            {{ second === undefined ? \'\' : (\'0\' + second).slice(-2) }}'+
    '          </li>'+
    '        </ul>'+
    '      </div>'+
    '    </template>'+
    '  </div>',
    directives: {
      repeatClick: VueUtil.component.repeatClick
    },
    props: {
      date: {},
      defaultValue: {},
      // reserved for future use
      showSeconds: {
        type: Boolean,
        default: true
      },
      arrowControl: Boolean,
      amPmMode: {
        type: String,
        default: '' // 'a': am/pm; 'A': AM/PM
  
      }
    },
    computed: {
      hours: function () {
        return this.date.getHours();
      },
      minutes: function () {
        return this.date.getMinutes();
      },
      seconds: function () {
        return this.date.getSeconds();
      },
      hoursList: function () {
        return getRangeHours(this.selectableRange);
      },
      minutesList: function () {
        return getRangeMinutes(this.selectableRange, this.hours);
      },
      arrowHourList: function () {
        var hours = this.hours;
        return [hours > 0 ? hours - 1 : undefined, hours, hours < 23 ? hours + 1 : undefined];
      },
      arrowMinuteList: function () {
        var minutes = this.minutes;
        return [minutes > 0 ? minutes - 1 : undefined, minutes, minutes < 59 ? minutes + 1 : undefined];
      },
      arrowSecondList: function () {
        var seconds = this.seconds;
        return [seconds > 0 ? seconds - 1 : undefined, seconds, seconds < 59 ? seconds + 1 : undefined];
      }
    },
    data: function () {
      return {
        selectableRange: [],
        currentScrollbar: null
      };
    },
    mounted: function () {
      var self = this;
  
      this.$nextTick(function () {
        !self.arrowControl && self.bindScrollEvent();
      });
    },
    methods: {
      increase: function () {
        this.scrollDown(1);
      },
      decrease: function () {
        this.scrollDown(-1);
      },
      modifyDateField: function (type, value) {
        switch (type) {
          case 'hours':
            this.$emit('change', modifyTime(this.date, value, this.minutes, this.seconds));
            break;
  
          case 'minutes':
            this.$emit('change', modifyTime(this.date, this.hours, value, this.seconds));
            break;
  
          case 'seconds':
            this.$emit('change', modifyTime(this.date, this.hours, this.minutes, value));
            break;
        }
      },
      handleClick: function (type, _ref) {
        var value = _ref.value,
            disabled = _ref.disabled;
  
        if (!disabled) {
          this.modifyDateField(type, value);
          this.emitSelectRange(type);
          this.adjustSpinner(type, value);
        }
      },
      emitSelectRange: function (type) {
        if (type === 'hours') {
          this.$emit('select-range', 0, 2);
        } else if (type === 'minutes') {
          this.$emit('select-range', 3, 5);
        } else if (type === 'seconds') {
          this.$emit('select-range', 6, 8);
        }
  
        this.currentScrollbar = type;
      },
      bindScrollEvent: function () {
        var self = this;
  
        var bindFuntion = function (type) {
          self.$refs[type].wrap.onscroll = function (e) {
            self.handleScroll(type, e);
          };
        };
  
        bindFuntion('hours');
        bindFuntion('minutes');
        bindFuntion('seconds');
      },
      handleScroll: function (type) {
        var value = Math.min(Math.floor((this.$refs[type].wrap.scrollTop - (this.scrollBarHeight(type) * 0.5 - 10) / this.typeItemHeight(type) + 3) / this.typeItemHeight(type)), type === 'hours' ? 23 : 59);
        this.modifyDateField(type, value);
      },
      // NOTE: used by datetime / date-range panel
      //       renamed from adjustScrollTop
      //       should try to refactory it
      adjustSpinners: function () {
        this.adjustSpinner('hours', this.hours);
        this.adjustSpinner('minutes', this.minutes);
        this.adjustSpinner('seconds', this.seconds);
      },
      adjustCurrentSpinner: function (type) {
        this.adjustSpinner(type, this[type]);
      },
      adjustSpinner: function (type, value) {
        if (this.arrowControl) return;
        var el = this.$refs[type].wrap;
  
        if (el) {
          el.scrollTop = Math.max(0, value * this.typeItemHeight(type));
        }
      },
      scrollDown: function (step) {
        if (!this.currentScrollbar) {
          this.emitSelectRange('hours');
        }
  
        var label = this.currentScrollbar;
        var hoursList = this.hoursList;
        var now = this[label];
  
        if (this.currentScrollbar === 'hours') {
          var total = Math.abs(step);
          step = step > 0 ? 1 : -1;
          var length = hoursList.length;
  
          while (length-- && total) {
            now = (now + step + hoursList.length) % hoursList.length;
  
            if (hoursList[now]) {
              continue;
            }
  
            total--;
          }
  
          if (hoursList[now]) return;
        } else {
          now = (now + step + 60) % 60;
        }
  
        this.modifyDateField(label, now);
        this.adjustSpinner(label, now);
      },
      amPm: function (hour) {
        var shouldShowAmPm = this.amPmMode.toLowerCase() === 'a';
        if (!shouldShowAmPm) return '';
        var isCapital = this.amPmMode === 'A';
        var content = hour < 12 ? ' am' : ' pm';
        if (isCapital) content = content.toUpperCase();
        return content;
      },
      typeItemHeight: function (type) {
        return this.$refs[type].$el.querySelector('li').offsetHeight;
      },
      scrollBarHeight: function (type) {
        return this.$refs[type].$el.offsetHeight;
      }
    }

  };
  var TimePanel = {
    template: '  <transition name="vue-zoom-in-top" @after-leave="$emit(\'destroyPopper\')">'+
    '    <div'+
    '      v-show="visible"'+
    '      class="vue-time-panel vue-popper"'+
    '      :class="popperClass">'+
    '      <div class="vue-time-panel__content" :class="{ \'has-seconds\': showSeconds }">'+
    '        <time-spinner'+
    '          ref="spinner"'+
    '          @change="handleChange"'+
    '          :arrow-control="useArrow"'+
    '          :show-seconds="showSeconds"'+
    '          :am-pm-mode="amPmMode"'+
    '          @select-range="setSelectionRange"'+
    '          :date="date">'+
    '        </time-spinner>'+
    '      </div>'+
    '      <div class="vue-time-panel__footer">'+
    '        <button'+
    '          type="button"'+
    '          class="vue-time-panel__btn cancel"'+
    '          @click="handleCancel">{{ $t(\'vue.datepicker.cancel\') }}</button>'+
    '        <button'+
    '          type="button"'+
    '          class="vue-time-panel__btn"'+
    '          :class="{confirm: !disabled}"'+
    '          @click="handleConfirm()">{{ $t(\'vue.datepicker.confirm\') }}</button>'+
    '      </div>'+
    '    </div>'+
    '  </transition>',

    components: {
      TimeSpinner: TimeSpinner
    },
    props: {
      visible: Boolean,
      timeArrowControl: Boolean
    },
    watch: {
      visible: function (val) {
        var self = this;
  
        if (val) {
          this.oldValue = this.value;
          this.$nextTick(function () {
            return self.$refs.spinner.emitSelectRange('hours');
          });
        } else {
          this.needInitAdjust = true;
        }
      },
      value: function (newVal) {
        var self = this;
  
        var date;
  
        if (newVal instanceof Date) {
          date = limitTimeRange(newVal, this.selectableRange, this.format);
        } else if (!newVal) {
          date = this.defaultValue ? new Date(this.defaultValue) : new Date();
        }
  
        this.date = date;
  
        if (this.visible && this.needInitAdjust) {
          this.$nextTick(function (_) {
            return self.adjustSpinners();
          });
          this.needInitAdjust = false;
        }
      },
      selectableRange: function (val) {
        this.$refs.spinner.selectableRange = val;
      },
      defaultValue: function (val) {
        if (!isDate(this.value)) {
          this.date = val ? new Date(val) : new Date();
        }
      }
    },
    data: function () {
      return {
        popperClass: '',
        format: 'HH:mm:ss',
        value: '',
        defaultValue: null,
        date: new Date(),
        oldValue: new Date(),
        selectableRange: [],
        selectionRange: [0, 2],
        disabled: false,
        arrowControl: false,
        needInitAdjust: true
      };
    },
    computed: {
      showSeconds: function () {
        return (this.format || '').indexOf('ss') !== -1;
      },
      useArrow: function () {
        return this.arrowControl || this.timeArrowControl || false;
      },
      amPmMode: function () {
        if ((this.format || '').indexOf('A') !== -1) return 'A';
        if ((this.format || '').indexOf('a') !== -1) return 'a';
        return '';
      }
    },
    methods: {
      handleCancel: function () {
        this.$emit('pick', this.oldValue, false);
      },
      handleChange: function (date) {
        // this.visible avoids edge cases, when use scrolls during panel closing animation
        if (this.visible) {
          this.date = clearMilliseconds(date); // if date is out of range, do not emit
          if (this.isValidValue(this.date)) {
            this.$emit('pick', this.date, true);
          }
        }
      },
      setSelectionRange: function (start, end) {
        this.$emit('select-range', start, end);
        this.selectionRange = [start, end];
      },
      handleConfirm: function () {
        var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var first = arguments.length > 1 ? arguments[1] : undefined;
        if (first) return;
        var date = clearMilliseconds(limitTimeRange(this.date, this.selectableRange, this.format));
        this.$emit('pick', date, visible, first);
      },
      handleKeydown: function (event) {
        var keyCode = event.keyCode;
        var mapping = {
          38: -1,
          40: 1,
          37: -1,
          39: 1
        }; // Left or Right
  
        if (keyCode === 37 || keyCode === 39) {
          var step = mapping[keyCode];
          this.changeSelectionRange(step);
          event.preventDefault();
          return;
        } // Up or Down
  
  
        if (keyCode === 38 || keyCode === 40) {
          var _step = mapping[keyCode];
          this.$refs.spinner.scrollDown(_step);
          event.preventDefault();
          return;
        }
      },
      isValidValue: function (date) {
        return timeWithinRange(date, this.selectableRange, this.format);
      },
      adjustSpinners: function () {
        return this.$refs.spinner.adjustSpinners();
      },
      changeSelectionRange: function (step) {
        var list = [0, 3].concat(this.showSeconds ? [6] : []);
        var mapping = ['hours', 'minutes'].concat(this.showSeconds ? ['seconds'] : []);
        var index = list.indexOf(this.selectionRange[0]);
        var next = (index + step + list.length) % list.length;
        this.$refs.spinner.emitSelectRange(mapping[next]);
      }
    },
    mounted: function () {
      var self = this;
  
      this.$nextTick(function () {
        return self.handleConfirm(true, true);
      });
      this.$emit('mounted');
    }
  };
  var TimeRangePanel = {
    template: '  <transition'+
    '    name="vue-zoom-in-top"'+
    '    @after-leave="$emit(\'destroyPopper\')">'+
    '    <div'+
    '      v-show="visible"'+
    '      class="vue-time-range-picker vue-picker-panel vue-popper"'+
    '      :class="popperClass">'+
    '      <div class="vue-time-range-picker__content">'+
    '        <div class="vue-time-range-picker__cell">'+
    '          <div class="vue-time-range-picker__header">{{ $t(\'vue.datepicker.startTime\') }}</div>'+
    '          <div'+
    '            :class="{ \'has-seconds\': showSeconds, \'is-arrow\': arrowControl }"'+
    '            class="vue-time-range-picker__body vue-time-panel__content">'+
    '            <time-spinner'+
    '              ref="minSpinner"'+
    '              :show-seconds="showSeconds"'+
    '              :am-pm-mode="amPmMode"'+
    '              @change="handleMinChange"'+
    '              :arrow-control="arrowControl"'+
    '              @select-range="setMinSelectionRange"'+
    '              :date="minDate">'+
    '            </time-spinner>'+
    '          </div>'+
    '        </div>'+
    '        <div class="vue-time-range-picker__cell">'+
    '          <div class="vue-time-range-picker__header">{{ $t(\'vue.datepicker.endTime\') }}</div>'+
    '          <div'+
    '            :class="{ \'has-seconds\': showSeconds, \'is-arrow\': arrowControl }"'+
    '            class="vue-time-range-picker__body vue-time-panel__content">'+
    '            <time-spinner'+
    '              ref="maxSpinner"'+
    '              :show-seconds="showSeconds"'+
    '              :am-pm-mode="amPmMode"'+
    '              @change="handleMaxChange"'+
    '              :arrow-control="arrowControl"'+
    '              @select-range="setMaxSelectionRange"'+
    '              :date="maxDate">'+
    '            </time-spinner>'+
    '          </div>'+
    '        </div>'+
    '      </div>'+
    '      <div class="vue-time-panel__footer">'+
    '        <button'+
    '          type="button"'+
    '          class="vue-time-panel__btn cancel"'+
    '          @click="handleCancel()">{{ $t(\'vue.datepicker.cancel\') }}</button>'+
    '        <button'+
    '          type="button"'+
    '          class="vue-time-panel__btn confirm"'+
    '          @click="handleConfirm()"'+
    '          :disabled="btnDisabled">{{ $t(\'vue.datepicker.confirm\') }}</button>'+
    '      </div>'+
    '    </div>'+
    '  </transition>',
    components: {
      TimeSpinner: TimeSpinner
    },
  
    computed: {
      showSeconds: function () {
        return (this.format || '').indexOf('ss') !== -1;
      },
      offset: function () {
        return this.showSeconds ? 11 : 8;
      },
      spinner: function () {
        return this.selectionRange[0] < this.offset ? this.$refs.minSpinner : this.$refs.maxSpinner;
      },
      btnDisabled: function () {
        return this.minDate.getTime() > this.maxDate.getTime();
      },
      amPmMode: function () {
        if ((this.format || '').indexOf('A') !== -1) return 'A';
        if ((this.format || '').indexOf('a') !== -1) return 'a';
        return '';
      }
    },
    data: function () {
      return {
        popperClass: '',
        minDate: new Date(),
        maxDate: new Date(),
        value: [],
        oldValue: [new Date(), new Date()],
        defaultValue: null,
        format: 'HH:mm:ss',
        visible: false,
        selectionRange: [0, 2],
        arrowControl: false
      };
    },
    watch: {
      value: function (_value) {
        if (Array.isArray(_value)) {
          this.minDate = new Date(_value[0]);
          this.maxDate = new Date(_value[1]);
        } else {
          if (Array.isArray(this.defaultValue)) {
            this.minDate = new Date(this.defaultValue[0]);
            this.maxDate = new Date(this.defaultValue[1]);
          } else if (this.defaultValue) {
            this.minDate = new Date(this.defaultValue);
            this.maxDate = advanceTime(new Date(this.defaultValue), 60 * 60 * 1000);
          } else {
            this.minDate = new Date();
            this.maxDate = advanceTime(new Date(), 60 * 60 * 1000);
          }
        }
      },
      visible: function (val) {
        var self = this;
  
        if (val) {
          this.oldValue = this.value;
          this.$nextTick(function () {
            return self.$refs.minSpinner.emitSelectRange('hours');
          });
        }
      }
    },
    methods: {
      handleClear: function () {
        this.$emit('pick', null);
      },
      handleCancel: function () {
        this.$emit('pick', this.oldValue);
      },
      handleMinChange: function (date) {
        this.minDate = clearMilliseconds(date);
        this.handleChange();
      },
      handleMaxChange: function (date) {
        this.maxDate = clearMilliseconds(date);
        this.handleChange();
      },
      handleChange: function () {
        if (this.isValidValue([this.minDate, this.maxDate])) {
          this.$refs.minSpinner.selectableRange = [[minTimeOfDay(this.minDate), this.maxDate]];
          this.$refs.maxSpinner.selectableRange = [[this.minDate, maxTimeOfDay(this.maxDate)]];
          this.$emit('pick', [this.minDate, this.maxDate], true);
        }
      },
      setMinSelectionRange: function (start, end) {
        this.$emit('select-range', start, end, 'min');
        this.selectionRange = [start, end];
      },
      setMaxSelectionRange: function (start, end) {
        this.$emit('select-range', start, end, 'max');
        this.selectionRange = [start + this.offset, end + this.offset];
      },
      handleConfirm: function () {
        var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var minSelectableRange = this.$refs.minSpinner.selectableRange;
        var maxSelectableRange = this.$refs.maxSpinner.selectableRange;
        this.minDate = limitTimeRange(this.minDate, minSelectableRange, this.format);
        this.maxDate = limitTimeRange(this.maxDate, maxSelectableRange, this.format);
        this.$emit('pick', [this.minDate, this.maxDate], visible);
      },
      adjustSpinners: function () {
        this.$refs.minSpinner.adjustSpinners();
        this.$refs.maxSpinner.adjustSpinners();
      },
      changeSelectionRange: function (step) {
        var list = this.showSeconds ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
        var mapping = ['hours', 'minutes'].concat(this.showSeconds ? ['seconds'] : []);
        var index = list.indexOf(this.selectionRange[0]);
        var next = (index + step + list.length) % list.length;
        var half = list.length / 2;
  
        if (next < half) {
          this.$refs.minSpinner.emitSelectRange(mapping[next]);
        } else {
          this.$refs.maxSpinner.emitSelectRange(mapping[next - half]);
        }
      },
      isValidValue: function (date) {
        return Array.isArray(date) && timeWithinRange(this.minDate, this.$refs.minSpinner.selectableRange) && timeWithinRange(this.maxDate, this.$refs.maxSpinner.selectableRange);
      },
      handleKeydown: function (event) {
        var keyCode = event.keyCode;
        var mapping = {
          38: -1,
          40: 1,
          37: -1,
          39: 1
        }; // Left or Right
  
        if (keyCode === 37 || keyCode === 39) {
          var step = mapping[keyCode];
          this.changeSelectionRange(step);
          event.preventDefault();
          return;
        } // Up or Down
  
  
        if (keyCode === 38 || keyCode === 40) {
          var _step = mapping[keyCode];
          this.spinner.scrollDown(_step);
          event.preventDefault();
          return;
        }
      }
    }
  };
  var VueTimePicker = {
    mixins: [VuePicker],
    name: 'VueTimePicker',
    props: {
      isRange: Boolean,
      arrowControl: Boolean
    },
    data: function () {
      return {
        type: ''
      };
    },
    watch: {
      isRange: function (_isRange) {
        if (this.picker) {
          this.unmountPicker();
          this.type = _isRange ? 'timerange' : 'time';
          this.panel = _isRange ? TimeRangePanel : TimePanel;
          this.mountPicker();
        } else {
          this.type = _isRange ? 'timerange' : 'time';
          this.panel = _isRange ? TimeRangePanel : TimePanel;
        }
      }
    },
    created: function () {
      this.type = this.isRange ? 'timerange' : 'time';
      this.panel = this.isRange ? TimeRangePanel : TimePanel;
    }
  };
  Vue.component(VueTimePicker.name, VueTimePicker);
  return TimePanel;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VuePicker', 'VueUtil', 'VueTimePicker'], definition);
  } else {
    context.VueDatePicker = definition(context.Vue, context.VuePicker, context.VueUtil, context.VueTimePicker);
    delete context.VueTimePicker;
  }
})(this, function(Vue, VuePicker, VueUtil, VueTimePicker) {
  'use strict';

  var _util = VueUtil,
  getFirstDayOfMonth = _util.getFirstDayOfMonth,
  getDayCountOfMonth = _util.getDayCountOfMonth,
  getWeekNumber = _util.getWeekNumber,
  getStartDateOfMonth = _util.getStartDateOfMonth,
  prevDate = _util.prevDate,
  nextDate = _util.nextDate,
  isDate = _util.isDate,
  clearTime = _util.clearTime,
  arrayFindIndex = _util.arrayFindIndex,
  arrayFind = _util.arrayFind,
  coerceTruthyValueToArray = _util.coerceTruthyValueToArray,
  getDayCountOfYear = _util.getDayCountOfYear,
  range = _util.range,
  hasClass = _util.hasClass,
  formatDate = _util.formatDate,
  parseDate = _util.parseDate,
  modifyDate = _util.modifyDate,
  modifyTime = _util.modifyTime,
  modifyWithTimeString = _util.modifyWithTimeString,
  clearMilliseconds = _util.clearMilliseconds,
  prevYear = _util.prevYear,
  nextYear = _util.nextYear,
  prevMonth = _util.prevMonth,
  nextMonth = _util.nextMonth,
  changeYearMonthAndClampDate = _util.changeYearMonthAndClampDate,
  extractDateFormat = _util.extractDateFormat,
  extractTimeFormat = _util.extractTimeFormat,
  timeWithinRange = _util.timeWithinRange;
    
  var datesInYear = function (year) {
    var numOfDays = getDayCountOfYear(year);
    var firstDay = new Date(year, 0, 1);
    return range(numOfDays).map(function (n) {
      return nextDate(firstDay, n);
    });
  };
  var datesInMonth = function (year, month) {
    var numOfDays = getDayCountOfMonth(year, month);
    var firstDay = new Date(year, month, 1);
    return range(numOfDays).map(function (n) {
      return nextDate(firstDay, n);
    });
  };

  var clearDate = function (date) {
    return new Date(date.getFullYear(), date.getMonth());
  };

  var getMonthTimestamp = function (time) {
    if (typeof time === 'number' || typeof time === 'string') {
      return clearDate(new Date(time)).getTime();
    } else if (time instanceof Date) {
      return clearDate(time).getTime();
    } else {
      return NaN;
    }
  };
  var WEEKS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  var getDateTimestamp = function (time) {
    if (typeof time === 'number' || typeof time === 'string') {
      return clearTime(new Date(time)).getTime();
    } else if (time instanceof Date) {
      return clearTime(time).getTime();
    } else {
      return NaN;
    }
  };
  var removeFromArray = function (arr, pred) {
    var idx = typeof pred === 'function' ? arrayFindIndex(arr, pred) : arr.indexOf(pred);
    return idx >= 0 ? [].concat(arr.slice(0, idx), arr.slice(idx + 1)) : arr;
  };

  var calcDefaultValue = function (defaultValue) {
    if (Array.isArray(defaultValue)) {
      return [new Date(defaultValue[0]), new Date(defaultValue[1])];
    } else if (defaultValue) {
      return [new Date(defaultValue), nextDate(new Date(defaultValue), 1)];
    } else {
      return [new Date(), nextDate(new Date(), 1)];
    }
  };
  var YearTable = {
    template: 
    '  <table @click="handleYearTableClick" class="vue-year-table">'+
    '    <tbody>'+
    '    <tr>'+
    '      <td class="available" :class="getCellStyle(startYear + 0)">'+
    '        <a class="cell">{{ startYear }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 1)">'+
    '        <a class="cell">{{ startYear + 1 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 2)">'+
    '        <a class="cell">{{ startYear + 2 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 3)">'+
    '        <a class="cell">{{ startYear + 3 }}</a>'+
    '      </td>'+
    '    </tr>'+
    '    <tr>'+
    '      <td class="available" :class="getCellStyle(startYear + 4)">'+
    '        <a class="cell">{{ startYear + 4 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 5)">'+
    '        <a class="cell">{{ startYear + 5 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 6)">'+
    '        <a class="cell">{{ startYear + 6 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 7)">'+
    '        <a class="cell">{{ startYear + 7 }}</a>'+
    '      </td>'+
    '    </tr>'+
    '    <tr>'+
    '      <td class="available" :class="getCellStyle(startYear + 8)">'+
    '        <a class="cell">{{ startYear + 8 }}</a>'+
    '      </td>'+
    '      <td class="available" :class="getCellStyle(startYear + 9)">'+
    '        <a class="cell">{{ startYear + 9 }}</a>'+
    '      </td>'+
    '      <td></td>'+
    '      <td></td>'+
    '    </tr>'+
    '    </tbody>'+
    '  </table>',
    props: {
      disabledDate: {},
      value: {},
      defaultValue:  {
        validator: function(val) {
          return val === null || (val instanceof Date && isDate(val));
        }
      },
      date: {
        default: function() {
          return new Date();
        }
      }
    },
    computed: {
      startYear: function() {
        return Math.floor(this.date.getFullYear() / 10) * 10;
      }
    },
    methods: {
      getCellStyle: function (year) {
        var style = {};
        var today = new Date();
        style.disabled = typeof this.disabledDate === 'function' ? datesInYear(year).every(this.disabledDate) : false;
        style.current = arrayFindIndex(coerceTruthyValueToArray(this.value), function (date) {
          return date.getFullYear() === year;
        }) >= 0;
        style.today = today.getFullYear() === year;
        style.default = this.defaultValue && this.defaultValue.getFullYear() === year;
        return style;
      },
      handleYearTableClick: function (event) {
        var target = event.target;
  
        if (target.tagName === 'A') {
          if (hasClass(target.parentNode, 'disabled')) return;
          var year = target.textContent || target.innerText;
          this.$emit('pick', Number(year));
        }
      }
    }
  };
  var MonthTable = {
    template: 
    '  <table @click="handleMonthTableClick" @mousemove="handleMouseMove" class="vue-month-table">'+
    '    <tbody>'+
    '    <tr v-for="(row, key) in rows" :key="key">'+
    '      <td :class="getCellStyle(cell)" v-for="(cell, key) in row" :key="key">'+
    '        <div>'+
    '          <a class="cell">{{ $t(\'vue.datepicker.months.\' + months[cell.text]) }}</a>'+
    '        </div>'+
    '      </td>'+
    '    </tr>'+
    '    </tbody>'+
    '  </table>',
    props: {
      disabledDate: {},
      value: {},
      selectionMode: {
        default: 'month'
      },
      minDate: {},
      maxDate: {},
      defaultValue: {
        validator: function (val) {
          return val === null || isDate(val) || Array.isArray(val) && val.every(isDate);
        }
      },
      date: {
        default: function() {
          return new Date();
        }
      },
      rangeState: {
        default: function () {
          return {
            endDate: null,
            selecting: false
          };
        }
      }
    },
    watch: {
      'rangeState.endDate': function (newVal) {
        this.markRange(this.minDate, newVal);
      },
      minDate: function (newVal, oldVal) {
        if (getMonthTimestamp(newVal) !== getMonthTimestamp(oldVal)) {
          this.markRange(this.minDate, this.maxDate);
        }
      },
      maxDate: function (newVal, oldVal) {
        if (getMonthTimestamp(newVal) !== getMonthTimestamp(oldVal)) {
          this.markRange(this.minDate, this.maxDate);
        }
      }
    },
    data: function () {
      return {
        months: ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'],
        tableRows: [[], [], []],
        lastRow: null,
        lastColumn: null
      };
    },
    methods: {
      cellMatchesDate: function (cell, date) {
        var value = new Date(date);
        return this.date.getFullYear() === value.getFullYear() && Number(cell.text) === value.getMonth();
      },
      getCellStyle: function (cell) {
        var self = this;
  
        var style = {};
        var year = this.date.getFullYear();
        var today = new Date();
        var month = cell.text;
        var defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];
        style.disabled = typeof this.disabledDate === 'function' ? datesInMonth(year, month).every(this.disabledDate) : false;
        style.current = arrayFindIndex(coerceTruthyValueToArray(this.value), function (date) {
          return date.getFullYear() === year && date.getMonth() === month;
        }) >= 0;
        style.today = today.getFullYear() === year && today.getMonth() === month;
        style.default = defaultValue.some(function (date) {
          return self.cellMatchesDate(cell, date);
        });
  
        if (cell.inRange) {
          style['in-range'] = true;
  
          if (cell.start) {
            style['start-date'] = true;
          }
  
          if (cell.end) {
            style['end-date'] = true;
          }
        }
  
        return style;
      },
      getMonthOfCell: function (month) {
        var year = this.date.getFullYear();
        return new Date(year, month, 1);
      },
      markRange: function (minDate, maxDate) {
        minDate = getMonthTimestamp(minDate);
        maxDate = getMonthTimestamp(maxDate) || minDate;
        var _ref = [Math.min(minDate, maxDate), Math.max(minDate, maxDate)];
        minDate = _ref[0];
        maxDate = _ref[1];
        var rows = this.rows;
  
        for (var i = 0, k = rows.length; i < k; i++) {
          var row = rows[i];
  
          for (var j = 0, l = row.length; j < l; j++) {
            var cell = row[j];
            var index = i * 4 + j;
            var time = new Date(this.date.getFullYear(), index).getTime();
            cell.inRange = minDate && time >= minDate && time <= maxDate;
            cell.start = minDate && time === minDate;
            cell.end = maxDate && time === maxDate;
          }
        }
      },
      handleMouseMove: function (event) {
        if (!this.rangeState.selecting) return;
        var target = event.target;
  
        if (target.tagName === 'A') {
          target = target.parentNode.parentNode;
        }
  
        if (target.tagName === 'DIV') {
          target = target.parentNode;
        }
  
        if (target.tagName !== 'TD') return;
        var row = target.parentNode.rowIndex;
        var column = target.cellIndex; // can not select disabled date
  
        if (this.rows[row][column].disabled) return; // only update rangeState when mouse moves to a new cell
        // this avoids frequent Date object creation and improves performance
  
        if (row !== this.lastRow || column !== this.lastColumn) {
          this.lastRow = row;
          this.lastColumn = column;
          this.$emit('changerange', {
            minDate: this.minDate,
            maxDate: this.maxDate,
            rangeState: {
              selecting: true,
              endDate: this.getMonthOfCell(row * 4 + column)
            }
          });
        }
      },
      handleMonthTableClick: function (event) {
        var target = event.target;
  
        if (target.tagName === 'A') {
          target = target.parentNode.parentNode;
        }
  
        if (target.tagName === 'DIV') {
          target = target.parentNode;
        }
  
        if (target.tagName !== 'TD') return;
        if (hasClass(target, 'disabled')) return;
        var column = target.cellIndex;
        var row = target.parentNode.rowIndex;
        var month = row * 4 + column;
        var newDate = this.getMonthOfCell(month);
  
        if (this.selectionMode === 'range') {
          if (!this.rangeState.selecting) {
            this.$emit('pick', {
              minDate: newDate,
              maxDate: null
            });
            this.rangeState.selecting = true;
          } else {
            if (newDate >= this.minDate) {
              this.$emit('pick', {
                minDate: this.minDate,
                maxDate: newDate
              });
            } else {
              this.$emit('pick', {
                minDate: newDate,
                maxDate: this.minDate
              });
            }
  
            this.rangeState.selecting = false;
          }
        } else {
          this.$emit('pick', month);
        }
      }
    },
    computed: {
      rows: function () {
        var self = this;
  
        var rows = this.tableRows;
        var disabledDate = this.disabledDate;
        var selectedDate = [];
        var now = getMonthTimestamp(new Date());
  
        for (var i = 0; i < 3; i++) {
          var row = rows[i];
  
          var _loop = function _loop(j) {
            var cell = row[j];
  
            if (!cell) {
              cell = {
                row: i,
                column: j,
                type: 'normal',
                inRange: false,
                start: false,
                end: false
              };
            }
  
            cell.type = 'normal';
            var index = i * 4 + j;
            var time = new Date(self.date.getFullYear(), index).getTime();
            cell.inRange = time >= getMonthTimestamp(self.minDate) && time <= getMonthTimestamp(self.maxDate);
            cell.start = self.minDate && time === getMonthTimestamp(self.minDate);
            cell.end = self.maxDate && time === getMonthTimestamp(self.maxDate);
            var isToday = time === now;
  
            if (isToday) {
              cell.type = 'today';
            }
  
            cell.text = index;
            var cellDate = new Date(time);
            cell.disabled = typeof disabledDate === 'function' && disabledDate(cellDate);
            cell.selected = arrayFind(selectedDate, function (date) {
              return date.getTime() === cellDate.getTime();
            });
  
            self.$set(row, j, cell);
          };
  
          for (var j = 0; j < 4; j++) {
            _loop(j);
          }
        }
  
        return rows;
      }
    }
  };
  var DateTable = {
    template: 
    '  <table'+
    '    cellspacing="0"'+
    '    cellpadding="0"'+
    '    class="vue-date-table"'+
    '    @click="handleClick"'+
    '    @mousemove="handleMouseMove"'+
    '    :class="{ \'is-week-mode\': selectionMode === \'week\' }">'+
    '    <tbody>'+
    '    <tr>'+
    '      <th v-if="showWeekNumber">{{ $t(\'vue.datepicker.week\') }}</th>'+
    '      <th v-for="(week, key) in WEEKS" :key="key">{{ $t(\'vue.datepicker.weeks.\' + week) }}</th>'+
    '    </tr>'+
    '    <tr'+
    '      class="vue-date-table__row"'+
    '      v-for="(row, key) in rows"'+
    '      :class="{ current: isWeekActive(row[1]) }"'+
    '      :key="key">'+
    '      <td'+
    '        v-for="(cell, key) in row"'+
    '        :class="getCellClasses(cell)"'+
    '        :key="key">'+
    '        <div>'+
    '          <span>'+
    '            {{ cell.text }}'+
    '          </span>'+
    '        </div>'+
    '      </td>'+
    '    </tr>'+
    '    </tbody>'+
    '  </table>',
    props: {
      firstDayOfWeek: {
        default: 7,
        type: Number,
        validator: function (val) {
          return val >= 1 && val <= 7;
        }
      },
      events: Array,
      value: {},
      defaultValue: {
        validator: function (val) {
          // either: null, valid Date object, Array of valid Date objects
          return val === null || isDate(val) || Array.isArray(val) && val.every(isDate);
        }
      },
      date: {},
      selectionMode: {
        default: 'day'
      },
      showWeekNumber: {
        type: Boolean,
        default: false
      },
      disabledDate: {},
      minDate: {},
      maxDate: {},
      rangeState: {
        default: function _default() {
          return {
            endDate: null,
            selecting: false
          };
        }
      }
    },
    computed: {
      offsetDay: function () {
        var week = this.firstDayOfWeek; // 3217654  -1
    
        return week > 3 ? 7 - week : -week;
      },
      WEEKS: function (_WEEKS) {
        function WEEKS() {
          return _WEEKS.apply(this, arguments);
        }
    
        WEEKS.toString = function () {
          return _WEEKS.toString();
        };
    
        return WEEKS;
      }(function () {
        var week = this.firstDayOfWeek;
        return WEEKS.concat(WEEKS).slice(week, week + 7);
      }),
      year: function () {
        return this.date.getFullYear();
      },
      month: function () {
        return this.date.getMonth();
      },
      startDate: function () {
        return getStartDateOfMonth(this.year, this.month);
      },
      rows: function () {
        var self = this;
    
        // TODO: refactory rows / getCellClasses
        var date = new Date(this.year, this.month, 1);
        var day = getFirstDayOfMonth(date); // day of first day
    
        var dateCountOfMonth = getDayCountOfMonth(date.getFullYear(), date.getMonth());
        var dateCountOfLastMonth = getDayCountOfMonth(date.getFullYear(), date.getMonth() === 0 ? 11 : date.getMonth() - 1);
        day = day === 0 ? 7 : day;
        var offset = this.offsetDay;
        var rows = this.tableRows;
        var count = 1;
        var startDate = this.startDate;
        var disabledDate = this.disabledDate;
        var selectedDate = this.selectionMode === 'dates' ? coerceTruthyValueToArray(this.value) : [];
        var now = getDateTimestamp(new Date());
    
        for (var i = 0; i < 6; i++) {
          var row = rows[i];
    
          if (this.showWeekNumber) {
            if (!row[0]) {
              row[0] = {
                type: 'week',
                text: getWeekNumber(nextDate(startDate, i * 7 + 1))
              };
            }
          }
    
          var _loop = function _loop(j) {
            var cell = row[self.showWeekNumber ? j + 1 : j];
    
            if (!cell) {
              cell = {
                row: i,
                column: j,
                type: 'normal',
                inRange: false,
                start: false,
                end: false
              };
            }
    
            cell.type = 'normal';
            var index = i * 7 + j;
            var time = nextDate(startDate, index - offset).getTime();
            cell.inRange = time >= getDateTimestamp(self.minDate) && time <= getDateTimestamp(self.maxDate);
            cell.start = self.minDate && time === getDateTimestamp(self.minDate);
            cell.end = self.maxDate && time === getDateTimestamp(self.maxDate);
            var isToday = time === now;
    
            if (isToday) {
              cell.type = 'today';
            }
    
            if (i >= 0 && i <= 1) {
              var numberOfDaysFromPreviousMonth = day + offset < 0 ? 7 + day + offset : day + offset;
    
              if (j + i * 7 >= numberOfDaysFromPreviousMonth) {
                cell.text = count++;
              } else {
                cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - j % 7) + 1 + i * 7;
                cell.type = 'prev-month';
              }
            } else {
              if (count <= dateCountOfMonth) {
                cell.text = count++;
              } else {
                cell.text = count++ - dateCountOfMonth;
                cell.type = 'next-month';
              }
            }
    
            var cellDate = new Date(time);
            cell.disabled = typeof disabledDate === 'function' && disabledDate(cellDate);
            cell.selected = arrayFind(selectedDate, function (date) {
              return VueUtil.formatDate(date, 'yyyyMMdd') === VueUtil.formatDate(cellDate, 'yyyyMMdd');
            });
    
            cell.event = false;
            if (cell.type === 'today' || cell.type === 'normal') {
              if (self.events && self.events.length > 0) {
                VueUtil.loop(self.events, function(event) {
                  var st = VueUtil.parseDate(event.start).getTime();
                  var ed = VueUtil.parseDate(event.end ? event.end : st).getTime();
                  if (time >= st && time <= ed) {
                    cell.event = true;
                  }
                });
              }
            }
            self.$set(row, self.showWeekNumber ? j + 1 : j, cell);
          };
    
          for (var j = 0; j < 7; j++) {
            _loop(j);
          }
    
          if (this.selectionMode === 'week') {
            var start = this.showWeekNumber ? 1 : 0;
            var end = this.showWeekNumber ? 7 : 6;
            var isWeekActive = this.isWeekActive(row[start + 1]);
            row[start].inRange = isWeekActive;
            row[start].start = isWeekActive;
            row[end].inRange = isWeekActive;
            row[end].end = isWeekActive;
          }
        }
        return rows;
      }
    },
    watch: {
      'rangeState.endDate': function (newVal) {
        this.markRange(this.minDate, newVal);
      },

      minDate: function (newVal, oldVal) {
        if (getDateTimestamp(newVal) !== getDateTimestamp(oldVal)) {
          this.markRange(this.minDate, this.maxDate);
        }
      },

      maxDate: function (newVal, oldVal) {
        if (getDateTimestamp(newVal) !== getDateTimestamp(oldVal)) {
          this.markRange(this.minDate, this.maxDate);
        }
      }
    },
    data: function() {
      return {
        tableRows: [ [], [], [], [], [], [] ],
        lastRow: null,
        lastColumn: null
      };
    },
    methods: {
      cellMatchesDate: function (cell, date) {
        var value = new Date(date);
        return this.year === value.getFullYear() && this.month === value.getMonth() && Number(cell.text) === value.getDate();
      },
      getCellClasses: function (cell) {
        var selectionMode = this.selectionMode;
        var defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];
        var classes = [];

        if ((cell.type === 'normal' || cell.type === 'today') && !cell.disabled) {
          classes.push('available');
    
          if (cell.type === 'today') {
            classes.push('today');
          }
        } else {
          classes.push(cell.type);
        }
    
        var self = this;
    
        if (cell.type === 'normal' && defaultValue.some(function (date) {
          return self.cellMatchesDate(cell, date);
        })) {
          classes.push('default');
        }

        if (selectionMode === 'day' && (cell.type === 'normal' || cell.type === 'today') && this.cellMatchesDate(cell, this.value)) {
          classes.push('current');
        }
    
        if (cell.inRange && (cell.type === 'normal' || cell.type === 'today' || this.selectionMode === 'week')) {
          classes.push('in-range');
    
          if (cell.start) {
            classes.push('start-date');
          }
    
          if (cell.end) {
            classes.push('end-date');
          }
        }
    
        if (cell.disabled) {
          classes.push('disabled');
        }

        if (cell.selected) {
          classes.push('selected');
        }
        if (cell.event) {
          classes.push('event-date');
        }
    
        return classes.join(' ');
      },
      getDateOfCell: function (row, column) {
        var offsetFromStart = row * 7 + (column - (this.showWeekNumber ? 1 : 0)) - this.offsetDay;
        return nextDate(this.startDate, offsetFromStart);
      },
      isWeekActive: function (cell) {
        if (this.selectionMode !== 'week') return false;
        var newDate = new Date(this.year, this.month, 1);
        var year = newDate.getFullYear();
        var month = newDate.getMonth();
    
        if (cell.type === 'prev-month') {
          newDate.setMonth(month === 0 ? 11 : month - 1);
          newDate.setFullYear(month === 0 ? year - 1 : year);
        }
    
        if (cell.type === 'next-month') {
          newDate.setMonth(month === 11 ? 0 : month + 1);
          newDate.setFullYear(month === 11 ? year + 1 : year);
        }
    
        newDate.setDate(parseInt(cell.text, 10));
    
        if (isDate(this.value)) {
          var dayOffset = (this.value.getDay() - this.firstDayOfWeek + 7) % 7 - 1;
          var weekDate = prevDate(this.value, dayOffset);
          return weekDate.getTime() === newDate.getTime();
        }
    
        return false;
      },
      markRange: function (minDate, maxDate) {
        minDate = getDateTimestamp(minDate);
        maxDate = getDateTimestamp(maxDate) || minDate;
        var _ref = [Math.min(minDate, maxDate), Math.max(minDate, maxDate)];
        minDate = _ref[0];
        maxDate = _ref[1];
        var startDate = this.startDate;
        var rows = this.rows;
    
        for (var i = 0, k = rows.length; i < k; i++) {
          var row = rows[i];
    
          for (var j = 0, l = row.length; j < l; j++) {
            if (this.showWeekNumber && j === 0) continue;
            var cell = row[j];
            var index = i * 7 + j + (this.showWeekNumber ? -1 : 0);
            var time = nextDate(startDate, index - this.offsetDay).getTime();
            cell.inRange = minDate && time >= minDate && time <= maxDate;
            cell.start = minDate && time === minDate;
            cell.end = maxDate && time === maxDate;
          }
        }
      },
      handleMouseMove: function (event) {
        if (!this.rangeState.selecting) return;
        var target = event.target;
    
        if (target.tagName === 'SPAN') {
          target = target.parentNode.parentNode;
        }
    
        if (target.tagName === 'DIV') {
          target = target.parentNode;
        }
    
        if (target.tagName !== 'TD') return;
        var row = target.parentNode.rowIndex - 1;
        var column = target.cellIndex; // can not select disabled date
    
        if (this.rows[row][column].disabled) return; // only update rangeState when mouse moves to a new cell
        // this avoids frequent Date object creation and improves performance
    
        if (row !== this.lastRow || column !== this.lastColumn) {
          this.lastRow = row;
          this.lastColumn = column;
          this.$emit('changerange', {
            minDate: this.minDate,
            maxDate: this.maxDate,
            rangeState: {
              selecting: true,
              endDate: this.getDateOfCell(row, column)
            }
          });
        }
      },
      handleClick: function (event) {
        var target = event.target;
    
        if (target.tagName === 'SPAN') {
          target = target.parentNode.parentNode;
        }
    
        if (target.tagName === 'DIV') {
          target = target.parentNode;
        }
    
        if (target.tagName !== 'TD') return;
        var row = target.parentNode.rowIndex - 1;
        var column = this.selectionMode === 'week' ? 1 : target.cellIndex;
        var cell = this.rows[row][column];
        if (cell.disabled || cell.type === 'week') return;
        var newDate = this.getDateOfCell(row, column);
    
        if (this.selectionMode === 'range') {
          if (!this.rangeState.selecting) {
            this.$emit('pick', {
              minDate: newDate,
              maxDate: null
            });
            this.rangeState.selecting = true;
          } else {
            if (newDate >= this.minDate) {
              this.$emit('pick', {
                minDate: this.minDate,
                maxDate: newDate
              });
            } else {
              this.$emit('pick', {
                minDate: newDate,
                maxDate: this.minDate
              });
            }
    
            this.rangeState.selecting = false;
          }
        } else if (this.selectionMode === 'day') {
          this.$emit('pick', newDate);
        } else if (this.selectionMode === 'week') {
          var weekNumber = getWeekNumber(newDate);
          var value = newDate.getFullYear() + 'w' + weekNumber;
          this.$emit('pick', {
            year: newDate.getFullYear(),
            week: weekNumber,
            value: value,
            date: newDate
          });
        } else if (this.selectionMode === 'dates') {
          var _value = this.value || [];
    
          var newValue = cell.selected ? removeFromArray(_value, function (date) {
            return date.getTime() === newDate.getTime();
          }) : [].concat(_value, [newDate]);
          this.$emit('pick', newValue);
        }
      }
    }
  };
  var DatePanel = {
    template: 
    '  <transition name="vue-zoom-in-top" @after-enter="handleEnter" @after-leave="handleLeave">'+
    '    <div'+
    '      v-show="visible"'+
    '      class="vue-picker-panel vue-date-picker vue-popper"'+
    '      :class="[{'+
    '        \'has-sidebar\': $slots.sidebar || shortcuts,'+
    '        \'has-time\': showTime'+
    '      }, popperClass]">'+
    '      <div class="vue-picker-panel__body-wrapper">'+
    '        <slot name="sidebar" class="vue-picker-panel__sidebar"></slot>'+
    '        <div class="vue-picker-panel__sidebar" v-if="shortcuts">'+
    '          <button'+
    '            type="button"'+
    '            class="vue-picker-panel__shortcut"'+
    '            v-for="(shortcut, key) in shortcuts"'+
    '            :key="key"'+
    '            @click="handleShortcutClick(shortcut)">{{ shortcut.text }}</button>'+
    '        </div>'+
    '        <div class="vue-picker-panel__body">'+
    '          <div class="vue-date-picker__time-header" v-if="showTime">'+
    '            <span class="vue-date-picker__editor-wrap">'+
    '              <vue-input'+
    '                :placeholder="$t(\'vue.datepicker.selectDate\')"'+
    '                :value="visibleDate"'+
    '                size="small"'+
    '                @input="function (val) { return userInputDate = val;}"'+
    '                @change="handleVisibleDateChange" />'+
    '            </span>'+
    '            <span class="vue-date-picker__editor-wrap" v-clickoutside="handleTimePickClose">'+
    '              <vue-input'+
    '                ref="input"'+
    '                @focus="timePickerVisible = true"'+
    '                :placeholder="$t(\'vue.datepicker.selectTime\')"'+
    '                :value="visibleTime"'+
    '                size="small"'+
    '                @input="function (val) { return userInputTime = val;}"'+
    '                @change="handleVisibleTimeChange" />'+
    '              <time-picker'+
    '                ref="timepicker"'+
    '                :time-arrow-control="arrowControl"'+
    '                @pick="handleTimePick"'+
    '                :visible="timePickerVisible"'+
    '                @mounted="proxyTimePickerDataProperties">'+
    '              </time-picker>'+
    '            </span>'+
    '          </div>'+
    '          <div'+
    '            class="vue-date-picker__header"'+
    '            :class="{ \'vue-date-picker__header--bordered\': currentView === \'year\' || currentView === \'month\' }"'+
    '            v-show="currentView !== \'time\'">'+
    '            <button'+
    '              type="button"'+
    '              @click="prevYear"'+
    '              :aria-label="$t(\'vue.datepicker.prevYear\')"'+
    '              class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-d-arrow-left">'+
    '            </button>'+
    '            <button'+
    '              type="button"'+
    '              @click="prevMonth"'+
    '              v-show="currentView === \'date\'"'+
    '              :aria-label="$t(\'vue.datepicker.prevMonth\')"'+
    '              class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-arrow-left">'+
    '            </button>'+
    '            <span'+
    '              @click="showYearPicker"'+
    '              role="button"'+
    '              class="vue-date-picker__header-label">{{ yearLabel }}</span>'+
    '            <span'+
    '              @click="showMonthPicker"'+
    '              v-show="currentView === \'date\'"'+
    '              role="button"'+
    '              class="vue-date-picker__header-label"'+
    '              :class="{ active: currentView === \'month\' }">{{$t(\'vue.datepicker.month\' + (month + 1))}}</span>'+
    '            <button'+
    '              type="button"'+
    '              @click="nextYear"'+
    '              :aria-label="$t(\'vue.datepicker.nextYear\')"'+
    '              class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-d-arrow-right">'+
    '            </button>'+
    '            <button'+
    '              type="button"'+
    '              @click="nextMonth"'+
    '              v-show="currentView === \'date\'"'+
    '              :aria-label="$t(\'vue.datepicker.nextMonth\')"'+
    '              class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-arrow-right">'+
    '            </button>'+
    '          </div>'+
    '          <div class="vue-picker-panel__content">'+
    '            <date-table'+
    '              v-show="currentView === \'date\'"'+
    '              @pick="handleDatePick"'+
    '              :selection-mode="selectionMode"'+
    '              :first-day-of-week="firstDayOfWeek"'+
    '              :value="value"'+
    '              :default-value="defaultValue ? new Date(defaultValue) : null"'+
    '              :date="date"'+
    '              :disabled-date="disabledDate">'+
    '            </date-table>'+
    '            <year-table'+
    '              v-show="currentView === \'year\'"'+
    '              @pick="handleYearPick"'+
    '              :value="value"'+
    '              :default-value="defaultValue ? new Date(defaultValue) : null"'+
    '              :date="date"'+
    '              :disabled-date="disabledDate">'+
    '            </year-table>'+
    '            <month-table'+
    '              v-show="currentView === \'month\'"'+
    '              @pick="handleMonthPick"'+
    '              :value="value"'+
    '              :default-value="defaultValue ? new Date(defaultValue) : null"'+
    '              :date="date"'+
    '              :disabled-date="disabledDate">'+
    '            </month-table>'+
    '          </div>'+
    '        </div>'+
    '      </div>'+
    '      <div'+
    '        class="vue-picker-panel__footer"'+
    '        v-show="footerVisible && currentView === \'date\'">'+
    '        <vue-button'+
    '          size="mini"'+
    '          type="text"'+
    '          class="vue-picker-panel__link-btn"'+
    '          @click="changeToNow"'+
    '          v-show="selectionMode !== \'dates\'">'+
    '          {{ $t(\'vue.datepicker.now\') }}'+
    '        </vue-button>'+
    '        <vue-button'+
    '          plain'+
    '          size="mini"'+
    '          class="vue-picker-panel__link-btn"'+
    '          @click="confirm">'+
    '          {{ $t(\'vue.datepicker.confirm\') }}'+
    '        </vue-button>'+
    '      </div>'+
    '    </div>'+
    '  </transition>',
    directives: {
      Clickoutside: VueUtil.component.clickoutside()
    },
    watch: {
      date: function(val, oldVal) {
        if(val.getFullYear() !== oldVal.getFullYear() || val.getMonth() !== oldVal.getMonth()) {
          this.$emit('view-month-change', val);
        }
      },
      showTime: function (val) {
        var self = this;
  
        /* istanbul ignore if */
        if (!val) return;
        this.$nextTick(function (_) {
          var inputElm = self.$refs.input.$el;
  
          if (inputElm) {
            self.pickerWidth = inputElm.getBoundingClientRect().width + 10;
          }
        });
      },
      value: function (val) {
        if (this.selectionMode === 'dates' && this.value) return;
  
        if (isDate(val)) {
          this.date = new Date(val);
        } else {
          this.date = this.getDefaultValue();
        }
      },
      defaultValue: function (val) {
        if (!isDate(this.value)) {
          this.date = val ? new Date(val) : new Date();
        }
      },
      timePickerVisible: function (val) {
        var self = this;
  
        if (val) this.$nextTick(function () {
          return self.$refs.timepicker.adjustSpinners();
        });
      },
      selectionMode: function (newVal) {
        if (newVal === 'month') {
          /* istanbul ignore next */
          if (this.currentView !== 'year' || this.currentView !== 'month') {
            this.currentView = 'month';
          }
        } else if (newVal === 'dates') {
          this.currentView = 'date';
        }
      }
    },
    methods: {
      proxyTimePickerDataProperties: function () {
        var self = this;
  
        var format = function (timeFormat) {
          self.$refs.timepicker.format = timeFormat;
        };
  
        var value = function (_value) {
          self.$refs.timepicker.value = _value;
        };
  
        var date = function (_date) {
          self.$refs.timepicker.date = _date;
        };
  
        var selectableRange = function (_selectableRange) {
          self.$refs.timepicker.selectableRange = _selectableRange;
        };
  
        this.$watch('value', value);
        this.$watch('date', date);
        this.$watch('selectableRange', selectableRange);
        format(this.timeFormat);
        value(this.value);
        date(this.date);
        selectableRange(this.selectableRange);
      },
      handleClear: function () {
        this.date = this.getDefaultValue();
        this.$emit('pick', null);
      },
      emit: function (value) {
        var self = this;
  
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
  
        if (!value) {
          this.$emit.apply(this, ['pick', value].concat(args));
        } else if (Array.isArray(value)) {
          var dates = value.map(function (date) {
            return self.showTime ? clearMilliseconds(date) : clearTime(date);
          });
          this.$emit.apply(this, ['pick', dates].concat(args));
        } else {
          this.$emit.apply(this, ['pick', this.showTime ? clearMilliseconds(value) : clearTime(value)].concat(args));
        }
  
        this.userInputDate = null;
        this.userInputTime = null;
      },
      resetDate: function() {
        this.date = new Date(this.date);
      },
      showMonthPicker: function () {
        this.currentView = 'month';
      },
      showYearPicker: function () {
        this.currentView = 'year';
      },
      // XXX: 
      // handleLabelClick() {
      //   if (this.currentView === 'date') {
      //     this.showMonthPicker();
      //   } else if (this.currentView === 'month') {
      //     this.showYearPicker();
      //   }
      // },
      prevMonth: function (_prevMonth) {
        function prevMonth() {
          return _prevMonth.apply(this, arguments);
        }
  
        prevMonth.toString = function () {
          return _prevMonth.toString();
        };
  
        return prevMonth;
      }(function () {
        this.date = prevMonth(this.date);
      }),
      nextMonth: function (_nextMonth) {
        function nextMonth() {
          return _nextMonth.apply(this, arguments);
        }
  
        nextMonth.toString = function () {
          return _nextMonth.toString();
        };
  
        return nextMonth;
      }(function () {
        this.date = nextMonth(this.date);
      }),
      prevYear: function (_prevYear) {
        function prevYear() {
          return _prevYear.apply(this, arguments);
        }
  
        prevYear.toString = function () {
          return _prevYear.toString();
        };
  
        return prevYear;
      }(function () {
        if (this.currentView === 'year') {
          this.date = prevYear(this.date, 10);
        } else {
          this.date = prevYear(this.date);
        }
      }),
      nextYear: function (_nextYear) {
        function nextYear() {
          return _nextYear.apply(this, arguments);
        }
  
        nextYear.toString = function () {
          return _nextYear.toString();
        };
  
        return nextYear;
      }(function () {
        if (this.currentView === 'year') {
          this.date = nextYear(this.date, 10);
        } else {
          this.date = nextYear(this.date);
        }
      }),
      handleShortcutClick: function (shortcut) {
        if (shortcut.onClick) {
          shortcut.onClick(this);
        }
      },
      handleTimePick: function (value, visible, first) {
        if (isDate(value)) {
          var newDate = this.value ? modifyTime(this.value, value.getHours(), value.getMinutes(), value.getSeconds()) : modifyWithTimeString(this.getDefaultValue(), this.defaultTime);
          this.date = newDate;
          this.emit(this.date, true);
        } else {
          this.emit(value, true);
        }
  
        if (!first) {
          this.timePickerVisible = visible;
        }
      },
      handleTimePickClose: function () {
        this.timePickerVisible = false;
      },
      handleMonthPick: function (month) {
        if (this.selectionMode === 'month') {
          this.date = modifyDate(this.date, this.year, month, 1);
          this.emit(this.date);
        } else {
          this.date = changeYearMonthAndClampDate(this.date, this.year, month); // TODO: should emit intermediate value ??
          // this.emit(this.date);
  
          this.currentView = 'date';
        }
      },
      handleDatePick: function (value) {
        if (this.selectionMode === 'day') {
          var newDate = this.value ? modifyDate(this.value, value.getFullYear(), value.getMonth(), value.getDate()) : modifyWithTimeString(value, this.defaultTime); // change default time while out of selectableRange
  
          if (!this.checkDateWithinRange(newDate)) {
            newDate = modifyDate(this.selectableRange[0][0], value.getFullYear(), value.getMonth(), value.getDate());
          }
  
          this.date = newDate;
          this.emit(this.date, this.showTime);
        } else if (this.selectionMode === 'week') {
          this.emit(value.date);
        } else if (this.selectionMode === 'dates') {
          this.emit(value, true); // set false to keep panel open
        }
      },
      handleYearPick: function (year) {
        if (this.selectionMode === 'year') {
          this.date = modifyDate(this.date, year, 0, 1);
          this.emit(this.date);
        } else {
          this.date = changeYearMonthAndClampDate(this.date, year, this.month); // TODO: should emit intermediate value ??
          // this.emit(this.date, true);
  
          this.currentView = 'month';
        }
      },
      changeToNow: function () {
        // NOTE: not a permanent solution
        //       consider disable "now" button in the future
        if ((!this.disabledDate || !this.disabledDate(new Date())) && this.checkDateWithinRange(new Date())) {
          this.date = new Date();
          this.emit(this.date);
        }
      },
      confirm: function () {
        if (this.selectionMode === 'dates') {
          this.emit(this.value);
        } else {
          // value were emitted in handle{Date,Time}Pick, nothing to update here
          // deal with the scenario where: user opens the picker, then confirm without doing anything
          var value = this.value ? this.value : modifyWithTimeString(this.getDefaultValue(), this.defaultTime);
          this.date = new Date(value); // refresh date
  
          this.emit(value);
        }
      },
      resetView: function () {
        if (this.selectionMode === 'month') {
          this.currentView = 'month';
        } else if (this.selectionMode === 'year') {
          this.currentView = 'year';
        } else {
          this.currentView = 'date';
        }
      },
      handleEnter: function () {
        document.body.addEventListener('keydown', this.handleKeydown);
      },
      handleLeave: function () {
        this.$emit('destroyPopper');
        document.body.removeEventListener('keydown', this.handleKeydown);
      },
      handleKeydown: function (event) {
        var keyCode = event.keyCode;
        var list = [38, 40, 37, 39];
  
        if (this.visible && !this.timePickerVisible) {
          if (list.indexOf(keyCode) !== -1) {
            this.handleKeyControl(keyCode);
            event.stopPropagation();
            event.preventDefault();
          }
  
          if (keyCode === 13 && this.userInputDate === null && this.userInputTime === null) {
            // Enter
            this.emit(this.date, false);
          }
        }
      },
      handleKeyControl: function (keyCode) {
        var mapping = {
          'year': {
            38: -4,
            40: 4,
            37: -1,
            39: 1,
            offset: function (date, step) {
              return date.setFullYear(date.getFullYear() + step);
            }
          },
          'month': {
            38: -4,
            40: 4,
            37: -1,
            39: 1,
            offset: function (date, step) {
              return date.setMonth(date.getMonth() + step);
            }
          },
          'week': {
            38: -1,
            40: 1,
            37: -1,
            39: 1,
            offset: function (date, step) {
              return date.setDate(date.getDate() + step * 7);
            }
          },
          'day': {
            38: -7,
            40: 7,
            37: -1,
            39: 1,
            offset: function (date, step) {
              return date.setDate(date.getDate() + step);
            }
          }
        };
        var mode = this.selectionMode;
        var year = 3.1536e10;
        var now = this.date.getTime();
        var newDate = new Date(this.date.getTime());
  
        while (Math.abs(now - newDate.getTime()) <= year) {
          var map = mapping[mode];
          map.offset(newDate, map[keyCode]);
  
          if (typeof this.disabledDate === 'function' && this.disabledDate(newDate)) {
            continue;
          }
  
          this.date = newDate;
          this.$emit('pick', newDate, true);
          break;
        }
      },
      handleVisibleTimeChange: function (value) {
        var time = parseDate(value, this.timeFormat);
  
        if (time && this.checkDateWithinRange(time)) {
          this.date = modifyDate(time, this.year, this.month, this.monthDate);
          this.userInputTime = null;
          this.$refs.timepicker.value = this.date;
          this.timePickerVisible = false;
          this.emit(this.date, true);
        }
      },
      handleVisibleDateChange: function (value) {
        var date = parseDate(value, this.dateFormat);
  
        if (date) {
          if (typeof this.disabledDate === 'function' && this.disabledDate(date)) {
            return;
          }
  
          this.date = modifyTime(date, this.date.getHours(), this.date.getMinutes(), this.date.getSeconds());
          this.userInputDate = null;
          this.resetView();
          this.emit(this.date, true);
        }
      },
      isValidValue: function (value) {
        return value && !isNaN(value) && (typeof this.disabledDate === 'function' ? !this.disabledDate(value) : true) && this.checkDateWithinRange(value);
      },
      getDefaultValue: function () {
        // if default-value is set, return it
        // otherwise, return now (the moment this method gets called)
        return this.defaultValue ? new Date(this.defaultValue) : new Date();
      },
      checkDateWithinRange: function (date) {
        return this.selectableRange.length > 0 ? timeWithinRange(date, this.selectableRange, this.format || 'HH:mm:ss') : true;
      }
    },
    components: {
      TimePicker: VueTimePicker,
      YearTable: YearTable,
      MonthTable: MonthTable,
      DateTable: DateTable
    },
    data: function () {
      return {
        popperClass: '',
        date: new Date(),
        value: '',
        defaultValue: null,
        // use getDefaultValue() for time computation
        defaultTime: null,
        showTime: false,
        selectionMode: 'day',
        shortcuts: '',
        visible: false,
        currentView: 'date',
        disabledDate: '',
        selectableRange: [],
        firstDayOfWeek: 7,
        showWeekNumber: false,
        timePickerVisible: false,
        format: '',
        arrowControl: false,
        userInputDate: null,
        userInputTime: null
      };
    },
    computed: {
      year: function () {
        return this.date.getFullYear();
      },
      month: function () {
        return this.date.getMonth();
      },
      week: function () {
        return getWeekNumber(this.date);
      },
      monthDate: function () {
        return this.date.getDate();
      },
      footerVisible: function () {
        return this.showTime || this.selectionMode === 'dates';
      },
      visibleTime: function () {
        if (this.userInputTime !== null) {
          return this.userInputTime;
        } else {
          return formatDate(this.value || this.defaultValue, this.timeFormat);
        }
      },
      visibleDate: function () {
        if (this.userInputDate !== null) {
          return this.userInputDate;
        } else {
          return formatDate(this.value || this.defaultValue, this.dateFormat);
        }
      },
      yearLabel: function () {
        var yearTranslation = this.$t('vue.datepicker.year');
  
        if (this.currentView === 'year') {
          var startYear = Math.floor(this.year / 10) * 10;
  
          if (yearTranslation) {
            return startYear + ' ' + yearTranslation + ' - ' + (startYear + 9) + ' ' + yearTranslation;
          }
  
          return startYear + ' - ' + (startYear + 9);
        }
  
        return this.year + ' ' + yearTranslation;
      },
      timeFormat: function () {
        if (this.format) {
          return extractTimeFormat(this.format);
        } else {
          return 'HH:mm:ss';
        }
      },
      dateFormat: function () {
        if (this.format) {
          return extractDateFormat(this.format);
        } else {
          return 'yyyy-MM-dd';
        }
      }
    }
  };
  var DateRangePanel = {
    template: 
    '  <transition name="vue-zoom-in-top" @after-leave="$emit(\'destroyPopper\')">'+
    '    <div'+
    '      v-show="visible"'+
    '      class="vue-picker-panel vue-date-range-picker vue-popper"'+
    '      :class="[{'+
    '        \'has-sidebar\': $slots.sidebar || shortcuts,'+
    '        \'has-time\': showTime'+
    '      }, popperClass]">'+
    '      <div class="vue-picker-panel__body-wrapper">'+
    '        <slot name="sidebar" class="vue-picker-panel__sidebar"></slot>'+
    '        <div class="vue-picker-panel__sidebar" v-if="shortcuts">'+
    '          <button'+
    '            type="button"'+
    '            class="vue-picker-panel__shortcut"'+
    '            v-for="(shortcut, key) in shortcuts"'+
    '            :key="key"'+
    '            @click="handleShortcutClick(shortcut)">{{shortcut.text}}</button>'+
    '        </div>'+
    '        <div class="vue-picker-panel__body">'+
    '          <div class="vue-date-range-picker__time-header" v-if="showTime">'+
    '            <span class="vue-date-range-picker__editors-wrap">'+
    '              <span class="vue-date-range-picker__time-picker-wrap">'+
    '                <vue-input'+
    '                  size="small"'+
    '                  :disabled="rangeState.selecting"'+
    '                  ref="minInput"'+
    '                  :placeholder="$t(\'vue.datepicker.startDate\')"'+
    '                  class="vue-date-range-picker__editor"'+
    '                  :value="minVisibleDate"'+
    '                  @input="function (val) {return handleDateInput(val, \'min\');}"'+
    '                  @change="function (val) {return handleDateChange(val, \'min\');}" />'+
    '              </span>'+
    '              <span class="vue-date-range-picker__time-picker-wrap" v-clickoutside="handleMinTimeClose">'+
    '                <vue-input'+
    '                  size="small"'+
    '                  class="vue-date-range-picker__editor"'+
    '                  :disabled="rangeState.selecting"'+
    '                  :placeholder="$t(\'vue.datepicker.startTime\')"'+
    '                  :value="minVisibleTime"'+
    '                  @focus="minTimePickerVisible = true"'+
    '                  @input="function (val) {return handleTimeInput(val, \'min\');}"'+
    '                  @change="function (val) {return handleTimeChange(val, \'min\');}" />'+
    '                <time-picker'+
    '                  ref="minTimePicker"'+
    '                  @pick="handleMinTimePick"'+
    '                  :time-arrow-control="arrowControl"'+
    '                  :visible="minTimePickerVisible"'+
    '                  @mounted="$refs.minTimePicker.format=timeFormat">'+
    '                </time-picker>'+
    '              </span>'+
    '            </span>'+
    '            <span class="vue-icon-arrow-right"></span>'+
    '            <span class="vue-date-range-picker__editors-wrap is-right">'+
    '              <span class="vue-date-range-picker__time-picker-wrap">'+
    '                <vue-input'+
    '                  size="small"'+
    '                  class="vue-date-range-picker__editor"'+
    '                  :disabled="rangeState.selecting"'+
    '                  :placeholder="$t(\'vue.datepicker.endDate\')"'+
    '                  :value="maxVisibleDate"'+
    '                  :readonly="!minDate"'+
    '                  @input="function (val) {return handleDateInput(val, \'max\');}"'+
    '                  @change="function (val) {return handleDateChange(val, \'max\');}" />'+
    '              </span>'+
    '              <span class="vue-date-range-picker__time-picker-wrap" v-clickoutside="handleMaxTimeClose">'+
    '                <vue-input'+
    '                  size="small"'+
    '                  class="vue-date-range-picker__editor"'+
    '                  :disabled="rangeState.selecting"'+
    '                  :placeholder="$t(\'vue.datepicker.endTime\')"'+
    '                  :value="maxVisibleTime"'+
    '                  :readonly="!minDate"'+
    '                  @focus="minDate && (maxTimePickerVisible = true)"'+
    '                  @input="function (val) {return handleTimeInput(val, \'max\');}"'+
    '                  @change="function (val) {return handleTimeChange(val, \'max\');}" />'+
    '                <time-picker'+
    '                  ref="maxTimePicker"'+
    '                  @pick="handleMaxTimePick"'+
    '                  :time-arrow-control="arrowControl"'+
    '                  :visible="maxTimePickerVisible"'+
    '                  @mounted="$refs.maxTimePicker.format=timeFormat">'+
    '                </time-picker>'+
    '              </span>'+
    '            </span>'+
    '          </div>'+
    '          <div class="vue-picker-panel__content vue-date-range-picker__content is-left">'+
    '            <div class="vue-date-range-picker__header">'+
    '              <button'+
    '                type="button"'+
    '                @click="leftPrevYear"'+
    '                class="vue-picker-panel__icon-btn vue-icon-d-arrow-left"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="leftPrevMonth"'+
    '                class="vue-picker-panel__icon-btn vue-icon-arrow-left"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="leftNextYear"'+
    '                v-if="unlinkPanels"'+
    '                :disabled="!enableYearArrow"'+
    '                :class="{ \'is-disabled\': !enableYearArrow }"'+
    '                class="vue-picker-panel__icon-btn vue-icon-d-arrow-right"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="leftNextMonth"'+
    '                v-if="unlinkPanels"'+
    '                :disabled="!enableMonthArrow"'+
    '                :class="{ \'is-disabled\': !enableMonthArrow }"'+
    '                class="vue-picker-panel__icon-btn vue-icon-arrow-right"></button>'+
    '              <div>{{ leftLabel }}</div>'+
    '            </div>'+
    '            <date-table'+
    '              selection-mode="range"'+
    '              :date="leftDate"'+
    '              :default-value="defaultValue"'+
    '              :min-date="minDate"'+
    '              :max-date="maxDate"'+
    '              :range-state="rangeState"'+
    '              :disabled-date="disabledDate"'+
    '              @changerange="handleChangeRange"'+
    '              :first-day-of-week="firstDayOfWeek"'+
    '              @pick="handleRangePick">'+
    '            </date-table>'+
    '          </div>'+
    '          <div class="vue-picker-panel__content vue-date-range-picker__content is-right">'+
    '            <div class="vue-date-range-picker__header">'+
    '              <button'+
    '                type="button"'+
    '                @click="rightPrevYear"'+
    '                v-if="unlinkPanels"'+
    '                :disabled="!enableYearArrow"'+
    '                :class="{ \'is-disabled\': !enableYearArrow }"'+
    '                class="vue-picker-panel__icon-btn vue-icon-d-arrow-left"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="rightPrevMonth"'+
    '                v-if="unlinkPanels"'+
    '                :disabled="!enableMonthArrow"'+
    '                :class="{ \'is-disabled\': !enableMonthArrow }"'+
    '                class="vue-picker-panel__icon-btn vue-icon-arrow-left"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="rightNextYear"'+
    '                class="vue-picker-panel__icon-btn vue-icon-d-arrow-right"></button>'+
    '              <button'+
    '                type="button"'+
    '                @click="rightNextMonth"'+
    '                class="vue-picker-panel__icon-btn vue-icon-arrow-right"></button>'+
    '              <div>{{ rightLabel }}</div>'+
    '            </div>'+
    '            <date-table'+
    '              selection-mode="range"'+
    '              :date="rightDate"'+
    '              :default-value="defaultValue"'+
    '              :min-date="minDate"'+
    '              :max-date="maxDate"'+
    '              :range-state="rangeState"'+
    '              :disabled-date="disabledDate"'+
    '              @changerange="handleChangeRange"'+
    '              :first-day-of-week="firstDayOfWeek"'+
    '              @pick="handleRangePick">'+
    '            </date-table>'+
    '          </div>'+
    '        </div>'+
    '      </div>'+
    '      <div class="vue-picker-panel__footer" v-if="showTime">'+
    '        <vue-button'+
    '          size="mini"'+
    '          type="text"'+
    '          class="vue-picker-panel__link-btn"'+
    '          @click="handleClear">'+
    '          {{ $t(\'vue.datepicker.clear\') }}'+
    '        </vue-button>'+
    '        <vue-button'+
    '          plain'+
    '          size="mini"'+
    '          class="vue-picker-panel__link-btn"'+
    '          :disabled="btnDisabled"'+
    '          @click="handleConfirm(false)">'+
    '          {{ $t(\'vue.datepicker.confirm\') }}'+
    '        </vue-button>'+
    '      </div>'+
    '    </div>'+
    '  </transition>',
    components: {
      TimePicker: VueTimePicker,
      DateTable: DateTable
    },
    directives: {
      Clickoutside: VueUtil.component.clickoutside()
    },
    computed: {
      btnDisabled: function () {
        return !(this.minDate && this.maxDate && !this.selecting && this.isValidValue([this.minDate, this.maxDate]));
      },
      leftLabel: function () {
        return this.leftDate.getFullYear() + ' ' + this.$t('vue.datepicker.year') + ' ' + this.$t('vue.datepicker.month'.concat(this.leftDate.getMonth() + 1));
      },
      rightLabel: function () {
        return this.rightDate.getFullYear() + ' ' + this.$t('vue.datepicker.year') + ' ' + this.$t('vue.datepicker.month'.concat(this.rightDate.getMonth() + 1));
      },
      leftYear: function () {
        return this.leftDate.getFullYear();
      },
      leftMonth: function () {
        return this.leftDate.getMonth();
      },
      leftMonthDate: function () {
        return this.leftDate.getDate();
      },
      rightYear: function () {
        return this.rightDate.getFullYear();
      },
      rightMonth: function () {
        return this.rightDate.getMonth();
      },
      rightMonthDate: function () {
        return this.rightDate.getDate();
      },
      minVisibleDate: function () {
        if (this.dateUserInput.min !== null) return this.dateUserInput.min;
        if (this.minDate) return formatDate(this.minDate, this.dateFormat);
        return '';
      },
      maxVisibleDate: function () {
        if (this.dateUserInput.max !== null) return this.dateUserInput.max;
        if (this.maxDate || this.minDate) return formatDate(this.maxDate || this.minDate, this.dateFormat);
        return '';
      },
      minVisibleTime: function () {
        if (this.timeUserInput.min !== null) return this.timeUserInput.min;
        if (this.minDate) return formatDate(this.minDate, this.timeFormat);
        return '';
      },
      maxVisibleTime: function () {
        if (this.timeUserInput.max !== null) return this.timeUserInput.max;
        if (this.maxDate || this.minDate) return formatDate(this.maxDate || this.minDate, this.timeFormat);
        return '';
      },
      timeFormat: function () {
        if (this.format) {
          return extractTimeFormat(this.format);
        } else {
          return 'HH:mm:ss';
        }
      },
      dateFormat: function () {
        if (this.format) {
          return extractDateFormat(this.format);
        } else {
          return 'yyyy-MM-dd';
        }
      },
      enableMonthArrow: function () {
        var nextMonth = (this.leftMonth + 1) % 12;
        var yearOffset = this.leftMonth + 1 >= 12 ? 1 : 0;
        return this.unlinkPanels && new Date(this.leftYear + yearOffset, nextMonth) < new Date(this.rightYear, this.rightMonth);
      },
      enableYearArrow: function () {
        return this.unlinkPanels && this.rightYear * 12 + this.rightMonth - (this.leftYear * 12 + this.leftMonth + 1) >= 12;
      }
    },
    data: function () {
      return {
        popperClass: '',
        value: [],
        defaultValue: null,
        defaultTime: null,
        minDate: '',
        maxDate: '',
        leftDate: new Date(),
        rightDate: nextMonth(new Date()),
        rangeState: {
          endDate: null,
          selecting: false,
          row: null,
          column: null
        },
        showTime: false,
        shortcuts: '',
        visible: '',
        disabledDate: '',
        firstDayOfWeek: 7,
        minTimePickerVisible: false,
        maxTimePickerVisible: false,
        format: '',
        arrowControl: false,
        unlinkPanels: false,
        dateUserInput: {
          min: null,
          max: null
        },
        timeUserInput: {
          min: null,
          max: null
        }
      };
    },
    watch: {
      minDate: function (val) {
        var self = this;
  
        this.dateUserInput.min = null;
        this.timeUserInput.min = null;
        this.$nextTick(function () {
          if (self.$refs.maxTimePicker && self.maxDate && self.maxDate < self.minDate) {
            var format = 'HH:mm:ss';
            self.$refs.maxTimePicker.selectableRange = [[parseDate(formatDate(self.minDate, format), format), parseDate('23:59:59', format)]];
          }
        });
  
        if (val && this.$refs.minTimePicker) {
          this.$refs.minTimePicker.date = val;
          this.$refs.minTimePicker.value = val;
        }
      },
      maxDate: function (val) {
        this.dateUserInput.max = null;
        this.timeUserInput.max = null;
  
        if (val && this.$refs.maxTimePicker) {
          this.$refs.maxTimePicker.date = val;
          this.$refs.maxTimePicker.value = val;
        }
      },
      minTimePickerVisible: function (val) {
        var self = this;
  
        if (val) {
          this.$nextTick(function () {
            self.$refs.minTimePicker.date = self.minDate;
            self.$refs.minTimePicker.value = self.minDate;
  
            self.$refs.minTimePicker.adjustSpinners();
          });
        }
      },
      maxTimePickerVisible: function (val) {
        var self = this;
  
        if (val) {
          this.$nextTick(function () {
            self.$refs.maxTimePicker.date = self.maxDate;
            self.$refs.maxTimePicker.value = self.maxDate;
  
            self.$refs.maxTimePicker.adjustSpinners();
          });
        }
      },
      value: function (newVal) {
        if (!newVal) {
          this.minDate = null;
          this.maxDate = null;
        } else if (Array.isArray(newVal)) {
          this.minDate = isDate(newVal[0]) ? new Date(newVal[0]) : null;
          this.maxDate = isDate(newVal[1]) ? new Date(newVal[1]) : null;
  
          if (this.minDate) {
            this.leftDate = this.minDate;
  
            if (this.unlinkPanels && this.maxDate) {
              var minDateYear = this.minDate.getFullYear();
              var minDateMonth = this.minDate.getMonth();
              var maxDateYear = this.maxDate.getFullYear();
              var maxDateMonth = this.maxDate.getMonth();
              this.rightDate = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? nextMonth(this.maxDate) : this.maxDate;
            } else {
              this.rightDate = nextMonth(this.leftDate);
            }
          } else {
            this.leftDate = calcDefaultValue(this.defaultValue)[0];
            this.rightDate = nextMonth(this.leftDate);
          }
        }
      },
      defaultValue: function (val) {
        if (!Array.isArray(this.value)) {
          var _calcDefaultValue = calcDefaultValue(val),
              left = _calcDefaultValue[0],
              right = _calcDefaultValue[1];
  
          this.leftDate = left;
          this.rightDate = val && val[1] && this.unlinkPanels ? right : nextMonth(this.leftDate);
        }
      }
    },
    methods: {
      handleClear: function () {
        this.minDate = null;
        this.maxDate = null;
        this.leftDate = calcDefaultValue(this.defaultValue)[0];
        this.rightDate = nextMonth(this.leftDate);
        this.$emit('pick', null);
      },
      handleChangeRange: function (val) {
        this.minDate = val.minDate;
        this.maxDate = val.maxDate;
        this.rangeState = val.rangeState;
      },
      handleDateInput: function (value, type) {
        this.dateUserInput[type] = value;
        if (value.length !== this.dateFormat.length) return;
        var parsedValue = parseDate(value, this.dateFormat);
  
        if (parsedValue) {
          if (typeof this.disabledDate === 'function' && this.disabledDate(new Date(parsedValue))) {
            return;
          }
  
          if (type === 'min') {
            this.minDate = modifyDate(this.minDate || new Date(), parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
            this.leftDate = new Date(parsedValue);
  
            if (!this.unlinkPanels) {
              this.rightDate = nextMonth(this.leftDate);
            }
          } else {
            this.maxDate = modifyDate(this.maxDate || new Date(), parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
            this.rightDate = new Date(parsedValue);
  
            if (!this.unlinkPanels) {
              this.leftDate = prevMonth(parsedValue);
            }
          }
        }
      },
      handleDateChange: function (value, type) {
        var parsedValue = parseDate(value, this.dateFormat);
  
        if (parsedValue) {
          if (type === 'min') {
            this.minDate = modifyDate(this.minDate, parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
  
            if (this.minDate > this.maxDate) {
              this.maxDate = this.minDate;
            }
          } else {
            this.maxDate = modifyDate(this.maxDate, parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());
  
            if (this.maxDate < this.minDate) {
              this.minDate = this.maxDate;
            }
          }
        }
      },
      handleTimeInput: function (value, type) {
        var self = this;
  
        this.timeUserInput[type] = value;
        if (value.length !== this.timeFormat.length) return;
        var parsedValue = parseDate(value, this.timeFormat);
  
        if (parsedValue) {
          if (type === 'min') {
            this.minDate = modifyTime(this.minDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
            this.$nextTick(function (_) {
              return self.$refs.minTimePicker.adjustSpinners();
            });
          } else {
            this.maxDate = modifyTime(this.maxDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
            this.$nextTick(function (_) {
              return self.$refs.maxTimePicker.adjustSpinners();
            });
          }
        }
      },
      handleTimeChange: function (value, type) {
        var parsedValue = parseDate(value, this.timeFormat);
  
        if (parsedValue) {
          if (type === 'min') {
            this.minDate = modifyTime(this.minDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
  
            if (this.minDate > this.maxDate) {
              this.maxDate = this.minDate;
            }
  
            this.$refs.minTimePicker.value = this.minDate;
            this.minTimePickerVisible = false;
          } else {
            this.maxDate = modifyTime(this.maxDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());
  
            if (this.maxDate < this.minDate) {
              this.minDate = this.maxDate;
            }
  
            this.$refs.maxTimePicker.value = this.minDate;
            this.maxTimePickerVisible = false;
          }
        }
      },
      handleRangePick: function (val) {
        var self = this;
  
        var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var defaultTime = this.defaultTime || [];
        var minDate = modifyWithTimeString(val.minDate, defaultTime[0]);
        var maxDate = modifyWithTimeString(val.maxDate, defaultTime[1]);
  
        if (this.maxDate === maxDate && this.minDate === minDate) {
          return;
        }
  
        this.onPick && this.onPick(val);
        this.maxDate = maxDate;
        this.minDate = minDate; // workaround for https://github.com/ElemeFE/element/issues/7539, should remove this block when we don't have to care about Chromium 55 - 57
  
        setTimeout(function () {
          self.maxDate = maxDate;
          self.minDate = minDate;
        }, 10);
        if (!close || this.showTime) return;
        this.handleConfirm();
      },
      handleShortcutClick: function (shortcut) {
        if (shortcut.onClick) {
          shortcut.onClick(this);
        }
      },
      handleMinTimePick: function (value, visible, first) {
        this.minDate = this.minDate || new Date();
  
        if (value) {
          this.minDate = modifyTime(this.minDate, value.getHours(), value.getMinutes(), value.getSeconds());
        }
  
        if (!first) {
          this.minTimePickerVisible = visible;
        }
  
        if (!this.maxDate || this.maxDate && this.maxDate.getTime() < this.minDate.getTime()) {
          this.maxDate = new Date(this.minDate);
        }
      },
      handleMinTimeClose: function () {
        this.minTimePickerVisible = false;
      },
      handleMaxTimePick: function (value, visible, first) {
        if (this.maxDate && value) {
          this.maxDate = modifyTime(this.maxDate, value.getHours(), value.getMinutes(), value.getSeconds());
        }
  
        if (!first) {
          this.maxTimePickerVisible = visible;
        }
  
        if (this.maxDate && this.minDate && this.minDate.getTime() > this.maxDate.getTime()) {
          this.minDate = new Date(this.maxDate);
        }
      },
      handleMaxTimeClose: function () {
        this.maxTimePickerVisible = false;
      },
      // leftPrev*, rightNext* need to take care of `unlinkPanels`
      leftPrevYear: function () {
        this.leftDate = prevYear(this.leftDate);
  
        if (!this.unlinkPanels) {
          this.rightDate = nextMonth(this.leftDate);
        }
      },
      leftPrevMonth: function () {
        this.leftDate = prevMonth(this.leftDate);
  
        if (!this.unlinkPanels) {
          this.rightDate = nextMonth(this.leftDate);
        }
      },
      rightNextYear: function () {
        if (!this.unlinkPanels) {
          this.leftDate = nextYear(this.leftDate);
          this.rightDate = nextMonth(this.leftDate);
        } else {
          this.rightDate = nextYear(this.rightDate);
        }
      },
      rightNextMonth: function () {
        if (!this.unlinkPanels) {
          this.leftDate = nextMonth(this.leftDate);
          this.rightDate = nextMonth(this.leftDate);
        } else {
          this.rightDate = nextMonth(this.rightDate);
        }
      },
      // leftNext*, rightPrev* are called when `unlinkPanels` is true
      leftNextYear: function () {
        this.leftDate = nextYear(this.leftDate);
      },
      leftNextMonth: function () {
        this.leftDate = nextMonth(this.leftDate);
      },
      rightPrevYear: function () {
        this.rightDate = prevYear(this.rightDate);
      },
      rightPrevMonth: function () {
        this.rightDate = prevMonth(this.rightDate);
      },
      handleConfirm: function () {
        var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  
        if (this.isValidValue([this.minDate, this.maxDate])) {
          this.$emit('pick', [this.minDate, this.maxDate], visible);
        }
      },
      isValidValue: function (value) {
        return Array.isArray(value) && value && value[0] && value[1] && isDate(value[0]) && isDate(value[1]) && value[0].getTime() <= value[1].getTime() && (typeof this.disabledDate === 'function' ? !this.disabledDate(value[0]) && !this.disabledDate(value[1]) : true);
      },
      resetView: function () {
        // NOTE: this is a hack to reset {min, max}Date on picker open.
        // TODO: correct way of doing so is to refactor {min, max}Date to be dependent on value and internal selection state
        //       an alternative would be resetView whenever picker becomes visible, should also investigate date-panel's resetView
        this.minDate = this.value && isDate(this.value[0]) ? new Date(this.value[0]) : null;
        this.maxDate = this.value && isDate(this.value[0]) ? new Date(this.value[1]) : null;
      }
    }
  };

  var getPanel = function (type) {
    if (type === 'daterange' || type === 'datetimerange') {
      return DateRangePanel;
    } else if (type === 'monthrange') {
      return MonthRangePanel;
    }
  
    return DatePanel;
  };
  var VueDatePicker = {
    mixins: [VuePicker],
    name: 'VueDatePicker',
    props: {
      type: {
        type: String,
        default: 'date'
      },
      timeArrowControl: Boolean
    },
    watch: {
      type: function (_type) {
        if (this.picker) {
          this.unmountPicker();
          this.panel = getPanel(_type);
          this.mountPicker();
        } else {
          this.panel = getPanel(_type);
        }
      }
    },
    created: function () {
      this.panel = getPanel(this.type);
    }
  };
  Vue.component(VueDatePicker.name, VueDatePicker);
  return function() {
    return {
      DatePanel: DatePanel,
      YearTable: YearTable,
      MonthTable: MonthTable
    };
  };
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VuePopup'], definition);
  } else {
    context.VueMessageBox = definition(context.Vue, context.VueUtil, context.VuePopup);
    delete context.VueMessageBox;
  }
})(this, function(Vue, VueUtil, VuePopup) {
  'use strict';
  var VueMessageBox = {
    template: '<div><div class="vue-message-box__wrapper" v-show="visible"></div><transition name="msgbox-fade" @after-leave="doDestroy"><div :class="[\'vue-message-box\', customClass]" v-show="visible"><div class="vue-message-box__header" v-if="title !== null"><div class="vue-message-box__title">{{title || $t(\'vue.messagebox.title\')}}</div></div><div class="vue-message-box__content" v-if="message !== \'\'"><div :class="[\'vue-message-box__status\', typeClass]"></div><div class="vue-message-box__message" :style="{\'margin-left\': typeClass ? \'50px\' : \'0\'}"><slot><p>{{message}}</p></slot></div></div><div class="vue-message-box__btns"><vue-button :loading="cancelButtonLoading" :class="[cancelButtonClasses]" v-if="showCancelButton" @click.native="handleAction(\'cancel\')">{{cancelButtonText || $t(\'vue.messagebox.cancel\')}}</vue-button><vue-button :loading="confirmButtonLoading" ref="confirm" :class="[confirmButtonClasses]" @click.native="handleAction(\'confirm\')">{{confirmButtonText || $t(\'vue.messagebox.confirm\')}}</vue-button></div></div></transition></div>',
    mixins: [VuePopup],
    computed: {
      typeClass: function() {
        var typeMap = {
          success: 'success',
          info: 'information',
          warning: 'warning',
          error: 'error'
        };
        return this.type && typeMap[this.type.toLowerCase()] ? 'vue-icon-' + typeMap[this.type.toLowerCase()] : '';
      },
      confirmButtonClasses: function() {
        return 'vue-button--primary ' + this.confirmButtonClass;
      },
      cancelButtonClasses: function() {
        return this.cancelButtonClass;
      }
    },
    methods: {
      getSafeClose: function() {
        var self = this;
        var currentId = self.uid;
        return function() {
          self.$nextTick(function() {
            if (currentId === self.uid) self.doClose();
          });
        };
      },
      doClose: function() {
        var self = this;
        if (!self.visible) return;
        self.visible = false;
        self.opened = false;
        if (self.action) self.callback(self.action, self);
      },
      handleAction: function(action) {
        this.action = action;
        if (VueUtil.isFunction(this.beforeClose)) {
          this.close = this.getSafeClose();
          this.beforeClose(action, this, this.close);
        } else {
          this.doClose();
        }
      },
      doDestroy: function() {
        this.$destroy();
      }
    },
    watch: {
      visible: function(val) {
        var self = this;
        if (val) {
          self.uid++;
          self.$nextTick(function() {
            self.$refs.confirm.$el.focus();
          });
        }
      }
    },
    data: function() {
      return {
        uid: 1,
        title: null,
        message: '',
        type: '',
        customClass: '',
        showCancelButton: false,
        action: '',
        confirmButtonText: '',
        cancelButtonText: '',
        confirmButtonLoading: false,
        cancelButtonLoading: false,
        confirmButtonClass: '',
        cancelButtonClass: '',
        callback: null,
        beforeClose: null
      };
    }
  };
  var MessageBoxConstructor = Vue.extend(VueMessageBox);
  var currentMsg, instance;
  var msgQueue = [];
  var defaultCallback = function(action) {
    if (currentMsg) {
      if (action === 'confirm') {
        currentMsg.resolve(action);
      }
      if (action === 'cancel') {
        currentMsg.reject(action);
      }
    }
  };
  var initInstance = function() {
    instance = new MessageBoxConstructor({
      el: document.createElement('div')
    });
    instance.callback = defaultCallback;
  };
  var showNextMsg = function() {
    initInstance();
    instance.action = '';
    if (!instance.visible) {
      if (msgQueue.length > 0) {
        currentMsg = msgQueue.shift();
        var options = currentMsg.options;
        VueUtil.ownPropertyLoop(options, function(prop) {
          instance[prop] = options[prop];
        });
        if (!VueUtil.isDef(options.callback)) {
          instance.callback = defaultCallback;
        }
        var oldCb = instance.callback;
        instance.callback = function(action, instance) {
          oldCb(action, instance);
          showNextMsg();
        };
        if (VueUtil.isVNode(instance.message)) {
          instance.$slots.default = [instance.message];
          instance.message = null;
        }
        document.body.appendChild(instance.$el);
        Vue.nextTick(function() {
          instance.visible = true;
        });
      }
    }
  };
  var MessageBox = function(options) {
    var callback;
    if (options.callback) {
      callback = options.callback;
    }
    return new Promise(function(resolve, reject) {
      msgQueue.push({
        options: VueUtil.merge({}, options, {closeOnPressEscape: false}),
        callback: callback,
        resolve: resolve,
        reject: reject
      });
      showNextMsg();
    });
  };
  var messageBoxAlert = function(options) {
    return new MessageBox(VueUtil.merge({}, options, {showCancelButton: false}));
  };
  var messageBoxConfirm = function(options) {
    return new MessageBox(VueUtil.merge({}, options, {showCancelButton: true}));
  };
  Vue.prototype.$alert = messageBoxAlert;
  Vue.prototype.$confirm = messageBoxConfirm;
  Vue.alert = messageBoxAlert;
  Vue.confirm = messageBoxConfirm;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueNotification = definition(context.Vue, context.VueUtil);
    delete context.VueNotification;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueNotification = {
    template: '<transition :name="isLeft ? \'notify-left\' : isTop ? \'notify-top\' : isBottom ? \'notify-bottom\' : isCenter? \'notify-center\' : \'notify-right\'" @after-leave="doDestroy"><div :class="[\'vue-notification\', {\'vue-notification-translateX\':centerX, \'vue-notification-translateY\':centerY},customClass]" v-show="visible" :style="{top: top ? top + \'px\' : \'auto\', bottom: bottom ? bottom + \'px\' : \'auto\', left: left ? left + \'px\' : \'auto\', right: right ? right + \'px\' : \'auto\'}"><i :class="[\'vue-notification__icon\', typeClass, iconClass]" v-if="type || iconClass"></i><div class="vue-notification__group"><h2 class="vue-notification__title" v-text="title" v-if="showTitle"></h2><div class="vue-notification__content" v-if="showMessage" :style="{\'margin-top\':showTitle?\'10px\':\'\'}"><slot>{{message}}</slot></div><div class="vue-notification__closeBtn vue-icon-close" @click="close" v-if="duration===0 || showClose"></div></div></div></transition>',
    data: function() {
      return {
        visible: false,
        title: '',
        message: '',
        duration: 3000,
        type: '',
        customClass: '',
        iconClass: '',
        onClose: null,
        closed: false,
        top: null,
        bottom: null,
        left: null,
        right: null,
        centerX: false,
        centerY: false,
        position: 'top-right',
        isLeft: false,
        isTop: false,
        isBottom: false,
        isCenter: false,
        showClose: false
      };
    },
    computed: {
      showTitle: function() {
        if (VueUtil.trim(this.title) === '') {
          return false;
        }
        return true;
      },
      showMessage: function() {
        if (VueUtil.trim(this.message) === '' && !this.$slots.default) {
          return false;
        }
        return true;
      },
      typeClass: function() {
        var typeMap = {
          success: 'success',
          info: 'information',
          warning: 'warning',
          error: 'error'
        };
        return this.type && typeMap[this.type.toLowerCase()] ? 'vue-icon-' + typeMap[this.type.toLowerCase()] : '';
      }
    },
    methods: {
      close: function() {
        this.closed = true;
        if (VueUtil.isFunction(this.onClose)) {
          this.onClose();
        }
      },
      doDestroy: function() {
        this.$destroy();
      }
    },
    mounted: function() {
      if (this.duration > 0) {
        VueUtil.debounce(this.duration, function() {
          !this.closed && this.close();
        }).call(this);
      }
    }
  };
  var NotificationConstructor = Vue.extend(VueNotification);
  var instances = [];
  var leftTopInstances = [];
  var leftBottomInstances = [];
  var rightTopInstances = [];
  var rightBottomInstances = [];
  var centerTopInstances = [];
  var centerBottomInstances = [];
  var insertIns = function(insertInstances, instance, position) {
    var distHeight = 8;
    instance[position] = distHeight;
    if (!VueUtil.config.notifyStack) {
      VueUtil.loop(insertInstances, function(insertInstance) {
        distHeight += insertInstance.dom.offsetHeight + 8;
      });
      instance[position] = distHeight;
    }
    insertInstances.push(instance);
  };
  var removeIns = function(removeInstances, instance, position) {
    var removedHeight = instance.dom.offsetHeight + 8;
    var removeIndex = removeInstances.indexOf(instance);
    removeInstances.splice(removeIndex, 1);
    if (!VueUtil.config.notifyStack) {
      VueUtil.loop(removeInstances, function(removeInstance, index) {
        if (index < removeIndex) return;
        removeInstance.dom.style[position] = parseInt(removeInstance.dom.style[position], 10) - removedHeight + 'px';
      });
    }
  };
  var getinsPos = function(instance) {
    var instancePosition = instance.position.split('-');
    var positionX = instancePosition[1];
    var positionY = instancePosition[0];
    var insPos = {};
    insPos.isLeft = (positionX.indexOf('left') !== -1);
    insPos.isCenterX = (positionX.indexOf('center') !== -1);
    insPos.isRight = (positionX.indexOf('right') !== -1);
    insPos.isTop = (positionY.indexOf('top') !== -1);
    insPos.isCenterY = (positionY.indexOf('center') !== -1);
    insPos.isBottom = (positionY.indexOf('bottom') !== -1);
    return insPos;
  };
  var Notification = function(options) {
    options = options || {};
    var userOnClose = options.onClose;
    var id = 'notification-' + VueUtil.createUuid();
    options.onClose = function() {
      Notification.close(id, userOnClose);
    };
    var instance = new NotificationConstructor({
      data: options
    });
    if (VueUtil.isVNode(options.message)) {
      instance.$slots.default = [options.message];
      options.message = '';
    }
    instance.id = id;
    instance.vm = instance.$mount();
    instance.dom = instance.vm.$el;
    instance.dom.style.zIndex = VueUtil.nextZIndex();
    var insPos = getinsPos(instance);
    if ((!insPos.isLeft && !insPos.isCenterX && !insPos.isRight) || (!insPos.isTop && !insPos.isCenterY && !insPos.isBottom)) {
      instance.$destroy();
      return;
    }
    instance.isLeft = false;
    instance.isBottom = false;
    instance.top = false;
    instance.isCenter = false;
    if (insPos.isCenterY) {
      instance.centerY = true;
    }
    if (insPos.isLeft) {
      instance.left = 8;
      instance.isLeft = true;
    }
    if (insPos.isCenterX) {
      instance.centerX = true;
      instance.isCenter = true;
      insPos.isBottom && (instance.isBottom = true);
      insPos.isTop && (instance.isTop = true);
    }
    if (insPos.isRight) {
      instance.right = 8;
    }
    if (insPos.isBottom) {
      var position = 'bottom';
      insPos.isLeft && insertIns(leftBottomInstances, instance, position);
      insPos.isCenterX && insertIns(centerBottomInstances, instance, position);
      insPos.isRight && insertIns(rightBottomInstances, instance, position);
    }
    if (insPos.isTop) {
      var position = 'top';
      insPos.isLeft && insertIns(leftTopInstances, instance, position);
      insPos.isCenterX && insertIns(centerTopInstances, instance, position);
      insPos.isRight && insertIns(rightTopInstances, instance, position);
    }
    instance.dom.style.display = '';
    instance.dom.style.opacity = 0;
    instances.push(instance);
    document.body.appendChild(instance.vm.$el);
    Vue.nextTick(function() {
      instance.vm.visible = true;
      instance.dom.style.opacity = 1;
    });
  };
  VueUtil.loop(['success', 'warning', 'info', 'error'], function(type) {
    Notification[type] = function(options) {
      options.type = type;
      Notification(options);
    };
  });
  Notification.close = function(id, userOnClose) {
    VueUtil.loop(instances, function(instance, i) {
      if (id === instance.id) {
        if (VueUtil.isFunction(userOnClose)) {
          userOnClose(instance);
        }
        var insPos = getinsPos(instance);
        if (insPos.isBottom) {
          var position = 'bottom';
          insPos.isLeft && removeIns(leftBottomInstances, instance, position);
          insPos.isCenterX && removeIns(centerBottomInstances, instance, position);
          insPos.isRight && removeIns(rightBottomInstances, instance, position);
        }
        if (insPos.isTop) {
          var position = 'top';
          insPos.isLeft && removeIns(leftTopInstances, instance, position);
          insPos.isCenterX && removeIns(centerTopInstances, instance, position);
          insPos.isRight && removeIns(rightTopInstances, instance, position);
        }
        instance.vm.visible = false;
        instances.splice(i, 1);
        return false;
      }
    });
  };
  Vue.prototype.$notify = Notification;
  Vue.notify = Notification;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VuePagination = definition(context.Vue, context.VueUtil);
    delete context.VuePagination;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VuePager = {
    template: '<ul @click="onPagerClick" class="vue-pager"><li :class="{active: currentPage === 1}" v-if="pageCount > 0" class="number">1</li><li :class="[\'vue-icon more btn-quickprev\', quickprevIconClass]" v-if="showPrevMore" @mouseenter="quickprevIconClass = \'vue-icon-d-arrow-left\'" @mouseleave="quickprevIconClass = \'vue-icon-more\'"></li><li v-for="pager in pagers" :class="[\'number\', {active: currentPage === pager}]">{{pager}}</li><li :class="[\'vue-icon more btn-quicknext\', quicknextIconClass]" v-if="showNextMore" @mouseenter="quicknextIconClass = \'vue-icon-d-arrow-right\'" @mouseleave="quicknextIconClass = \'vue-icon-more\'"></li><li :class="[\'number\', {active: currentPage === pageCount}]" v-if="pageCount > 1">{{pageCount}}</li></ul>',
    name: 'VuePager',
    props: {
      currentPage: Number,
      pageCount: Number
    },
    watch: {
      showPrevMore: function(val) {
        if (!val) this.quickprevIconClass = 'vue-icon-more';
      },
      showNextMore: function(val) {
        if (!val) this.quicknextIconClass = 'vue-icon-more';
      }
    },
    methods: {
      onPagerClick: function(event) {
        var target = event.target;
        if (target.tagName === 'UL') {
          return;
        }
        var newPage = Number(event.target.textContent);
        var pageCount = this.pageCount;
        var currentPage = this.currentPage;
        if (target.className.indexOf('more') !== -1) {
          if (target.className.indexOf('quickprev') !== -1) {
            newPage = currentPage - 5;
          } else if (target.className.indexOf('quicknext') !== -1) {
            newPage = currentPage + 5;
          }
        }
        if (!isNaN(newPage)) {
          if (newPage < 1) {
            newPage = 1;
          }
          if (newPage > pageCount) {
            newPage = pageCount;
          }
        }
        if (newPage !== currentPage) {
          this.$emit('change', newPage);
        }
      }
    },
    computed: {
      pagers: function() {
        var pagerCount = 7;
        var currentPage = Number(this.currentPage);
        var pageCount = Number(this.pageCount);
        var showPrevMore = false;
        var showNextMore = false;
        if (pageCount > pagerCount) {
          if (currentPage > pagerCount - 2) {
            showPrevMore = true;
          }
          if (currentPage < pageCount - 2) {
            showNextMore = true;
          }
        }
        var array = [];
        if (showPrevMore && !showNextMore) {
          var startPage = pageCount - (pagerCount - 2);
          for (var i = startPage; i < pageCount; i++) {
            array.push(i);
          }
        } else if (!showPrevMore && showNextMore) {
          for (var i = 2; i < pagerCount; i++) {
            array.push(i);
          }
        } else if (showPrevMore && showNextMore) {
          var offset = Math.floor(pagerCount / 2) - 1;
          for (var i = currentPage - offset; i <= currentPage + offset; i++) {
            array.push(i);
          }
        } else {
          for (var i = 2; i < pageCount; i++) {
            array.push(i);
          }
        }
        this.showPrevMore = showPrevMore;
        this.showNextMore = showNextMore;
        return array;
      }
    },
    data: function() {
      return {
        current: null,
        showPrevMore: false,
        showNextMore: false,
        quicknextIconClass: 'vue-icon-more',
        quickprevIconClass: 'vue-icon-more'
      };
    }
  };
  var VuePagination = {
    name: 'VuePagination',
    props: {
      pageSize: {
        type: Number,
        default: 10
      },
      small: Boolean,
      total: Number,
      pageCount: Number,
      currentPage: {
        type: Number,
        default: 1
      },
      layout: {
        default: 'prev, pager, next, jumper, ->, total'
      },
      pageSizes: {
        type: Array,
        default: function() {
          return [10, 20, 30, 40, 50, 100];
        }
      }
    },
    data: function() {
      return {
        internalCurrentPage: 1,
        internalPageSize: 0
      };
    },
    render: function(createElement) {
      var self = this;
      var template = createElement('div', {class: 'vue-pagination'}, []);
      var layout = self.layout || '';
      if (!layout) return;
      var TEMPLATE_MAP = {
        prev: createElement('prev', null, []),
        jumper: createElement('jumper', null, []),
        pager: createElement('pager', {attrs: {currentPage: self.internalCurrentPage, pageCount: self.internalPageCount}, on: {change: self.handleCurrentChange}}, []),
        next: createElement('next', null, []),
        sizes: createElement('sizes', {attrs: {pageSizes: self.pageSizes}}, []),
        slot: createElement('my-slot', null, []),
        total: createElement('total', null, [])
      };
      var components = VueUtil.map(layout.split(','), function(item) {return item.trim();});
      var rightWrapper = createElement('div', {class: 'vue-pagination__rightwrapper'}, []);
      var haveRightWrapper = false;
      if (self.small) {
        template.data.class += ' vue-pagination--small';
      }
      VueUtil.loop(components, function(compo) {
        if (compo === '->') {
          haveRightWrapper = true;
          return;
        }
        if (!haveRightWrapper) {
          template.children.push(TEMPLATE_MAP[compo]);
        } else {
          rightWrapper.children.push(TEMPLATE_MAP[compo]);
        }
      });
      if (haveRightWrapper) {
        template.children.push(rightWrapper);
      }
      return template;
    },
    components: {
      MySlot: {
        render: function(createElement) {
          return this.$parent.$slots.default ? this.$parent.$slots.default[0] : '';
        }
      },
      Prev: {
        render: function(createElement) {
          return createElement('button', {attrs: {type: 'button'}, class: ['btn-prev', {disabled: this.$parent.internalCurrentPage <= 1}], on: {click: this.$parent.prev}}, [createElement('i', {class: 'vue-icon vue-icon-arrow-left'}, [])]);
        }
      },
      Next: {
        render: function(createElement) {
          return createElement('button', {attrs: {type: 'button'}, class: ['btn-next', {disabled: this.$parent.internalCurrentPage === this.$parent.internalPageCount || 0 === this.$parent.internalPageCount}], on: {click: this.$parent.next}}, [createElement('i', {class: 'vue-icon vue-icon-arrow-right'}, [])]);
        }
      },
      Sizes: {
        props: {
          pageSizes: Array
        },
        watch: {
          pageSizes: {
            immediate: true,
            handler: function(value) {
              if (VueUtil.isArray(value)) {
                this.$parent.internalPageSize = value.indexOf(this.$parent.pageSize) !== -1 ? this.$parent.pageSize : this.pageSizes[0];
              }
            }
          }
        },
        render: function(createElement) {
          var self = this;
          return createElement('span', {class: 'vue-pagination__sizes'}, [createElement('vue-select', {attrs: {value: this.$parent.internalPageSize}, on: {input: this.handleChange}}, [VueUtil.map(this.pageSizes, function(item) {return createElement('vue-option', {attrs: {value: item, label: item + ' ' + self.$t('vue.pagination.pagesize')}}, []);})])]);
        },
        methods: {
          handleChange: function(val) {
            if (val !== this.$parent.internalPageSize) {
              this.$parent.internalPageSize = val = parseInt(val, 10);
              this.$parent.$emit('size-change', val);
            }
          }
        }
      },
      Jumper: {
        data: function() {
          return {
            oldValue: null
          };
        },
        methods: {
          handleFocus: function(event) {
            this.oldValue = event.target.value;
          },
          handleChange: function(event) {
            this.$parent.internalCurrentPage = this.$parent.getValidCurrentPage(event.target.value);
            this.oldValue = null;
          }
        },
        render: function(createElement) {
          return createElement('span', {class: 'vue-pagination__jump'}, [this.$t('vue.pagination.goto'), createElement('input', {class: 'vue-pagination__editor', attrs: {type: 'number', min: 1, max: this.$parent.internalPageCount, number: !0}, domProps: {value: this.$parent.internalCurrentPage}, on: {change: this.handleChange, focus: this.handleFocus}, style: {width: '30px'}}, []), this.$t('vue.pagination.pageClassifier')]);
        }
      },
      Total: {
        render: function(createElement) {
          return VueUtil.isNumber(this.$parent.total) ? createElement('span', {class: 'vue-pagination__total'}, [this.$t('vue.pagination.total', {total: this.$parent.total})]) : '';
        }
      },
      Pager: VuePager
    },
    methods: {
      handleCurrentChange: function(val) {
        this.internalCurrentPage = this.getValidCurrentPage(val);
      },
      prev: function() {
        var newVal = this.internalCurrentPage - 1;
        this.internalCurrentPage = this.getValidCurrentPage(newVal);
      },
      next: function() {
        var newVal = this.internalCurrentPage + 1;
        this.internalCurrentPage = this.getValidCurrentPage(newVal);
      },
      getValidCurrentPage: function(value) {
        value = parseInt(value, 10);
        var havePageCount = VueUtil.isNumber(this.internalPageCount);
        var resetValue;
        if (!havePageCount) {
          if (isNaN(value) || value < 1) resetValue = 1;
        } else {
          if (value < 1) {
            resetValue = 1;
          } else if (value > this.internalPageCount) {
            resetValue = this.internalPageCount;
          }
        }
        if (!VueUtil.isDef(resetValue) && isNaN(value)) {
          resetValue = 1;
        } else if (resetValue === 0) {
          resetValue = 1;
        }
        return !VueUtil.isDef(resetValue) ? value : resetValue;
      }
    },
    computed: {
      internalPageCount: function() {
        if (VueUtil.isNumber(this.total)) {
          return Math.ceil(this.total / this.internalPageSize);
        } else if (VueUtil.isNumber(this.pageCount)) {
          return this.pageCount;
        }
        return null;
      }
    },
    watch: {
      currentPage: {
        immediate: true,
        handler: function(val) {
          this.internalCurrentPage = val;
        }
      },
      pageSize: {
        immediate: true,
        handler: function(val) {
          this.internalPageSize = val;
        }
      },
      internalCurrentPage: function(newVal, oldVal) {
        var self = this;
        newVal = parseInt(newVal, 10);
        if (isNaN(newVal)) {
          newVal = oldVal || 1;
        } else {
          newVal = self.getValidCurrentPage(newVal);
        }
        if (VueUtil.isDef(newVal)) {
          self.$nextTick(function() {
            self.internalCurrentPage = newVal;
            if (oldVal !== newVal) {
              self.$emit('current-change', self.internalCurrentPage);
            }
          });
        } else {
          self.$emit('current-change', self.internalCurrentPage);
        }
      },
      internalPageCount: function(newVal) {
        var oldPage = this.internalCurrentPage;
        if (newVal > 0 && oldPage === 0) {
          this.internalCurrentPage = 1;
        } else if (oldPage > newVal) {
          this.internalCurrentPage = newVal === 0 ? 1 : newVal;
        }
      }
    }
  };
  Vue.component(VuePagination.name, VuePagination);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueProgress = definition(context.Vue);
    delete context.VueProgress;
  }
})(this, function(Vue) {
  'use strict';
  var VueProgress = {
    template: '<div :class="[\'vue-progress\', \'vue-progress--\' + type, status ? \'is-\' + status : \'\',{\'vue-progress--without-text\': !showText,\'vue-progress--text-inside\': textInside,}]"><div class="vue-progress-bar" v-if="type === \'line\'"><div class="vue-progress-bar__outer" :style="{height: strokeWidth + \'px\'}"><div class="vue-progress-bar__inner" :style="barStyle"><div class="vue-progress-bar__innerText" v-if="showText && textInside">{{percentage}}%</div></div></div></div><div class="vue-progress-circle" :style="{height: width + \'px\', width: width + \'px\'}" v-else><svg viewBox="0 0 100 100"><path class="vue-progress-circle__track" :d="trackPath" stroke="#e5e9f2" :stroke-width="relativeStrokeWidth" fill="none"></path><path class="vue-progress-circle__path" :d="trackPath" stroke-linecap="round" :stroke="stroke" :stroke-width="relativeStrokeWidth" fill="none" :style="circlePathStyle"></path></svg></div><div class="vue-progress__text" v-if="showText && !textInside" :style="{fontSize: progressTextSize + \'px\'}"><template v-if="!status">{{percentage}}%</template><i v-else :class="iconClass"></i></div></div>',
    name: 'VueProgress',
    props: {
      type: {
        type: String,
        default: 'line',
        validator: function(val) {return ['line', 'circle'].indexOf(val) !== -1;}
      },
      percentage: {
        type: Number,
        default: 0,
        validator: function(val) {return val >= 0 && val <= 100;}
      },
      status: {
        type: String
      },
      strokeWidth: {
        type: Number,
        default: 6
      },
      textInside: Boolean,
      width: {
        type: Number,
        default: 126
      },
      showText: {
        type: Boolean,
        default: true
      }
    },
    computed: {
      barStyle: function() {
        var style = {};
        style.width = this.percentage + '%';
        return style;
      },
      relativeStrokeWidth: function() {
        return (this.strokeWidth / this.width * 100).toFixed(1);
      },
      trackPath: function() {
        var radius = parseInt(50 - parseFloat(this.relativeStrokeWidth) / 2, 10);
        return 'M 50 50 m 0 -' + radius + ' a ' + radius + ' ' + radius + ' 0 1 1 0 ' + 2 * radius + ' a ' + radius + ' ' + radius + ' 0 1 1 0 -' + 2 * radius;
      },
      perimeter: function() {
        var radius = 50 - parseFloat(this.relativeStrokeWidth) / 2;
        return 2 * Math.PI * radius;
      },
      circlePathStyle: function() {
        var perimeter = this.perimeter;
        return {
          strokeDasharray: perimeter + 'px,' + perimeter + 'px',
          strokeDashoffset: (1 - this.percentage / 100) * perimeter + 'px',
          transition: 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease'
        };
      },
      stroke: function() {
        var ret;
        switch (this.status) {
          case 'success':
            ret = '#67c23a';
            break;
          case 'exception':
            ret = '#fb5555';
            break;
          default:
            ret = '#409eff';
        }
        return ret;
      },
      iconClass: function() {
        if (this.type === 'line') {
          return this.status === 'success' ? 'vue-icon-success' : 'vue-icon-error';
        } else {
          return this.status === 'success' ? 'vue-icon-check' : 'vue-icon-close';
        }
      },
      progressTextSize: function() {
        return this.type === 'line' ? 12 + this.strokeWidth * 0.4 : this.width * 0.25 + 6;
      }
    }
  };
  Vue.component(VueProgress.name, VueProgress);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueSlider = definition(context.Vue, context.VueUtil);
    delete context.VueSlider;
  }
})(this, function(Vue, VueUtil, VueTooltip) {
  'use strict';
  var VueSliderButton = {
    template: '<div @mouseenter="handleMouseEnter" @mouseleave="handleMouseLeave" @mousedown="onButtonDown" @touchstart="onButtonDown" :class="[\'vue-slider__button-wrapper\', {\'hover\': hovering, \'dragging\': dragging}]" :style="wrapperStyle" ref="button"><vue-tooltip placement="top" ref="tooltip" :disabled="!showTooltip"><span slot="content">{{formatValue}}</span><div :class="[\'vue-slider__button\', {\'hover\': hovering, \'dragging\': dragging}]"></div></vue-tooltip></div>',
    name: 'VueSliderButton',
    props: {
      value: {
        type: Number,
        default: 0
      },
      vertical: Boolean
    },
    data: function() {
      return {
        hovering: false,
        dragging: false,
        startX: 0,
        currentX: 0,
        startY: 0,
        currentY: 0,
        startPosition: 0,
        newPosition: null,
        oldValue: this.value
      };
    },
    computed: {
      disabled: function() {
        return this.$parent.disabled;
      },
      max: function() {
        return this.$parent.max;
      },
      min: function() {
        return this.$parent.min;
      },
      step: function() {
        return this.$parent.step;
      },
      showTooltip: function() {
        return this.$parent.showTooltip;
      },
      precision: function() {
        return this.$parent.precision;
      },
      currentPosition: function() {
        return (this.value - this.min) / (this.max - this.min) * 100 + '%';
      },
      enableFormat: function() {
        return this.$parent.formatTooltip instanceof Function;
      },
      formatValue: function() {
        return this.enableFormat && this.$parent.formatTooltip(this.value) || this.value;
      },
      wrapperStyle: function() {
        return this.vertical ? {bottom: this.currentPosition} : {left: this.currentPosition};
      }
    },
    watch: {
      dragging: function(val) {
        this.$parent.dragging = val;
      }
    },
    methods: {
      displayTooltip: function() {
        this.$refs.tooltip && (this.$refs.tooltip.showPopper = true);
      },
      hideTooltip: function() {
        this.$refs.tooltip && (this.$refs.tooltip.showPopper = false);
      },
      handleMouseEnter: function() {
        this.hovering = true;
        this.displayTooltip();
      },
      handleMouseLeave: function() {
        this.hovering = false;
        this.hideTooltip();
      },
      onButtonDown: function(event) {
        if (this.disabled) return;
        event.preventDefault();
        this.displayTooltip();
        this.onDragStart(event);
        VueUtil.addTouchMove(document, this.onDragging);
        VueUtil.addTouchEnd(document, this.onDragEnd);
        VueUtil.on(document, 'contextmenu', this.onDragEnd);
      },
      onDragStart: function(event) {
        this.dragging = true;
        if (this.vertical) {
          this.startY = event.clientY || event.touches[0].clientY;
        } else {
          this.startX = event.clientX || event.touches[0].clientX;
        }
        this.startPosition = parseFloat(this.currentPosition);
      },
      onDragging: function(event) {
        if (this.dragging) {
          this.displayTooltip();
          var diff = 0;
          var sliderSize = 1;
          var parentObj = this.$parent;
          if (parentObj.$refs.slider) {
            sliderSize = parentObj.$refs.slider['client' + (parentObj.vertical ? 'Height' : 'Width')];
          }
          if (this.vertical) {
            this.currentY = event.clientY || event.touches[0].clientY;
            diff = (this.startY - this.currentY) / sliderSize * 100;
          } else {
            this.currentX = event.clientX || event.touches[0].clientX;
            diff = (this.currentX - this.startX) / sliderSize * 100;
          }
          this.newPosition = this.startPosition + diff;
          this.setPosition(this.newPosition);
        }
      },
      onDragEnd: function() {
        if (this.dragging) {
          VueUtil.debounce(function() {
            this.dragging = false;
            this.hideTooltip();
            this.setPosition(this.newPosition);
          }).call(this);
          VueUtil.removeTouchMove(document, this.onDragging);
          VueUtil.removeTouchEnd(document, this.onDragEnd);
          VueUtil.off(document, 'contextmenu', this.onDragEnd);
        }
      },
      setPosition: function(newPosition) {
        if (newPosition === null) return;
        if (newPosition < 0) {
          newPosition = 0;
        } else if (newPosition > 100) {
          newPosition = 100;
        }
        var lengthPerStep = 100 / ((this.max - this.min) / this.step);
        var steps = Math.round(newPosition / lengthPerStep);
        var value = steps * lengthPerStep * (this.max - this.min) * 0.01 + this.min;
        value = parseFloat(value.toFixed(this.precision));
        this.$emit('input', value);
        this.$refs.tooltip && this.$refs.tooltip.updatePopper();
        if (!this.dragging && this.value !== this.oldValue) {
          this.oldValue = this.value;
        }
      }
    }
  };
  var VueSlider = {
    template: '<div class="vue-slider" :class="{\'is-vertical\': vertical}"><div :class="[\'vue-slider__runway\', {\'disabled\': disabled}]" :style="runwayStyle" @click="onSliderClick" ref="slider"><div class="vue-slider__bar" :style="barStyle"></div><slider-button :vertical="vertical" v-model="firstValue" ref="button1"></slider-button><slider-button :vertical="vertical" v-model="secondValue" ref="button2" v-if="range"></slider-button><div class="vue-slider__stop" v-for="item in stops" :style="vertical ? {\'bottom\': item + \'%\'} : {\'left\': item + \'%\'}" v-if="showStops"></div></div></div>',
    name: 'VueSlider',
    mixins: [VueUtil.component.emitter],
    props: {
      min: {
        type: Number,
        default: 0
      },
      max: {
        type: Number,
        default: 100
      },
      step: {
        type: Number,
        default: 1
      },
      value: {
        type: [Number, Array],
        default: 0
      },
      showStops: Boolean,
      showTooltip: {
        type: Boolean,
        default: true
      },
      formatTooltip: Function,
      disabled: Boolean,
      range: Boolean,
      vertical: Boolean,
      height: {
        type: Number,
        default: 200
      }
    },
    components: {
      SliderButton: VueSliderButton
    },
    data: function() {
      return {
        firstValue: null,
        secondValue: null,
        oldValue: null,
        dragging: false
      };
    },
    watch: {
      value: function(val, oldVal) {
        if (this.dragging ||
          VueUtil.isArray(val) &&
          VueUtil.isArray(oldVal) &&
          val.every(function(item, index) {return item === oldVal[index];})) {
          return;
        }
        this.setValues();
      },
      dragging: function(val) {
        if (!val) {
          this.setValues();
        }
      },
      firstValue: function(val) {
        if (this.range) {
          this.$emit('input', [this.minValue, this.maxValue]);
        } else {
          this.$emit('input', val);
        }
      },
      secondValue: function() {
        if (this.range) {
          this.$emit('input', [this.minValue, this.maxValue]);
        }
      },
      min: function() {
        this.setValues();
      },
      max: function() {
        this.setValues();
      }
    },
    methods: {
      valueChanged: function() {
        var self = this;
        if (self.range) {
          return ![self.minValue, self.maxValue]
            .every(function(item, index) {return item === self.oldValue[index];});
        } else {
          return self.value !== self.oldValue;
        }
      },
      setValues: function() {
        var val = this.value;
        if (this.range && VueUtil.isArray(val)) {
          if (val[1] < this.min) {
            this.$emit('input', [this.min, this.min]);
          } else if (val[0] > this.max) {
            this.$emit('input', [this.max, this.max]);
          } else if (val[0] < this.min) {
            this.$emit('input', [this.min, val[1]]);
          } else if (val[1] > this.max) {
            this.$emit('input', [val[0], this.max]);
          } else {
            this.firstValue = val[0];
            this.secondValue = val[1];
            if (this.valueChanged()) {
              this.$emit('change', [this.minValue, this.maxValue]);
              this.dispatch('VueFormItem', 'vue.form.change', [this.minValue, this.maxValue]);
              this.oldValue = VueUtil.mergeArray([], val);
            }
          }
        } else if (!this.range && VueUtil.isNumber(val)) {
          if (val < this.min) {
            this.$emit('input', this.min);
          } else if (val > this.max) {
            this.$emit('input', this.max);
          } else {
            this.firstValue = val;
            if (this.valueChanged()) {
              this.$emit('change', val);
              this.dispatch('VueFormItem', 'vue.form.change', val);
              this.oldValue = val;
            }
          }
        }
      },
      setPosition: function(percent) {
        var targetValue = this.min + percent * (this.max - this.min) / 100;
        if (!this.range) {
          this.$refs.button1.setPosition(percent);
          return;
        }
        var button;
        if (Math.abs(this.minValue - targetValue) < Math.abs(this.maxValue - targetValue)) {
          button = this.firstValue < this.secondValue ? 'button1' : 'button2';
        } else {
          button = this.firstValue > this.secondValue ? 'button1' : 'button2';
        }
        this.$refs[button].setPosition(percent);
      },
      onSliderClick: function(event) {
        if (this.disabled || this.dragging) return;
        var sliderSize = 1;
        if (this.$refs.slider) {
          sliderSize = this.$refs.slider['client' + (this.vertical ? 'Height' : 'Width')];
        }
        if (this.vertical) {
          var sliderOffsetBottom = this.$refs.slider.getBoundingClientRect().bottom;
          this.setPosition((sliderOffsetBottom - (event.clientY || event.touches[0].clientY)) / sliderSize * 100);
        } else {
          var sliderOffsetLeft = this.$refs.slider.getBoundingClientRect().left;
          this.setPosition(((event.clientX || event.touches[0].clientX) - sliderOffsetLeft) / sliderSize * 100);
        }
      }
    },
    computed: {
      stops: function() {
        var self = this;
        var stopCount = (self.max - self.min) / self.step;
        var stepWidth = 100 * self.step / (self.max - self.min);
        var result = [];
        for (var i = 1; i < stopCount; i++) {
          result.push(i * stepWidth);
        }
        if (self.range) {
          return VueUtil.filter(result, function(step) {
            return step < 100 * (self.minValue - self.min) / (self.max - self.min) ||
              step > 100 * (self.maxValue - self.min) / (self.max - self.min);
          });
        } else {
          return VueUtil.filter(result, function(step) {return step > 100 * (self.firstValue - self.min) / (self.max - self.min);});
        }
      },
      minValue: function() {
        return Math.min(this.firstValue, this.secondValue);
      },
      maxValue: function() {
        return Math.max(this.firstValue, this.secondValue);
      },
      barSize: function() {
        return this.range ? 100 * (this.maxValue - this.minValue) / (this.max - this.min) + '%' : 100 * (this.firstValue - this.min) / (this.max - this.min) + '%';
      },
      barStart: function() {
        return this.range ? 100 * (this.minValue - this.min) / (this.max - this.min) + '%' : '0%';
      },
      precision: function() {
        var precisions = VueUtil.map([this.min, this.max, this.step], function(item) {
          var decimal = ('' + item).split('.')[1];
          return decimal ? decimal.length : 0;
        });
        return Math.max.apply(null, precisions);
      },
      runwayStyle: function() {
        return this.vertical ? {height: this.height + 'px'} : {};
      },
      barStyle: function() {
        return this.vertical ? {height: this.barSize, bottom: this.barStart} : {width: this.barSize, left: this.barStart};
      }
    },
    mounted: function() {
      if (this.range) {
        if (VueUtil.isArray(this.value)) {
          this.firstValue = Math.max(this.min, this.value[0]);
          this.secondValue = Math.min(this.max, this.value[1]);
        } else {
          this.firstValue = this.min;
          this.secondValue = this.max;
        }
        this.oldValue = [this.firstValue, this.secondValue];
      } else {
        if (!VueUtil.isNumber(this.value)) {
          this.firstValue = this.min;
        } else {
          this.firstValue = Math.min(this.max, Math.max(this.min, this.value));
        }
        this.oldValue = this.firstValue;
      }
    }
  };
  Vue.component(VueSlider.name, VueSlider);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueRate = definition(context.Vue, context.VueUtil);
    delete context.VueRate;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueRate = {
    template: '<div class="vue-rate"><span v-for="item in max" class="vue-rate__item" @mousemove="setCurrentValue(item, $event)" @mouseleave="resetCurrentValue" @click="selectValue(item)" :style="{cursor: disabled ? \'auto\' : \'pointer\'}"><i :class="[\'vue-rate__icon\', classes[item - 1], {\'hover\': hoverIndex === item}]" :style="getIconStyle(item)"><i v-if="showDecimalIcon(item)" :class="[\'vue-rate__decimal\', decimalIconClass]" :style="decimalStyle"></i></i></span><span v-if="showText" class="vue-rate__text" :style="{color: textColor}">{{text}}</span></div>',
    name: 'VueRate',
    data: function() {
      return {
        classMap: {},
        colorMap: {},
        pointerAtLeftHalf: false,
        currentValue: this.value,
        hoverIndex: -1
      };
    },
    props: {
      value: {
        type: Number,
        default: 0
      },
      lowThreshold: {
        type: Number,
        default: 2
      },
      highThreshold: {
        type: Number,
        default: 4
      },
      max: {
        type: Number,
        default: 5
      },
      colors: {
        type: Array,
        default: function() {
          return ['#F7BA2A', '#F7BA2A', '#F7BA2A'];
        }
      },
      voidColor: {
        type: String,
        default: '#C6D1DE'
      },
      disabledVoidColor: {
        type: String,
        default: '#EFF2F7'
      },
      iconClasses: {
        type: Array,
        default: function() {
          return ['vue-icon-star-on', 'vue-icon-star-on', 'vue-icon-star-on'];
        }
      },
      voidIconClass: {
        type: String,
        default: 'vue-icon-star-off'
      },
      disabledVoidIconClass: {
        type: String,
        default: 'vue-icon-star-on'
      },
      disabled: Boolean,
      allowHalf: Boolean,
      showText: Boolean,
      textColor: {
        type: String,
        default: '1f2d3d'
      },
      texts: {
        type: Array,
        default: function() {
          return [];
        }
      },
      textTemplate: {
        type: String,
        default: '{value}'
      }
    },
    computed: {
      text: function() {
        var result = '';
        if (this.disabled) {
          result = this.textTemplate.replace(/\{\s*value\s*\}/, this.value);
        } else {
          result = this.texts[Math.ceil(this.currentValue) - 1];
        }
        return result;
      },
      decimalStyle: function() {
        var width = '';
        if (this.disabled) {
          width = (this.valueDecimal < 50 ? 0 : 50) + '%';
        }
        if (this.allowHalf) {
          width = '50%';
        }
        return {
          color: this.activeColor,
          width: width
        };
      },
      valueDecimal: function() {
        return this.value * 100 - Math.floor(this.value) * 100;
      },
      decimalIconClass: function() {
        return this.getValueFromMap(this.value, this.classMap);
      },
      voidClass: function() {
        return this.disabled ? this.classMap.disabledVoidClass : this.classMap.voidClass;
      },
      activeClass: function() {
        return this.getValueFromMap(this.currentValue, this.classMap);
      },
      activeColor: function() {
        return this.getValueFromMap(this.currentValue, this.colorMap);
      },
      classes: function() {
        var result = [];
        var i = 0;
        var threshold = this.currentValue;
        if (this.allowHalf && this.currentValue !== Math.floor(this.currentValue)) {
          threshold--;
        }
        for (; i < threshold; i++) {
          result.push(this.activeClass);
        }
        for (; i < this.max; i++) {
          result.push(this.voidClass);
        }
        return result;
      }
    },
    watch: {
      value: function(val) {
        this.$emit('change', val);
        this.currentValue = val;
      },
      colors: function(val) {
        this.colorMap.lowColor = val[0];
        this.colorMap.mediumColor = val[1];
        this.colorMap.highColor = val[2];
      },
      voidColor: function(val) {
        this.colorMap.voidColor = val;
      },
      disabledVoidColor: function(val) {
        this.colorMap.disabledVoidColor = val;
      },
      iconClasses: function(val) {
        this.classMap.lowClass = val[0];
        this.classMap.mediumClass = val[1];
        this.classMap.highClass = val[2];
      },
      voidClass: function(val) {
        this.classMap.voidClass = val;
      },
      disabledVoidClass: function(val) {
        this.classMap.disabledVoidClass = val;
      }
    },
    methods: {
      getValueFromMap: function(value, map) {
        var result = '';
        if (value <= this.lowThreshold) {
          result = map.lowColor || map.lowClass;
        } else if (value >= this.highThreshold) {
          result = map.highColor || map.highClass;
        } else {
          result = map.mediumColor || map.mediumClass;
        }
        return result;
      },
      showDecimalIcon: function(item) {
        var showWhenDisabled = this.disabled && this.valueDecimal > 0 && item - 1 < this.value && item > this.value;
        var showWhenAllowHalf = this.allowHalf && this.pointerAtLeftHalf && ((item - 0.5).toFixed(1) === this.currentValue.toFixed(1));
        return showWhenDisabled || showWhenAllowHalf;
      },
      getIconStyle: function(item) {
        var voidColor = this.disabled ? this.colorMap.disabledVoidColor : this.colorMap.voidColor;
        return {
          color: item <= this.currentValue ? this.activeColor : voidColor
        };
      },
      selectValue: function(value) {
        if (this.disabled) {
          return;
        }
        if (this.allowHalf && this.pointerAtLeftHalf) {
          this.$emit('input', this.currentValue);
        } else {
          this.$emit('input', value);
        }
      },
      setCurrentValue: function(value, event) {
        if (this.disabled) {
          return;
        }
        if (this.allowHalf) {
          var target = event.target;
          if (VueUtil.hasClass(target, 'vue-rate__item')) {
            target = target.querySelector('.vue-rate__icon');
          }
          if (VueUtil.hasClass(target, 'vue-rate__decimal')) {
            target = target.parentNode;
          }
          this.pointerAtLeftHalf = event.offsetX * 2 <= target.clientWidth;
          this.currentValue = this.pointerAtLeftHalf ? value - 0.5 : value;
        } else {
          this.currentValue = value;
        }
        this.hoverIndex = value;
      },
      resetCurrentValue: function() {
        if (this.disabled) {
          return;
        }
        if (this.allowHalf) {
          this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
        }
        this.currentValue = this.value;
        this.hoverIndex = -1;
      }
    },
    created: function() {
      if (!this.value) {
        this.$emit('input', 0);
      }
      this.classMap = {
        lowClass: this.iconClasses[0],
        mediumClass: this.iconClasses[1],
        highClass: this.iconClasses[2],
        voidClass: this.voidIconClass,
        disabledVoidClass: this.disabledVoidIconClass
      };
      this.colorMap = {
        lowColor: this.colors[0],
        mediumColor: this.colors[1],
        highColor: this.colors[2],
        voidColor: this.voidColor,
        disabledVoidColor: this.disabledVoidColor
      };
    }
  };
  Vue.component(VueRate.name, VueRate);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VueResource'], definition);
  } else {
    context.VueUpload = definition(context.Vue, context.VueUtil);
    delete context.VueUpload;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  function noop() {}
  var UploadDragger = {
    template: '<div :class="[\'vue-upload-dragger\', {\'is-dragover\': dragover}]" @drop.prevent="onDrop" @dragover.prevent="onDragover" @dragleave.prevent="dragover = false"><slot></slot></div>',
    name: 'VueUploadDrag',
    props: {
      disabled: Boolean
    },
    data: function() {
      return {
        dragover: false
      };
    },
    methods: {
      onDragover: function() {
        if (!this.disabled) {
          this.dragover = true;
        }
      },
      onDrop: function(e) {
        if (!this.disabled) {
          this.dragover = false;
          this.$emit('file', e.dataTransfer.files);
        }
      }
    }
  };
  var UploadList = {
    template: '<transition-group tag="ul" :class="[\'vue-upload-list\', \'vue-upload-list--\' + listType, {\'is-disabled\': disabled}]" name="vue-list"><li v-for="(file, index) in files" :class="[\'vue-upload-list__item\', \'is-\' + file.status]" :key="file.uid"><img class="vue-upload-list__item-thumbnail" v-if="file.status !== \'uploading\' && [\'picture-card\', \'picture\'].indexOf(listType) !== -1" :src="file.url" :alt="file.name"><a class="vue-upload-list__item-name" @click="handleClick(file)"><i class="vue-icon-document"></i>{{file.name}}</a><label class="vue-upload-list__item-status-label"><i :class="{\'vue-icon-upload-success\': true, \'vue-icon-success\': listType === \'text\', \'vue-icon-check\': [\'picture-card\', \'picture\'].indexOf(listType) !== -1}"></i></label><i class="vue-icon-close" v-if="!disabled" @click="$emit(\'remove\', file)"></i><vue-progress v-if="file.status === \'uploading\'" :type="listType === \'picture-card\' ? \'circle\' : \'line\'" :stroke-width="listType === \'picture-card\' ? 6 : 2" :percentage="parsePercentage(file.percentage)"></vue-progress><span class="vue-upload-list__item-actions" v-if="listType === \'picture-card\'"><span class="vue-upload-list__item-preview" v-if="handlePreview && listType === \'picture-card\'" @click="handlePreview(file)"><i class="vue-icon-view"></i></span><span v-if="!disabled" class="vue-upload-list__item-delete" @click="$emit(\'remove\', file)"><i class="vue-icon-delete2"></i></span></span></li></transition-group>',
    props: {
      files: {
        type: Array,
        default: function() {
          return [];
        }
      },
      disabled: Boolean,
      handlePreview: Function,
      listType: String
    },
    methods: {
      parsePercentage: function(val) {
        return parseInt(val, 10);
      },
      handleClick: function(file) {
        this.handlePreview && this.handlePreview(file);
      }
    }
  };
  var Upload = {
    inject: ['uploader'],
    components: {
      UploadDragger: UploadDragger
    },
    props: {
      type: String,
      action: {
        type: String,
        default: location.href
      },
      name: {
        type: String,
        default: 'file'
      },
      data: Object,
      headers: Object,
      withCredentials: Boolean,
      multiple: Boolean,
      max: Number,
      accept: String,
      onStart: Function,
      onProgress: Function,
      onSuccess: Function,
      onError: Function,
      beforeUpload: Function,
      drag: Boolean,
      onPreview: {
        type: Function,
        default: function() {}
      },
      onRemove: {
        type: Function,
        default: function() {}
      },
      fileList: Array,
      autoUpload: Boolean,
      listType: String,
      httpRequest: {
        type: Function,
        default: function(option) {
          if (!VueUtil.isDef(this.$http)) return;
          var httpOption = {};
          httpOption.headers = option.headers;
          httpOption.progress = function progress(e) {
            if (e.total > 0) {
              e.percent = e.loaded / e.total * 100;
            }
            option.onProgress(e);
          };
          if (option.withCredentials) {
            httpOption.emulateJSON = true;
          }
          var formData = new FormData();
          if (option.data) {
            VueUtil.ownPropertyLoop(option.data, function(key) {
              formData.append(key, option.data[key]);
            });
          }
          formData.append(option.filename, option.file);
          this.$http.post(option.action, formData, httpOption).then(function(reqponse) {
            option.onSuccess(reqponse);
          }, function(reqponse) {
            option.onError(reqponse);
          });
        }
      },
      disabled: Boolean
    },
    data: function() {
      return {
        mouseover: false,
        reqs: {}
      };
    },
    methods: {
      isImage: function(str) {
        return str.indexOf('image') !== -1;
      },
      handleChange: function(ev) {
        var files = ev.target.files;
        if (!files) return;

        if (this.max > 0 && this.multiple) {
          files = [].slice.call(files, 0, this.max - this.fileList.length);
        }
        this.uploadFiles(files);
      },
      uploadFiles: function(files) {
        var self = this;
        var postFiles = [].slice.call(files);
        if (!self.multiple) {
          postFiles = postFiles.slice(0, 1);
        }
        if (postFiles.length === 0) return;
        VueUtil.loop(postFiles, function(rawFile) {
          self.onStart(rawFile);
          if (self.autoUpload) self.upload(rawFile);
        });
      },
      upload: function(rawFile) {
        var self = this;
        self.$refs.input.value = null;
        if (!self.beforeUpload) {
          return self.post(rawFile);
        }
        var before = self.beforeUpload(rawFile);
        if (before && before.then) {
          before.then(function(processedFile) {
            if (VueUtil.isFile(processedFile)) {
              self.post(processedFile);
            } else {
              self.post(rawFile);
            }
          }, function() {
            self.onRemove(rawFile, true);
          });
        } else if (before !== false) {
          self.post(rawFile);
        } else {
          self.onRemove(rawFile, true);
        }
      },
      abort: function(rawFile) {
        var reqs = this.reqs;
        if (rawFile) {
          var uid = rawFile;
          if (rawFile.uid) uid = rawFile.uid;
          if (reqs[uid]) {
            reqs[uid].abort();
          }
        } else {
          VueUtil.ownPropertyLoop(reqs, function(uid) {
            if (reqs[uid]) reqs[uid].abort();
            delete reqs[uid];
          });
        }
      },
      post: function(rawFile) {
        var self = this;
        var uid = rawFile.uid;
        var options = {
          headers: self.headers,
          withCredentials: self.withCredentials,
          file: rawFile,
          data: self.data,
          filename: self.name,
          action: self.action,
          onProgress: function onProgress(e) {
            self.onProgress(e, rawFile);
          },
          onSuccess: function onSuccess(res) {
            self.onSuccess(res, rawFile);
            delete self.reqs[uid];
          },
          onError: function onError(err) {
            self.onError(err, rawFile);
            delete self.reqs[uid];
          }
        };
        var req = self.httpRequest(options);
        self.reqs[uid] = req;
        if (req && req.then) {
          req.then(options.onSuccess, options.onError);
        }
      },
      handleClick: function() {
        if (!this.disabled) {
          this.$refs.input.value = null;
          this.$refs.input.click();
        }
      }
    },
    render: function(createElement) {
      var handleClick = this.handleClick;
      var drag = this.drag;
      var handleChange = this.handleChange;
      var multiple = this.multiple;
      var accept = this.accept;
      var listType = this.listType;
      var uploadFiles = this.uploadFiles;
      var disabled = this.disabled;
      var data = {
        class: {
          'vue-upload': true,
          'is-disabled': disabled
        },
        on: {
          click: handleClick
        }
      };
      data.class['vue-upload--' + listType] = true;
      return createElement('div', data, [drag ? createElement('upload-dragger', {attrs: {disabled: disabled}, on: {'file': uploadFiles}}, [this.$slots.default]) : this.$slots.default, createElement('input', {class: 'vue-upload__input', attrs: {type: 'file', name: name, multiple: multiple, accept: accept}, ref: 'input', on: {'change': handleChange}}, [])]);
    }
  };
  var IframeUpload = {
    components: {
      UploadDragger: UploadDragger
    },
    props: {
      type: String,
      data: {},
      action: {
        type: String,
        default: location.href
      },
      name: {
        type: String,
        default: 'file'
      },
      withCredentials: Boolean,
      accept: String,
      onStart: Function,
      onProgress: Function,
      onSuccess: Function,
      onError: Function,
      beforeUpload: Function,
      onPreview: {
        type: Function,
        default: function() {}
      },
      onRemove: {
        type: Function,
        default: function() {}
      },
      drag: Boolean,
      listType: String,
      disabled: Boolean
    },
    data: function() {
      return {
        mouseover: false,
        domain: '',
        file: null,
        submitting: false
      };
    },
    methods: {
      isImage: function(str) {
        return str.indexOf('image') !== -1;
      },
      handleClick: function() {
        if (!this.disabled) {
          this.$refs.input.click();
        }
      },
      handleChange: function(ev) {
        var file = ev.target.value;
        if (file) {
          this.uploadFiles(file);
        }
      },
      uploadFiles: function(file) {
        if (this.submitting) return;
        this.submitting = true;
        this.file = file;
        this.onStart(file);
        var formNode = this.getFormNode();
        var dataSpan = this.getFormDataNode();
        var data = this.data;
        if (VueUtil.isFunction(data)) {
          data = data(file);
        }
        var inputs = [];
        VueUtil.ownPropertyLoop(data, function(key) {
          inputs.push('<input name="' + key + '" value="' + data[key] + '"/>');
        });
        dataSpan.innerHTML = inputs.join('');
        formNode.submit();
        dataSpan.innerHTML = '';
      },
      getFormNode: function() {
        return this.$refs.form;
      },
      getFormDataNode: function() {
        return this.$refs.data;
      },
      messageHandle: function(event) {
        if (!this.file) return;
        var targetOrigin = new URL(this.action).origin;
        if (event.origin !== targetOrigin) return;
        var response = event.data;
        if (response.result === 'success') {
          this.onSuccess(response, this.file);
        } else if (response.result === 'failed') {
          this.onError(response, this.file);
        }
        this.submitting = false;
        this.file = null;
      }
    },
    created: function() {
      this.frameName = 'frame-' + Date.now();
    },
    mounted: function() {
      var self = this;
      VueUtil.on(document, 'message', this.messageHandle);
    },
    beforeDestroy: function() {
      VueUtil.off(document, 'message', this.messageHandle);
    },
    render: function(createElement) {
      var drag = this.drag;
      var uploadFiles = this.uploadFiles;
      var listType = this.listType;
      var frameName = this.frameName;
      var disabled = this.disabled;
      var oClass = {'vue-upload': true};
      oClass['vue-upload--' + listType] = true;
      return createElement('div', {'class': oClass, on: {'click': this.handleClick}, nativeOn: {'drop': this.onDrop, 'dragover': this.handleDragover, 'dragleave': this.handleDragleave}}, [createElement('iframe', {on: {'load': this.onload}, ref: 'iframe', attrs: {name: frameName}}, []), createElement('form', {ref: 'form', attrs: {action: this.action, target: frameName, enctype: 'multipart/form-data', method: 'POST'}}, [createElement('input', {'class': 'vue-upload__input', attrs: {type: 'file', name: 'file', accept: this.accept}, ref: 'input', on: {'change': this.handleChange}}, []), createElement('input', {attrs: {type: 'hidden', name: 'documentDomain', value: document.domain}}, []), createElement('span', {ref: 'data'}, [])]), drag ? createElement('upload-dragger', {on: {'file': uploadFiles}, attrs: {disabled: disabled}}, [this.$slots.default]) : this.$slots.default]);
    }
  };
  var migrating = {
    mounted: function() {
      if (!this.$vnode) return;
    },
    methods: {
      getMigratingConfig: function() {
        return {
          props: {},
          events: {}
        };
      }
    }
  };
  var VueUpload = {
    name: 'VueUpload',
    mixins: [migrating],
    components: {
      UploadList: UploadList,
      Upload: Upload,
      IframeUpload: IframeUpload
    },
    provide: {
      uploader: null
    },
    props: {
      action: {
        type: String,
        default: location.href
      },
      headers: {
        type: Object,
        default: function() {
          return {};
        }
      },
      data: Object,
      multiple: Boolean,
      max: {
        type: Number,
        default: 0
      },
      name: {
        type: String,
        default: 'file'
      },
      drag: Boolean,
      dragger: Boolean,
      withCredentials: Boolean,
      showFileList: {
        type: Boolean,
        default: true
      },
      accept: String,
      type: {
        type: String,
        default: 'select'
      },
      beforeUpload: Function,
      beforeRemove: Function,
      onRemove: {
        type: Function,
        default: function() {}
      },
      onChange: {
        type: Function,
        default: function() {}
      },
      onPreview: {
        type: Function
      },
      onSuccess: {
        type: Function,
        default: function() {}
      },
      onProgress: {
        type: Function,
        default: function() {}
      },
      onError: {
        type: Function,
        default: function() {}
      },
      fileList: {
        type: Array,
        default: function() {
          return [];
        }
      },
      autoUpload: {
        type: Boolean,
        default: true
      },
      listType: {
        type: String,
        default: 'text'
      },
      httpRequest: Function,
      disabled: Boolean
    },
    data: function() {
      return {
        uploadFiles: [],
        dragOver: false,
        draging: false,
        tempIndex: 1
      };
    },
    watch: {
      fileList: {
        immediate: true,
        handler: function(fileList) {
          var self = this;
          self.uploadFiles = VueUtil.map(fileList, function(item) {
            item.uid = item.uid || (Date.now() + self.tempIndex++);
            item.status = self.autoUpload ? 'success' : 'ready';
            return item;
          });
        }
      }
    },
    methods: {
      handleStart: function(rawFile) {
        rawFile.uid = Date.now() + this.tempIndex++;
        var file = {
          status: 'ready',
          name: rawFile.name,
          size: rawFile.size,
          percentage: 0,
          uid: rawFile.uid,
          raw: rawFile
        };
        try {
          file.url = URL.createObjectURL(rawFile);
        } catch (e) {
          throw e;
        }
        this.uploadFiles.push(file);
        this.onChange(file, this.uploadFiles);
      },
      handleProgress: function(ev, rawFile) {
        var file = this.getFile(rawFile);
        this.onProgress(ev, file, this.uploadFiles);
        file.status = 'uploading';
        file.percentage = ev.percent || 0;
      },
      handleSuccess: function(res, rawFile) {
        var file = this.getFile(rawFile);
        if (file) {
          file.status = 'success';
          file.response = res;
          this.onSuccess(res, file, this.uploadFiles);
          this.onChange(file, this.uploadFiles);
        }
      },
      handleError: function(err, rawFile) {
        var file = this.getFile(rawFile);
        var fileList = this.uploadFiles;
        file.status = 'fail';
        fileList.splice(fileList.indexOf(file), 1);
        this.onError(err, file, this.uploadFiles);
        this.onChange(file, this.uploadFiles);
      },
      handleRemove: function(file, raw) {
        if (raw) {
          file = this.getFile(raw);
        }

        var self = this;
        function doRemove() {
          self.abort(file);
          var fileList = self.uploadFiles;
          fileList.splice(fileList.indexOf(file), 1);
          self.onRemove(file, fileList);
        }

        if (!this.beforeRemove) {
          doRemove();
        } else if (typeof this.beforeRemove === 'function') {
          var before = this.beforeRemove(file, this.uploadFiles);
          if (before && before.then) {
            before.then(function() {
              doRemove();
            }, noop);
          } else if (before !== false) {
            doRemove();
          }
        }
      },
      getFile: function(rawFile) {
        var fileList = this.uploadFiles;
        var target;
        fileList.every(function(item) {
          target = rawFile.uid === item.uid ? item : null;
          return !target;
        });
        return target;
      },
      abort: function(file) {
        this.$refs['upload-inner'].abort(file);
      },
      clearFiles: function() {
        this.uploadFiles = [];
      },
      submit: function() {
        var self = this;
        VueUtil.loop(VueUtil.filter(self.uploadFiles, function(file) {
          return file.status === 'ready';
        }), function(file) {
          self.$refs['upload-inner'].upload(file.raw);
        });
      },
      getMigratingConfig: function() {
        return {
          props: {
            'default-file-list': 'default-file-list is renamed to file-list.',
            'show-upload-list': 'show-file-list is renamed to show-file-list.',
            'thumbnail-mode': 'thumbnail-mode has been deprecated.'
          }
        };
      }
    },
    render: function(createElement) {
      var uploadList;
      if (this.showFileList) {
        uploadList = createElement('UploadList', {attrs: {disabled: this.disabled, listType: this.listType, files: this.uploadFiles, handlePreview: this.onPreview}, on: {'remove': this.handleRemove}}, []);
      }
      var uploadData = {
        directives: [{
          name: 'show',
          value: this.max == 0 || this.max > this.uploadFiles.length
        }],
        props: {
          type: this.type,
          drag: this.drag,
          action: this.action,
          multiple: this.multiple,
          max: this.max,
          'before-upload': this.beforeUpload,
          'with-credentials': this.withCredentials,
          headers: this.headers,
          name: this.name,
          data: this.data,
          accept: this.accept,
          fileList: this.uploadFiles,
          autoUpload: this.autoUpload,
          listType: this.listType,
          disabled: this.disabled,
          'on-start': this.handleStart,
          'on-progress': this.handleProgress,
          'on-success': this.handleSuccess,
          'on-error': this.handleError,
          'on-preview': this.onPreview,
          'on-remove': this.handleRemove,
          'http-request': this.httpRequest
        },
        ref: 'upload-inner'
      };
      var trigger = this.$slots.trigger || this.$slots.default;
      var uploadComponent = (VueUtil.isDef(FormData)) ? createElement('upload', uploadData, [trigger]) : createElement('iframeUpload', uploadData, [trigger]);
      return createElement('div', null, ['picture-card' === this.listType ? uploadList : '', this.$slots.trigger ? [uploadComponent, this.$slots.default] : uploadComponent, this.$slots.tip, 'picture-card' !== this.listType ? uploadList : '']);
    },
    mounted: function() {
      if (this.disabled) {
        VueUtil.loop(this.$el.querySelectorAll('button'), function(buttonNote) {
          VueUtil.addClass(buttonNote, 'is-disabled');
        });
      }
    }
  };
  Vue.component(VueUpload.name, VueUpload);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueLoadingBar = definition(context.Vue, context.VueUtil);
    delete context.VueLoadingBar;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var loadingBar = null;
  var intervaler = null;
  var newInstance = function() {
    var loadingBar = document.createElement('div');
    loadingBar.className = 'vue-loading-bar';
    loadingBar.style.display = 'none';
    var innerDiv = document.createElement('div');
    VueUtil.addClass(innerDiv, 'vue-loading-bar-inner');
    VueUtil.addClass(innerDiv, 'vue-loading-bar-inner-color-primary');
    loadingBar.appendChild(innerDiv);
    document.body.appendChild(loadingBar);
    return {
      show: function(options) {
        if (loadingBar.style.display === 'none') {
          loadingBar.style.display = '';
          loadingBar.style.zIndex = VueUtil.nextZIndex();
        }
        if (options.error) {
          VueUtil.addClass(innerDiv, 'vue-loading-bar-inner-color-error');
        } else {
          VueUtil.removeClass(innerDiv, 'vue-loading-bar-inner-color-error');
        }
        if (VueUtil.isDef(options.percent)) {
          innerDiv.style.width = options.percent + '%';
        }
      },
      hide: function() {
        loadingBar.style.display = 'none';
      },
      isShow: function() {
        return (loadingBar.style.display !== 'none');
      }
    };
  };
  var initLoadingBar = function() {
    if (!VueUtil.isDef(loadingBar)) loadingBar = newInstance();
  };
  var hideInstance = VueUtil.debounce(500, function(fn) {
    if (VueUtil.isFunction(fn)) fn();
    loadingBar.hide();
  });
  var VueLoadingBar = {
    start: function(fn) {
      initLoadingBar();
      if (loadingBar.isShow()) return;
      var percent = 0;
      loadingBar.show({percent: percent});
      intervaler = setInterval(function() {
        percent += 6;
        if (percent > 95) {
          clearInterval(intervaler);
          percent = 96;
        }
        loadingBar.show({percent: percent});
      }, 250);
      if (VueUtil.isFunction(fn)) fn();
    },
    update: function(percent, fn) {
      initLoadingBar();
      clearInterval(intervaler);
      loadingBar.show({percent: percent});
      if (VueUtil.isFunction(fn)) fn();
    },
    finish: VueUtil.debounce(function(fn) {
      initLoadingBar();
      clearInterval(intervaler);
      loadingBar.show({percent: 100});
      hideInstance(fn);
    }),
    error: VueUtil.debounce(function(fn) {
      initLoadingBar();
      clearInterval(intervaler);
      loadingBar.show({percent: 100, error: true});
      hideInstance(fn);
    })
  };
  Vue.loadingBar = VueLoadingBar;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueNote = definition(context.Vue);
    delete context.VueNote;
  }
})(this, function(Vue) {
  'use strict';
  var VueNote = {
    template: '<div :class="[\'vue-note\', typeClass, typeBox]"><div class="vue-note__content"><span class="vue-note__title is-bold" v-if="title">{{title}}</span><div class="vue-note__description"><slot></slot></div></div></div>',
    name: 'VueNote',
    props: {
      title: {
        type: String,
        default: ''
      },
      type: {
        type: String,
        default: 'info'
      },
      plain: Boolean
    },
    computed: {
      typeClass: function() {
        return 'vue-note--' + this.type;
      },
      typeBox: function() {
        if (this.plain) {
          return 'vue-note--plain';
        }
      }
    }
  };
  Vue.component(VueNote.name, VueNote);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueList = definition(context.Vue, context.VueUtil);
    delete context.VueList;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueList = {
    name: 'VueList',
    data: function() {
      return {
        defaultSlotLen: 0,
        activedIndex: null,
        keyList: []
      };
    },
    props: {
      height: {
        type: Number,
        default: 200
      },
      onScroll: Function,
      defaultActivedIndex: {
        type: Number,
        default: 0
      },
      defaultSelected: {
        type: Boolean,
        default: true
      },
      scrollbar: Boolean
    },
    methods: {
      updateKeyList: function() {
        if(Array.isArray(this.$slots.default)) {
          this.keyList = this.$slots.default.map(function(item) {
            return item.key;
          });
        }
      },
      setItemIndex: function(item) {
        if(this.$slots.default.length != this.keyList.length) {
          this.updateKeyList();
        }
        item.index = this.keyList.indexOf(item.$vnode.key);
      },
      handleItemClick: function(itemObj) {
        this.activedIndex = itemObj.index;
      },
      handleScroll: function(e, scrollTop, isTop, isBottom) {
        if (!VueUtil.isDef(scrollTop)) {
          scrollTop = this.$el.scrollTop;
          isTop = (scrollTop === 0);
          isBottom = (scrollTop === this.$el.scrollHeight - this.$el.clientHeight);
        }
        this.updateZone(scrollTop);
        this.$emit('scroll', e, scrollTop, isTop, isBottom);
      },
      updateZone: function(offset) {
        var delta = this.delta;
        if (!VueUtil.isDef(delta)) return;
        if (delta.total <= delta.keeps) return;
        offset = offset || 0;
        var overs = Math.floor(offset / delta.size);
        overs < 0 && (overs = 0);
        var start = overs;
        var end = overs + delta.keeps;
        if (overs + delta.keeps >= delta.total) {
          end = delta.total;
          start = delta.total - delta.keeps;
        }
        delta.end = end;
        delta.start = start;
        this.$forceUpdate();
      },
      filter: function(slots) {
        var delta = this.delta;
        if (delta.keeps === 0 || slots.length <= delta.keeps) {
          delta.marginTop = 0;
          delta.marginBottom = 0;
          return slots;
        }
        delta.total = slots.length;
        delta.marginTop = delta.size * delta.start;
        delta.marginBottom = delta.size * (delta.total - delta.keeps - delta.start);
        var result = [];
        for (var i = delta.start, j = delta.end; i < j; i++) {
          result.push(slots[i]);
        }
        return result;
      },
      createDelta: function(slots) {
        var delta = this.delta = Object.create(null);
        delta.start = 0;
        delta.total = 0;
        delta.marginTop = 0;
        delta.marginBottom = 0;
        delta.size = 20;
        delta.remain = Math.floor(this.height * 1 / delta.size);
        delta.end = delta.remain;
        delta.keeps = delta.remain;
        if (slots.length <= delta.remain) {
          delta.end = slots.length;
          delta.keeps = slots.length;
        }
      }
    },
    render: function(createElement) {
      var slots = this.$slots.default;
      if (!VueUtil.isArray(slots)) return null;
      if (!VueUtil.isDef(this.delta) || this.defaultSlotLen !== slots.length) {
        this.createDelta(slots);
        this.defaultSlotLen = slots.length;
      }
      var delta = this.delta;
      var showList = this.filter(slots);
      var style = {
        'margin-top': delta.marginTop + 'px',
        'margin-bottom':  delta.marginBottom + 'px'
      };
      if (VueUtil.isChrome) {
        style = {
          'padding-top': delta.marginTop + 'px',
          'padding-bottom':  delta.marginBottom + 'px'
        };
      }
      var list = null;
      if (this.scrollbar) {
        list = createElement('div', {
          'class': ['vue-list'],
          'style': {
            'height': this.height * 1 + 'px'
          }
        }, [createElement('vue-scrollbar', {
            props: {
              height: this.height * 1
            },
            'on': {
              'scrollY': this.handleScroll
            },
            ref: 'scrollbar'
          }, [createElement('div', {
            'style': style
          }, showList)])
        ]);
      } else {
        list = createElement('div', {
          'class': ['vue-list'],
          'style': {
            'height': this.height * 1 + 'px',
            'overflow': 'auto'
          },
          'on': {
            'scroll': this.handleScroll
          }
        }, [createElement('div', {
            'style': {
              'margin-top': delta.marginTop + 'px',
              'margin-bottom':  delta.marginBottom + 'px'
            }
          }, showList)
        ]);
      }
      return list;
    },
    created: function() {
      this.updateKeyList();
    },
    mounted: function() {
      var self = this;
      self.$on('item-click', self.handleItemClick);
      if (self.defaultSelected && self.$slots.default) {
        self.$nextTick(function() {
          var defaultSlot = self.$slots.default[self.defaultActivedIndex];
          defaultSlot && defaultSlot.componentInstance && defaultSlot.componentInstance.handleClick();
        });
      }
    }
  };
  Vue.component(VueList.name, VueList);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueListItem = definition(context.Vue, context.VueUtil);
    delete context.VueListItem;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueListItem = {
    template: '<div :class="[\'vue-list-item\', {\'is-active\': isActive}]" @click="handleClick"><slot></slot></div>',
    name: 'VueListItem',
    mixins: [VueUtil.component.emitter],
    data: function() {
      return {
        index: null
      };
    },
    methods: {
      handleClick: function() {
        this.dispatch('VueList', 'item-click', this);
        this.$emit('select', this);
      }
    },
    computed: {
      list: function() {
        var parent = this.$parent;
        while (parent.$options.name !== 'VueList') {
          parent = parent.$parent;
        }
        return parent;
      },
      isActive: function() {
        return this.list.activedIndex === this.index;
      }
    },
    mounted: function() {
      this.list.setItemIndex(this);
    }
  };
  Vue.component(VueListItem.name, VueListItem);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueDivider = definition(context.Vue);
    delete context.VueDivider;
  }
})(this, function(Vue) {
  'use strict';
  var VueDivider = {
    template: '<div class="vue-divider"><legend class="vue-divider__content" v-if="$slots.default"><slot></slot></legend></div>',
    name: 'VueDivider'
  };
  Vue.component(VueDivider.name, VueDivider);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VuePopper'], definition);
  } else {
    context.VueColorPicker = definition(context.Vue, context.VueUtil, context.VuePopper);
    delete context.VueColorPicker;
  }
})(this, function(Vue, VueUtil, VuePopper) {
  'use strict';
  var bound01 = function(value, max) {
    var isOnePointZero = function(n) {
      return VueUtil.isString(n) && n.indexOf('.') !== -1 && parseFloat(n) === 1;
    };
    var isPercentage = function(n) {
      return VueUtil.isString(n) && n.indexOf('%') !== -1;
    };
    if (isOnePointZero(value)) value = '100%';
    var processPercent = isPercentage(value);
    value = Math.min(max, Math.max(0, parseFloat(value)));
    if (processPercent) {
      value = parseInt(value * max, 10) / 100;
    }
    if ((Math.abs(value - max) < 0.000001)) {
      return 1;
    }
    return (value % max) / parseFloat(max);
  };
  var rgb2hsv = function(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h,
      s;
    var v = max;
    var d = max - min;
    s = max === 0 ? 0 : d / max;
    if (max === min) {
      h = 0;
    } else {
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }
    return {
      h: h * 360,
      s: s * 100,
      v: v * 100
    };
  };
  var hsv2rgb = function(h, s, v) {
    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    var i = Math.floor(h);
    var f = h - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    var mod = i % 6;
    var r = [v, q, p, p, t, v][mod];
    var g = [t, v, v, q, p, p][mod];
    var b = [p, p, t, v, v, q][mod];
    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  };
  var Color = function(options) {
    var self = this;
    self._hue = 0;
    self._saturation = 100;
    self._value = 100;
    self._alpha = 100;
    self.enableAlpha = false;
    self.format = 'hex';
    self.value = '';
    options = options || {};
    VueUtil.ownPropertyLoop(options, function(option) {
      self[option] = options[option];
    });
    self.doOnChange();
  };
  Color.prototype.set = function(prop, value) {
    var self = this;
    if (arguments.length === 1 && VueUtil.isObject(prop)) {
      VueUtil.ownPropertyLoop(prop, function(p) {
        self.set(p, prop[p]);
      });
      return;
    }
    self['_' + prop] = value;
    self.doOnChange();
  };
  Color.prototype.get = function(prop) {
    return this['_' + prop];
  };
  Color.prototype.toRgb = function() {
    return hsv2rgb(this._hue, this._saturation, this._value);
  };
  Color.prototype.fromString = function(value) {
    var self = this;
    if (!value) {
      this._hue = 0;
      this._saturation = 100;
      this._value = 100;
      this.doOnChange();
      return;
    }
    var fromHSV = function(h, s, v) {
      self._hue = h;
      self._saturation = s;
      self._value = v;
      self.doOnChange();
    };
    if (value.indexOf('hsl') !== -1) {
      var parts = VueUtil.map(VueUtil.filter(value.replace(/hsla|hsl|\(|\)/gm, '').split(/\s|,/g), function(val) {return val !== '';}), function(val, index) {return index > 2 ? parseFloat(val) : parseInt(val, 10);});
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      }
      if (parts.length >= 3) {
        var hsl2hsv = function(hue, sat, light) {
          sat = sat / 100;
          light = light / 100;
          var smin = sat;
          var lmin = Math.max(light, 0.01);
          var sv;
          var v;
          light *= 2;
          sat *= (light <= 1) ? light : 2 - light;
          smin *= lmin <= 1 ? lmin : 2 - lmin;
          v = (light + sat) / 2;
          sv = light === 0 ? (2 * smin) / (lmin + smin) : (2 * sat) / (light + sat);
          return {
            h: hue,
            s: sv * 100,
            v: v * 100
          };
        };
        var _hsl2hsv = hsl2hsv(parts[0], parts[1], parts[2]);
        var h = _hsl2hsv.h;
        var s = _hsl2hsv.s;
        var v = _hsl2hsv.v;
        fromHSV(h, s, v);
      }
    } else if (value.indexOf('hsv') !== -1) {
      var parts = VueUtil.map(VueUtil.filter(value.replace(/hsva|hsv|\(|\)/gm, '').split(/\s|,/g), function(val) {return val !== '';}), function(val, index) {return index > 2 ? parseFloat(val) : parseInt(val, 10);});
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      }
      if (parts.length >= 3) {
        fromHSV(parts[0], parts[1], parts[2]);
      }
    } else if (value.indexOf('rgb') !== -1) {
      var parts = VueUtil.map(VueUtil.filter(value.replace(/rgba|rgb|\(|\)/gm, '').split(/\s|,/g), function(val) {return val !== '';}), function(val, index) {return index > 2 ? parseFloat(val) : parseInt(val, 10);});
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      }
      if (parts.length >= 3) {
        var _rgb2hsv = rgb2hsv(parts[0], parts[1], parts[2]);
        var h = _rgb2hsv.h;
        var s = _rgb2hsv.s;
        var v = _rgb2hsv.v;
        fromHSV(h, s, v);
      }
    } else if (value.indexOf('#') !== -1) {
      var hex = value.replace('#', '').trim();
      var r, g, b;
      var parseHexChannel = function(hex) {
        var HEX_INT_MAP = {A: 10, B: 11, C: 12, D: 13, E: 14, F: 15};
        if (hex.length === 2) {
          return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
        }
        return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
      };
      if (hex.length === 3) {
        r = parseHexChannel(hex[0] + hex[0]);
        g = parseHexChannel(hex[1] + hex[1]);
        b = parseHexChannel(hex[2] + hex[2]);
      } else if (hex.length === 6) {
        r = parseHexChannel(hex.substring(0, 2));
        g = parseHexChannel(hex.substring(2, 4));
        b = parseHexChannel(hex.substring(4));
      }
      var _rgb2hsv = rgb2hsv(r, g, b);
      var h = _rgb2hsv.h;
      var s = _rgb2hsv.s;
      var v = _rgb2hsv.v;
      fromHSV(h, s, v);
    }
  };
  Color.prototype.doOnChange = function() {
    var _hue = this._hue;
    var _saturation = this._saturation;
    var _value = this._value;
    var _alpha = this._alpha;
    var format = this.format;
    var hsv2hsl = function(hue, sat, val) {
      return [hue, (sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue)) || 0, hue / 2];
    };
    if (this.enableAlpha) {
      switch (format) {
        case 'hsl':
          var hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = 'hsla(' + _hue + ', ' + Math.round(hsl[1] * 100) + '%, ' + Math.round(hsl[2] * 100) + '%, ' + _alpha / 100 + ')';
          break;
        case 'hsv':
          this.value = 'hsva(' + _hue + ', ' + Math.round(_saturation) + '%, ' + Math.round(_value) + '%, ' + _alpha / 100 + ')';
          break;
        default:
          var _hsv2rgb = hsv2rgb(_hue, _saturation, _value);
          var r = _hsv2rgb.r;
          var g = _hsv2rgb.g;
          var b = _hsv2rgb.b;
          this.value = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + _alpha / 100 + ')';
      }
    } else {
      switch (format) {
        case 'hsl':
          var hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = 'hsl(' + _hue + ', ' + Math.round(_hsl[1] * 100) + '%, ' + Math.round(_hsl[2] * 100) + '%)';
          break;
        case 'hsv':
          this.value = 'hsv(' + _hue + ', ' + Math.round(_saturation) + '%, ' + Math.round(_value) + '%)';
          break;
        case 'rgb':
          var _hsv2rgb2 = hsv2rgb(_hue, _saturation, _value);
          var r = _hsv2rgb2.r;
          var g = _hsv2rgb2.g;
          var b = _hsv2rgb2.b;
          this.value = 'rgb(' + r + ', ' + g + ', ' + b + ')';
          break;
        default:
          var toHex = function(ref) {
            var r = ref.r;
            var g = ref.g;
            var b = ref.b;
            var INT_HEX_MAP = {10: 'A', 11: 'B', 12: 'C', 13: 'D', 14: 'E', 15: 'F'};
            var hexOne = function(value) {
              value = Math.min(Math.round(value), 255);
              var high = Math.floor(value / 16);
              var low = value % 16;
              return '' + (INT_HEX_MAP[high] || high) + (INT_HEX_MAP[low] || low);
            };
            if (isNaN(r) || isNaN(g) || isNaN(b)) return '';
            return '#' + hexOne(r) + hexOne(g) + hexOne(b);
          };
          this.value = toHex(hsv2rgb(_hue, _saturation, _value));
      }
    }
  };
  var draggable = function(element, options) {
    var isDragging = false;
    var moveFn = function(event) {
      if (options.drag) {
        options.drag(event);
      }
    };
    var upFn = function(event) {
      if (options.end) {
        options.end(event);
      }
      VueUtil.removeTouchMove(document, moveFn);
      VueUtil.removeTouchEnd(document, upFn);
      document.onselectstart = null;
      document.ondragstart = null;
      isDragging = false;
    };
    var downFn = function(event) {
      if (isDragging) return;
      if (options.start) {
        options.start(event);
      }
      VueUtil.addTouchMove(document, moveFn);
      VueUtil.addTouchEnd(document, upFn);
      document.onselectstart = function() {return false;};
      document.ondragstart = function() {return false;};
      isDragging = true;
    };
    VueUtil.addTouchStart(element, downFn);
  };
  var SvPanel = {
    template: '<div class="vue-color-svpanel" :style="{backgroundColor: background}"><div class="vue-color-svpanel__white"></div><div class="vue-color-svpanel__black"></div><div class="vue-color-svpanel__cursor" :style="{top: cursorTop + \'px\', left: cursorLeft + \'px\'}"><div></div></div></div>',
    props: {
      color: {
        required: true,
      }
    },
    computed: {
      colorValue: function() {
        var hue = this.color.get('hue');
        var value = this.color.get('value');
        return {hue: hue, value: value};
      }
    },
    watch: {
      colorValue: function() {
        this.update();
      }
    },
    methods: {
      update: function() {
        var saturation = this.color.get('saturation');
        var value = this.color.get('value');
        var el = this.$el;
        var boundingClientRect = el.getBoundingClientRect();
        var width = boundingClientRect.width;
        var height = boundingClientRect.height;
        if (!height) height = width * 3 / 4;
        this.cursorLeft = saturation * width / 100;
        this.cursorTop = (100 - value) * height / 100;
        this.background = 'hsl(' + this.color.get('hue') + ', 100%, 50%)';
      },
      handleDrag: function(event) {
        if (!VueUtil.isDef(event.clientX) && event.touches.length === 0) return;
        var el = this.$el;
        var rect = el.getBoundingClientRect();
        var left = (event.clientX || event.touches[0].clientX) - rect.left;
        var top = (event.clientY || event.touches[0].clientY) - rect.top;
        left = Math.max(0, left);
        left = Math.min(left, rect.width);
        top = Math.max(0, top);
        top = Math.min(top, rect.height);
        this.cursorLeft = left;
        this.cursorTop = top;
        this.color.set({
          saturation: left / rect.width * 100,
          value: 100 - top / rect.height * 100
        });
      }
    },
    mounted: function() {
      var self = this;
      draggable(self.$el, {
        start: function(event) {
          self.handleDrag(event);
        },
        drag: function(event) {
          self.handleDrag(event);
        },
        end: function(event) {
          self.handleDrag(event);
        }
      });
      self.update();
    },
    data: function() {
      return {
        cursorTop: 0,
        cursorLeft: 0,
        background: 'hsl(0, 100%, 50%)'
      };
    }
  };
  var HueSlider = {
    template: '<div :class="[\'vue-color-hue-slider\', {\'is-vertical\': vertical}]"><div class="vue-color-hue-slider__bar" @click="handleClick" ref="bar"></div><div class="vue-color-hue-slider__thumb" :style="{left: thumbLeft + \'px\', top: thumbTop + \'px\'}" ref="thumb"></div></div>',
    props: {
      color: {
        required: true
      },
      vertical: Boolean
    },
    data: function() {
      return {
        thumbLeft: 0,
        thumbTop: 0
      };
    },
    computed: {
      hueValue: function() {
        var hue = this.color.get('hue');
        return hue;
      }
    },
    watch: {
      hueValue: function() {
        this.update();
      }
    },
    methods: {
      handleClick: function(event) {
        var thumb = this.$refs.thumb;
        var target = event.target;
        if (target !== thumb) {
          this.handleDrag(event);
        }
      },
      handleDrag: function(event) {
        if (!VueUtil.isDef(event.clientX) && event.touches.length === 0) return;
        var rect = this.$el.getBoundingClientRect();
        var thumb = this.$refs.thumb;
        var hue;
        if (!this.vertical) {
          var thumbWidth = thumb.offsetWidth;
          var left = (event.clientX || event.touches[0].clientX) - rect.left;
          left = Math.min(left, rect.width - thumbWidth / 2);
          left = Math.max(thumbWidth / 2, left);
          hue = Math.round((left - thumbWidth / 2) / (rect.width - thumbWidth) * 360);
        } else {
          var thumbHeight = thumb.offsetHeight;
          var top = (event.clientY || event.touches[0].clientY) - rect.top;
          top = Math.min(top, rect.height - thumbHeight / 2);
          top = Math.max(thumbHeight / 2, top);
          hue = Math.round((top - thumbHeight / 2) / (rect.height - thumbHeight) * 360);
        }
        this.color.set('hue', hue);
      },
      getThumbLeft: function() {
        if (this.vertical) return 0;
        var el = this.$el;
        var hue = this.color.get('hue');
        if (!el) return 0;
        var thumb = this.$refs.thumb;
        return Math.round(hue * (el.offsetWidth - thumb.offsetWidth / 2) / 360);
      },
      getThumbTop: function() {
        if (!this.vertical) return 0;
        var el = this.$el;
        var hue = this.color.get('hue');
        if (!el) return 0;
        var thumb = this.$refs.thumb;
        return Math.round(hue * (el.offsetHeight - thumb.offsetHeight / 2) / 360);
      },
      update: function() {
        this.thumbLeft = this.getThumbLeft();
        this.thumbTop = this.getThumbTop();
      }
    },
    mounted: function() {
      var self = this;
      var _$refs = self.$refs;
      var bar = _$refs.bar;
      var thumb = _$refs.thumb;
      var dragConfig = {
        start: function(event) {
          self.handleDrag(event);
        },
        drag: function(event) {
          self.handleDrag(event);
        },
        end: function(event) {
          self.handleDrag(event);
        }
      };
      draggable(bar, dragConfig);
      draggable(thumb, dragConfig);
      self.update();
    }
  };
  var AlphaSlider = {
    template: '<div :class="[\'vue-color-alpha-slider\', {\'is-vertical\': vertical}]"><div class="vue-color-alpha-slider__bar" @click="handleClick" ref="bar" :style="{background: background}"></div><div class="vue-color-alpha-slider__thumb" ref="thumb" :style="{left: thumbLeft + \'px\', top: thumbTop + \'px\'}"></div></div>',
    props: {
      color: {
        required: true
      },
      vertical: Boolean
    },
    watch: {
      'color._alpha': function() {
        this.update();
      },
      'color.value': function() {
        this.update();
      }
    },
    methods: {
      handleClick: function(event) {
        var thumb = this.$refs.thumb;
        var target = event.target;
        if (target !== thumb) {
          this.handleDrag(event);
        }
      },
      handleDrag: function(event) {
        if (!VueUtil.isDef(event.clientX) && event.touches.length === 0) return;
        var rect = this.$el.getBoundingClientRect();
        var thumb = this.$refs.thumb;
        if (!this.vertical) {
          var thumbWidth = thumb.offsetWidth;
          var left = (event.clientX || event.touches[0].clientX) - rect.left;
          left = Math.max(thumbWidth / 2, left);
          left = Math.min(left, rect.width - thumbWidth / 2);
          this.color.set('alpha', Math.round((left - thumbWidth / 2) / (rect.width - thumbWidth) * 100));
        } else {
          var thumbHeight = thumb.offsetHeight;
          var top = (event.clientY || event.touches[0].clientY) - rect.top;
          top = Math.max(thumbHeight / 2, top);
          top = Math.min(top, rect.height - thumbHeight / 2);
          this.color.set('alpha', Math.round((top - thumbHeight / 2) / (rect.height - thumbHeight) * 100));
        }
      },
      getThumbLeft: function() {
        if (this.vertical) return 0;
        var el = this.$el;
        var alpha = this.color._alpha;
        if (!el) return 0;
        var thumb = this.$refs.thumb;
        return Math.round(alpha * (el.offsetWidth - thumb.offsetWidth / 2) / 100);
      },
      getThumbTop: function() {
        if (!this.vertical) return 0;
        var el = this.$el;
        var alpha = this.color._alpha;
        if (!el) return 0;
        var thumb = this.$refs.thumb;
        return Math.round(alpha * (el.offsetHeight - thumb.offsetHeight / 2) / 100);
      },
      getBackground: function() {
        if (this.color && this.color.value) {
          var colorToRgb = this.color.toRgb();
          var r = colorToRgb.r;
          var g = colorToRgb.g;
          var b = colorToRgb.b;
          return 'linear-gradient(to right, rgba(' + r + ', ' + g + ', ' + b + ', 0) 0%, rgba(' + r + ', ' + g + ', ' + b + ', 1) 100%)';
        }
        return null;
      },
      update: function() {
        this.thumbLeft = this.getThumbLeft();
        this.thumbTop = this.getThumbTop();
        this.background = this.getBackground();
      }
    },
    data: function() {
      return {
        thumbLeft: 0,
        thumbTop: 0,
        background: null
      };
    },
    mounted: function() {
      var self = this;
      var _$refs = self.$refs;
      var bar = _$refs.bar;
      var thumb = _$refs.thumb;
      var dragConfig = {
        start: function(event) {
          self.handleDrag(event);
        },
        drag: function(event) {
          self.handleDrag(event);
        },
        end: function(event) {
          self.handleDrag(event);
        }
      };
      draggable(bar, dragConfig);
      draggable(thumb, dragConfig);
      self.update();
    }
  };
  var PickerDropdown = {
    template: '<transition @after-leave="destroyPopper"><div class="vue-color-dropdown" v-show="showPopper"><div class="vue-color-dropdown__main-wrapper"><hue-slider ref="hue" :color="color" vertical style="float: right;"></hue-slider><sv-panel ref="sl" :color="color"></sv-panel></div><alpha-slider v-if="showAlpha" ref="alpha" :color="color"></alpha-slider><div class="vue-color-dropdown__btns"><vue-row type="flex" justify="space-between"><vue-col :span="14"><vue-input size="small" class="vue-color-dropdown__value" v-model="currentColor" @blur="formatColor"></vue-input></vue-col><vue-col :span="8"><vue-button type="text" @click="$emit(\'clear\')">{{$t(\'vue.colorpicker.clear\')}}</vue-button><vue-button @click="confirmValue">{{$t(\'vue.colorpicker.confirm\')}}</vue-button></vue-col></vue-row></div></div></transition>',
    mixins: [VuePopper],
    components: {
      SvPanel: SvPanel,
      HueSlider: HueSlider,
      AlphaSlider: AlphaSlider
    },
    props: {
      color: {
        required: true
      },
      showAlpha: Boolean
    },
    data: function() {
      return {
        currentColor: null
      };
    },
    methods: {
      confirmValue: function() {
        this.$emit('pick');
      },
      formatColor: function() {
        this.$parent.color.fromString(this.currentColor);
      }
    },
    mounted: function() {
      this.$parent.popperElm = this.popperElm = this.$el;
      this.referenceElm = this.$parent.$el;
    },
    watch: {
      '$parent.color.value': function(val) {
        this.currentColor = val;
      },
      showPopper: function(val) {
        var self = this;
        if (val === true) {
          self.$nextTick(function() {
            var _$refs = self.$refs;
            var sl = _$refs.sl;
            var hue = _$refs.hue;
            var alpha = _$refs.alpha;
            sl && sl.update();
            hue && hue.update();
            alpha && alpha.update();
          });
        }
      }
    }
  };
  var VueColorPicker = {
    template: '<div class="vue-color-picker" :class="[disabled ? \'is-disabled\' : \'\']" v-clickoutside="hide"> \
                <div class="vue-color-picker__mask" v-if="disabled"></div> \
                <div class="vue-color-picker__trigger" @click="handleTrigger"> \
                  <slot>\
                  <span :class="[\'vue-color-picker__color\', {\'is-alpha\': showAlpha}]">\
                    <span class="vue-color-picker__color-inner" :style="{backgroundColor: displayedColor}"></span> \
                    <span class="vue-color-picker__empty vue-icon-close" v-if="!value && !showPanelColor"></span> \
                  </span> \
                  <span class="vue-color-picker__icon vue-icon-arrow-down"></span>\
                  </slot>\
                </div> \
                <picker-dropdown ref="dropdown" \
                  class="vue-color-picker__panel" v-model="showPicker" @pick="confirmValue" @clear="clearValue" :color="color" \
                  :show-alpha="showAlpha">\
                </picker-dropdown> \
              </div>',
    name: 'VueColorPicker',
    props: {
      value: String,
      showAlpha: Boolean,
      colorFormat: String,
      disabled: Boolean
    },
    directives: {
      Clickoutside: VueUtil.component.clickoutside()
    },
    computed: {
      displayedColor: function() {
        if (!this.value && !this.showPanelColor) {
          return 'transparent';
        } else {
          var colorToRgb = this.color.toRgb();
          var r = colorToRgb.r;
          var g = colorToRgb.g;
          var b = colorToRgb.b;
          return this.showAlpha ? 'rgba(' + r + ', ' + g + ', ' + b + ', ' + this.color.get('alpha') / 100 + ')' : 'rgb(' + r + ', ' + g + ', ' + b + ')';
        }
      }
    },
    watch: {
      value: function(val) {
        if (!val) {
          this.showPanelColor = false;
        } else if (val !== this.color.value) {
          this.color.fromString(val);
        }
      },
      color: {
        deep: true,
        handler: function() {
          this.showPanelColor = true;
        }
      },
      disabled: function(val) {
        if(val === true) {
          this.showPicker = false;
        }
      }
    },
    methods: {
      handleTrigger: function() {
        if (this.disabled) return;
        this.showPicker = !this.showPicker;
      },
      confirmValue: function(value) {
        this.$emit('input', this.color.value);
        this.$emit('change', this.color.value);
        this.showPicker = false;
      },
      clearValue: function() {
        this.$emit('input', null);
        this.$emit('change', null);
        this.showPanelColor = false;
        this.showPicker = false;
        this.resetColor();
      },
      hide: function() {
        this.showPicker = false;
        this.resetColor();
      },
      resetColor: function() {
        var self = this;
        self.$nextTick(function() {
          if (self.value) {
            self.color.fromString(self.value);
          } else {
            self.showPanelColor = false;
          }
        });
      }
    },
    mounted: function() {
      var value = this.value;
      if (value) {
        this.color.fromString(value);
      }
      this.popperElm = this.$refs.dropdown.$el;
    },
    data: function() {
      var color = new Color({
        enableAlpha: this.showAlpha,
        format: this.colorFormat
      });
      return {
        color: color,
        showPicker: false,
        showPanelColor: false
      };
    },
    components: {
      PickerDropdown: PickerDropdown
    }
  };
  Vue.component(VueColorPicker.name, VueColorPicker);
});

(function(context, definition) {
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VueDatePicker'], definition);
  } else {
    context.VueCalendar = definition(context.Vue, context.VueUtil, context.VueDatePicker);
    delete context.VueCalendar;
    delete context.VueDatePicker;
    delete context.VuePicker;
  }
})(this, function(Vue, VueUtil, VueDatePicker) {
  'use strict';
  var EventCard = {
    props: {
      date: Date,
      firstDay: Number,
      event: Object
    },
    data: function() {
      return {
        defaultWidth: 0
      };
    },
    render: function(createElement) {
      if (this.defaultWidth === 0) return;
      var self = this;
      var event = self.event;
      var start = VueUtil.parseDate(event.start);
      var end = VueUtil.parseDate(event.end);
      var showTitile = (self.date.getDay() === self.firstDay || VueUtil.formatDate(start) === VueUtil.formatDate(self.date));
      var eventItem = createElement('div', {class: ['vue-full-calendar__event-item', 'is-opacity']}, []);
      if (showTitile) {
        var dateCount = Math.floor((end.getTime() - self.date.getTime()) / 86400000) + 1;
        var lastDayCount = 7 - self.date.getDay();
        var defaultWidth = self.defaultWidth;
        var isEnd = false;
        if (lastDayCount >= dateCount) {
          defaultWidth = defaultWidth * dateCount;
          isEnd = true;
        } else {
          defaultWidth = defaultWidth * lastDayCount;
        }
        if (isEnd) defaultWidth = defaultWidth - 4;
        var eventClass = [];
        var customClass = event.customClass;
        if (VueUtil.isDef(customClass)) {
          VueUtil.mergeArray(eventClass, customClass);
        }
        if (VueUtil.formatDate(start) === VueUtil.formatDate(self.date)) {
          eventClass.push('is-start');
          defaultWidth = defaultWidth - 4;
        }
        eventClass = eventClass.join(' ');
        var mouseenterItem = function(eventCards, event) {
          VueUtil.loop(eventCards, function(card) {
            if (card.event.cellIndex === event.cellIndex
              && VueUtil.formatDate(event.start) === VueUtil.formatDate(card.event.start)
              && VueUtil.formatDate(event.end) === VueUtil.formatDate(card.event.end)) {
              card.$refs.eventItem && card.$refs.eventItem.classList.add('hover');
            }
          });
        };
        var mouseleaveItem = function(eventCards, event) {
          VueUtil.loop(eventCards, function(card) {
            if (card.event.cellIndex === event.cellIndex
              && VueUtil.formatDate(event.start) === VueUtil.formatDate(card.event.start)
              && VueUtil.formatDate(event.end) === VueUtil.formatDate(card.event.end)) {
              card.$refs.eventItem && card.$refs.eventItem.classList.remove('hover');
            }
          });
        };
        var eventCards = self.$parent.$refs.eventCard;
        eventItem = createElement('div', null, [createElement('div', {
          class: ['vue-full-calendar__event-item', eventClass, {'is-opacity': !event.isShow}],
          style: {'position': 'absolute', 'width': defaultWidth + 'px'},
          ref: 'eventItem',
          attrs: {title: event.title},
          on: {
            click: function(e) {
              self.$emit('click', event, e);
            },
            mouseenter: function(e) {mouseenterItem(eventCards, event);},
            mouseleave: function(e) {mouseleaveItem(eventCards, event);}
          },
        }, [event.title]), createElement('div', {class: ['vue-full-calendar__event-item', 'is-opacity']}, [])]);
      }
      return eventItem;
    }
  };
  var FcHeader = {
    template: '<div class="vue-full-calendar-header"><div class="vue-full-calendar-header__left"><slot name="fcLeftHeader"></slot></div><div class="vue-full-calendar-header__center"><button type="button" @click="changeMonth(-1 , \'year\')" class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-d-arrow-left"></button><button type="button" @click="changeMonth(-1, \'month\')" class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-arrow-left"></button><vue-popover trigger="click"><year-table @pick="handleYearPick" :year="currentMonth.getFullYear()"></year-table><span slot="reference" class="vue-date-picker__header-label">{{yearLabel}}</span></vue-popover><vue-popover trigger="click"><month-table @pick="handleMonthPick" :month="currentMonth.getMonth()"></month-table><span slot="reference" :class="[\'vue-date-picker__header-label\']">{{monthLabel}}</span></vue-popover><button type="button" @click="changeMonth(1 , \'year\')" class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-d-arrow-right"></button><button type="button" @click="changeMonth(1 , \'month\')" class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-arrow-right"></button></div><div class="vue-full-calendar-header__right"><slot name="fcRightHeader"></slot><span class="thisMonth" @click="changeToNow" v-if="!$slots.fcRightHeader">{{$t(\'vue.datepicker.thisMonth\')}}</span></div></div>',
    props: {
      currentMonth: Date,
      firstDay: Number
    },
    components: {
      YearTable: VueDatePicker().YearTable,
      MonthTable: VueDatePicker().MonthTable
    },
    computed: {
      monthLabel: function() {
        var month = this.currentMonth.getMonth() + 1;
        return this.$t('vue.datepicker.month' + month);
      },
      yearLabel: function() {
        var year = this.currentMonth.getFullYear();
        if (!year) return '';
        var yearTranslation = this.$t('vue.datepicker.year');
        return year + ' ' + yearTranslation;
      }
    },
    methods: {
      handleYearPick: function(year) {
        var result = new Date();
        this.currentMonth.setFullYear(year);
        result.setTime(this.currentMonth.getTime());
        this.$emit('change', result);
      },
      handleMonthPick: function(month) {
        var result = new Date();
        this.currentMonth.setMonth(month);
        result.setTime(this.currentMonth.getTime());
        this.$emit('change', result);
      },
      changeMonth: function(num, type) {
        var newMonth = VueUtil.addDate(this.currentMonth, num, type);
        this.$emit('change', newMonth);
      },
      changeToNow: function() {
        this.$emit('change', new Date);
      }
    }
  };
  var FullCalendar = {
    template: '<div class="vue-full-calendar" :style="compStyle"><fc-header :current-month="currentMonth" :first-day="firstDay" @change="emitChangeMonth"><slot slot="fcLeftHeader" name="fcHeaderLeft"></slot><slot slot="fcRightHeader" name="fcHeaderRight"></slot></fc-header><div class="vue-full-calendar-body"><div v-if="weekLabel" class="vue-full-calendar__weeks"><div class="vue-full-calendar__week" v-for="(week, weekIndex) in WEEKS" :key="weekIndex">{{$t(weekLabel[week])}}</div></div><div v-else class="vue-full-calendar__weeks"><div class="vue-full-calendar__week" v-for="(week, weekIndex) in WEEKS" :key="weekIndex">{{$t(\'vue.datepicker.weeks.\'+week)}}</div></div><div class="vue-full-calendar__dates"><div class="vue-full-calendar__dates-events"><div class="vue-full-calendar__events-week" v-for="(week,weekIndex) in currentDates" :key="weekIndex"><div v-for="(day, dayIndex) in week" :style="eventDayStyle" :key="dayIndex" :class="[\'vue-full-calendar__events-day\', {\'today\': day.isToday}, day.dayClass]" ref="eventsDay"><div :class="[\'day-number\']" @mouseenter="mouseenterDay" @mouseleave="mouseleaveDay" @click="dayclick(day.date, $event)">{{day.monthDay}}</div><div class="vue-full-calendar__event-box"><event-card ref="eventCard" :event="event" :date="day.date" :firstDay="firstDay" v-for="(event, eventIndex) in day.events" :key="eventIndex" v-show="event.cellIndex <= eventLimit" @click="eventclick"></event-card><vue-popover trigger="click" v-if="day.events.length > eventLimit && showMore"><div class="vue-full-calendar__more-events"><ul class="events-list"><li v-for="(event, eventIndex) in selectDay.showEvents" :key="eventIndex" :class="[\'vue-full-calendar__event-item\', event.customClass]" @click="eventclick(event, $event)" @mouseenter="mouseenterEvent(event, $event)" @mouseleave="mouseleaveEvent(event, $event)" :title="event.title">{{event.title}}</li></ul></div><div slot="reference" class="more-link" @click="moreclick(day, $event)">+ {{day.moreCount}}</div></vue-popover><div v-if="day.events.length > eventLimit && !showMore" class="more-link" @click="moreclick(day, $event)">+{{day.moreCount}}</div></div></div></div></div></div></div></div>',
    props: {
      events: Array,
      eventLimit: Number,
      showMore: Boolean,
      dateClass: Array,
      weekClass: Array,
      weekLabel: Object
    },
    components: {
      EventCard: EventCard,
      FcHeader: FcHeader
    },
    mounted: function() {
      this.emitChangeMonth(this.currentMonth);
      VueUtil.addResizeListener(this.$el, this.changeEventCardWidth);
    },
    beforeDestroy: function() {
      this.$el && VueUtil.removeResizeListener(this.$el, this.changeEventCardWidth);
    },
    data: function() {
      return {
        currentMonth: new Date,
        firstDay: 0,
        selectDay: {}
      };
    },
    computed: {
      currentDates: function() {
        return this.getCalendar();
      },
      WEEKS: function() {
        var WEEKS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
        var week = this.firstDay;
        return VueUtil.mergeArray(WEEKS, WEEKS).slice(week, week + 7);
      },
      eventDayStyle: function() {
        var style = {};
        var height = (this.eventLimit + 2) * 20;
        style.height = height + 'px';
        return style;
      },
      compStyle: function() {
        var style = {};
        var width = (this.eventLimit + 2) * 20 * 7 + 43;
        var height = (this.eventLimit + 2) * 20 * 7 + 63 - this.eventLimit * 20;
        style.width = width + 'px';
        style.height = height + 'px';
        return style;
      }
    },
    watch: {
      events: function(val) {
        this.$nextTick(this.changeEventCardWidth);
      }
    },
    methods: {
      changeEventCardWidth: function() {
        var eventCard = this.$refs.eventCard;
        var defaultWidth = parseFloat(VueUtil.getStyle(this.$refs.eventsDay[0], 'width'));
        if (VueUtil.isArray(eventCard)) {
          VueUtil.loop(eventCard, function(card) {
            card.defaultWidth = defaultWidth;
          });
        } else if(VueUtil.isDef(eventCard)) {
          eventCard.defaultWidth = defaultWidth;
        }
      },
      getStartDateOfMonth: function(year, month) {
        var result = new Date(year, month, 1);
        var day = result.getDay();
        if (day === 0) day = 7;
        result.setTime(result.getTime() - 86400000 * day);
        return result;
      },
      emitChangeMonth: function(firstDayOfMonth) {
        this.currentMonth = firstDayOfMonth;
        var start = this.getStartDateOfMonth(firstDayOfMonth.getFullYear(), firstDayOfMonth.getMonth());
        var end = VueUtil.addDate(start, 6, 'week');
        this.$emit('changemonth', start, end, firstDayOfMonth);
        this.$nextTick(this.changeEventCardWidth);
      },
      getCalendar: function() {
        var monthViewStartDate = this.getStartDateOfMonth(this.currentMonth.getFullYear(), this.currentMonth.getMonth());
        var calendar = [];
        var dateClassAry = this.dateClass;
        var weekClassAry = this.weekClass;
        for (var perWeek = 0; perWeek < 6; perWeek++) {
          var week = [];
          for (var perDay = 0; perDay < 7; perDay++) {
            var dayClass = [];
            VueUtil.loop(dateClassAry, function(dateClass) {
              if (VueUtil.formatDate(dateClass.date) === VueUtil.formatDate(monthViewStartDate)) {
                VueUtil.mergeArray(dayClass, dateClass.customClass);
              }
            });
            VueUtil.loop(weekClassAry, function(weekClass) {
              if (weekClass.week === perDay) {
                VueUtil.mergeArray(dayClass, weekClass.customClass);
              }
            });
            week.push({
              monthDay: monthViewStartDate.getDate(),
              isToday: (VueUtil.formatDate(monthViewStartDate) === VueUtil.formatDate(new Date)),
              weekDay: perDay,
              date: monthViewStartDate,
              events: this.slotEvents(monthViewStartDate),
              dayClass: dayClass
            });
            monthViewStartDate = VueUtil.addDate(monthViewStartDate, 1);
          }
          var self = this;
          VueUtil.loop(week, function(day) {
            day.showEvents = VueUtil.filter(day.events, function(event) {
              return event.isShow === true;
            });
            day.moreCount = 0;
            VueUtil.loop(day.showEvents, function(event) {
              if (event.cellIndex > self.eventLimit) {
                day.moreCount++;
              }
            });
          });
          calendar.push(week);
        }
        return calendar;
      },
      slotEvents: function(date) {
        var cellIndexArr = [];
        var events = VueUtil.mergeArray([], this.events);
        var thisDayEvents = VueUtil.filter(events, function(day) {
          var st = VueUtil.parseDate(day.start).getTime();
          var ed = VueUtil.parseDate(day.end ? day.end : st).getTime();
          var de = VueUtil.parseDate(date).getTime();
          return (de >= st && de <= ed);
        });
        thisDayEvents.sort(function(a, b) {
          if (!a.cellIndex) return 1;
          if (!b.cellIndex) return -1;
          return a.cellIndex - b.cellIndex;
        });
        for (var i = 0; i < thisDayEvents.length; i++) {
          thisDayEvents[i].cellIndex = thisDayEvents[i].cellIndex || (i + 1);
          thisDayEvents[i].isShow = true;
          if (thisDayEvents[i].cellIndex === i + 1 || i > this.eventLimit) continue;
          var formatDate = VueUtil.formatDate(date);
          thisDayEvents.splice(i, 0, {
            cellIndex: i + 1,
            start: formatDate,
            end: formatDate,
            isShow: false
          });
        }
        return thisDayEvents;
      },
      findEventsByDate: function(date, events) {
        var findEvents = [];
        VueUtil.loop(events, function(event) {
          var st = VueUtil.parseDate(event.start).getTime();
          var ed = VueUtil.parseDate(event.end ? event.end : st).getTime();
          var de = VueUtil.parseDate(date).getTime();
          if (de >= st && de <= ed) {
            findEvents.push(event);
          }
        });
        return findEvents;
      },
      mouseenterDay: function(e) {
        e.target.parentElement.classList.add('hover');
      },
      mouseleaveDay: function(e) {
        e.target.parentElement.classList.remove('hover');
      },
      mouseenterEvent: function(event, e) {
        VueUtil.loop(this.$refs.eventCard, function(card) {
          if (card.event.cellIndex === event.cellIndex
            && VueUtil.formatDate(event.start) === VueUtil.formatDate(card.event.start)
            && VueUtil.formatDate(event.end) === VueUtil.formatDate(card.event.end)) {
            card.$refs.eventItem && card.$refs.eventItem.classList.add('hover');
          }
        });
        e.target.classList.add('hover');
      },
      mouseleaveEvent: function(event, e) {
        VueUtil.loop(this.$refs.eventCard, function(card) {
          if (card.event.cellIndex === event.cellIndex
            && VueUtil.formatDate(event.start) === VueUtil.formatDate(card.event.start)
            && VueUtil.formatDate(event.end) === VueUtil.formatDate(card.event.end)) {
            card.$refs.eventItem && card.$refs.eventItem.classList.remove('hover');
          }
        });
        e.target.classList.remove('hover');
      },
      moreclick: function(day, jsEvent) {
        this.selectDay = day;
        var dateEvents = this.findEventsByDate(day.date, this.events);
        this.$emit('moreclick', day.date, dateEvents, jsEvent);
      },
      dayclick: function(date, jsEvent) {
        var dateEvents = this.findEventsByDate(date, this.events);
        this.$emit('dayclick', date, dateEvents, jsEvent);
      },
      eventclick: function(event, jsEvent) {
        if (!event.isShow) return;
        jsEvent.stopPropagation();
        this.$emit('eventclick', event, jsEvent);
      }
    }
  };
  var DefaultCalendar = {
    template:'<div                                                                                                                     '+
    'class="vue-picker-panel vue-date-picker vue-popper"                                                                      '+
    ':class="[{                                                                                                               '+
    '  \'has-sidebar\': $slots.sidebar || shortcuts,                                                                          '+
    '  \'has-time\': showTime ,                                                                                                '+
    '  \'fix-month\': fixMonth                                                                                                 '+
    '}, popperClass]">                                                                                                        '+
    '<div class="vue-picker-panel__body-wrapper">                                                                             '+
    '  <div class="vue-picker-panel__body">                                                                                   '+
    '    <div                                                                                                                 '+
    '      class="vue-date-picker__header"                                                                                    '+
    '      :class="{ \'vue-date-picker__header--bordered\': currentView === \'year\' || currentView === \'month\' }"          '+
    '      v-show="currentView !== \'time\'">                                                                                 '+
    '      <button  v-if="!fixMonth"                                                                                          '+
    '        type="button"                                                                                                    '+
    '        @click="prevYear"                                                                                                '+
    '        :aria-label="$t(\'vue.datepicker.prevYear\')"                                                                    '+
    '        class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-d-arrow-left">                              '+
    '      </button>                                                                                                          '+
    '      <button   v-if="!fixMonth"                                                                                         '+
    '        type="button"                                                                                                    '+
    '        @click="prevMonth"                                                                                               '+
    '        v-show="currentView === \'date\'"                                                                                '+
    '        :aria-label="$t(\'vue.datepicker.prevMonth\')"                                                                   '+
    '        class="vue-picker-panel__icon-btn vue-date-picker__prev-btn vue-icon-arrow-left">                                '+
    '      </button>                                                                                                          '+
    '      <span     v-if="!fixMonth"                                                                                           '+
    '        @click="showYearPicker"                                                                                          '+
    '        role="button"                                                                                                    '+
    '        class="vue-date-picker__header-label">{{ yearLabel }}</span>                                                     '+
    '      <span     v-if="!fixMonth"                                                                                        '+
    '        @click="showMonthPicker"                                                                                         '+
    '        v-show="currentView === \'date\'"                                                                                '+
    '        role="button"                                                                                                    '+
    '        class="vue-date-picker__header-label"                                                                            '+
    '        :class="{ active: currentView === \'month\' }">{{$t(\'vue.datepicker.month\' + (month + 1))}}</span>             '+
    
    '      <span   v-if="fixMonth"                                                                                            '+
    '        role="button"                                                                                                    '+
    '        >{{ yearLabel }}</span>                                                     '+
    '      <span    v-if="fixMonth"                                                                                           '+
    '        v-show="currentView === \'date\'"                                                                                '+
    '        role="button"                                                                                                    '+
    '                                                                                    '+
    '        :class="{ active: currentView === \'month\' }">{{$t(\'vue.datepicker.month\' + (month + 1))}}</span>             '+

    '      <button    v-if="!fixMonth"                                                                                         '+
    '        type="button"                                                                                                    '+
    '        @click="nextYear"                                                                                                '+
    '        :aria-label="$t(\'vue.datepicker.nextYear\')"                                                                    '+
    '        class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-d-arrow-right">                             '+
    '      </button>                                                                                                          '+
    '      <button      v-if="!fixMonth"                                                                                          '+
    '        type="button"                                                                                                    '+
    '        @click="nextMonth"                                                                                               '+
    '        v-show="currentView === \'date\'"                                                                                '+
    '        :aria-label="$t(\'vue.datepicker.nextMonth\')"                                                                   '+
    '        class="vue-picker-panel__icon-btn vue-date-picker__next-btn vue-icon-arrow-right">                               '+
    '      </button>                                                                                                          '+
    '    </div>                                                                                                               '+
    '    <div class="vue-picker-panel__content">                                                                              '+
    '      <date-table                                                                                                        '+
    '        v-show="currentView === \'date\'"                                                                                '+
    '        @pick="handleDatePick"                                                                                           '+
    '        :selection-mode="selectionMode"                                                                                  '+
    '        :events="events"                                                                                                 '+
    '        :first-day-of-week="firstDayOfWeek"                                                                              '+
    '        :value="value"                                                                                                   '+
    '        :default-value="defaultValue ? new Date(defaultValue) : null"                                                    '+
    '        :date="date"                                                                                                     '+
    '        :disabled-date="disabledDate">                                                                                   '+
    '      </date-table>                                                                                                      '+
    '      <year-table                                                                                                        '+
    '        v-show="currentView === \'year\'"                                                                                '+
    '        @pick="handleYearPick"                                                                                           '+
    '        :value="value"                                                                                                   '+
    '        :default-value="defaultValue ? new Date(defaultValue) : null"                                                    '+
    '        :date="date"                                                                                                     '+
    '        :disabled-date="disabledDate">                                                                                   '+
    '      </year-table>                                                                                                      '+
    '      <month-table                                                                                                       '+
    '        v-show="currentView === \'month\'"                                                                               '+
    '        @pick="handleMonthPick"                                                                                          '+
    '        :value="value"                                                                                                   '+
    '        :default-value="defaultValue ? new Date(defaultValue) : null"                                                    '+
    '        :date="date"                                                                                                     '+
    '        :disabled-date="disabledDate">                                                                                   '+
    '      </month-table>                                                                                                     '+
    '    </div>                                                                                                               '+
    '  </div>                                                                                                                 '+
    '</div>                                                                                                                   '+
    '<div v-show="selectionMode !== \'dates\'"                                                                                  '+
    '  class="vue-picker-panel__footer">                                                                                      '+
    '  <vue-button                                                                                                            '+
    '    size="mini"                                                                                                          '+
    '    type="text"                                                                                                          '+
    '    class="vue-picker-panel__link-btn"                                                                                   '+
    '    @click="changeToNow" >                                                                                '+
    '    {{ nowLabel }}                                                                                                       '+
    '  </vue-button>                                                                                                          '+
    '</div>                                                                                                                   '+
    '</div>                                                                                                                   ',
    mixins: [VueDatePicker().DatePanel],
    data: function() {
      return {
        date: new Date(),
        currentView: 'date',
        width: 0,
      };
    },
    props: {
      type: {
        default: 'date',
        type: String
      },
      fixMonth: Boolean,
      events: Array,
      disabledDates: Function
    },
    computed: {
      yearLabel: function() {
        var year = this.year;
        if (!year)
          return '';
        var yearTranslation = this.$t('vue.datepicker.year');
        if (this.currentView === 'year') {
          var startYear = Math.floor(year / 10) * 10;
          if (yearTranslation) {
            return startYear + ' ' + yearTranslation + ' - ' + (startYear + 9) + ' ' + yearTranslation;
          }
          return startYear + ' - ' + (startYear + 9);
        }
        return this.year + ' ' + yearTranslation;
      },
      monthLabel: function() {
        return this.$t('vue.datepicker.month' + (this.month + 1));
      },
      nowLabel: function() {
        return this.$t('vue.datepicker.today');
      }
    },
    mounted: function() {
      if (this.type === 'week') {
        this.selectionMode =  'week';
      } else if (this.type === 'month') {
        this.selectionMode = 'month';
      } else if (this.type === 'year') {
        this.selectionMode = 'year';
      } else if (this.type === 'dates') {
        this.selectionMode = 'dates';
      } else {
        this.selectionMode = 'day';
      }

      if (this.date && !this.year) {
        this.year = this.date.getFullYear();
        this.month = this.date.getMonth();
      }
      this.disabledDate = this.disabledDates;
    },
    created: function() {
      this.$on('pick', function(date) {
        var findEventsByDate = function(date, events) {
          if (events && events.length > 0) {
            var findEvents = [];
            VueUtil.loop(events, function(event) {
              var st = VueUtil.parseDate(event.start).getTime();
              var ed = VueUtil.parseDate(event.end ? event.end : st).getTime();
              var de = VueUtil.parseDate(date).getTime();
              if (de >= st && de <= ed) {
                findEvents.push(event);
              }
            });
            return findEvents;
          }
        };
        //this.value = date;
        var dateEvents;
        if (this.selectionMode == 'day') {
          dateEvents = findEventsByDate(date, this.events);
        }
        this.$emit('dayclick', date, dateEvents);
      });
    }
  };
  var VueCalendar = {
    template: '<full-calendar v-if="full" ref="fullCalendar" :date-class="dateClass" :week-class="weekClass" :week-label="weekLabel" :events="events" :event-limit="eventLimit" :show-more="showMore" @dayclick="dayclick" @eventclick="eventclick" @moreclick="moreclick"><slot name="headerLeft" slot="fcHeaderLeft"></slot><slot name="headerRight" slot="fcHeaderRight"></slot></full-calendar><calendar v-else :events="events" :type="type" :fixMonth="fixMonth" :disabled-dates="disabledDate" @dayclick="dayclick" @view-month-change="viewMonthChange" ref="calendar"></calendar>',
    name: 'VueCalendar',
    components: {
      calendar: DefaultCalendar,
      FullCalendar: FullCalendar
    },
    props: {
      events: {
        type: Array,
        default: function() {
          return [];
        }
      },
      eventLimit: {
        type: Number,
        default: 2
      },
      showMore: {
        type: Boolean,
        default: true
      },
      dateClass: {
        type: Array,
        default: function() {
          return [];
        }
      },
      weekClass: {
        type: Array,
        default: function() {
          return [];
        }
      },
      weekLabel: {
        type: Object,
        default: function() {
          return null;
        }
      },
      type: {
        default: 'date',
        type: String
      },
      full: Boolean,
      value: '',
      fixMonth: Boolean,
      disabledDate: Function
    },
    model: {
      event: 'dayclick'
    },
    methods: {
      toDate: function(date) {
        this.$refs.calendar.date = new Date(date);
      },
      changeToNow: function () {
        if (this.$refs.fullCalendar && this.$refs.fullCalendar.emitChangeMonth) {
          this.$refs.fullCalendar.emitChangeMonth(new Date);
        } else {
          this.$refs.calendar.changeToNow();
        }
      },
      dayclick: function(day, events, jsEvent) {
        this.$emit('dayclick', day, events, jsEvent);
      },
      viewMonthChange: function(date, events, jsEvent) {
        this.$emit('view-month-change', date, events, jsEvent);
      },
      eventclick: function(event, jsEvent) {
        this.$emit('eventclick', event, jsEvent);
      },
      moreclick: function(day, events, jsEvent) {
        this.$emit('moreclick', day, events, jsEvent);
      },
    },
    watch: {
      value: function(val) {
        this.$refs.calendar.value = val;
      }
    },
    mounted: function() {
      if(!this.full) {
        this.$refs.calendar.value = this.value;
        this.$refs.calendar.$emit('pick', this.value);
        if(this.value instanceof Array && this.value.length > 0) {
          this.$refs.calendar.date = this.value[0];
        }
      }
    }
  };
  Vue.component(VueCalendar.name, VueCalendar);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VuePin = definition(context.Vue, context.VueUtil);
    delete context.VuePin;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VuePin = {
    template: '<div><div :style="styles"><slot></slot></div></div>',
    name: 'VuePin',
    props: {
      offsetTop: {
        type: Number,
        default: 0
      },
      offsetBottom: {
        type: Number
      },
      fixed: Boolean
    },
    data: function() {
      return {
        pin: false,
        styles: {}
      };
    },
    computed: {
      offsetType: function() {
        var type = 'top';
        if (this.offsetBottom >= 0) {
          type = 'bottom';
        }
        return type;
      }
    },
    mounted: function() {
      var self = this;
      self.$nextTick(function() {
        if (self.fixed) {
          self.pin = true;
          var elOffset = self.getOffset(self.$el);
          if (self.offsetType == 'bottom') {
            self.styles = {
              bottom: self.offsetBottom + 'px',
              left: elOffset.left + 'px',
              width: self.$el.offsetWidth + 'px',
              position: 'fixed',
              zIndex: VueUtil.nextZIndex()
            };
          } else {
            self.styles = {
              top: self.offsetTop + 'px',
              left: elOffset.left + 'px',
              width: self.$el.offsetWidth + 'px',
              position: 'fixed',
              zIndex: VueUtil.nextZIndex()
            };
          }
        } else {
          self.scrollParent = VueUtil.component.getScrollParent(self.$el);
          VueUtil.on(self.scrollParent, 'scroll', self.handleScroll);
          VueUtil.addResizeListener(self.handleScroll);
        }
      });
    },
    beforeDestroy: function() {
      if (!this.fixed) {
        VueUtil.off(this.scrollParent, 'scroll', this.handleScroll);
        VueUtil.removeResizeListener(this.handleScroll);
      }
    },
    methods: {
      getScroll: function(top) {
        var ret = null;
        if (VueUtil.isDef(top)) {
          ret = pageYOffset;
          if (!VueUtil.isNumber(ret)) ret = document.documentElement.scrollTop;
        } else {
          ret = pageXOffset;
          if (!VueUtil.isNumber(ret)) ret = document.documentElement.scrollLeft;
        }
        return ret;
      },
      getOffset: function(element) {
        var rect = element.getBoundingClientRect();
        var scrollTop = this.getScroll(true);
        var scrollLeft = this.getScroll();
        var clientTop = document.body.clientTop || 0;
        var clientLeft = document.body.clientLeft || 0;
        return {
          top: rect.top + scrollTop - clientTop,
          left: rect.left + scrollLeft - clientLeft
        };
      },
      handleScroll: function() {
        var pin = this.pin;
        var scrollTop = this.getScroll(true);
        var elOffset = this.getOffset(this.$el);
        var windowHeight = innerHeight;
        var elHeight = this.$el.getElementsByTagName('div')[0].offsetHeight;
        if ((elOffset.top - this.offsetTop) < scrollTop && this.offsetType == 'top' && !pin) {
          this.pin = true;
          this.styles = {
            top: this.offsetTop + 'px',
            left: elOffset.left + 'px',
            width: this.$el.offsetWidth + 'px',
            position: 'fixed',
            zIndex: VueUtil.nextZIndex()
          };
          this.$emit('change', true);
        } else if ((elOffset.top - this.offsetTop) > scrollTop && this.offsetType == 'top' && pin) {
          this.pin = false;
          this.styles = null;
          this.$emit('change', false);
        }
        if ((elOffset.top + this.offsetBottom + elHeight) > (scrollTop + windowHeight) && this.offsetType == 'bottom' && !pin) {
          this.pin = true;
          this.styles = {
            bottom: this.offsetBottom + 'px',
            left: elOffset.left + 'px',
            width: this.$el.offsetWidth + 'px',
            position: 'fixed',
            zIndex: VueUtil.nextZIndex()
          };
          this.$emit('change', true);
        } else if ((elOffset.top + this.offsetBottom + elHeight) < (scrollTop + windowHeight) && this.offsetType == 'bottom' && pin) {
          this.pin = false;
          this.styles = null;
          this.$emit('change', false);
        }
      }
    }
  };
  Vue.component(VuePin.name, VuePin);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueDraggable = definition(context.Vue, context.VueUtil);
    delete context.VueDraggable;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var directive = function() {
    var Bind = function(object, fun, args) {
      return function() {
        return fun.apply(object, args || []);
      };
    };
    var BindAsEventListener = function(object, fun) {
      var args = [].slice.call(arguments).slice(2);
      return function(e) {
        return fun.apply(object, VueUtil.mergeArray([e || event], args));
      };
    };
    var Class = function(properties) {
      var _class = function() {
        return (arguments[0] !== null && VueUtil.isFunction(this.initialize)) ? this.initialize.apply(this, arguments) : this;
      };
      _class.prototype = properties;
      return _class;
    };
    var dragEl = new Class({
      initialize: function(el, cancelObj, resizeObj, offsetLeft, offsetTop) {
        this._dragobj = el;
        this._body = cancelObj;
        this._resize = resizeObj;
        this._x = 0;
        this._y = 0;
        this._fM = BindAsEventListener(this, this.Move);
        this._fS = Bind(this, this.Stop);
        this._isdrag = null;
        this._Css = null;
        this.offsetLeft = offsetLeft;
        this.offsetTop = offsetTop;
        this.Minwidth = parseInt(VueUtil.getStyle(el, 'minWidth'));
        this.Minheight = parseInt(VueUtil.getStyle(el, 'minHeight'));
        VueUtil.addTouchStart(this._dragobj, BindAsEventListener(this, this.Start, true));
        VueUtil.addTouchStart(this._resize, BindAsEventListener(this, this.Start, false));
      },
      isCancel: function(el) {
        if (this._body.indexOf(el) !== -1) return true;
        if (this._dragobj === el) return false;
        return this.isCancel(el.parentElement);
      },
      Cancelbubble: function(e) {
        VueUtil.isBoolean(e.cancelBubble) && (e.cancelBubble = true);
        VueUtil.isFunction(e.stopPropagation) && e.stopPropagation();
      },
      Changebg: function(o, x1, x2) {
        o.style.backgroundPosition = (o.style.backgroundPosition == x1) ? x2 : x1;
      },
      Start: function(e, isdrag) {
        var clientX = e.clientX;
        var clientY = e.clientY;
        if (e.touches && e.touches[0]) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        }
        if (!VueUtil.isDef(clientX) || !VueUtil.isDef(clientY) || this.isCancel(e.target)) return;
        if (!isdrag) this.Cancelbubble(e);
        this._Css = isdrag ? {
          x: 'left',
          y: 'top'
        } : {
            x: 'width',
            y: 'height'
          };
        this._isdrag = isdrag;
        this._x = isdrag ? (clientX - this._dragobj.offsetLeft + this.offsetLeft) : (this._dragobj.offsetLeft || 0);
        this._y = isdrag ? (clientY - this._dragobj.offsetTop + this.offsetTop) : (this._dragobj.offsetTop || 0);
        if (document.all) {
          VueUtil.on(this._dragobj, 'losecapture', this._fS);
          this._dragobj.setCapture();
        } else {
          e.preventDefault();
          VueUtil.on(document, 'blur', this._fS);
        }
        VueUtil.addTouchMove(document, this._fM);
        VueUtil.addTouchEnd(document, this._fS);
      },
      Move: function(e) {
        var clientX = e.clientX;
        var clientY = e.clientY;
        if (e.touches && e.touches[0]) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        }
        if (!VueUtil.isDef(clientX) || !VueUtil.isDef(clientY)) return;
        getSelection ? getSelection().removeAllRanges() : document.selection.empty();
        var i_x = clientX - this._x;
        var i_y = clientY - this._y;
        this._dragobj.style[this._Css.x] = (this._isdrag ? i_x : Math.max(i_x, this.Minwidth)) + 'px';
        this._dragobj.style[this._Css.y] = (this._isdrag ? i_y : Math.max(i_y, this.Minheight)) + 'px';
        if (!this._isdrag) {
          VueUtil.setStyle(this._dragobj, 'height', Math.max(i_y, this.Minheight) - 2 * parseInt(VueUtil.getStyle(this._dragobj, 'paddingLeft')) + 'px');
        }
      },
      Stop: function() {
        VueUtil.removeTouchMove(document, this._fM);
        VueUtil.removeTouchEnd(document, this._fS);
        if (document.all) {
          VueUtil.off(this._dragobj, 'losecapture', this._fS);
          this._dragobj.releaseCapture();
        } else {
          VueUtil.off(document, 'blur', this._fS);
        }
      }
    });
    Vue.directive('draggable', {
      inserted: function(el, binding) {
        var cancelObj = [];
        var cancelSelectors = el.getAttribute('draggable-cancel-selector');
        if (cancelSelectors) {
          VueUtil.loop(cancelSelectors.split(','), function(cancelSelector) {
            if (VueUtil.hasClass(el, cancelSelector.split('.')[1])) {
              cancelObj.push(el);
              return false;
            }
            cancelObj.push(el.querySelector(cancelSelector));
          });
        }
        if (cancelObj.indexOf(el) !== -1) return;
        var resizeObj = null;
        var resizeFlg = el.getAttribute('draggable-resize');
        if (resizeFlg) {
          resizeObj = document.createElement('DIV');
          var resizeStyle = {
            bottom: '1px',
            right: '1px',
            cursor: 'nw-resize',
            position: 'absolute',
            width: '10px',
            height: '10px',
            fontSize: 0
          };
          VueUtil.merge(resizeObj.style, resizeStyle);
          el.appendChild(resizeObj);
        }
        Vue.nextTick(function() {
          var positionStyle = VueUtil.getStyle(el, 'position');
          var offsetLeft = el.offsetLeft;
          var offsetTop = el.offsetTop;
          if (positionStyle !== 'fixed') {
            var displayStyle = VueUtil.getStyle(el, 'display');
            VueUtil.setStyle(el, 'display', 'block');
            offsetLeft = el.offsetLeft;
            offsetTop = el.offsetTop;
            VueUtil.setStyle(el, 'display', displayStyle);
            VueUtil.setStyle(el, 'position', 'relative');
            VueUtil.setStyle(el, 'zIndex', VueUtil.nextZIndex());
          }
          new dragEl(el, cancelObj, resizeObj, offsetLeft, offsetTop);
        });
      }
    });
  };
  Vue.use(directive);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil', 'VueRouter', 'Vuex'], definition);
  } else {
    context.VueLoader = definition(context.Vue, context.VueUtil, context.VueRouter, context.Vuex);
  }
})(this, function(Vue, VueUtil, VueRouter, Vuex) {
  'use strict';
  var promiseLoop = function(arr, cb) {
    var realResult = [];
    var result = Promise.resolve();
    arr.reverse();
    arr.forEach(function(a) {
      result = result.then(function() {
        return cb(a).then(function(res) {
          realResult.push(res);
        });
      });
    });
    return result.then(function() {
      return realResult;
    });
  };
  var scriptCache = [];
  var scriptScopedCache = [];
  var identity = function(value) {
    return value;
  };
  var resolveURL = function(baseURL, url) {
    if (url.substr(0, 2) === './' || url.substr(0, 3) === '../') {
      return baseURL + url;
    }
    return url;
  };
  var StyleContext = function(component, elt) {
    this.component = component;
    this.elt = elt;
  };
  StyleContext.prototype = {
    withBase: function(callback) {
      var tmpBaseElt;
      if (this.component.baseURI) {
        tmpBaseElt = document.createElement('base');
        tmpBaseElt.href = this.component.baseURI;
        var headElt = this.component.getHead();
        headElt.insertBefore(tmpBaseElt, headElt.firstChild);
      }
      callback.call(this);
      if (tmpBaseElt)
        this.component.getHead().removeChild(tmpBaseElt);
    },
    scopeStyles: function(styleElt, scopeName) {

      function process() {

        var sheet = styleElt.sheet;
        var rules = sheet.cssRules;

        for ( var i = 0; i < rules.length; ++i ) {
          var rule = rules[i];
          if ( rule.type !== 1 )
            continue;

          var scopedSelectors = [];

          rule.selectorText.split(/\s*,\s*/).forEach(function(sel) {

            scopedSelectors.push(scopeName+' '+sel);
            var segments = sel.match(/([^ :]+)(.+)?/);
            scopedSelectors.push(segments[1] + scopeName + (segments[2]||''));
          });

          var scopedRule = scopedSelectors.join(',') + rule.cssText.substr(rule.selectorText.length);
          sheet.deleteRule(i);
          sheet.insertRule(scopedRule, i);
        }
      }

      try {
        process();
      } catch (ex) {

        if ( ex instanceof DOMException && ex.code === DOMException.INVALID_ACCESS_ERR ) {

          styleElt.sheet.disabled = true;
          styleElt.addEventListener('load', function onStyleLoaded() {

            styleElt.removeEventListener('load', onStyleLoaded);
            setTimeout(function() {
              process();
              styleElt.sheet.disabled = false;
            });
          });
          return;
        }
        throw ex;
      }
    },
    compile: function() {
      var hasTemplate = this.template !== null;
      var scoped = this.elt.hasAttribute('scoped');
      if (scoped) {
        if (!hasTemplate) return;
        this.elt.removeAttribute('scoped');
      }
      this.withBase(function() {
        this.component.getHead().appendChild(this.elt);
      });
      if (scoped) this.scopeStyles(this.elt, '[' + this.component.getScopeId() + ']');
      return Promise.resolve();
    },
    getContent: function() {
      return this.elt.textContent;
    },
    setContent: function(content) {
      this.withBase(function() {
        this.elt.textContent = content;
      });
    }
  };
  var ScriptContext = function(component, elt) {
    this.component = component;
    this.elt = elt;
    this.module = {
      exports: {}
    };
  };
  ScriptContext.prototype = {
    getContent: function() {
      return this.elt.textContent;
    },
    setContent: function(content) {
      this.elt.textContent = content;
    },
    addContent: function(content) {
      this.elt.textContent = content + this.elt.textContent;
    },
    asynReadContent: function(url) {
      return new Promise(function(resolve, reject) {
        Vue.http.get(url).then(function(reqponse) {
          resolve(reqponse.bodyText);
        }, function(reqponse) {
          reject(reqponse.status);
        });
      });
    },
    compile: function() {
      var childModuleRequire = function(childURL) {
        return httpVueLoader.require(resolveURL(this.component.baseURI, childURL));
      }.bind(this);
      var childLoader = function(childURL) {
        return VueLoader(resolveURL(this.component.baseURI, childURL));
      }.bind(this);
      try {
        //Vue.config.devtools && this.addContent('debugger');
        Function('exports', 'require', 'Vue', 'VueUtil', 'VueRouter', 'Vuex', 'VueLoader', 'module', this.getContent()).call(this.module.exports, this.module.exports, childModuleRequire, Vue, VueUtil, VueRouter, Vuex, childLoader, this.module);
      } catch (ex) {
        Vue.config.productionTip && console.error('[VueLoader error]: in \'' + this.component.url + '\'\n\n' + ex);
      }
      return Promise.resolve(this.module.exports);
    }
  };
  var TemplateContext = function(component, elt) {
    this.component = component;
    this.elt = elt;
  };
  TemplateContext.prototype = {
    getContent: function() {
      return this.elt.innerHTML;
    },
    setContent: function(content) {
      this.elt.innerHTML = content;
    },
    getRootElt: function() {
      var tplElt = this.elt.content || this.elt;
      var firstElt = tplElt.firstElementChild;
      if (VueUtil.isElement(firstElt)) return firstElt;
      for (tplElt = tplElt.firstChild; tplElt !== null; tplElt = tplElt.nextSibling) {
        if (VueUtil.isElement(tplElt)) return tplElt;
      }
      return null;
    },
    compile: function() {
      return Promise.resolve();
    }
  };
  var Component = function() {
    this.template = null;
    this.script = null;
    this.styles = [];
    this._scopeId = '';
    this.url = null;
  };
  Component.prototype = {
    getHead: function() {
      return document.head || document.getElementsByTagName('head')[0];
    },
    getScopeId: function() {
      if (this._scopeId === '') {
        this._scopeId = 'scope-' + VueUtil.createUuid();
        this.template.getRootElt().setAttribute(this._scopeId, '');
      }
      return this._scopeId;
    },
    load: function(componentURL) {
      this.url = componentURL;
      return httpVueLoader.httpRequest(componentURL).then(function(responseText) {
        scriptScopedCache = [];
        this.baseURI = componentURL.substr(0, componentURL.lastIndexOf('/') + 1);
        var doc = document.implementation.createHTMLDocument('');
        doc.body.innerHTML = (this.baseURI ? '<base href="' + this.baseURI + '">' : '') + responseText;
        for (var it = doc.body.firstChild; it; it = it.nextSibling) {
          switch (it.nodeName) {
          case 'TEMPLATE':
            this.template = new TemplateContext(this,it);
            break;
          case 'SCRIPT':
            var srcStr = it.getAttribute('src');
            var scoped = it.getAttribute('scoped');
            if (srcStr) {
              var async = it.getAttribute('async');
              if (VueUtil.isDef(scoped)) {
                if (scriptScopedCache.indexOf(srcStr) === -1) scriptScopedCache.push(srcStr);
              } else {
                if (scriptCache.indexOf(srcStr) === -1) {
                  if (!async || async === 'true') {
                    var newScript = document.createElement('script');
                    newScript.setAttribute('src', srcStr);
                    newScript.async = false;
                    this.getHead().appendChild(newScript);
                    scriptCache.push(srcStr);
                  } else if (async === 'false'){
                    var req = new XMLHttpRequest();
                    req.open('GET', srcStr, false);
                    req.onreadystatechange = function(){
                        if (req.readyState == 4) {
                            var s = document.createElement('script');
                            s.appendChild(document.createTextNode(req.responseText));
                            document.head.appendChild(s);
                        }
                    };
                    req.send(null);
                  }
                
                }
              }
            } else {
              this.script = new ScriptContext(this, it);
            }
            break;
          case 'STYLE':
            this.styles.push(new StyleContext(this,it));
            break;
          }
        }
        return this;
      }.bind(this));
    },
    _normalizeSection: function(eltCx) {
      var p;
      if (eltCx === null || !eltCx.elt.hasAttribute('src')) {
        p = Promise.resolve(null);
      } else {
        p = httpVueLoader.httpRequest(eltCx.elt.getAttribute('src')).then(function(content) {
          eltCx.elt.removeAttribute('src');
          return content;
        });
      }
      return p.then(function(content) {
        if (eltCx !== null && eltCx.elt.hasAttribute('lang')) {
          var lang = eltCx.elt.getAttribute('lang');
          eltCx.elt.removeAttribute('lang');
          return httpVueLoader.langProcessor[lang.toLowerCase()](content === null ? eltCx.getContent() : content);
        }
        return content;
      }).then(function(content) {
        if (content !== null)
          eltCx.setContent(content);
      });
    },
    normalize: function() {
      return Promise.all(VueUtil.mergeArray(this._normalizeSection(this.template), this._normalizeSection(this.script), VueUtil.map(this.styles, this._normalizeSection))).then(function() {
        return this;
      }.bind(this));
    },
    compile: function() {
      return Promise.all(VueUtil.mergeArray(this.template && this.template.compile(), this.script && this.script.compile(), VueUtil.map(this.styles, function(style) {
        return style.compile();
      }))).then(function() {
        return this;
      }.bind(this));
    }
  };
  var httpVueLoader = {
    load: function(url) {
      return function() {
        return new Component().load(url).then(function(component) {
          if (VueUtil.isDef(component.script)) {
            return promiseLoop(scriptScopedCache, component.script.asynReadContent).then(function(responseText){
              component.script.addContent(responseText);
              return component;
            });
          } else {
            return component;
          }
        }).then(function(component) {
          return component.normalize();
        }).then(function(component) {
          return component.compile();
        }).then(function(component) {
          var exports = component.script !== null ? component.script.module.exports : {};
          if (component.template !== null)
            exports.template = component.template.getContent();
          exports._baseURI = component.baseURI;
          return exports;
        });
      };
    },
    require: function(moduleName) {
      return window[moduleName];
    },
    httpRequest: function(url) {
      return new Promise(function(resolve, reject) {
        Vue.http.get(url).then(function(reqponse) {
          resolve(reqponse.bodyText);
        }, function(reqponse) {
          reject(reqponse.status);
        });
      });
    },
    langProcessor: {
      html: identity,
      js: identity,
      css: identity
    }
  };
  var VueLoader = function(url) {
    return httpVueLoader.load(url);
  };
  return VueLoader;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue'], definition);
  } else {
    context.VueImgLoad = definition(context.Vue);
    delete context.VueImgLoad;
  }
})(this, function(Vue) {
  'use strict';
  var imgload = function() {
    var loadImg = function(el, binding) {
      if (el.tagName === 'IMG') {
        var img = new Image();
        img.src = binding.value;
        img.onload = function() {
          el.src = img.src;
        };
      }
    };
    Vue.directive('imgload', {
      bind: function(el, binding) {
        el._src_ = el.src;
        loadImg(el, binding);
      },
      update: function(el, binding) {
        el.src = el._src_;
        loadImg(el, binding);
      }
    });
  };
  Vue.use(imgload);
});

/*!
 * Signature Pad v2.3.2
 * https://github.com/szimek/signature_pad
 *
 * Copyright 2017 Szymon Nowak
 * Released under the MIT license
 *
 * The main idea and some parts of the code (e.g. drawing variable width Bzier curve) are taken from:
 * http://corner.squareup.com/2012/07/smoother-signatures.html
 *
 * Implementation of interpolation using cubic Bzier curves is taken from:
 * http://benknowscode.wordpress.com/2012/09/14/path-interpolation-using-cubic-bezier-and-control-point-estimation-in-javascript
 *
 * Algorithm for approximated length of a Bzier curve is taken from:
 * http://www.lemoda.net/maths/bezier-length/index.html
 *
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.SignaturePad = factory());
}(this, (function () { 'use strict';

function Point(x, y, time) {
  this.x = x;
  this.y = y;
  this.time = time || new Date().getTime();
}

Point.prototype.velocityFrom = function (start) {
  return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 1;
};

Point.prototype.distanceTo = function (start) {
  return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
};

Point.prototype.equals = function (other) {
  return this.x === other.x && this.y === other.y && this.time === other.time;
};

function Bezier(startPoint, control1, control2, endPoint) {
  this.startPoint = startPoint;
  this.control1 = control1;
  this.control2 = control2;
  this.endPoint = endPoint;
}

// Returns approximated length.
Bezier.prototype.length = function () {
  var steps = 10;
  var length = 0;
  var px = void 0;
  var py = void 0;

  for (var i = 0; i <= steps; i += 1) {
    var t = i / steps;
    var cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
    var cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
    if (i > 0) {
      var xdiff = cx - px;
      var ydiff = cy - py;
      length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
    }
    px = cx;
    py = cy;
  }

  return length;
};

/* eslint-disable no-multi-spaces, space-in-parens */
Bezier.prototype._point = function (t, start, c1, c2, end) {
  return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;
};

/* eslint-disable */

// http://stackoverflow.com/a/27078401/815507
function throttle(func, wait, options) {
  var context, args, result;
  var timeout = null;
  var previous = 0;
  if (!options) options = {};
  var later = function later() {
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  return function () {
    var now = Date.now();
    if (!previous && options.leading === false) previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
}

function SignaturePad(canvas, options) {
  var self = this;
  var opts = options || {};

  this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;
  this.minWidth = opts.minWidth || 0.5;
  this.maxWidth = opts.maxWidth || 2.5;
  this.throttle = 'throttle' in opts ? opts.throttle : 16; // in miliseconds
  this.minDistance = 'minDistance' in opts ? opts.minDistance : 5;

  if (this.throttle) {
    this._strokeMoveUpdate = throttle(SignaturePad.prototype._strokeUpdate, this.throttle);
  } else {
    this._strokeMoveUpdate = SignaturePad.prototype._strokeUpdate;
  }

  this.dotSize = opts.dotSize || function () {
    return (this.minWidth + this.maxWidth) / 2;
  };
  this.penColor = opts.penColor || 'black';
  this.backgroundColor = opts.backgroundColor || 'rgba(0,0,0,0)';
  this.onBegin = opts.onBegin;
  this.onEnd = opts.onEnd;

  this._canvas = canvas;
  this._ctx = canvas.getContext('2d');
  this.clear();

  // We need add these inline so they are available to unbind while still having
  // access to 'self' we could use _.bind but it's not worth adding a dependency.
  this._handleMouseDown = function (event) {
    if (event.which === 1) {
      self._mouseButtonDown = true;
      self._strokeBegin(event);
    }
  };

  this._handleMouseMove = function (event) {
    if (self._mouseButtonDown) {
      self._strokeMoveUpdate(event);
    }
  };

  this._handleMouseUp = function (event) {
    if (event.which === 1 && self._mouseButtonDown) {
      self._mouseButtonDown = false;
      self._strokeEnd(event);
    }
  };

  this._handleTouchStart = function (event) {
    if (event.targetTouches.length === 1) {
      var touch = event.changedTouches[0];
      self._strokeBegin(touch);
    }
  };

  this._handleTouchMove = function (event) {
    // Prevent scrolling.
    event.preventDefault();

    var touch = event.targetTouches[0];
    self._strokeMoveUpdate(touch);
  };

  this._handleTouchEnd = function (event) {
    var wasCanvasTouched = event.target === self._canvas;
    if (wasCanvasTouched) {
      event.preventDefault();
      self._strokeEnd(event);
    }
  };

  // Enable mouse and touch event handlers
  this.on();
}

// Public methods
SignaturePad.prototype.clear = function () {
  var ctx = this._ctx;
  var canvas = this._canvas;

  ctx.fillStyle = this.backgroundColor;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  this._data = [];
  this._reset();
  this._isEmpty = true;
};

SignaturePad.prototype.fromDataURL = function (dataUrl) {
  var _this = this;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var image = new Image();
  var ratio = options.ratio || window.devicePixelRatio || 1;
  var width = options.width || this._canvas.width / ratio;
  var height = options.height || this._canvas.height / ratio;

  this._reset();
  image.src = dataUrl;
  image.onload = function () {
    _this._ctx.drawImage(image, 0, 0, width, height);
  };
  this._isEmpty = false;
};

SignaturePad.prototype.toDataURL = function (type) {
  var _canvas;

  switch (type) {
    case 'image/svg+xml':
      return this._toSVG();
    default:
      for (var _len = arguments.length, options = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        options[_key - 1] = arguments[_key];
      }

      return (_canvas = this._canvas).toDataURL.apply(_canvas, [type].concat(options));
  }
};

SignaturePad.prototype.on = function () {
  this._handleMouseEvents();
  this._handleTouchEvents();
};

SignaturePad.prototype.off = function () {
  this._canvas.removeEventListener('mousedown', this._handleMouseDown);
  this._canvas.removeEventListener('mousemove', this._handleMouseMove);
  document.removeEventListener('mouseup', this._handleMouseUp);

  this._canvas.removeEventListener('touchstart', this._handleTouchStart);
  this._canvas.removeEventListener('touchmove', this._handleTouchMove);
  this._canvas.removeEventListener('touchend', this._handleTouchEnd);
};

SignaturePad.prototype.isEmpty = function () {
  return this._isEmpty;
};

// Private methods
SignaturePad.prototype._strokeBegin = function (event) {
  this._data.push([]);
  this._reset();
  this._strokeUpdate(event);

  if (typeof this.onBegin === 'function') {
    this.onBegin(event);
  }
};

SignaturePad.prototype._strokeUpdate = function (event) {
  var x = event.clientX;
  var y = event.clientY;

  var point = this._createPoint(x, y);
  var lastPointGroup = this._data[this._data.length - 1];
  var lastPoint = lastPointGroup && lastPointGroup[lastPointGroup.length - 1];
  var isLastPointTooClose = lastPoint && point.distanceTo(lastPoint) < this.minDistance;

  // Skip this point if it's too close to the previous one
  if (!(lastPoint && isLastPointTooClose)) {
    var _addPoint = this._addPoint(point),
        curve = _addPoint.curve,
        widths = _addPoint.widths;

    if (curve && widths) {
      this._drawCurve(curve, widths.start, widths.end);
    }

    this._data[this._data.length - 1].push({
      x: point.x,
      y: point.y,
      time: point.time,
      color: this.penColor
    });
  }
};

SignaturePad.prototype._strokeEnd = function (event) {
  var canDrawCurve = this.points.length > 2;
  var point = this.points[0]; // Point instance

  if (!canDrawCurve && point) {
    this._drawDot(point);
  }

  if (point) {
    var lastPointGroup = this._data[this._data.length - 1];
    var lastPoint = lastPointGroup[lastPointGroup.length - 1]; // plain object

    // When drawing a dot, there's only one point in a group, so without this check
    // such group would end up with exactly the same 2 points.
    if (!point.equals(lastPoint)) {
      lastPointGroup.push({
        x: point.x,
        y: point.y,
        time: point.time,
        color: this.penColor
      });
    }
  }

  if (typeof this.onEnd === 'function') {
    this.onEnd(event);
  }
};

SignaturePad.prototype._handleMouseEvents = function () {
  this._mouseButtonDown = false;

  this._canvas.addEventListener('mousedown', this._handleMouseDown);
  this._canvas.addEventListener('mousemove', this._handleMouseMove);
  document.addEventListener('mouseup', this._handleMouseUp);
};

SignaturePad.prototype._handleTouchEvents = function () {
  // Pass touch events to canvas element on mobile IE11 and Edge.
  this._canvas.style.msTouchAction = 'none';
  this._canvas.style.touchAction = 'none';

  this._canvas.addEventListener('touchstart', this._handleTouchStart);
  this._canvas.addEventListener('touchmove', this._handleTouchMove);
  this._canvas.addEventListener('touchend', this._handleTouchEnd);
};

SignaturePad.prototype._reset = function () {
  this.points = [];
  this._lastVelocity = 0;
  this._lastWidth = (this.minWidth + this.maxWidth) / 2;
  this._ctx.fillStyle = this.penColor;
};

SignaturePad.prototype._createPoint = function (x, y, time) {
  var rect = this._canvas.getBoundingClientRect();

  return new Point(x - rect.left, y - rect.top, time || new Date().getTime());
};

SignaturePad.prototype._addPoint = function (point) {
  var points = this.points;
  var tmp = void 0;

  points.push(point);

  if (points.length > 2) {
    // To reduce the initial lag make it work with 3 points
    // by copying the first point to the beginning.
    if (points.length === 3) points.unshift(points[0]);

    tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
    var c2 = tmp.c2;
    tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
    var c3 = tmp.c1;
    var curve = new Bezier(points[1], c2, c3, points[2]);
    var widths = this._calculateCurveWidths(curve);

    // Remove the first element from the list,
    // so that we always have no more than 4 points in points array.
    points.shift();

    return { curve: curve, widths: widths };
  }

  return {};
};

SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
  var dx1 = s1.x - s2.x;
  var dy1 = s1.y - s2.y;
  var dx2 = s2.x - s3.x;
  var dy2 = s2.y - s3.y;

  var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };
  var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };

  var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

  var dxm = m1.x - m2.x;
  var dym = m1.y - m2.y;

  var k = l2 / (l1 + l2);
  var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };

  var tx = s2.x - cm.x;
  var ty = s2.y - cm.y;

  return {
    c1: new Point(m1.x + tx, m1.y + ty),
    c2: new Point(m2.x + tx, m2.y + ty)
  };
};

SignaturePad.prototype._calculateCurveWidths = function (curve) {
  var startPoint = curve.startPoint;
  var endPoint = curve.endPoint;
  var widths = { start: null, end: null };

  var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - this.velocityFilterWeight) * this._lastVelocity;

  var newWidth = this._strokeWidth(velocity);

  widths.start = this._lastWidth;
  widths.end = newWidth;

  this._lastVelocity = velocity;
  this._lastWidth = newWidth;

  return widths;
};

SignaturePad.prototype._strokeWidth = function (velocity) {
  return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
};

SignaturePad.prototype._drawPoint = function (x, y, size) {
  var ctx = this._ctx;

  ctx.moveTo(x, y);
  ctx.arc(x, y, size, 0, 2 * Math.PI, false);
  this._isEmpty = false;
};

SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
  var ctx = this._ctx;
  var widthDelta = endWidth - startWidth;
  var drawSteps = Math.floor(curve.length());

  ctx.beginPath();

  for (var i = 0; i < drawSteps; i += 1) {
    // Calculate the Bezier (x, y) coordinate for this step.
    var t = i / drawSteps;
    var tt = t * t;
    var ttt = tt * t;
    var u = 1 - t;
    var uu = u * u;
    var uuu = uu * u;

    var x = uuu * curve.startPoint.x;
    x += 3 * uu * t * curve.control1.x;
    x += 3 * u * tt * curve.control2.x;
    x += ttt * curve.endPoint.x;

    var y = uuu * curve.startPoint.y;
    y += 3 * uu * t * curve.control1.y;
    y += 3 * u * tt * curve.control2.y;
    y += ttt * curve.endPoint.y;

    var width = startWidth + ttt * widthDelta;
    this._drawPoint(x, y, width);
  }

  ctx.closePath();
  ctx.fill();
};

SignaturePad.prototype._drawDot = function (point) {
  var ctx = this._ctx;
  var width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;

  ctx.beginPath();
  this._drawPoint(point.x, point.y, width);
  ctx.closePath();
  ctx.fill();
};

SignaturePad.prototype._fromData = function (pointGroups, drawCurve, drawDot) {
  for (var i = 0; i < pointGroups.length; i += 1) {
    var group = pointGroups[i];

    if (group.length > 1) {
      for (var j = 0; j < group.length; j += 1) {
        var rawPoint = group[j];
        var point = new Point(rawPoint.x, rawPoint.y, rawPoint.time);
        var color = rawPoint.color;

        if (j === 0) {
          // First point in a group. Nothing to draw yet.

          // All points in the group have the same color, so it's enough to set
          // penColor just at the beginning.
          this.penColor = color;
          this._reset();

          this._addPoint(point);
        } else if (j !== group.length - 1) {
          // Middle point in a group.
          var _addPoint2 = this._addPoint(point),
              curve = _addPoint2.curve,
              widths = _addPoint2.widths;

          if (curve && widths) {
            drawCurve(curve, widths, color);
          }
        } else {
          // Last point in a group. Do nothing.
        }
      }
    } else {
      this._reset();
      var _rawPoint = group[0];
      drawDot(_rawPoint);
    }
  }
};

SignaturePad.prototype._toSVG = function () {
  var _this2 = this;

  var pointGroups = this._data;
  var canvas = this._canvas;
  var ratio = Math.max(window.devicePixelRatio || 1, 1);
  var minX = 0;
  var minY = 0;
  var maxX = canvas.width / ratio;
  var maxY = canvas.height / ratio;
  var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

  svg.setAttributeNS(null, 'width', canvas.width);
  svg.setAttributeNS(null, 'height', canvas.height);

  this._fromData(pointGroups, function (curve, widths, color) {
    var path = document.createElement('path');

    // Need to check curve for NaN values, these pop up when drawing
    // lines on the canvas that are not continuous. E.g. Sharp corners
    // or stopping mid-stroke and than continuing without lifting mouse.
    if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {
      var attr = 'M ' + curve.startPoint.x.toFixed(3) + ',' + curve.startPoint.y.toFixed(3) + ' ' + ('C ' + curve.control1.x.toFixed(3) + ',' + curve.control1.y.toFixed(3) + ' ') + (curve.control2.x.toFixed(3) + ',' + curve.control2.y.toFixed(3) + ' ') + (curve.endPoint.x.toFixed(3) + ',' + curve.endPoint.y.toFixed(3));

      path.setAttribute('d', attr);
      path.setAttribute('stroke-width', (widths.end * 2.25).toFixed(3));
      path.setAttribute('stroke', color);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke-linecap', 'round');

      svg.appendChild(path);
    }
  }, function (rawPoint) {
    var circle = document.createElement('circle');
    var dotSize = typeof _this2.dotSize === 'function' ? _this2.dotSize() : _this2.dotSize;
    circle.setAttribute('r', dotSize);
    circle.setAttribute('cx', rawPoint.x);
    circle.setAttribute('cy', rawPoint.y);
    circle.setAttribute('fill', rawPoint.color);

    svg.appendChild(circle);
  });

  var prefix = 'data:image/svg+xml;base64,';
  var header = '<svg' + ' xmlns="http://www.w3.org/2000/svg"' + ' xmlns:xlink="http://www.w3.org/1999/xlink"' + (' viewBox="' + minX + ' ' + minY + ' ' + maxX + ' ' + maxY + '"') + (' width="' + maxX + '"') + (' height="' + maxY + '"') + '>';
  var body = svg.innerHTML;

  // IE hack for missing innerHTML property on SVGElement
  if (body === undefined) {
    var dummy = document.createElement('dummy');
    var nodes = svg.childNodes;
    dummy.innerHTML = '';

    for (var i = 0; i < nodes.length; i += 1) {
      dummy.appendChild(nodes[i].cloneNode(true));
    }

    body = dummy.innerHTML;
  }

  var footer = '</svg>';
  var data = header + body + footer;

  return prefix + btoa(data);
};

SignaturePad.prototype.fromData = function (pointGroups) {
  var _this3 = this;

  this.clear();

  this._fromData(pointGroups, function (curve, widths) {
    return _this3._drawCurve(curve, widths.start, widths.end);
  }, function (rawPoint) {
    return _this3._drawDot(rawPoint);
  });

  this._data = pointGroups;
};

SignaturePad.prototype.toData = function () {
  return this._data;
};

return SignaturePad;

})));

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueSignature = definition(context.Vue, context.VueUtil);
    delete context.VueSignature;
  }
})(this, function(Vue, VueUtil) {
  'use strict';

  var DEFAULT_OPTIONS = {
    dotSize: (0.5 + 2.5) / 2,
    minWidth: 0.5,
    maxWidth: 2.5,
    throttle: 16,
    minDistance: 5,
    backgroundColor: 'rgba(0,0,0,0)',
    penColor: 'black',
    velocityFilterWeight: 0.7,
    onBegin: function onBegin() {},
    onEnd: function onEnd() {}
  };

  var convert2NonReactive = function (observerValue) {
    return JSON.parse(JSON.stringify(observerValue));
  };

  var TRANSPARENT_PNG = {
    src:
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=',
    x: 0,
    y: 0
  };
  var VueSignature = {
    name: 'VueSignature',
    props: {
      width: {
        type: String,
        default: '100%'
      },
      height: {
        type: String,
        default: '100%'
      },
      customStyle: {
        type: Object
      },
      saveType: {
        type: String,
        default: 'image/png'
      },
      options: {
        type: Object,
        default: function () {
          return {};
        }
      },
      images: {
        type: Array,
        default: function () {
          return [];
        }
      }
    },
    data: function() {
      return {
        signaturePad: {},
        cacheImages: [],
        signatureData: TRANSPARENT_PNG,
        onResizeHandler: null
      };
    },
    mounted: function() {
      var options = this.options;
      var canvas = this.$refs.signaturePadCanvas;
      var signaturePad = new SignaturePad(canvas, VueUtil.merge({}, DEFAULT_OPTIONS, options));
      this.signaturePad = signaturePad;
  
      this.onResizeHandler = this.resizeCanvas.bind(this);
  
      window.addEventListener('resize', this.onResizeHandler, false);
  
      this.resizeCanvas();
    },
    beforeDestroy: function() {
      if (this.onResizeHandler) {
        window.removeEventListener('resize', this.onResizeHandler, false);
      }
    },
    methods: {
      resizeCanvas: function() {
        var canvas = this.$refs.signaturePadCanvas;
        var data = this.signaturePad.toData();
        var ratio = Math.max(window.devicePixelRatio || 1, 1);
        canvas.width = canvas.offsetWidth * ratio;
        canvas.height = canvas.offsetHeight * ratio;
        canvas.getContext('2d').scale(ratio, ratio);
        this.signaturePad.clear();
        this.signatureData = TRANSPARENT_PNG;
        this.signaturePad.fromData(data);
      },
      saveSignature: function() {
        var signaturePad = this.signaturePad;
        var saveType = this.saveType;
  
        if (['image/png', 'image/jpeg', 'image/svg+xml'].indexOf(saveType) == -1) {
          throw new Error('Image type is incorrect!');
        }
  
        if (signaturePad.isEmpty()) {
          return {
            data: undefined,
            isEmpty: true
          };
        } else {
          this.signatureData = signaturePad.toDataURL(saveType);
  
          return {
            isEmpty: false,
            data: this.signatureData
          };
        }
      },
      undoSignature: function() {
        var signaturePad = this.signaturePad;
        var record = signaturePad.toData();
  
        if (record) {
          return signaturePad.fromData(record.slice(0, -1));
        }
      },
      // mergeImageAndSignature(customSignature) {
      //   this.signatureData = customSignature;
  
      //   return mergeImages([
      //     ...this.images,
      //     ...this.cacheImages,
      //     this.signatureData
      //   ]);
      // },
      // addImages(images = []) {
      //   this.cacheImages = [...this.cacheImages, ...images];
  
      //   return mergeImages([
      //     ...this.images,
      //     ...this.cacheImages,
      //     this.signatureData
      //   ]);
      // },
      fromDataURL: function(data) {
        return this.signaturePad.fromDataURL(data);
      },
      lockSignaturePad: function() {
        return this.signaturePad.off();
      },
      openSignaturePad: function() {
        return this.signaturePad.on();
      },
      isEmpty: function() {
        return this.signaturePad.isEmpty();
      },
      getPropImagesAndCacheImages: function() {
        return this.propsImagesAndCustomImages;
      },
      clearCacheImages: function() {
        this.cacheImages = [];
  
        return this.cacheImages;
      },
      clearSignature: function() {
        return this.signaturePad.clear();
      }
    },
    computed: {
      propsImagesAndCustomImages: function() {
        var nonReactiveProrpImages = convert2NonReactive(this.images);
        var nonReactiveCachImages = convert2NonReactive(this.cacheImages);
  
        return nonReactiveProrpImages.concat(nonReactiveCachImages);
      }
    },
    render: function(createElement) {
      var width = this.width;
      var height = this.height;
      var customStyle = this.customStyle;

      return createElement(
        'div',
        {
          style: VueUtil.merge({
            width: width,
            height: height,
          }, customStyle)
        },
        [
          createElement('canvas', {
            style: {
              width: '100%',
              height: '100%'
            },
            ref: 'signaturePadCanvas'
          })
        ]
      );
    }
  };
  Vue.component(VueSignature.name, VueSignature);
});
(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueRipple = definition(context.Vue, context.VueUtil);
    delete context.VueRipple;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var directive = function() {
    var doRipple = VueUtil.throttle(function(e) {
      var clientX = e.clientX;
      var clientY = e.clientY;
      var el = this;
      el.style.position = 'relative';
      var ripple = el.querySelector('.vue-ripple__container');
      var animation = el.querySelector('.vue-ripple__animation');
      var size = el.clientWidth > el.clientHeight ? el.clientWidth : el.clientHeight;
      animation.style.height = animation.style.width = size + 'px';
      var offset = el.getBoundingClientRect();
      var x = clientX - offset.left + 'px';
      var y = clientY - offset.top + 'px';
      animation.style.left = x;
      animation.style.top = y;
      animation.style.display = '';
      ripple.style.display = '';
      VueUtil.debounce(500, function() {
        animation.style.display = 'none';
        ripple.style.display = 'none';
        el.style.position = el.__originalPosition__;
      }).call();
    });
    Vue.directive('ripple', {
      bind: function(el, binding) {
        VueUtil.debounce(function() {
          el.__originalPosition__ = el.style.position;
          var ripple = el.__ripple__ = document.createElement('div');
          ripple.className = 'vue-ripple__container';
          ripple.style.display = 'none';
          var animation = document.createElement('div');
          animation.style.display = 'none';
          animation.className = 'vue-ripple__animation';
          ripple.appendChild(animation);
          el.appendChild(ripple);
          VueUtil.on(el, 'mousedown', doRipple);
        }).call();
      },
      unbind: function(el) {
        VueUtil.off(el, 'mousedown', doRipple);
      }
    });
  };
  Vue.use(directive);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueAdaptiveGroup = definition(context.Vue, context.VueUtil);
    delete context.VueAdaptiveGroup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueAdaptiveGroup = {
    template: '<div class="vue-adaptive-group"><div v-if="adaptiveType" :class="[customClass, liClass]"><slot></slot><slot v-for="index in slotLen" :name="\'li\' + index"></slot></div><div v-else><slot></slot><vue-dropdown trigger="click" :class="[customClass]"><vue-button :icon="iconClass" type="text" style="transform: rotate3d(0,0,1,-90deg);"></vue-button><vue-dropdown-menu slot="dropdown" :class="[liClass]"><vue-dropdown-item v-for="index in slotLen" :key="index"><slot :name="\'li\' + index"></slot></vue-dropdown-item></vue-dropdown-menu></vue-dropdown></div></div>',
    name: 'VueAdaptiveGroup',
    props: {
      size: {
        type: String,
        default: 'md'
      },
      customClass: String,
      liClass: String,
      iconClass: {
        type: String,
        default: 'vue-icon-more'
      }
    },
    data: function() {
      return {
        adaptiveType: true
      };
    },
    methods: {
      resetType: function() {
        var size = this.size;
        var sizeMap = Object.create(null);
        sizeMap.lg = 1200;
        sizeMap.md = 992;
        sizeMap.sm = 768;
        var sizeValue = sizeMap[size];
        if (!VueUtil.isDef(sizeValue)) {
          size = 'md';
          sizeValue = sizeMap[size];
        }
        this.adaptiveType = sizeValue <= innerWidth;
      }
    },
    computed: {
      slotLen: function() {
        var soltLiLen = 0;
        VueUtil.ownPropertyLoop(this.$slots, function(prop) {
          var propAry = prop.split('li');
          if (propAry[0] === '' && VueUtil.isNumber(propAry[1]*1))
            soltLiLen++;
        });
        return soltLiLen;
      }
    },
    mounted: function() {
      VueUtil.addResizeListener(this.resetType);
    },
    beforeDestroy: function() {
      VueUtil.removeResizeListener(this.resetType);
    }
  };
  Vue.component(VueAdaptiveGroup.name, VueAdaptiveGroup);
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define(['Vue', 'VueUtil'], definition);
  } else {
    context.VueLang = definition(context.Vue, context.VueUtil);
    delete context.VueLang;
    delete context.VuePopper;
    delete context.VuePopup;
  }
})(this, function(Vue, VueUtil) {
  'use strict';
  var VueLang = {
    zh: {
      vue: {
        colorpicker: {
          confirm: '',
          clear: ''
        },
        datepicker: {
          now: '',
          today: '',
          thisMonth: '',
          cancel: '',
          clear: '',
          confirm: '',
          selectDate: '',
          selectTime: '',
          startDate: '',
          startTime: '',
          endDate: '',
          endTime: '',
          year: '',
          month1: '1 ',
          month2: '2 ',
          month3: '3 ',
          month4: '4 ',
          month5: '5 ',
          month6: '6 ',
          month7: '7 ',
          month8: '8 ',
          month9: '9 ',
          month10: '10 ',
          month11: '11 ',
          month12: '12 ',
          week: '',
          weeks: {
            sun: '',
            mon: '',
            tue: '',
            wed: '',
            thu: '',
            fri: '',
            sat: ''
          },
          months: {
            jan: '',
            feb: '',
            mar: '',
            apr: '',
            may: '',
            jun: '',
            jul: '',
            aug: '',
            sep: '',
            oct: '',
            nov: '',
            dec: ''
          }
        },
        select: {
          loading: '',
          noMatch: '',
          noData: '',
          placeholder: ''
        },
        cascader: {
          noMatch: '',
          placeholder: ''
        },
        pagination: {
          goto: '',
          pagesize: '/',
          total: ' {total} ',
          pageClassifier: ''
        },
        messagebox: {
          title: '',
          confirm: '',
          cancel: '',
          error: '!'
        },
        upload: {
          delete: '',
          preview: '',
          continue: ''
        },
        table: {
          emptyText: '',
          confirmFilter: '',
          resetFilter: '',
          clearFilter: '',
          sumText: '',
          countText: '',
          averageText: '',
          minText: '',
          maxText: '',
          contextMenu: '',
          pin: '',
          leftPin: '',
          rightPin: '',
          sort: '',
          sortBy: '',
          filter: '',
          column: '',
          conditions: '',
          filterBy: '',
          display: '',
          exportData: '',
          fileName: '',
          exportOrgData: '',
          exportHandleData: ''
        },
        tree: {
          emptyText: ''
        },
        screenfull: {
          canot: '!'
        }
      }
    },
    ja: {
      vue: {
        colorpicker: {
          confirm: '',
          clear: ''
        },
        datepicker: {
          now: '',
          today: '',
          thisMonth: '',
          cancel: '',
          clear: '',
          confirm: '',
          selectDate: '',
          selectTime: '',
          startDate: '',
          startTime: '',
          endDate: '',
          endTime: '',
          year: '',
          week: '',
          month1: '',
          month2: '',
          month3: '',
          month4: '',
          month5: '',
          month6: '',
          month7: '',
          month8: '',
          month9: '',
          month10: '',
          month11: '',
          month12: '',
          weeks: {
            sun: '',
            mon: '',
            tue: '',
            wed: '',
            thu: '',
            fri: '',
            sat: ''
          },
          months: {
            jan: '',
            feb: '',
            mar: '',
            apr: '',
            may: '',
            jun: '',
            jul: '',
            aug: '',
            sep: '',
            oct: '',
            nov: '',
            dec: ''
          }
        },
        select: {
          loading: '',
          noMatch: '',
          noData: '',
          placeholder: ''
        },
        cascader: {
          noMatch: '',
          placeholder: ''
        },
        pagination: {
          goto: '',
          pagesize: '/',
          total: ' {total} ',
          pageClassifier: ''
        },
        messagebox: {
          title: '',
          confirm: '',
          cancel: '',
          error: ''
        },
        upload: {
          delete: '',
          preview: '',
          continue: ''
        },
        table: {
          emptyText: '',
          confirmFilter: '',
          resetFilter: '',
          clearFilter: '',
          sumText: '',
          countText: '',
          averageText: '',
          minText: '',
          maxText: '',
          contextMenu: '',
          pin: '',
          leftPin: '',
          rightPin: '',
          sort: '',
          sortBy: '',
          filter: '',
          column: '',
          conditions: '',
          filterBy: '',
          display: '',
          exportData: '',
          fileName: '',
          exportOrgData: '',
          exportHandleData: ''
        },
        tree: {
          emptyText: ''
        },
        screenfull: {
          canot: '!'
        }
      }
    },
    en: {
      vue: {
        colorpicker: {
          confirm: 'OK',
          clear: 'Clear'
        },
        datepicker: {
          now: 'Now',
          today: 'Today',
          thisMonth: 'This Month',
          cancel: 'Cancel',
          clear: 'Clear',
          confirm: 'OK',
          selectDate: 'Select date',
          selectTime: 'Select time',
          startDate: 'Start Date',
          startTime: 'Start Time',
          endDate: 'End Date',
          endTime: 'End Time',
          year: '',
          week: 'Wk',
          month1: 'Jan',
          month2: 'Feb',
          month3: 'Mar',
          month4: 'Apr',
          month5: 'May',
          month6: 'Jun',
          month7: 'Jul',
          month8: 'Aug',
          month9: 'Sep',
          month10: 'Oct',
          month11: 'Nov',
          month12: 'Dec',
          weeks: {
            sun: 'Sun',
            mon: 'Mon',
            tue: 'Tue',
            wed: 'Wed',
            thu: 'Thu',
            fri: 'Fri',
            sat: 'Sat'
          },
          months: {
            jan: 'Jan',
            feb: 'Feb',
            mar: 'Mar',
            apr: 'Apr',
            may: 'May',
            jun: 'Jun',
            jul: 'Jul',
            aug: 'Aug',
            sep: 'Sep',
            oct: 'Oct',
            nov: 'Nov',
            dec: 'Dec'
          }
        },
        select: {
          loading: 'Loading',
          noMatch: 'No matching data',
          noData: 'No data',
          placeholder: 'Select'
        },
        cascader: {
          noMatch: 'No matching data',
          placeholder: 'Select'
        },
        pagination: {
          goto: 'Go to',
          pagesize: '/page',
          total: 'Total {total}',
          pageClassifier: ''
        },
        messagebox: {
          title: 'Message',
          confirm: 'OK',
          cancel: 'Cancel',
          error: 'Illegal input'
        },
        upload: {
          delete: 'Delete',
          preview: 'Preview',
          continue: 'Continue'
        },
        table: {
          emptyText: 'No Data',
          confirmFilter: 'Confirm',
          resetFilter: 'Reset',
          clearFilter: 'All',
          sumText: 'Sum',
          countText: 'Count',
          averageText: 'Average',
          minText: 'Mix',
          maxText: 'Max',
          contextMenu: 'Context Menu',
          pin: 'Pin',
          leftPin: 'Left Pin',
          rightPin: 'Right Pin',
          sort: 'Sort',
          sortBy: 'Sort By',
          filter: 'Filter',
          column: 'Column',
          conditions: 'Conditions',
          filterBy: 'Filter By',
          display: 'Display',
          exportData: 'Data Export',
          fileName: 'File Name',
          exportOrgData: 'Original Data Export',
          exportHandleData: 'Data Export'
        },
        tree: {
          emptyText: 'No Data'
        },
        screenfull: {
          canot: 'You browser can\'t work!'
        }
      }
    }
  };
  VueUtil.setLocale('zh', VueLang.zh);
  VueUtil.setLocale('ja', VueLang.ja);
  VueUtil.setLocale('en', VueLang.en);
  VueUtil.setLang('zh');
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueFormatter = definition();
  }
})(this, function() {
  
  'use strict';

  // var format = function(value, regex) {
  //   var res = '';
  //   if(!regex.test(value)) {
  //     for (var i = 0; i < value.length; i++) {
  //       var char = value.charAt(i);
  //       if(regex.test(char)) {
  //         res += char;
  //       }
  //     }
  //   } else {
  //     res = value;
  //   }
  //   return res;
  // };

  var alpha = function(value) {
    // return format(value, /^([a-zA-Z]+)$/);
    return value.replace(/([^a-zA-Z])/, '');
  };
  var alnum = function(value) {
    //return format(value, /^([a-zA-Z0-9\.]+)$/);
    return value.replace(/([^a-zA-Z0-9.])/, '');
  };
  var alint = function(value) {
    // return format(value, /^([a-zA-Z0-9]+)$/);
    return value.replace(/([^a-zA-Z0-9])/, '');
  };
  // //todo 
  // var halfwidthkana = function(value) {
  //   return format(value, /^([- ]+)$/);
  // };
  // var hiragana = function(value) {
  //   return format(value, /^([- ]+)$/);
  // };
  // var katakana = function(value) {
  //   return format(value, /^([- ]+)$/);
  // };
  // var fullwithkana = function(value) {
  //   return format(value, /^([-- ]+)$/);
  // };
  // //end todo

  var alnumsymbol = function(value) {
    // return format(value, /^([0-9a-zA-Z\!\"\#\$\%\&\'\(\)\-\=\^\~\\\|\@\`\[\{\;\+\:\*\]\}\,\>\.\<;\/\?\_ ]+)$/);
    return value.replace(/([^0-9a-zA-Z\!\"\#\$\%\&\'\(\)\-\=\^\~\\\|\@\`\[\{\;\+\:\*\]\}\,\>\.\<;\/\?\_ ])/, '');
  };
  var alnumhyphenasterisk = function(value) {
    return value.replace(/([^0-9a-zA-Z\-*])/, '');
  };
  var alnumhyphen = function(value) {
    // return format(value, /^([0-9a-zA-Z\-]+)$/);
    return value.replace(/([^0-9a-zA-Z\-])/, '');
  };
  var VueFormatter = {
    alpha: alpha,
    alnum: alnum,
    alint: alint,
    // halfwidthkana: halfwidthkana,
    // hiragana: hiragana,
    // katakana: katakana,
    // fullwithkana: fullwithkana,
    alnumsymbol: alnumsymbol,
    alnumhyphenasterisk: alnumhyphenasterisk,
    alnumhyphen: alnumhyphen,
  };
  Vue.prototype.$formatter = VueFormatter;
  return VueFormatter;
});

(function(context, definition) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    context.VueRules = definition();
  }
})(this, function() {
  'use strict';

  var basicRule = function(rule, value, callback, regex) {
    if (regex.test(value)) {
      callback();
    } else {
      callback(new Error(rule.message));
    }
  };

  var halfwidthkana = function(rule, value, callback) {
    return basicRule(rule, value, callback, /^([- ]+)$/);
  };
  var hiragana = function(rule, value, callback) {
    return basicRule(rule, value, callback, /^([- ]+)$/);
  };
  var katakana = function(rule, value, callback) {
    return basicRule(rule, value, callback, /^([- ]+)$/);
  };
  var fullwithkana = function(rule, value, callback) {
    return basicRule(rule, value, callback, /^([-- ]+)$/);
  };

  var VueRules = {
    halfwidthkana: halfwidthkana,
    hiragana: hiragana,
    katakana: katakana,
    fullwithkana: fullwithkana,
  };
  Vue.prototype.$rules = VueRules;
  return VueRules;
});
